#+TITLE: cicada english core
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* TODO
  1. wodyli processing
     then digrap in cicada
  2. tab completion in the REPL
     (or in text editor)
  3. better basic interface of the OS
  4. let functions in assembly-code
     be able to call functions in cicada-style-assembly-code
  5. 实现对多种实现技术的定制
  6. 重新思考某些术语和命名方式
  7. 更改所谓的线程技术
     以支持汇编扩展
     然后利用会汇编扩展的良好支持来优化某些代码
  8. cicada should design it's own abstractions of IO
     this can help cicada to be portable
  9. 在核心就直接使用hash-table来find
     但是list还是必要的
     因为这样就能保持对字典的灵活控制
  10. better interface for lambda
  11. memory allocation
  12. use hash-table to lookup dictionary
      then mutually recursive call
  13. flow-point number
  14. >< maybe substitute word to execute in lambda-body
  15. >< maybe syntax-check
  16. >< modern pattern-match  HOW ???
  17. better interface for debuger
  18. TAIL-CALL-OPTIMIZATION in apply lambda-body
  19. more protection on allocated memory
      maybe use paging
  20. cicada-assembler
  21. cicada-editor
  22. APL-like array-processing
  23. needs better sexp-reader&write
      design a better way
      to use local-label to from list-with-circuit
* ==================================================
* *chapter 2*
** note
   this chapter contains code written in cicada language
** TEN COMMANDMENTS OF CICADA
   1. you can break any commandment when necessary
   2. in cicada every function can be redefined
      the later definition will override the former definition
      the order of function definition is very important
   3. in cicada, a ``word'' can not begin with [0-9]
      and can not begin with a `-' follows [0-9]
   4. ``The whole point of Forth was that
      you didn't write programs in Forth
      you wrote vocabularies in Forth.
      When you devised an application
      you wrote a hundred words or so that discussed the application
      and you used those hundred words
      to write a one line definition to solve the application.
      It is not easy to find those hundred words,
      but they exist,
      they always exist.''
** --------------------------------------
** magic check
   #+begin_src cicada :tangle ../play/english-core.ccd
   (* magic check *)
   #+end_src
** defineVar & defineConst (new lexicographers)
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : defineVar,byString
      (* initial-value, String[address, length] -- *)
      create-word-header
      Variable-explainer append-number-to-here
      swap (* leave wordHeader *)
      append-number-to-here (* the initial-value of Var *)
      add-new-word-to-dictionary
      Exit
    ; define-function

    : defineVar (* byWordList *)
      (* initial-value, WordList[address, the number of words] -- *)
      head-of-word-list
      defineVar,byString
      Exit
    ; define-function

    : defineConst,byString
      (* initial-value, WordList[address, the number of words] -- *)
      create-word-header
      Constant-explainer append-number-to-here
      swap (* leave wordHeader *)
      append-number-to-here (* the initial-value of Const *)
      add-new-word-to-dictionary
      Exit
    ; define-function

    : defineConst (* byWordList *)
      (* initial-value, WordList[address, the number of words] -- *)
      head-of-word-list
      defineConst,byString
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    0 : Yi ; defineVar

    Yi fetch . (* 0 *) cr
    1 Yi save
    Yi fetch . (* 1 *) cr

    7 : Qi ; defineConst
    Qi . (* 7 *) cr

    : QiJiaYi (* -- *)
      Qi Yi fetch + .
      Exit
    ; define-function
    QiJiaYi (* 8 *) cr
    #+end_src
** fixnum
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : /mod (* a, b -- quotient, a mod b *)
      mod/ swap
      Exit
    ; define-function

    : / (* a, b -- quotient *)
      /mod drop
      Exit
    ; define-function

    : mod (* a, b -- a mod b *)
      mod/ drop
      Exit
    ; define-function

    : negate (* n --  -n *)
      Zero swap -
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    10 3 / . (* 3 *)
    10 3 mod . (* 1 *)
    #+end_src
** ASCII chars
   #+begin_src cicada :tangle ../play/english-core.ccd 
   9   : 'tab'      ; defineConst
   10  : 'linefeed' ; defineConst
   10  : 'newline'  ; defineConst
   27  : 'esc'      ; defineConst
   27  : 'escape'   ; defineConst
   32  : 'space'    ; defineConst
   127 : 'delete'   ; defineConst

   33 : '!' ; defineConst
   34 : '"' ; defineConst
   35 : '#' ; defineConst
   36 : '$' ; defineConst
   37 : '%' ; defineConst
   38 : '&' ; defineConst
   39 : ''' ; defineConst
   40 : '(' ; defineConst
   41 : ')' ; defineConst
   42 : '*' ; defineConst
   43 : '+' ; defineConst
   44 : ',' ; defineConst
   45 : '-' ; defineConst
   46 : '.' ; defineConst
   47 : '/' ; defineConst

   48 : '0' ; defineConst
   49 : '1' ; defineConst
   50 : '2' ; defineConst
   51 : '3' ; defineConst
   52 : '4' ; defineConst
   53 : '5' ; defineConst
   54 : '6' ; defineConst
   55 : '7' ; defineConst
   56 : '8' ; defineConst
   57 : '9' ; defineConst

   58 : ':' ; defineConst
   59 : ';' ; defineConst
   60 : '<' ; defineConst
   61 : '=' ; defineConst
   62 : '>' ; defineConst
   63 : '?' ; defineConst
   64 : '@' ; defineConst

   65 : 'A' ; defineConst
   66 : 'B' ; defineConst
   67 : 'C' ; defineConst
   68 : 'D' ; defineConst
   69 : 'E' ; defineConst
   70 : 'F' ; defineConst
   71 : 'G' ; defineConst
   72 : 'H' ; defineConst
   73 : 'I' ; defineConst
   74 : 'J' ; defineConst
   75 : 'K' ; defineConst
   76 : 'L' ; defineConst
   77 : 'M' ; defineConst
   78 : 'N' ; defineConst
   79 : 'O' ; defineConst
   80 : 'P' ; defineConst
   81 : 'Q' ; defineConst
   82 : 'R' ; defineConst
   83 : 'S' ; defineConst
   84 : 'T' ; defineConst
   85 : 'U' ; defineConst
   86 : 'V' ; defineConst
   87 : 'W' ; defineConst
   88 : 'X' ; defineConst
   89 : 'Y' ; defineConst
   90 : 'Z' ; defineConst

   91 : '[' ; defineConst
   92 : '\' ; defineConst
   93 : ']' ; defineConst
   94 : '^' ; defineConst
   95 : '_' ; defineConst
   96 : '`' ; defineConst

   97  : 'a' ; defineConst
   98  : 'b' ; defineConst
   99  : 'c' ; defineConst
   100 : 'd' ; defineConst
   101 : 'e' ; defineConst
   102 : 'f' ; defineConst
   103 : 'g' ; defineConst
   104 : 'h' ; defineConst
   105 : 'i' ; defineConst
   106 : 'j' ; defineConst
   107 : 'k' ; defineConst
   108 : 'l' ; defineConst
   109 : 'm' ; defineConst
   110 : 'n' ; defineConst
   111 : 'o' ; defineConst
   112 : 'p' ; defineConst
   113 : 'q' ; defineConst
   114 : 'r' ; defineConst
   115 : 's' ; defineConst
   116 : 't' ; defineConst
   117 : 'u' ; defineConst
   118 : 'v' ; defineConst
   119 : 'w' ; defineConst
   120 : 'x' ; defineConst
   121 : 'y' ; defineConst
   122 : 'z' ; defineConst

   123 : '{' ; defineConst
   124 : '|' ; defineConst
   125 : '}' ; defineConst
   126 : '~' ; defineConst
   #+end_src
** ><>< string & defineConstString (new lexicographer)
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* ><><>< string of 0 length is a not handled  error *)
    : headOfString (* string[address, length] -- first char *)
      drop fetch-byte
      Exit
    ; define-function

    : tailOfString (* string[address, length] -- string[address + 1, length - 1] *)
      sub1 swap add1 swap
      Exit
    ; define-function

    : tailAndHeadOfString
      (* string[address, length] --
	 string[address + 1, length - 1], first char *)
      dup2 tailOfString xx|swap|xx headOfString
      Exit
    ; define-function

    : :" (* -- string[address of Basic-string-buffer, length] *)
      read-string-into-buffer
      Exit
    ; define-function

    : ." (* -- string[address of Basic-string-buffer, length] *)
      read-string-into-buffer print-string
      Exit
    ; define-function

    : defineConstString,byString
      (* initial-string[address, length],
	 string[address, length], the number of words] -- *)
      create-word-header
      Constant-string-explainer append-number-to-here
      xx|swap|x (* leave wordHeader *)
      append-string-to-here (* initial-string *)
      add-new-word-to-dictionary
      Exit
    ; define-function

    : defineConstString (* byWordList *)
      (* string[address, length],
	 wordList[address, the number of words] -- *)
      head-of-word-list
      defineConstString,byString
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    :" xxx"
    : k ; defineConstString
    k print-string (* xxx *)
    #+end_src
** recursive Function & decision (new lexicographers)
*** note
    one predicate can make two branchs
    three predicates can make four branchs
    three predicates may only make three branchs
    but indeed there must be an invisible branch
*** implementation
    bug:
    if there is one ``if,then'' pair mismatch
    there will be crazy bug which is very hard to test !!
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : defineRecursiveFunction (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      add-new-word-to-dictionary
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      Exit
    ; define-function

    :" if"    : String,KeyWord,if   ; defineConstString
    :" else"  : String,KeyWord,else ; defineConstString
    :" then"  : String,KeyWord,then ; defineConstString

    : append-word-description-to-here,with-if&then
      (* wordList[address, the number of words] -- *)
	dup zero? false?branch 3
	  drop2 Exit

	tail-and-head-of-word-list

	dup2 String,KeyWord,if equal-string? false?branch 12
	  drop2
	  literal false?branch append-number-to-here
	  Here fetch xx|swap|x
	  Zero append-number-to-here (* leave a place *)
	  append-word-description-to-here,with-if&then Exit

	dup2 String,KeyWord,then equal-string? false?branch 13
	  drop2
	  x|swap|xx
	  Here fetch over -  Cell-width /
	  swap save
	  append-word-description-to-here,with-if&then Exit

	dup2 string-denote-number? false?branch 6
	  number drop append-number-to-here
	  append-word-description-to-here,with-if&then Exit

	  find word-link->word-explainer append-number-to-here
	  append-word-description-to-here,with-if&then Exit
    ; defineRecursiveFunction

    : defineRecursiveFunctionWith:if&then
      (* wordList[address, the number of words] -- *)
	tail-and-head-of-word-list
	create-word-header-for-function
	set-size-of-function-body
	add-new-word-to-dictionary
	Function-body-explainer append-number-to-here
	append-word-description-to-here,with-if&then
	Exit
    ; define-function


    (* redefine append-word-description-to-here add `else' *)

    : append-word-description-to-here
      (* wordList[address, the number of words] -- *)
	dup zero? if
	  drop2 Exit
	then
	tail-and-head-of-word-list
	dup2 String,KeyWord,if equal-string? if
	  drop2
	  literal false?branch append-number-to-here
	  Here fetch xx|swap|x
	  Zero append-number-to-here (* leave a place *)
	  append-word-description-to-here Exit
	then
	dup2 String,KeyWord,else equal-string? if
	  drop2
	  literal branch append-number-to-here
	  Here fetch xxx|swap|x
	  Zero append-number-to-here (* leave a place *)
	  x|swap|xx
	  Here fetch over -  Cell-width /
	  swap save
	  append-word-description-to-here Exit
	then
	dup2 String,KeyWord,then equal-string? if
	  drop2
	  x|swap|xx
	  Here fetch over -  Cell-width /
	  swap save
	  append-word-description-to-here Exit
	then
	dup2 string-denote-number? if
	  number drop append-number-to-here
	  append-word-description-to-here Exit
	then
	  find word-link->word-explainer append-number-to-here
	  append-word-description-to-here Exit
    ; defineRecursiveFunctionWith:if&then


    (* redefine defineRecursiveFunction & define-function *)

    : define-function
      (* wordList[address, the number of words] -- *)
	tail-and-head-of-word-list
	create-word-header-for-function
	set-size-of-function-body
	xx|swap|x
	Function-body-explainer append-number-to-here
	append-word-description-to-here
	add-new-word-to-dictionary
	Exit
    ; define-function

    : defineRecursiveFunction
      (* wordList[address, the number of words] -- *)
	tail-and-head-of-word-list
	create-word-header-for-function
	set-size-of-function-body
	add-new-word-to-dictionary
	Function-body-explainer append-number-to-here
	append-word-description-to-here
	Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    : factorial (* n -- n! *)
      dup one? if
	Exit
      then
      dup sub1 factorial * Exit
    ; defineRecursiveFunction



    1 factorial .
    2 factorial .
    3 factorial .
    4 factorial .
    5 factorial .
    6 factorial .
    7 factorial .
    8 factorial .
    9 factorial .
    10 factorial .
    11 factorial .
    12 factorial .
    13 factorial .
    14 factorial .
    15 factorial .
    16 factorial .
    17 factorial .
    18 factorial .
    19 factorial .
    20 factorial .



    : .12 (* 1 2 -- *)
      Two == if
	'2' write-char
	One == if
	  '1' write-char
	else
	  '_' write-char
	then
      else
	'_' write-char
	One == if
	  '1' write-char
	else
	  '_' write-char
	then
      then
      Exit
    ; define-function

    1 2 .12 cr
    6 2 .12 cr
    1 6 .12 cr
    6 6 .12 cr
    #+end_src
** predicates
   #+begin_src cicada :tangle ../play/english-core.ccd 
   : specialKeyWord? (* word[explainer] -- True or False *)
     dup literal literal           == if drop True Exit then
     dup literal branch            == if drop True Exit then
     dup literal zero?branch       == if drop True Exit then
     dup literal false?branch      == if drop True Exit then
     dup literal not-false?branch  == if drop True Exit then
     drop False
     Exit
   ; define-function
   #+end_src
** NOTE ABOUT reader
   when you want to read,
   say, hex based number in a REPL
   just set the variable ``Base'', and restore it after then.
** writers of number
*** note
    1. it is great if want a reader can read
       is identical to what a writer would write
       and what a writer write
       could be read by reader without any changes
       I will try to achieve this
    2. due to the lack of the ``semantic of substitution''
       to achieve the following functions
       I have to copy lots of code
       instead of just using lambda-abstraction
*** implementation
**** writeDecNumber
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : writeDecNumberChar (* byte -- *)
       '0' + write-char
       Exit
     ; define-function

     : help,writeDecNumber,pushChars
       (* ... , number of small DecNumbers, fixnum --
	  ... , number of small DecNumbers *)
       Dec-base mod/
       dup zero? if
	 drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help,writeDecNumber,pushChars
       Exit
     ; defineRecursiveFunction

     : help,writeDecNumber,write-chars
       (* ... , number of small DecNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeDecNumberChar
       help,writeDecNumber,write-chars
       Exit
     ; defineRecursiveFunction

     : writeDecNumber (* fixnum -- *)
       Zero swap
       help,writeDecNumber,pushChars
       help,writeDecNumber,write-chars
       Exit
     ; define-function

     : writeDecNumber,signed (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeDecNumber
       Exit
     ; define-function
     #+end_src
**** writeBinNumber
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : writeBinNumberChar (* byte -- *)
       '0' + write-char
       Exit
     ; define-function

     : help,writeBinNumber,pushChars
       (* ... , number of small BinNumbers, fixnum --
	  ... , number of small BinNumbers *)
       Bin-base mod/
       dup zero? if
	 drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help,writeBinNumber,pushChars
       Exit
     ; defineRecursiveFunction

     : help,writeBinNumber,write-chars
       (* ... , number of small BinNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeBinNumberChar
       help,writeBinNumber,write-chars
       Exit
     ; defineRecursiveFunction

     : writeBinNumber (* fixnum -- *)
       Zero swap
       help,writeBinNumber,pushChars
       help,writeBinNumber,write-chars
       Exit
     ; define-function

     : writeBinNumber,signed (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeBinNumber
       Exit
     ; define-function
     #+end_src
**** writeOctNumber
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : writeOctNumberChar (* byte -- *)
       '0' + write-char
       Exit
     ; define-function

     : help,writeOctNumber,pushChars
       (* ... , number of small OctNumbers, fixnum --
	  ... , number of small OctNumbers *)
       Oct-base mod/
       dup zero? if
	 drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help,writeOctNumber,pushChars
       Exit
     ; defineRecursiveFunction

     : help,writeOctNumber,write-chars
       (* ... , number of small OctNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeOctNumberChar
       help,writeOctNumber,write-chars
       Exit
     ; defineRecursiveFunction

     : writeOctNumber (* fixnum -- *)
       Zero swap
       help,writeOctNumber,pushChars
       help,writeOctNumber,write-chars
       Exit
     ; define-function

     : writeOctNumber,signed (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeOctNumber
       Exit
     ; define-function
     #+end_src
**** writeHexNumber
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : writeHexNumberChar (* byte -- *)
       dup Ten < if
	 '0' + write-char Exit
       then
       Ten -
       'a' + write-char
       Exit
     ; define-function

     : writeHexNumberChar,capital (* byte -- *)
       dup Ten < if
	 '0' + write-char Exit
       then
       Ten -
       'A' + write-char
       Exit
     ; define-function

     : help,writeHexNumber,pushChars
       (* ... , number of small HexNumbers, fixnum --
	  ... , number of small HexNumbers *)
       Hex-base mod/
       dup zero? if
	 drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help,writeHexNumber,pushChars
       Exit
     ; defineRecursiveFunction

     : help,writeHexNumber,write-chars
       (* ... , number of small HexNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeHexNumberChar
       help,writeHexNumber,write-chars
       Exit
     ; defineRecursiveFunction

     : help,writeHexNumber,write-chars,capital
       (* ... , number of small HexNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeHexNumberChar,capital
       help,writeHexNumber,write-chars,capital
       Exit
     ; defineRecursiveFunction

     : writeHexNumber (* fixnum -- *)
       Zero swap
       help,writeHexNumber,pushChars
       help,writeHexNumber,write-chars
       Exit
     ; define-function

     : writeHexNumber,capital (* fixnum -- *)
       Zero swap
       help,writeHexNumber,pushChars
       help,writeHexNumber,write-chars,capital
       Exit
     ; define-function

     : writeHexNumber,signed (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeHexNumber
       Exit
     ; define-function

     : writeHexNumber,signed,capital (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeHexNumber,capital
       Exit
     ; define-function
     #+end_src
**** writeAphNumber
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : writeAphNumberChar (* byte -- *)
       dup Ten < if
	 '0' + write-char Exit
       then
       Ten -
       'a' + write-char
       Exit
     ; define-function

     : writeAphNumberChar,capital (* byte -- *)
       dup Ten < if
	 '0' + write-char Exit
       then
       Ten -
       'A' + write-char
       Exit
     ; define-function

     : help,writeAphNumber,pushChars
       (* ... , number of small AphNumbers, fixnum --
	  ... , number of small AphNumbers *)
       Aph-base mod/
       dup zero? if
	 drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help,writeAphNumber,pushChars
       Exit
     ; defineRecursiveFunction

     : help,writeAphNumber,write-chars
       (* ... , number of small AphNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeAphNumberChar
       help,writeAphNumber,write-chars
       Exit
     ; defineRecursiveFunction

     : help,writeAphNumber,write-chars,capital
       (* ... , number of small AphNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap writeAphNumberChar,capital
       help,writeAphNumber,write-chars,capital
       Exit
     ; defineRecursiveFunction

     : writeAphNumber (* fixnum -- *)
       Zero swap
       help,writeAphNumber,pushChars
       help,writeAphNumber,write-chars
       Exit
     ; define-function

     : writeAphNumber,capital (* fixnum -- *)
       Zero swap
       help,writeAphNumber,pushChars
       help,writeAphNumber,write-chars,capital
       Exit
     ; define-function

     : writeAphNumber,signed (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeAphNumber
       Exit
     ; define-function

     : writeAphNumber,signed,capital (* fixnum -- *)
       dup Zero < if
	 '-' write-char
	 negate
       then
       writeAphNumber,capital
       Exit
     ; define-function
     #+end_src
**** usage
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : .unsigned (* fixnum -- *)
       writeDecNumber
       'space' write-char
       Exit
     ; define-function

     : .signed (* fixnum -- *)
       writeDecNumber,signed
       'space' write-char
       Exit
     ; define-function


     : . .signed Exit ; define-function


     : .bin (* fixnum -- *)
       writeBinNumber
       'space' write-char
       Exit
     ; define-function

     : .bin,signed (* fixnum -- *)
       writeBinNumber,signed
       'space' write-char
       Exit
     ; define-function

     : .oct (* fixnum -- *)
       writeOctNumber
       'space' write-char
       Exit
     ; define-function

     : .oct,signed (* fixnum -- *)
       writeOctNumber,signed
       'space' write-char
       Exit
     ; define-function

     : .hex (* fixnum -- *)
       writeHexNumber
       'space' write-char
       Exit
     ; define-function

     : .hex,signed (* fixnum -- *)
       writeHexNumber,signed
       'space' write-char
       Exit
     ; define-function

     : .hex,capital (* fixnum -- *)
       writeHexNumber,capital
       'space' write-char
       Exit
     ; define-function

     : .hex,signed,capital (* fixnum -- *)
       writeHexNumber,signed,capital
       'space' write-char
       Exit
     ; define-function


     : .aph (* fixnum -- *)
       writeAphNumber
       'space' write-char
       Exit
     ; define-function

     : .aph,signed (* fixnum -- *)
       writeAphNumber,signed
       'space' write-char
       Exit
     ; define-function

     : .aph,capital (* fixnum -- *)
       writeAphNumber,capital
       'space' write-char
       Exit
     ; define-function

     : .aph,signed,capital (* fixnum -- *)
       writeAphNumber,signed,capital
       'space' write-char
       Exit
     ; define-function

     : cr (* -- *)
       'newline' write-char Exit
     ; define-function


     : writeSpace (* -- *)
       'space' write-char Exit
     ; define-function

     : writeSomeSpace (* n -- *)
       dup zero? if
	 drop Exit
       then
       sub1
       writeSpace
       writeSomeSpace
       Exit
     ; defineRecursiveFunction
     #+end_src
*** test
    #+begin_src cicada
    123 321 123321 . . .
    -123 321 -123321 . . .
    -123 321 -123321 .signed .signed .signed
    -123 321 -123321 .unsigned .unsigned .unsigned

    123 321 123321 .bin .bin .bin
    -123 321 -123321 .bin,signed .bin,signed .bin,signed

    123 321 123321 .oct .oct .oct
    -123 321 -123321 .oct,signed .oct,signed .oct,signed

    123 321 123321 .hex .hex .hex
    123 321 123321 .hex,capital .hex,capital .hex,capital
    -123 321 -123321 .hex,signed .hex,signed .hex,signed
    -123 321 -123321 .hex,signed,capital .hex,signed,capital .hex,signed,capital

    123 321 123321 .aph .aph .aph
    123 321 123321 .aph,capital .aph,capital .aph,capital
    -123 321 -123321 .aph,signed .aph,signed .aph,signed
    -123 321 -123321 .aph,signed,capital .aph,signed,capital .aph,signed,capital
    #+end_src
** debugerREPL & traceFunction
*** note
    1. after type tag encoding
       we should handle type error as possible as we could
    2. the ``IdentificationOf#Word'' in ``def*'' macros is for ``debuger''
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : countReturnStack (* -- the length of ReturnStack *)
      Return-stack-top fetch-return-stack-pointer -
      Eight /
      sub1 (* for we are in this function call *)
      Exit
    ; define-function
    
    : countArgumentStack (* -- the length of ArgumentStack *)
      Argument-stack-top fetch-argument-stack-pointer -
      Eight /
      Exit
    ; define-function
    
    
    0 : ReturnStackPosition ; defineVar
    0 : ArgumentStackPosition ; defineVar
    
    (* the following two function are as interface *)
    : debuger,fetchFromReturnStack (* n -- *)
      sub1 Eight *
      ReturnStackPosition fetch +
      fetch
      Exit
    ; define-function
    
    : debuger,fetchFromArgumentStack (* n -- *)
      sub1 Eight *
      ArgumentStackPosition fetch +
      fetch
      Exit
    ; define-function
    
    
    :" bye"
    : String,bye ; defineConstString
    
    : execute-word (* string[address, length] -- unknown *)
      dup2
      string-denote-number? if
        number drop 
        Exit
      then
      dup2 find dup not-zero? if
        xx|swap|x drop2
        word-link->word-explainer execute 
        Exit
      then
      drop 
      String,undefined-word print-string
      print-string cr
      Exit
    ; define-function
    
    : debugerREPL (* unknown -- unknown *)
      read-word-for-runtime
      dup2
      String,bye equal-string? if
        drop2
        Exit
      then
      execute-word
      debugerREPL
      Exit
    ; defineRecursiveFunction
    
    :" debuger said: ``Welcome! Hope you find what's wrong.''"
    : String,debuger,Welcome ; defineConstString
    
    :" the length of ReturnStack is: "
    : String,debuger,theLengthOfReturnStack ; defineConstString
    
    :" the length of ArgumentStack is: "
    : String,debuger,theLengthOfArgumentStack ; defineConstString
    
    :" debuger said: ``Good bye! The computation will go on!''"
    : String,debuger,Goodbye ; defineConstString
    
    : debuger (* unknown -- unknown *)
      String,debuger,Welcome print-string cr
      Three writeSomeSpace String,debuger,theLengthOfReturnStack print-string
        countReturnStack writeDecNumber cr
      Three writeSomeSpace String,debuger,theLengthOfArgumentStack print-string
        countArgumentStack writeDecNumber cr
      fetch-return-stack-pointer ReturnStackPosition save
      fetch-argument-stack-pointer ArgumentStackPosition save
      Input-buffer Current-reading save
      Input-buffer Reading-boundary save
      debugerREPL
      String,debuger,Goodbye print-string cr
      Exit
    ; define-function
    
    (* ><><>< bug ><><>< *)
    (* ``1 fetch'' will cause core dump *)
    : identificationOfWord? (* an address in a word -- *)
      dup fetch ==
      Exit
    ; define-function
    
    (* ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     ,* || m(bytes) : name-string  ||
     ,* ||  1 : size of function body  ||
     ,* ||  1 : identification  ||
     ,* ||  1 : link  ||
     ,* ||  1 : type  ||
     ,* ||  1 : address-of-name-string-header  ||
     ,* ||  1 : address-of-explainer  ||
     ,* ||  n : body  ||
     ,*)
    
    : word,body->id
      (* [an address of a cell in a word] -- word[identification] *)
      dup
      identificationOfWord? if
        Exit
      then
      Cell-width -
      word,body->id
      Exit
    ; defineRecursiveFunction
    
    : word,id->name
      (* word[identification] -- string[address, length] *)
      Cell-width Three * +
      fetch dup
      add8 swap
      fetch
      Exit
    ; define-function
    
    : word,id->explainer
      (* word[identification] -- explainer *)
      Cell-width Four * +
      fetch
      Exit
    ; define-function
    
    : word,id->body-size
      (* word[identification] -- body-size *)
      Cell-width -
      fetch
      Exit
    ; define-function
    
    : word,id->body-list
      (* word[identification] -- body-list[address, length] *)
      dup
        Cell-width Five * +
      swap
      word,id->body-size
      Exit
    ; define-function
    
    : printNameOfExplainer (* explainer -- *)
      dup Function-body-explainer == if
        literal Function-body-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Variable-explainer == if
        literal Variable-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Constant-explainer == if
        literal Constant-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Constant-string-explainer == if
        literal Constant-string-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      drop
      Exit
    ; define-function
    
    : printFunctionBodyList (* body-list[address, length] -- *)
      dup zero? if
        drop2 Exit
      then
      Six writeSomeSpace
      over fetch word,body->id word,id->name print-string cr
      sub1 swap
      Cell-width + swap
      printFunctionBodyList
      Exit
    ; defineRecursiveFunction
    
    :"  -->  "
    : String,_-->__ ; defineConstString
    
    (* the following function is the first function
       on which I must use ``if,else,then'' *)
    : withPointer,printFunctionBodyList
      (* [an address of a cell in a word], body-list[address, length] -- *)
      dup zero? if
        drop2 drop Exit
      then
      x|over|xx x|over|xx == if
        String,_-->__ print-string
      else
        Six writeSomeSpace
      then
      over
      dup fetch specialKeyWord? if
        fetch word,body->id word,id->name print-string cr
        sub2 swap
        dup
        Six writeSomeSpace
        Cell-width + fetch writeDecNumber cr
        Cell-width Two * + swap
        withPointer,printFunctionBodyList
        Exit
      then
      fetch word,body->id word,id->name print-string cr
      sub1 swap
      Cell-width + swap
      withPointer,printFunctionBodyList
      Exit
    ; defineRecursiveFunction
    
    
    :" traceFunction said: ``Ya! Let's trace a function!''"
    : String,traceFunction,Welcome ; defineConstString
    
    :" The function we use to trace is:"
    : String,traceFunction,FunctionToTrace ; defineConstString
    
    :" The function be traced to is:"
    : String,traceFunction,FunctionBeTracedTo ; defineConstString
    
    :" The size of the body of this function is:"
    : String,traceFunction,FunctionBodySize ; defineConstString
    
    :" The body of this function is:"
    : String,traceFunction,FunctionBody ; defineConstString
    
    :" traceFunction said: ``The end of a tracing.''"
    : String,traceFunction,Goodbye ; defineConstString
    
    : traceFunction
      (* [an address of a cell in a word] -- *)
      String,traceFunction,Welcome print-string cr
      dup
        Three writeSomeSpace String,traceFunction,FunctionToTrace print-string cr
        Six writeSomeSpace fetch word,body->id word,id->name print-string cr
      dup (* withPointer,printFunctionBodyList still uses original arg *)
      word,body->id
        dup
          Three writeSomeSpace String,traceFunction,FunctionBeTracedTo print-string cr
          Six writeSomeSpace word,id->name print-string cr
        dup
          Three writeSomeSpace String,traceFunction,FunctionBodySize print-string cr
          Six writeSomeSpace word,id->body-size writeDecNumber cr
        Three writeSomeSpace String,traceFunction,FunctionBody print-string cr
        word,id->body-list withPointer,printFunctionBodyList
      String,traceFunction,Goodbye print-string cr
      Exit
    ; define-function
    #+end_src
*** simple trace
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : trace (* n -- *)
      debuger,fetchFromReturnStack
      traceFunction
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    (* test: traceFunction *)

    : xxx (* n, m -- *)
       debuger
       +
       literal 666 .
       .
       Exit
    ; define-function

    10 1 xxx
      1 debuger,fetchFromReturnStack  traceFunction
      2 debuger,fetchFromReturnStack  traceFunction
      bye
    (* 666 11 *)


    : factorial (* n -- n! *)
	dup one? if
	  debuger
	  Exit
	then
	dup sub1 factorial * Exit
    ; defineRecursiveFunction

    10 factorial
      1 debuger,fetchFromReturnStack
	traceFunction
      9 debuger,fetchFromReturnStack
	traceFunction
      10 debuger,fetchFromReturnStack
	traceFunction
      bye
    . (* 3628800 *)



    (* about tail call *)
    : writeSomeSpace (* n -- *)
	dup zero? if
	  drop Exit
	then
	sub1
	'space' write-char
	debuger
	writeSomeSpace
	Exit
    ; defineRecursiveFunction

    100 writeSomeSpace
      1 debuger,fetchFromReturnStack
	traceFunction
      2 debuger,fetchFromReturnStack
	traceFunction
      bye
    (* Ya! you can never say ``bye'' to this call of ``debuger'' *)
    (* when ever you call ``debuger'' in front of a recursive call, this happens *)
    basic-REPL
    countArgumentStack . (* 0 *)
    countReturnStack . (* 0 *)
    #+end_src
** new lexicographers with debuger
*** note
    1. the following redefined ``append-word-description-to-here''
       will call debuger if it meets a undefined word
    2. there will be syntax-check after the implementation of ``list''
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : printWordList (* WordList[address, the number of words] -- *)
      dup zero? if
	drop2
	cr Exit
      then
      Three writeSomeSpace
      tail-and-head-of-word-list print-string cr
      printWordList
      Exit
    ; defineRecursiveFunction


    :" an error occurs!
    append-word-description-to-here said:
       ``I am a tail-recursive-function.
	 My function-type is (* WordList[address, the number of words] -- *)
	 `defineRecursiveFunction' and `define-function' call me.
	 The following word is undefined.
	 I will print the rest of the WordList and call debuger.''
       --> "
    : String,append-word-description-to-here,meetUndefinedWord
    ; defineConstString

    :" The length of the rest of the WordList is: "
    : String,append-word-description-to-here,LengthOfTheRestOfTheWordList
    ; defineConstString

    :" The rest of the WordList is: "
    : String,append-word-description-to-here,TheRestOfTheWordList
    ; defineConstString


    : append-word-description-to-here
      (* WordList[address, the number of words] -- *)
      dup zero? if
	drop2 Exit
      then
      tail-and-head-of-word-list
	dup2 String,KeyWord,if equal-string? if
	  drop2
	  literal false?branch append-number-to-here
	  Here fetch xx|swap|x
	  Zero append-number-to-here (* leave a place *)
	  append-word-description-to-here Exit
	then
	dup2 String,KeyWord,else equal-string? if
	  drop2
	  literal branch append-number-to-here
	  Here fetch xxx|swap|x
	  Zero append-number-to-here (* leave a place *)
	  x|swap|xx
	  Here fetch over -  Cell-width /
	  swap save
	  append-word-description-to-here Exit
	then
	dup2 String,KeyWord,then equal-string? if
	  drop2
	  x|swap|xx
	  Here fetch over -  Cell-width /
	  swap save
	  append-word-description-to-here Exit
	then
	dup2 string-denote-number? if
	  number drop append-number-to-here
	  append-word-description-to-here Exit
	then
	dup2
	find dup not-zero? if
	  word-link->word-explainer append-number-to-here
	  drop2 (* drop the string[address, length], which is for debuger *)
	  append-word-description-to-here
	  Exit
	then
	drop (* drop the Zero *)
      String,append-word-description-to-here,meetUndefinedWord print-string
      print-string cr
      String,append-word-description-to-here,LengthOfTheRestOfTheWordList
      print-string dup writeDecNumber cr
      String,append-word-description-to-here,TheRestOfTheWordList print-string cr
      printWordList
      debuger
      Exit
    ; defineRecursiveFunction


    : define-function
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      xx|swap|x
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      add-new-word-to-dictionary
      Exit
    ; define-function

    : defineRecursiveFunction
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      add-new-word-to-dictionary
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      Exit
    ; define-function

    (*
     ,* (\* wordy version for testing *\)
     ,* : define-function
     ,*   (\* wordList[address, the number of words] -- *\)
     ,*   tail-and-head-of-word-list
     ,*     dup2 print-string
     ,*     'newline' write-char
     ,*   create-word-header-for-function
     ,*   set-size-of-function-body
     ,*   xx|swap|x
     ,*   Function-body-explainer append-number-to-here
     ,*   append-word-description-to-here
     ,*   add-new-word-to-dictionary
     ,*   Exit
     ,* ; define-function
     ,*
     ,* : defineRecursiveFunction
     ,*   (\* wordList[address, the number of words] -- *\)
     ,*   tail-and-head-of-word-list
     ,*     dup2 print-string
     ,*     'newline' write-char
     ,*   create-word-header-for-function
     ,*   set-size-of-function-body
     ,*   add-new-word-to-dictionary
     ,*   Function-body-explainer append-number-to-here
     ,*   append-word-description-to-here
     ,*   Exit
     * ; define-function
     *)
    #+end_src
** --------------------------------------
** index-hashback->string & string-hash->index
*** note
1. ``string-hash->index index-hashback->string''
   is a identity function
   and if the argumt is a index returned by ``string-hash->index''
   ``index-hashback->string string-hash->index''
   also is a identity function
2. you can set a 8 bytes value
   to every symbol in this hash-table
   by:
   [value, index] index->address save
   dynamic type system make use of it
   for I implement type-tag as a special symbol
   but you should NOT set a pair to a symbol
   for I can not afford to let gc scan the whole hash-table to mark it
3. hash-function (string)
   ==> (sum-up [byte_n * 2^n]) mod Number-of-symbol-entrys
   + where:
     0 <= n < Symbol-max-length
     and the Number-of-symbol-entrys is a prime number
   after sum-up, the greatest number < 2^(Symbol-max-length + 8)
   so I let Symbol-max-length == 64 - 8 == 56
   only first Symbol-max-length of the string is used by the hash-function
*** string-hash->index & index-hashback->string
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* a SymbolEntry [unit : byte]
     ,* ==========================
     ,*  ||   8 : SymbolValue   ||
     ,* --------------------------
     ,*  ||   1 : SymbolLength  ||
     ,* --------------------------
     ,*  || 56+ : SymbolString  ||
     ,* ==========================
     ,* where Symbol-max-length = 56 *)

    :" an error occurs!
    index->address said:
       ``My function-type is (* index -- address *)
	 The following unsign-number is not a index of the hash-table
	 I will not touch it and call debuger.''
       --> "
    : String,index->address,error ; defineConstString

    : index->address (* index -- address *)
      dup Number-of-symbol-entrys >= if
	String,index->address,error print-string
	dup writeDecNumber cr
	debuger Exit
      then
      dup Zero < if
	String,index->address,error print-string
	dup writeDecNumber cr
	debuger Exit
      then
      Symbol-entry-bytes-size *
      First-symbol-entry +
      Exit
    ; define-function

    : index-hashback->string
      (* index -- string[address, length] *)
      index->address Eight +
      dup add1 swap
      fetch-byte
      Exit
    ; define-function


    : help,string-hash->index,sum-up
      (* sum-up , string[address, length] -- sum-up *)
      dup zero? if
	drop2 Exit
      then
      tailAndHeadOfString
      over shift-left
      x|swap|xxx  +  xx|swap|x
      help,string-hash->index,sum-up
      Exit
    ; defineRecursiveFunction

    : help,string-hash->index,find-old-or-creat-new
      (* string[address, length], index -- index *)
      xx|tuck|x
      index-hashback->string
      (* index, string[address, length], string-2[address, length] *)
      dup zero? if  (* creat-new *)
	drop
	(* index, string[address, length], destination-address *)
	over over
	(* index, string[address, length], destination-address, length, address *)
	sub1 save-byte
	swap
	(* index,, source-address, destination-address, length *)
	copy-byte-string
	Exit
      then
      (* index, string[address, length], string-2[address, length] *)
      xx|over|xx equal-string? if (* found old *)
	drop2 Exit
      then
      x|swap|xx (* to get next-index *)
      (* string[address, length], index *)
      dup index->address Last-symbol-entry == if
	drop
	Zero
	help,string-hash->index,find-old-or-creat-new
	Exit
      then
      add1
      help,string-hash->index,find-old-or-creat-new
      Exit
    ; defineRecursiveFunction

    : help,string-hash->index,sum-up->index
      (* sum-up -- index *)
      Number-of-symbol-entrys mod
      Exit
    ; define-function

    : string-hash->index
      (* string[address, length] -- index *)
      dup2
	dup Symbol-max-length > if
	  drop Symbol-max-length
	  (* this means only first Symbol-max-length of the string is used by the hash-function *)
	then
	Zero xx|swap|x
	help,string-hash->index,sum-up
	help,string-hash->index,sum-up->index
      help,string-hash->index,find-old-or-creat-new
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    Number-of-symbol-entrys 1 -
    index->address Last-symbol-entry == . (* 1 *)

    -1 index->address
    basic-REPL
    1000000000 index->address
    basic-REPL

    :" a" string-hash->index . cr
    :" b" string-hash->index . cr
    :" c" string-hash->index . cr

    :" k" string-hash->index . cr
    :" kk" string-hash->index . cr
    :" xxx" string-hash->index . cr
    :" xxxk" string-hash->index . cr
    :" xxxkk" string-hash->index . cr
    :" xxxxxx" string-hash->index . cr
    :" xxxxxxk" string-hash->index . cr
    :" xxxxxxkk" string-hash->index . cr
    :" xxxxxxxxx" string-hash->index . cr
    :" xxxxxxxxxk" string-hash->index . cr
    :" xxxxxxxxxkk" string-hash->index . cr
    :" xxxxxxxxxxxx" string-hash->index . cr
    :" xxxxxxxxxxxxk" string-hash->index . cr
    :" xxxxxxxxxxxxkk" string-hash->index . cr
    :" xxxxxxxxxxxxxxx" string-hash->index . cr
    :" xxxxxxxxxxxxxxxk" string-hash->index . cr
    :" xxxxxxxxxxxxxxxkk" string-hash->index . cr


    (* Number-of-symbol-entrys : 10_0333 , 10_0003
       97      97
       98      98
       99      99
       107     107
       321     321
       749     749
       1605    1605
       3317    3317
       6741    6741
       13589   13589
       27285   27285
       54677   54677
       9128    9458
       18363   19023
       36833   38153
       73773   76413
       47320   52930
       94747   5964
       89268   12035
       78310   24177
     ,*)


    (* test: collision *)
    (*  'A'*2 + 'c' = 'B'*2 + 'a' *)
    :" Ac" string-hash->index . cr (* 229 *)
    :" Ba" string-hash->index . cr (* 230 *)

    :" A"
      string-hash->index index-hashback->string
    print-string

    :" Ac"
      string-hash->index index-hashback->string
    print-string

    :" Ba"
      string-hash->index index-hashback->string
    print-string

    (* test: rounding *)

    (* when: Number-of-symbol-entrys = 10_0003 *)
    10_0003 .bin (* 11000011010100011 *)

    (* when: Number-of-symbol-entrys = 10_0333 *)
    10_0333 .bin (* 11000011111101101 *)


    (* I do not want to solve two funny equations about ascii-chars,
     ,* just to test the two ``Number-of-symbol-entrys'' above !!!???
     ,* so, to test this, I reset ``Number-of-symbol-entrys'' to 230, in assembler,
     ,* then the greatest index == 229,
     ,* then to test collision is to test rounding
     ,*)


    :" Ac" string-hash->index . cr (* 229 *)
    :" Ba" string-hash->index . cr (* 0 *)

    :" Ac"
      string-hash->index index-hashback->string
    print-string

    :" Ba"
      string-hash->index index-hashback->string
    print-string
    #+end_src
** dynamic type system
*** note
1. I make the following stipulations about creating cicada words:
   1) constants and variables are nouns,
      the first letter of them should be capitalized.
      (just as in Deutsch)
   2) functions are verbs,
      the first letter of them should be NOT capitalized.
   3) I use compoundWordByCamelCase
      when the word is about non-typed value.
      examples:
      Base print-string printTypeTag define-function
   4) I use compound-word-with-dashes
      when the word is about typed value.
      examples:
      cons car cdr set-car! set-cdr! list-copy
   5) I use <this-kind-of-word>
      when the word is about type.
      examples:
      <pair> <pair-like>? <graph> <lambda> <fixnum> <type>
   6) I do not use compound_word_with_underscores
2. atom :
   TypedValue[valus, type tag]
3. non-atom :
   TypedValue[address, type tag]
4. this is really a flexible and dangerous way to use dynamic-type-value
5. this is dangerous,
   for you can meet semantic overload sometimes
   for example,
   True-Bool == [1, <bool>]
   True == 1
   that means you have two syntaxes to denote one semantic
   then, how should you implement ``if,else,then'' ???
   this is really not acceptable !!!
6. this is flexible,
   for you can easily define different kinds of <pair-like> values:
   1) <list>
   2) <alist> (associated-list)
   3) <dalin> (double-linked-list)
   4) <wodyli> (wodyli)
   5) <graph>
   6) and more
7. to implement gc
   one have to (and only have to)
   be able to distinguish <pair> and <non-pair>
8. every new data type implemented by <pair>
   have to be handled by gc as <pair>
9. I do not need type-inherit at all
   for I can easily convert one type to another
   say, I have <xxx-list>
   a function apply on <list> will not apply on <xxx-list>
   but if I use <xxx-list> as a list
   which every cdr is of type <list>
   only the first type is change from <list> to <xxx-list>
   then, when I want to treat this <xxx-list> as a <list>
   I just ``drop <list>''
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* if 1 is setted to a symbol, this symbol is a fixnum like data type
       if 2 is setted to a symbol, this symbol is a pair like data type *)

    : defineDataType
      (* wordList[address, the number of words] -- *)
      dup2
	head-of-word-list
	string-hash->index
	dup
	  index->address One swap save
	xx|swap|x
      defineConst
      Exit
    ; define-function

    : definePairLikeDataType
      (* wordList[address, the number of words] -- *)
      dup2
	head-of-word-list
	string-hash->index
	dup
	  index->address Two swap save
	xx|swap|x
      defineConst
      Exit
    ; define-function


    (* every word can be used as a name of a data type
       the following are my convention *)

    : <fixnum>    ; defineDataType
    : <bool>      ; defineDataType
    : <type>      ; defineDataType
    : <char>      ; defineDataType
    : <symbol>    ; defineDataType
    : <substring> ; defineDataType
    : <null>      ; defineDataType


    : <fixnum-like>? (* type -- True or False *)
	index->address fetch One ==
	Exit
    ; define-function


    0 : Null ; defineConst

    : null Null <null> Exit ; define-function

    : null? (* [value, type] -- True or False *)
      <null> == if
	Null == if
	  True Exit
	then
	False Exit
      then
      drop False Exit
    ; define-function




    : True-Bool  True  <bool> Exit ; define-function
    : False-Bool False <bool> Exit ; define-function



    : <pair>    ; definePairLikeDataType
    : <string>  ; definePairLikeDataType
    : <list>    ; definePairLikeDataType

    : <dalin>   ; definePairLikeDataType

    : <wody>           ; definePairLikeDataType
    : <bound-variable> ; definePairLikeDataType
    : <wodyli>         ; definePairLikeDataType


    : <pair-like>? (* type -- True or False *)
	index->address fetch Two ==
	Exit
    ; define-function

    : <not-pair-like>? (* type -- True or False *)
	index->address fetch Two =/=
	Exit
    ; define-function


    : <dalin-like>? (* type -- True or False *)
      dup <dalin> == if
	drop True Exit
      then
      dup <wodyli> == if
	drop True Exit
      then
      drop False Exit
    ; define-function


    : <not-dalin-like>? (* type -- True or False *)
      dup <dalin> == if
	drop False Exit
      then
      dup <wodyli> == if
	drop False Exit
      then
      drop True Exit
    ; define-function




    :" an error occurs!
    printTypeTag said:
       ``My function-type is (* type-tag[index of hash-table] -- *)
	 The following index is not a type-tag
	 I will not touch it and call debuger.''
       --> "
    : String,printTypeTag,error ; defineConstString

    : printTypeTag
      (* type-tag[index of hash-table] -- *)
      dup
      index->address fetch One == if
	index-hashback->string print-string Exit
      then
      dup
      index->address fetch Two == if
	index-hashback->string print-string Exit
      then
      String,printTypeTag,error print-string
      writeDecNumber cr
      debuger Exit
    ; define-function


    : eq? (* [value, type], [value, type] -- True or False *)
      x|over|xx =/= if
	drop drop2 False Exit
      then
      x|over|xx =/= if
	drop2 False Exit
      then
      drop2 True Exit
    ; define-function
    #+end_src
** dictionary operations
*** >< note
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (*
     ,* a word in the dictionary [unit : Cell-width = 8 bytes]
     ,*   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     ,*   ||  m : name-string  ||
     ,*   ||  1 : SizeOfFunctionBody ||
     ,*   ||  1 : identification  ||
     ,*   ||  1 : link  ||
     ,*   ||  1 : type  ||
     ,*   ||  1 : address-of-name-string-header  ||
     ,*   ||  1 : address-of-explainer  ||
     ,*   ||  n : body  ||
     ,* where
     ,*   ||  1 : type  ||
     ,* ==
     ,*   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
     ,* type-bit-0 is for HiddenWord
     ,* type-bit-1 is for VariableOfTypedValue [DynamicVar]
     ,*)

    : lastWordInTheDictionary? (* word[address of link] -- True or False *)
	zero? Exit
    ; define-function

    : nextWordInTheDictionary
      (* word[address of link] -- next-word[address of link] *)
	fetch Exit
    ; define-function

    : fetchWordType (* word[address of link] -- WordType *)
	add8 fetch
	Exit
    ; define-function

    : saveWordType (* word[address of link], WordType -- *)
	swap add8 save
	Exit
    ; define-function


    0 : offsetForHiddenWord          ; defineConst
    1 : offsetForDynamicVariableWord ; defineConst

    : dynamicVariableWord? (* word[address of link] -- True or False *)
	fetchWordType offsetForDynamicVariableWord fetch-bit one?
	Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    : ~ (* word[address of link] -- word[address of link] *)
	dup dynamicVariableWord? .
	(* dup lastWordInTheDictionary? . *)
	nextWordInTheDictionary
      Exit
    ; define-function

    first-word-in-dictionary fetch

    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~

    #+end_src
** interface of LambdaStack & ready
*** note
    1. note that
       not to much stack-processing is needed here
    2. LambdaStack can be used to save the faked-local-vars
    3. instead of allocate this stack in assembly
       I can also use list-processing to implement it
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    Lambda-stack-top : LambdaStackPointer ; defineVar

    : pushLambdaStack
      (* ArgumentStack::  value -->
	 LambdaStack::  value *)
      Cell-width LambdaStackPointer add-save
      LambdaStackPointer fetch save
      Exit
    ; define-function

    : popLambdaStack
      (* LambdaStack::  value -->
	 ArgumentStack::  value *)
      LambdaStackPointer fetch fetch
      Cell-width LambdaStackPointer sub-save
      Exit
    ; define-function


    : ready (* or twoPushLambdaStack *)
      (* ArgumentStack::  value-a, value-b -->
	 LambdaStack::  value-a, value-b *)
      swap pushLambdaStack pushLambdaStack
      Exit
    ; define-function

    : getBack (* or twoPopLambdaStack *)
      (* LambdaStack::  value-a, value-b -->
	 ArgumentStack::  value-a, value-b *)
      popLambdaStack popLambdaStack swap
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    1 2 . . (* 2 1 *)
    1 2 ready getBack . . (* 2 1 *)
    #+end_src
** *incremental-gc* & <pair> & <string>
*** note
1. this gc is a incremental-gc
   a marking-gc for pair
   a copy-gc for string
2. if StringHeap is used up
   before PairConstructionsArray is used up
   gc must be restart
   so StringHeap should be large to avoid this
3. there are two way to represent string now:
   1) [address, length]
   2) [address, <string>]
      in this one,
      there must be 4-bytes in address-4
      to save the length of the string
*** dynamic-allocation of string
**** try,copy-substring,from->to
     #+begin_src cicada :tangle ../play/english-core.ccd 
     (* example of a substring stored in StringHeap :
	|| 4 : length of substring  ||
	|| n : substring  ||
      ,*)

     String-heap-1 : Variable,StringHeap,from ; defineVar
     String-heap-2 : Variable,StringHeap,to   ; defineVar

     String-heap-1 : CurrFreeStringAddress,from ; defineVar
     String-heap-2 : CurrFreeStringAddress,to   ; defineVar

     (*
      ,* little experiment:
      ,*   Hex-base Base save
      ,*     10_10_00_00 fetch-argument-stack-pointer
      ,*     dup
      ,*       1 swap save-byte
      ,*     dup
      ,*       1 swap add1 save-byte
      ,*     fetch .hex .hex
      ,*   Dec-base Base save
      ,*)

     : fetchFourBytes (* address -- value *)
       Zero fetch-argument-stack-pointer
       x|over|xx swap
       Four copy-byte-string
       swap drop
       Exit
     ; define-function

     : saveFourBytes (* value, address -- *)
       swap fetch-argument-stack-pointer
       x|over|xx
       Four copy-byte-string
       drop2
       Exit
     ; define-function

     (*
      ,* test:
      ,*   Hex-base Base save
      ,*    10__10_10_00_00 fetch-argument-stack-pointer
      ,*    dup
      ,*      1 swap save-byte
      ,*    dup
      ,*      1 swap add1 save-byte
      ,*    fetchFourBytes .hex .hex
      ,*    10__10_10_00_00 fetch-argument-stack-pointer
      ,*    dup
      ,*      22_22_22_22 swap saveFourBytes
      ,*    fetchFourBytes .hex .hex
      ,*   Dec-base Base save
      ,*)

     : getLengthOfString (* string[address] -- length *)
       sub4 fetchFourBytes
       Exit
     ; define-function

     : stringIn?StringHeap,from (* string[address] -- True or False *)
       Variable,StringHeap,from fetch
       over over
       Size-of-string-heap +  <
       xx|swap|x  >=
       bitwise-and
       Exit
     ; define-function

     : stringIn?StringHeap,to (* string[address] -- True or False *)
       Variable,StringHeap,to fetch
       over over
       Size-of-string-heap +  <
       xx|swap|x  >=
       bitwise-and
       Exit
     ; define-function

     : withLength,copy-byte-string
       (* source address, destination address, length -- *)
       dup x|over|xx saveFourBytes
       swap add4 swap
       copy-byte-string
       Exit
     ; define-function

     : try,copy-substring,from->to
       (* [address, <substring>] -- [address, <substring>] *)
       (*
	,* dup <substring> =/= if
	,*   Exit
	,* then
	,*)
       over dup
       stringIn?StringHeap,to if
	 drop Exit
       then
       CurrFreeStringAddress,to fetch
       over getLengthOfString
       withLength,copy-byte-string
       (* set return value *)
       CurrFreeStringAddress,to fetch add4
       |123->321|
       (* update CurrFreeStringAddress,to *)
       getLengthOfString add4
       CurrFreeStringAddress,to add-save
       Exit
     ; define-function

     (* test: *)
     (*
      ,* CurrFreeStringAddress,to fetch
      ,*   s" xxx " dup2 print-string (\* xxx *\)
      ,*   drop <substring>
      ,*   try,copy-substring,from->to
      ,*   drop2
      ,* add4 dup
      ,* getLengthOfString
      ,* print-string (\* xxx *\)
      ,*)


     : try,copy-substring,from->to,forCar
       (* [address, <pair-like>] -- [address, <pair-like>] *)
       over fetch2 (* this line is as car *)
       dup <substring> =/= if
	 drop2 (* drop car *)
	 Exit
       then
       try,copy-substring,from->to
       x|over|xxx save2 (* this line is as set-car! *)
       Exit
     ; define-function

     : try,copy-substring,from->to,forCdr
       (* [address, <pair-like>] -- [address, <pair-like>] *)
       over Car-bytes-size + fetch2 (* this line is as cdr *)
       dup <substring> =/= if
	 drop2 (* drop cdr *)
	 Exit
       then
       try,copy-substring,from->to
       x|over|xxx Car-bytes-size + save2 (* this line is as set-cdr! *)
       Exit
     ; define-function


     (*
      ,* {* s" xxx" drop <substring>
      ,*    s" ppp" drop <substring> *}
      ,*
      ,* dup2
      ,*   car printTypeTag cr (\* <substring> *\)
      ,*   dup getLengthOfString
      ,*   print-string cr (\* xxx *\)
      ,* dup2
      ,*   cdr printTypeTag cr (\* <substring> *\)
      ,*   dup getLengthOfString
      ,*   print-string cr (\* ppp *\)
      ,*
      ,* dup2
      ,*   car drop .hex cr (\* >< *\)
      ,* dup2
      ,*   cdr drop .hex cr (\* >< *\)
      ,*
      ,* dup2
      ,*   try,copy-substring,from->to,forCar
      ,*   try,copy-substring,from->to,forCdr
      ,*
      ,* dup2
      ,*   car printTypeTag cr (\* <substring> *\)
      ,*   dup getLengthOfString
      ,*   print-string cr (\* xxx *\)
      ,* dup2
      ,*   cdr printTypeTag cr (\* <substring> *\)
      ,*   dup getLengthOfString
      ,*   print-string cr (\* ppp *\)
      ,*
      ,* (\* the two hex numbers must be different *\)
      ,* dup2
      ,*   car drop .hex cr (\* >< *\)
      * dup2
      *   cdr drop .hex cr (\* >< *\)
      *
      * drop2
      *)
     #+end_src
**** readString
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : readNonStringEndingChar (* -- FirstNonBlankChar or Zero *)
       read-char
       dup '"' == if
	 drop Zero
       then Exit
     ; define-function

     : help,readString,loop (* begin-address -- end-address *)
       readNonStringEndingChar
       dup zero? if
	 drop Exit
       then
       over save-byte
       add1
       help,readString,loop
       Exit
     ; defineRecursiveFunction

     : readString (* -- string[address, length] *)
       CurrFreeStringAddress,from fetch add4
       dup (* leave begin-address *)
	 help,readString,loop
       dup (* leave end-address *)
	 CurrFreeStringAddress,from save
       over -
       dup (* return: length *)
       x|over|xx (* return: address *)
       sub4 saveFourBytes
       Exit
     ; define-function

     : s" (* -- string[address, length] *)
       readString Exit
     ; define-function

     (* test: *)
     (* s" 123 xxx aaa !!! @@@ ###" print-string *)
     #+end_src
*** gc & <pair> & <string>
**** notation
     Lisp was originally implemented on the IBM 704 computer, in the late 1950s.
     The 704 hardware had special support for
     splitting a 36-bit machine word into four parts:
     1. address part   : 15 bits
     2. decrement part : 15 bits
     3. prefix part    : 3 bits
     4. tag part       : 3 bits
     Precursors to Lisp included the following functions:
     (The term "register" in the following context refers to "memory location")
     1. car : Contents of the Address part of Register number
     2. cdr : Contents of the Decrement part of Register number
     3. cpr : Contents of the Prefix part of Register number
     4. ctr : Contents of the Tag part of Register number
     --------------------------------------------------------
     in my cicada, for my PairConstruction
     I introduce the following c*r functions:
     (maybe more in the future, if needed)
     1. clr : color byte
        for garbage-collection
     2. car : contents of the address part of a PairConstruction
        as the first typed-value of a pair
     3. cdr : contents of the decrement part of a PairConstruction
        as the second typed-value of a pair
**** the construction & clr, car, cdr
     #+begin_src cicada :tangle ../play/english-core.ccd 
     (* the construction of pair : [unit : byte]
      ,* clr:
      ,*     ||  1 : color     ||
      ,* car:
      ,*     ||  8 : type tag  ||
      ,*     ||  8 : value     ||
      ,* cdr:
      ,*     ||  8 : type tag  ||
      ,*     ||  8 : value     ||
      ,*)

     (* the following constants are defined in assembler:
      ,* Cons-bytes-size == 33
      ,* Clr-bytes-size  ==  1
      ,* Car-bytes-size  == 16
      ,* Cdr-bytes-size  == 16
      ,*)

     :" clr said:
	``My function-type is (* [address, <pair-like>] -- color-byte *)
	  But the type I received is the following,
	  I will not touch it and call debuger.''
	--> "
     : String,clr,type-error ; defineConstString
     : clr (* [address, <pair-like>] -- color-byte *)
       dup <not-pair-like>? if
	 String,clr,type-error print-string
	 dup printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag *)
       sub1 fetch-byte Exit
     ; define-function


     :" car said:
	``My function-type is (* [address, <pair-like>] -- [value, type] *)
	  But the type I received is the following,
	  I will not touch it and call debuger.''
	--> "
     : String,car,type-error ; defineConstString
     : car (* [address, <pair-like>] -- [value, type] *)
       dup <not-pair-like>? if
	 String,car,type-error print-string
	 dup printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag *)
       fetch2 Exit
     ; define-function


     :" cdr said:
	``My function-type is (* [address, <pair-like>] -- [value, type] *)
	  But the type I received is the following,
	  I will not touch it and call debuger.''
	--> "
     : String,cdr,type-error ; defineConstString
     : cdr (* [address, <pair-like>] -- [value, type] *)
       dup <not-pair-like>? if
	 String,cdr,type-error print-string
	 dup printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag *)
       Car-bytes-size + fetch2 Exit
     ; define-function
     #+end_src
**** color & set-clr!
     two colors is enough
     a black pair in GreyPairStackTop is as a ``grey'' pair
     a grey-pair denotes front of the spreading black sub-graph
     these nodes maybe at the junction of black and white (maybe not)
     #+begin_src cicada :tangle ../play/english-core.ccd 
     0 : White ; defineConst
     1 : Black ; defineConst

     (* set three offsets used by fetch-byte, set-bit, clear-bit *)
     0 : VariableColorOffsetForFinding  ; defineVar
     1 : VariableColorOffsetForMarking  ; defineVar
     2 : VariableColorOffsetForCleaning ; defineVar
     : ColorOffsetForFinding  VariableColorOffsetForFinding  fetch Exit ; define-function
     : ColorOffsetForMarking  VariableColorOffsetForMarking  fetch Exit ; define-function
     : ColorOffsetForCleaning VariableColorOffsetForCleaning fetch Exit ; define-function

     :" set-clr! said:
	``My function-type is (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
	  If I view the second argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,set-clr!,type-error ; defineConstString
     : set-clr! (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
       over dup  <not-pair-like>? if
	 String,set-clr!,type-error print-string
	 printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag *)
       x|over|xx sub1 save-byte Exit
     ; define-function
     #+end_src
**** marking
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : whiteColorForMarking? (* color-byte -- True or False *)
       ColorOffsetForMarking fetch-bit White == Exit
     ; define-function

     : blackColorForMarking? (* color-byte -- True or False *)
       ColorOffsetForMarking fetch-bit Black == Exit
     ; define-function

     : black-<pair>? (* [address, <pair-like>] -- True or False *)
       clr blackColorForMarking? Exit
     ; define-function


     (* the following function is the only function who push-grey-pair-stack
      ,* and this function is called by one,grey->black and so on *)
     :" try,white->grey said:
	``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
	  But the type I received is the following,
	  I will not touch it and call debuger.''
	--> "
     : String,try,white->grey,type-error ; defineConstString
     : try,white->grey (* [address, <pair-like>] -- [address, <pair-like>] *)
       dup <not-pair-like>? if
	 String,try,white->grey,type-error print-string
	 dup printTypeTag cr
	 debuger
	 Exit
       then
       dup2 clr
       dup
       whiteColorForMarking? if
	 ColorOffsetForMarking set-bit set-clr!

	 try,copy-substring,from->to,forCar
	 try,copy-substring,from->to,forCdr
	 over push-grey-pair-stack
	 Exit
       then
       drop (* drop the color-byte *) Exit
     ; define-function


     : one,try,grey->black (* -- *)
       empty-grey-pair-stack? if
	 Exit
       then
       pop-grey-pair-stack dup
	 fetch2 dup <pair-like>? if
	   try,white->grey
	 then drop2
	 Car-bytes-size +
	 fetch2 dup <pair-like>? if
	   try,white->grey
	 then drop2
       Exit
     ; define-function


     (* the following is a help-function of all,grey->black
      ,* the GreyPairStack must not be empty when it is called *)

     : one,grey->black (* -- *)
       pop-grey-pair-stack dup
	 fetch2 dup <pair-like>? if
	   try,white->grey
	 then drop2
	 Car-bytes-size +
	 fetch2 dup <pair-like>? if
	   try,white->grey
	 then drop2
       Exit
     ; define-function

     : all,grey->black (* -- *)
       empty-grey-pair-stack? if
	 Exit
       then
       one,grey->black
       all,grey->black Exit
     ; defineRecursiveFunction
     #+end_src
**** set!, set-car!, set-cdr!
     in cicada, to make the gc to be incremental
     there are many strategies you can use
     the following shows one of them
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : set!
       (* VarForTypedValue[address], [value, type] -- VarForTypedValue[address] *)
       dup <pair-like>? if
	 all,grey->black (* to be incremental-gc is to call this function here *)
	 try,white->grey
       then
       x|over|xx save2
       Exit
     ; define-function


     : help,set-car!&set-cdr!,for-black-<pair>
       (* [valus, type] -- [valus, type] *)
       dup <pair-like>? if
	 all,grey->black (* to be incremental-gc is to call this function here *)
	 try,white->grey
       then
       Exit
     ; define-function


     :" set-car! said:
	``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
	  If I view the third argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,set-car!,type-error ; defineConstString

     : set-car!
       (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
       x|over|xx dup  <not-pair-like>? if
	 String,set-car!,type-error print-string
	 printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag overed *)
       xx|over|xx black-<pair>? if
	 help,set-car!&set-cdr!,for-black-<pair>
       then
       x|over|xxx save2
       Exit
     ; define-function


     :" set-cdr! said:
	``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
	  If I view the third argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,set-cdr!,type-error ; defineConstString

     : set-cdr!
       (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
       x|over|xx dup  <not-pair-like>? if
	 String,set-cdr!,type-error print-string
	 printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag overed *)
       xx|over|xx black-<pair>? if
	 help,set-car!&set-cdr!,for-black-<pair>
       then
       x|over|xxx Car-bytes-size + save2
       Exit
     ; define-function


     (* ------------------------------------------------- *)


     :" [cons,car]! said:
	``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
	  If I view the third argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,[cons,car]!,type-error ; defineConstString

     : [cons,car]!
       (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
       x|over|xx dup  <not-pair-like>? if
	 String,[cons,car]!,type-error print-string
	 printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag overed *)
       xx|over|xx black-<pair>? if
	 help,set-car!&set-cdr!,for-black-<pair>
       then
       x|over|xxx save2
       Exit
     ; define-function


     :" [cons,cdr]! said:
	``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
	  If I view the third argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,[cons,cdr]!,type-error ; defineConstString

     : [cons,cdr]!
       (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
       x|over|xx dup  <not-pair-like>? if
	 String,[cons,cdr]!,type-error print-string
	 printTypeTag cr
	 debuger Exit
       then
       drop (* drop the type-tag overed *)
       xx|over|xx black-<pair>? if
	 help,set-car!&set-cdr!,for-black-<pair>
       then
       x|over|xxx Car-bytes-size + save2
       Exit
     ; define-function


     (* ------------------------------------------------- *)


     :" [car,cons]! said:
	``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
	  If I view the first argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,[car,cons]!,type-error ; defineConstString

     : [car,cons]!
       (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
       (* you can read this as ``car-cons-set'' *)
       dup <not-pair-like>? if
	 String,[car,cons]!,type-error print-string
	 dup printTypeTag cr
	 debuger Exit
       then
       dup2 black-<pair>? if
	 xx|swap|xx help,set-car!&set-cdr!,for-black-<pair> xx|swap|xx
       then
       xx|tuck|xx
       drop save2
       Exit
     ; define-function


     :" [cdr,cons]! said:
	``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
	  If I view the first argument as a type-tag,
	  it will be as the following,
	  I will not touch it and call debuger.''
	--> "
     : String,[cdr,cons]!,type-error ; defineConstString

     : [cdr,cons]!
       (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
       (* you can read this as ``cdr-cons-set'' *)
       dup <not-pair-like>? if
	 String,[cdr,cons]!,type-error print-string
	 dup printTypeTag cr
	 debuger Exit
       then
       dup2 black-<pair>? if
	 xx|swap|xx help,set-car!&set-cdr!,for-black-<pair> xx|swap|xx
       then
       xx|tuck|xx
       drop Car-bytes-size + save2
       Exit
     ; define-function
     #+end_src
**** marking & define
     define and set! are the interface of dynamic-typed-value
     #+begin_src cicada :tangle ../play/english-core.ccd 
     (* recall
      ,* a word in the dictionary [unit : Cell-width = 8 bytes]
      ,*   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
      ,*   ||  m : name-string  ||
      ,*   ||  1 : SizeOfFunctionBody  ||
      ,*   ||  1 : identification  ||
      ,*   ||  1 : link  ||
      ,*   ||  1 : type  ||
      ,*   ||  1 : address-of-name-string-header  ||
      ,*   ||  1 : address-of-explainer  ||
      ,*   ||  n : body  ||
      ,* where
      ,*   ||  1 : type  ||
      ,* ==
      ,*   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
      ,* type-bit-0 is for HiddenWord
      ,* type-bit-1 is for VariableOfTypedValue
      ,*)

     : create-word-header-for-typed-value
       (* string[address, length] -- word[address of link] *)
       Here fetch xx|swap|x (* address-of-name-string-header *)
       append-string-to-here
       Here fetch append-number-to-here (* identification *)
       Here fetch (* leave the word[link] *)
       Zero append-number-to-here (* link *)
       Two append-number-to-here  (* type *)
       swap
       append-number-to-here (* address-of-name-string-header *)
       Exit
     ; define-function

     : define,byString
       (* [value, type], string[address, length] -- *)
       create-word-header-for-typed-value
       Variable-explainer append-number-to-here
       xx|swap|x  (* leave wordHeader *)
       dup <pair-like>? if
	 try,white->grey
       then
       append-number-to-here append-number-to-here
       add-new-word-to-dictionary
       Exit
     ; define-function

     : define
       (* [value, type], wordList[address, the number of words] -- *)
       head-of-word-list
       define,byString
       Exit
     ; define-function
     #+end_src
**** finding & cons : constructor of <pair>
     #+begin_src cicada :tangle ../play/english-core.ccd 
     (* the following functions are helping cons *)
     
     : clearColorBitOfPairForCleaning (* pair[address] -- pair[address] *)
         <pair>
         dup2 clr
         ColorOffsetForCleaning clear-bit
         set-clr!
         drop
         Exit
     ; define-function
     
     : whiteColorForFinding? (* color-byte -- True or False *)
         ColorOffsetForFinding fetch-bit White ==
         Exit
     ; define-function
     
     : findNextFreePairConstruction
       (* pair[address] -- Zero or NextFreePairConstruction[address] *)
         dup Last-pair-construction == if
           drop Zero Exit
         then
         Cons-bytes-size +
         clearColorBitOfPairForCleaning
         dup <pair> clr
         whiteColorForFinding? if
           Exit
         then
         findNextFreePairConstruction
         Exit
     ; defineRecursiveFunction
     
     
     
     (* a cyclic permutation
      ,* of the two three period cyclic permutation
      ,* in the third-order permutation group
      VariableColorOffsetForFinding  --> VariableColorOffsetForCleaning
      VariableColorOffsetForMarking  --> VariableColorOffsetForFinding
      VariableColorOffsetForCleaning --> VariableColorOffsetForMarking
      ,*)
     : resetColorOffsets (* -- *)
         VariableColorOffsetForFinding  fetch
         VariableColorOffsetForMarking  fetch
         VariableColorOffsetForCleaning fetch
         VariableColorOffsetForMarking  save
         VariableColorOffsetForFinding  save
         VariableColorOffsetForCleaning save
         Exit
     ; define-function
     
     
     : dynamicVariableWordFor<pair-like>? (* word[address of link] -- True or False *)
         dup dynamicVariableWord? if
         word-link->word-explainer execute fetch2
         swap drop
         <pair-like>?
         Exit
         then
         drop False Exit
     ; define-function
     
     : help,pushAllRootNodeIntoGreyPairStack (* word[address of link] -- *)
         dup lastWordInTheDictionary? if
           drop Exit
         then
         dup dynamicVariableWordFor<pair-like>? if
         dup word-link->word-explainer execute fetch2
         try,white->grey drop2
         then
         nextWordInTheDictionary
         help,pushAllRootNodeIntoGreyPairStack
         Exit
     ; defineRecursiveFunction
     
     : pushAllRootNodeIntoGreyPairStack (* -- *)
         first-word-in-dictionary fetch
         help,pushAllRootNodeIntoGreyPairStack
         Exit
     ; define-function
     
     
     
     (* the following function is not intrinsic
        but I have to use it this way *)
     
     (* a value meet the following three conditions is an AddressOfPair
      ,*  (the following is infix notations)
      ,* 1. Value >= First-pair-construction
      ,* 2. Value <= Last-pair-construction
      ,* 3. [Value - First-pair-construction] mod Cons-bytes-size == 0
      ,*)
     
     : addressOfPair? (* value -- True or False *)
         dup First-pair-construction < if
           drop False Exit
         then
         dup Last-pair-construction > if
           drop False Exit
         then
         First-pair-construction - Cons-bytes-size mod zero?
         Exit
     ; define-function
     
     
     
     : help,allPairsInArgumentStack,try,white->grey
       (* address of a Cell in ArgumentStack -- *)
         dup Argument-stack-top > if
           drop Exit
         then
         dup fetch addressOfPair? if
           dup fetch
           <pair> try,white->grey
           drop2
         then
         Cell-width +
         help,allPairsInArgumentStack,try,white->grey
         Exit
     ; defineRecursiveFunction
     : allPairsInArgumentStack,try,white->grey (* -- *)
         fetch-argument-stack-pointer
         help,allPairsInArgumentStack,try,white->grey
         Exit
     ; define-function
     
     
     : help,allPairsInLambdaStack,try,white->grey
       (* address of a Cell in LambdaStack -- *)
         dup Lambda-stack-top > if
           drop Exit
         then
         dup fetch addressOfPair? if
           dup fetch
           <pair> try,white->grey
           drop2
         then
         Cell-width +
         help,allPairsInLambdaStack,try,white->grey
         Exit
     ; defineRecursiveFunction
     : allPairsInLambdaStack,try,white->grey (* -- *)
         LambdaStackPointer fetch
         help,allPairsInLambdaStack,try,white->grey
         Exit
     ; define-function
     
     
     
     : resetVariablesAboutString (* -- *)
       CurrFreeStringAddress,to fetch CurrFreeStringAddress,from save
       Variable,StringHeap,from fetch CurrFreeStringAddress,to   save
       Variable,StringHeap,to   fetch Variable,StringHeap,from   save
       CurrFreeStringAddress,to fetch Variable,StringHeap,to     save
       Exit
     ; define-function
     
     
     :"  :gc: "
     : String,gc ; defineConstString
     
     :" cons said: ``Memory for cons is used up! No value is returned!''"
     : String,cons,MemoryIsUsedUp ; defineConstString
     
     : cons (* -- [address, <pair>] *)
         Current-free-pair-construction fetch <pair> (* leave the return <value> *)
         Current-free-pair-construction fetch findNextFreePairConstruction
         dup not-zero? (* Zero denotes fail to find *) if
           Current-free-pair-construction save
           Exit
         then drop (* drop the Zero, which denotes fail to find, need gc *)
         allPairsInArgumentStack,try,white->grey
         all,grey->black
         resetColorOffsets resetVariablesAboutString (* note the timing to reset *)
         pushAllRootNodeIntoGreyPairStack
         In-front-of-the-first-pair-construction findNextFreePairConstruction
         dup not-zero? if
           Current-free-pair-construction save
           String,gc print-string
           Exit
         then drop
         (* if after gc still fail to find, we know the memory is used up *)
         drop2
         String,cons,MemoryIsUsedUp print-string cr
         debuger
         Exit
     ; define-function
     #+end_src
**** substring & string : constructor of <substring> & <string>
     #+begin_src cicada :tangle ../play/english-core.ccd 
     : read-string (* -- [address, <string>] *)
       cons drop (* drop <pair> *) <string>
       s" drop (* drop length *) <substring>
       set-car!
       null set-cdr!
       Exit
     ; define-function

     : ::" (* -- [address, <string>] *)
       read-string Exit
     ; define-function


     :" write-string said:
	``My function-type is ( [address, <string>] -- ).
	  But the type I received is the following,
	  I will not touch it and call debuger.''
	--> "
     : String,write-string,type-error ; defineConstString

     : write-string (* [address, <string>] -- *)
       dup <string> =/= if
	 String,write-string,type-error print-string
	 dup printTypeTag cr
	 debuger Exit
       then
       car drop (* drop <substring> *)
       dup getLengthOfString print-string
       Exit
     ; define-function

     : substring (* length -- address *)
       (* allocate a substring of the given length *)
       CurrFreeStringAddress,from fetch add4 swap (* leave begin-address *)
       dup CurrFreeStringAddress,from fetch saveFourBytes
       Four + CurrFreeStringAddress,from add-save
       Exit
     ; define-function

     : string (* length -- [address, <string>] *)
       (* allocate a string of the given length *)
       substring <substring>
       null
       cons drop <string>
       [cdr,cons]!
       [car,cons]!
       Exit
     ; define-function
     #+end_src
**** about test
     #+begin_src cicada :tangle ../play/english-core.ccd 
     (* for test *)
     : printTypeOfIt (* type -- *)
       printTypeTag ':' write-char writeSpace Exit
     ; define-function

     (* test: gc *)
     : ask-for-lots-of-cons (* n -- *)
	 dup zero? if drop Exit
	 then
	 sub1
	 cons
	   literal 555 <fixnum> set-car!
	   literal 666 <fixnum> set-cdr!
	 drop2
	 ask-for-lots-of-cons
	 Exit
     ; defineRecursiveFunction

     : ask-for-lots-of-cons,leave-them-on-the-ArgumentStack (* n -- *)
	 dup zero? if drop Exit
	 then
	 sub1
	 cons
	   literal 555 <fixnum> set-car!
	   literal 666 <fixnum> set-cdr!
	 x|swap|xx
	 ask-for-lots-of-cons,leave-them-on-the-ArgumentStack
	 Exit
     ; defineRecursiveFunction
     #+end_src
*** test
    #+begin_src cicada
    : {* cons Exit ; define-function
    : *} xx|swap|xxxx [cdr,cons]! [car,cons]! Exit ; define-function


    (* test: define *)
    6 <fixnum> : Liu-fixnum ; define
    Liu-fixnum fetch2 printTypeOfIt . cr (* <fixnum>: 6 *)

    (* test: cons *)
    cons 9 <fixnum> set-car!
	 8 <fixnum> set-cdr!
    dup2
      car printTypeOfIt . cr (* <fixnum>: 9 *)
    dup2
      cdr printTypeOfIt . cr (* <fixnum>: 8 *)
    drop2

    {* 9 <fixnum>  8 <fixnum> *}
    dup2
      car printTypeOfIt . cr (* <fixnum>: 9 *)
    dup2
      cdr printTypeOfIt . cr (* <fixnum>: 8 *)
    drop2

    (* test: cons *)
    9 <fixnum>  8 <fixnum>  cons
    [cdr,cons]! [car,cons]!
    dup2
      car printTypeOfIt . cr (* <fixnum>: 9 *)
    dup2
      cdr printTypeOfIt . cr (* <fixnum>: 8 *)
    drop2


    (* test: define a pair *)
    cons 9 <fixnum> set-car!
	 8 <fixnum> set-cdr!
    : Simple-pair ; define
    Simple-pair fetch2
    dup2
      car printTypeOfIt . cr (* <fixnum>: 9 *)
    dup2
      cdr printTypeOfIt . cr (* <fixnum>: 8 *)
    drop2


    (* test: set-car! & set-cdr! *)
    Simple-pair fetch2
      {* 7 <fixnum>   6 <fixnum> *}
    set-car!
    dup2
      car car printTypeOfIt . cr (* <fixnum>: 7 *)
    dup2
      car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
    drop2




    Simple-pair fetch2
      {* 5 <fixnum>
	 {* 4 <fixnum>  3 <fixnum> *} *}
    set-cdr!

    dup2
      car car printTypeOfIt . cr (* <fixnum>: 7 *)
    dup2
      car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
    dup2
      cdr car printTypeOfIt . cr (* <fixnum>: 5 *)
    dup2
      cdr cdr car printTypeOfIt . cr (* <fixnum>: 4 *)
    dup2
      cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
    drop2




    (* test: all,grey->black *)
      empty-grey-pair-stack? . cr (* 0 *)
      all,grey->black
      empty-grey-pair-stack? . cr (* 1 *)


    (* test: marking *)
      Simple-pair fetch2
      cdr cdr clr ColorOffsetForMarking fetch-bit . cr (* 1 *)




    all,grey->black


    (* test: reset set-cdr! *)
    Simple-pair fetch2
      {* 1 <fixnum>
	 {* 2 <fixnum>  3 <fixnum> *} *}
    set-cdr!

    dup2
      car car printTypeOfIt . cr (* <fixnum>: 7 *)
    dup2
      car cdr printTypeOfIt . cr (* <fixnum>: 6 *)

    dup2
      cdr car printTypeOfIt . cr (* <fixnum>: 1 *)
    dup2
      cdr cdr car printTypeOfIt . cr (* <fixnum>: 2 *)
    dup2
      cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
    drop2



    (* test: gc *)
    : ask-for-lots-of-cons (* n -- *)
	dup zero? if drop Exit
	then
	sub1
	{* literal 555 <fixnum>
	   literal 666 <fixnum> *}
	drop2
	ask-for-lots-of-cons
	Exit
    ; defineRecursiveFunction


    Number-of-pair-constructions ask-for-lots-of-cons

    Number-of-pair-constructions 30 * ask-for-lots-of-cons




    (* after gc the Simple-pair must still be ok *)
    Simple-pair fetch2

    dup2
      car car printTypeOfIt . cr (* <fixnum>: 7 *)
    dup2
      car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
    dup2
      cdr car printTypeOfIt . cr (* <fixnum>: 1 *)
    dup2
      cdr cdr car printTypeOfIt . cr (* <fixnum>: 2 *)
    dup2
      cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
    drop2



    (* ----------------------------------------------------------- *)
    (* after gc the values in the stack must still be ok *)

    {* {* 147 <fixnum>
	  258 <fixnum> *}
       369 <fixnum> *}

    Number-of-pair-constructions 30 * ask-for-lots-of-cons

    dup2

    cr
    dup2
       car car printTypeOfIt . cr (* <fixnum>: 147 *)
    dup2
       car cdr printTypeOfIt . cr (* <fixnum>: 258 *)
    dup2
       cdr printTypeOfIt . cr (* <fixnum>: 369 *)
    drop2
    ok

    Number-of-pair-constructions 30 * ask-for-lots-of-cons

    cr
    dup2
       car car printTypeOfIt . cr (* <fixnum>: 147 *)
    dup2
       car cdr printTypeOfIt . cr (* <fixnum>: 258 *)
    dup2
       cdr printTypeOfIt . cr (* <fixnum>: 369 *)
    drop2
    ok





    (* ----------------------------------------------------------- *)
    (* about string *)
    (* after gc the values in the stack must still be ok *)


    ::" 111 "
    Number-of-pair-constructions  ask-for-lots-of-cons
    ::" 222 "
    Number-of-pair-constructions  ask-for-lots-of-cons
    ::" 333 "
    Number-of-pair-constructions  ask-for-lots-of-cons
    Number-of-pair-constructions  ask-for-lots-of-cons
    cr ok

    write-string write-string write-string (* 333 222 111 *)
    cr


    ::" aaa "
    : Simple-string ; define
    Number-of-pair-constructions ask-for-lots-of-cons
    ::" AAA "
    Number-of-pair-constructions ask-for-lots-of-cons
    ::" AAA "
    Number-of-pair-constructions ask-for-lots-of-cons
    ::" AAA "
    Number-of-pair-constructions ask-for-lots-of-cons
    ::" AAA "
    ::" AAA "
    ::" AAA "
    Number-of-pair-constructions 20 * ask-for-lots-of-cons
    ok (* yse *)

    Simple-string fetch2 write-string (* aaa *)

    Number-of-pair-constructions  ask-for-lots-of-cons
    write-string write-string write-string (* AAA AAA AAA *)
    cr
    Number-of-pair-constructions  ask-for-lots-of-cons
    write-string write-string write-string (* AAA AAA AAA *)
    cr





    (* ----------------------------------------------------------- *)
    (* about using up memory *)


    (*
     ,* Number-of-pair-constructions
     ,* ask-for-lots-of-cons,leave-them-on-the-ArgumentStack
     ,*
     ,*
     ,* (\* in debugerREPL: *\)
     ,*   1 debuger,fetchFromReturnStack traceFunction
     ,*   2 debuger,fetchFromReturnStack traceFunction
     ,*
     ,* basic-REPL countArgumentStack . cr (\* 0 *\)
     *)
    #+end_src
** --------------------------------------
** about list-processing
*** note
    1. but the value you put into a list or a dalin
       should always be converted to dynamic-typed-value
       while they should always be read as simple as possible
    2. I found out that to parse post-lambda expression easily
       we have to always use dalin
       so dalin should be the default-list used in cicada
    3. so I have the following notations about list-processing :
       | { } | list   | single-linked-list |
       | [ ] | dalin  | double-linked-list |
       | ( ) | wodyli | wordy-list         |
    4. if I define ``['' and ``{'' as readers
       then, as functions the have to call each other
       due to the semantic of cicada
       this calls can not be compiled into the function-bodys of them
       unless I introduce new syntaxes
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" {" : String,begining-list ; defineConstString
    :" }" : String,ending-list   ; defineConstString

    :" ." : String,dot           ; defineConstString

    :" (esc" : String,begining-list-escape ; defineConstString
    :" )"    : String,ending-list-escape   ; defineConstString

    :" [" : String,begining-*dalin ; defineConstString
    :" ]" : String,ending-*dalin   ; defineConstString

    :" (" : String,begining-wodyli ; defineConstString
    :" )" : String,ending-wodyli   ; defineConstString
    #+end_src
** write
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" write-list"    : String,write-list   ; defineConstString
    :" write-*dalin"  : String,write-*dalin ; defineConstString
    :" write-wodyli"  : String,write-wodyli ; defineConstString
    :" write-wody-or-bound-variable"
    : String,write-wody-or-bound-variable ; defineConstString

    :" null"  : String,null ; defineConstString

    :" write said:
       ``I do not know how to write the following type of value,
	 I will not touch it and call debuger.''
       --> "
    : String,write,type-error ; defineConstString

    : write (* [value, type] -- *)
      dup <fixnum> == if drop (* drop type-tag *)
	writeDecNumber  writeSpace
	Exit
      then
      dup <symbol> == if drop (* drop type-tag *)
	index-hashback->string print-string  writeSpace
	Exit
      then
      dup <null> == if drop (* drop type-tag *)
	drop
	String,null print-string writeSpace
	Exit
      then
      dup <list> == if
	String,write-list find word-link->word-explainer execute
	Exit
      then
      dup <dalin> == if
	String,write-*dalin find word-link->word-explainer execute
	Exit
      then
      dup <wody> ==
      over <bound-variable> ==
      bitwise-or if
	String,write-wody-or-bound-variable find word-link->word-explainer execute
	Exit
      then
      dup <wodyli> == if
	String,write-wodyli find word-link->word-explainer execute
	Exit
      then
      String,write,type-error print-string
      dup printTypeTag cr
      debuger Exit
    ; define-function
    #+end_src
** read-list & write-list
*** note
1. this is the old good lisp-like single-linked-list
2. like the language shen
   I do not use '() to quote a list (as in LISP)
   but use {} and []
   [ 1 (esc + 1 1 ) 3 ] or
   { 1 (esc + 1 1 ) 3 } as
   `(1 ,(+ 1 1) 3) in LISP
   because ``quote'' in LISP is just to provide you
   a convenient mechanism to read a list
3. the good about LISP's way is that
   you can quote a symbol out side the list as 'a-symbol
   otherwise the symbol will be treated as a variable
4. while in shen
   if one type ``a-symbol'' into the REPL
   it will be treated as a symbol
   you have to use a explicit way
   to treat it as a variable, i.e. ``(value a-symbol)''
5. in cicada things are very different
   no analogy should be drawed here
6. the ``list-escape'' is very interesting
   it is to call a another reader in a list-reader
   and get back to the list-reader when finished
   it looks like the classic forth REPL
   which have two modes
   at first in the implementation of cicada
   I try to avoid many modes in REPL
   but now the list-leader brings me back to the classic forth
*** execute-word,for-list-reader
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : stringDenoteListReader?
      (* string[address, length] -- True or False *)
      dup2 String,begining-list equal-string? if
	drop2 True Exit
      then
      dup2 String,begining-list-escape equal-string? if
	drop2 True Exit
      then
      dup2 String,begining-*dalin equal-string? if
	drop2 True Exit
      then
      dup2 String,begining-wodyli equal-string? if
	drop2 True Exit
      then
      drop2 False Exit
    ; define-function

    (* then we need mutually recursive call *)
    : execute-word,for-list-reader
      (* string[address, length] -- [value, type] *)
      dup2 stringDenoteListReader? if
	find word-link->word-explainer execute
	Exit
      then
      dup2 string-denote-number? if
	number drop <fixnum>
	Exit
      then
      dup2 String,null equal-string? if
	drop2 null
	Exit
      then
      string-hash->index <symbol>
      Exit
    ; define-function
    #+end_src
*** list-escape-REPL
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : list-escape-REPL
      (* could  be: unknown -- unknown *)
      (* should be:  -- [value, type] *)
      read-word-for-runtime
      dup2
      string-denote-number? if
	number drop
	list-escape-REPL
	Exit
      then
      dup2
      String,ending-list-escape equal-string? if
	drop2
	Exit
      then
      dup2 find dup not-zero? if
        xx|swap|x drop2
	word-link->word-explainer execute
	list-escape-REPL
	Exit
      then
      drop
      String,undefined-word print-string
      print-string cr
      list-escape-REPL
      Exit
    ; defineRecursiveFunction

    : (esc list-escape-REPL Exit ; define-function
    #+end_src
*** read-list
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : read-list (* -- [address, <list>] *)
      read-word
      dup2 String,ending-list equal-string? if
	drop2
	null Exit
      then
      dup2 String,dot equal-string? if
	drop2
	read-list car
	(* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
	Exit
      then
      execute-word,for-list-reader
      cons drop <list>
	xx|swap|xx  set-car!
	read-list   set-cdr!
      Exit
    ; defineRecursiveFunction

    : { read-list Exit ; define-function
    #+end_src
*** write-list
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,write-list (* [address, <list>] or [Null, <null>] -- *)
      dup <null> == if
	drop2 Exit
      then
      dup <pair-like>? if
	dup2
	car write
	cdr help,write-list
	Exit
      then
      String,dot print-string writeSpace
      write
      Exit
    ; defineRecursiveFunction


    :" write-list said:
       ``My function-type is (* [address, <list>] -- *)
	 But the 1st argument is the following
	 I will not touch it and call debuger.''
       --> "
    : String,write-list,type-error ; defineConstString

    : write-list (* [address, <list>] -- *)
      dup <list> =/= if
	String,write-list,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      String,begining-list print-string writeSpace
      help,write-list
      String,ending-list print-string writeSpace
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    { 1
      { 1 2 3 4 5   { 1 2 3 4 5  6 }  6  }
	xxx 3 4 5
      { 1 2 3 4 5  6 } 6 }
    write-list

    { 1 . 2 } write-list
    { 1 2 3 4 5 6 7 8 9 . 0 } write-list
    { 1 . { 1 . 2 } } write-list
    { 1 . { 1 . (esc 2 <fixnum> ) } } write-list
    { 1 . { 1 . (esc 2 <fixnum> ) } } write


    (* beware of the following,
       error will not occurs ! *)

    { 1 . 2 3 }
    write-list  (* { 1 . 2 } *)

    { 1 . 2 { 1 . 2 3 } }
    write-list  (* { 1 . 2 } *)


    (* test: mutually recursive call *)
    { 1 [ 1 2 3 ] { 1 . (esc 2 <fixnum> ) } } write
    { 1 [ 1 2 3 ] . { 1 . (esc 2 <fixnum> ) } } write
    #+end_src
** set-*!
*** >< note
the name of the following functions should be changed
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" set-car-to-{car}! said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,set-car-to-{car}!,type-error ; defineConstString
    (* [car.cdr]->[[car].cdr] *)
    : set-car-to-{car}!
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
	String,set-car-to-{car}!,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      dup2
      car cons
	xx|swap|xx set-car!
	null set-cdr!
      set-car!
      Exit
    ; define-function


    :" set-car-to-{cdr}! said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,set-car-to-{cdr}!,type-error ; defineConstString
    (* [car.cdr]->[car.[cdr]] *)
    : set-cdr-to-{cdr}!
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
	String,set-car-to-{cdr}!,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      dup2
      cdr cons
	xx|swap|xx set-car!
	null set-cdr!
      set-cdr!
      Exit
    ; define-function




    :" set-car-to-{car.x}! said:
       ``My function-type is
	(* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
	 If I view the second argument as a type-tag,
	 It will be the following,
	 I will not touch it and call debuger.''
       --> "
    : String,set-car-to-{car.x}!,type-error ; defineConstString

    : set-car-to-{car.x}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
	String,set-car-to-{car.x}!,type-error print-string
	x|over|xx printTypeTag cr
	debuger Exit
      then
      xx|over|xx
      car cons
	xx|swap|xx set-car!
	xx|swap|xx set-cdr!
      set-car!
      Exit
    ; define-function


    :" set-car-to-{cdr.x}! said:
       ``My function-type is
	(* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
	 If I view the second argument as a type-tag,
	 It will be the following,
	 I will not touch it and call debuger.''
       --> "
    : String,set-car-to-{cdr.x}!,type-error ; defineConstString

    (* [car.cdr],x->[car.[cdr.x]]! *)
    : set-cdr-to-{cdr.x}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
	String,set-car-to-{cdr.x}!,type-error print-string
	x|over|xx printTypeTag cr
	debuger Exit
      then
      xx|over|xx
      cdr cons
	xx|swap|xx set-car!
	xx|swap|xx set-cdr!
      set-cdr!
      Exit
    ; define-function


    :" set-car-to-{x.car}! said:
       ``My function-type is
	(* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
	 If I view the second argument as a type-tag,
	 It will be the following,
	 I will not touch it and call debuger.''
       --> "
    : String,set-car-to-{x.car}!,type-error ; defineConstString

    : set-car-to-{x.car}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
	String,set-car-to-{x.car}!,type-error print-string
	x|over|xx printTypeTag cr
	debuger Exit
      then
      xx|over|xx
      car cons
	xx|swap|xx set-cdr!
	xx|swap|xx set-car!
      set-car!
      Exit
    ; define-function


    :" set-car-to-{x.cdr}! said:
       ``My function-type is
	(* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
	 If I view the second argument as a type-tag,
	 It will be the following,
	 I will not touch it and call debuger.''
       --> "
    : String,set-car-to-{x.cdr}!,type-error ; defineConstString

    : set-cdr-to-{x.cdr}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
	String,set-car-to-{x.cdr}!,type-error print-string
	x|over|xx printTypeTag cr
	debuger Exit
      then
      xx|over|xx
      cdr cons
	xx|swap|xx set-cdr!
	xx|swap|xx set-car!
      set-cdr!
      Exit
    ; define-function
    #+end_src
** dalin processing
*** <- & ->
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" <- said:
       ``My function-type is (* [address, <dalin-like>] -- [address, <dalin>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,<-,type-error ; defineConstString

    : <- (* [address, <dalin-like>] -- [address, <dalin>] *)
      dup <not-dalin-like>? if
	String,<-,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      cdr car Exit
    ; define-function


    :" -> said:
       ``My function-type is (* [address, <dalin-like>] -- [address, <dalin>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,->,type-error ; defineConstString

    : -> (* [address, <dalin-like>] -- [address, <dalin>] *)
      dup <not-dalin-like>? if
	String,->,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      cdr cdr Exit
    ; define-function
    #+end_src
*** list->dalin
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* note that:
       in the following, I am using side-effect to change a existed list
       but NOT to form a new dalin from scratch *)

    : help,list->dalin
      (* [address, <dalin>], left[address, <dalin>] -- [address, <dalin>] *)
      (* or *)
      (* [address, <dalin>], [value, <non-dalin>] -- [address, <dalin>] *)
      set-cdr-to-{x.cdr}! (* set the ``left'' *)
      dup2 cdr
	dup2 cdr <not-pair-like>? if
	  drop (* drop the non-pair-value *)
	  null set-cdr!
	  (* this means the 3 in { 1 2 . 3 } will be droped *)
	  drop2 Exit
	then
	(* change the type-tag of the cdr of the old list, from <list> to <dalin> *)
	(* the pair-like-value is still here *) <dalin> set-cdr!
	cdr
      (* [address, <dalin>], [address, <pair-like>] *)
      xx|swap|xx
      help,list->dalin
      Exit
    ; defineRecursiveFunction


    :" list->*dalin* said:
       ``My function-type is
	 (* [address, <list>] -- head[address, <dalin>], tail[address, <dalin>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,list->*dalin*,type-error ; defineConstString

    : list->*dalin*
      (* [address, <list>] -- head[address, <dalin>], tail[address, <dalin>] *)
      dup <list> =/= if
	String,list->*dalin*,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop <dalin>
      dup2 (* leave the return value *)
      null
      help,list->dalin
      Exit
    ; define-function


    :" list->dalin* said:
       ``My function-type is (* [address, <list>] -- tail[address, <dalin>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,list->dalin*,type-error ; defineConstString

    : list->dalin*
      (* [address, <list>] -- tail[address, <dalin>] *)
      dup <list> =/= if
	String,list->dalin*,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop <dalin>
      null
      help,list->dalin
      Exit
    ; define-function


    :" list->*dalin said:
       ``My function-type is (* [address, <list>] -- head[address, <dalin>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,list->*dalin,type-error ; defineConstString

    : list->*dalin
      (* [address, <list>] -- head[address, <dalin>] *)
      dup <list> =/= if
	String,list->*dalin,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop <dalin>
      dup2 (* leave the return value *)
      null
      help,list->dalin
      drop2
      Exit
    ; define-function
    #+end_src
*** *dalin? & dalin*?
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : *dalin? (* [address, <dalin>] -- True or False *)
      <- null? if
	True Exit
      then
      False Exit
    ; define-function

    : dalin*? (* [address, <dalin>] -- True or False *)
      -> null? if
	True Exit
      then
      False Exit
    ; define-function
    #+end_src
*** nested-list->dalin
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,nested-list->dalin
      (* [address, <dalin>], left[address, <dalin>] -- [address, <dalin>] *)
      (* or *)
      (* [address, <dalin>], [value, <non-dalin>] -- [address, <dalin>] *)
      set-cdr-to-{x.cdr}! (* set the ``left'' *)
      dup2 car dup <list> == if
	list->*dalin set-car!
      else
	drop2
      then
      dup2 cdr
	dup2 cdr <not-pair-like>? if
	  drop (* drop the non-pair-value *)
	  null set-cdr!
	  (* this means the 3 in { 1 2 . 3 } will be droped *)
	  drop2 Exit
	then
	(* change the type-tag of the cdr of the old list, from <list> to <dalin> *)
	(* the pair-like-value is still here *) <dalin> set-cdr!
	cdr
      (* [address, <dalin>], [address, <pair-like>] *)
      xx|swap|xx
      help,nested-list->dalin
      Exit
    ; defineRecursiveFunction


    :" nested-list->*dalin said:
       ``My function-type is (* [address, <list>] -- head[address, <dalin>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,nested-list->*dalin,type-error ; defineConstString

    : nested-list->*dalin
      (* [address, <list>] -- head[address, <dalin>] *)
      dup <list> =/= if
	String,nested-list->*dalin,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop <dalin>
      dup2 (* leave the return value *)
      null
      help,nested-list->dalin
      drop2
      Exit
    ; define-function
    #+end_src
*** dalin->tail & head<-dalin
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" dalin->tail said:
       ``My function-type is
	 (* [address, <dalin-like>] -- tail[address, <dalin-like>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,dalin->tail,type-error ; defineConstString

    : dalin->tail
      (* [address, <dalin-like>] -- tail[address, <dalin-like>] *)
      dup <not-dalin-like>? if
	String,dalin->tail,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      dup2 dalin*? if
	Exit
      then
      ->  dalin->tail
      Exit
    ; defineRecursiveFunction


    :" head<-dalin said:
       ``My function-type is
	 (* [address, <dalin-like>] -- head[address, <dalin-like>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,head<-dalin,type-error ; defineConstString

    : head<-dalin
      (* [address, <dalin-like>] -- head[address, <dalin-like>] *)
      dup <not-dalin-like>? if
	String,head<-dalin,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      dup2 *dalin? if
	Exit
      then
      <-  head<-dalin
      Exit
    ; defineRecursiveFunction
    #+end_src
*** [value,dalin]-associate & [value,dalin]-member?
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" [value,dalin]-associate said:
       ``My function-type is
	 (* [value, type], head[address, <dalin-like>] --
	    associate-pair[address, <pair-like>] or [Null, <null>] *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,[value,dalin]-associate,type-error,at-first
    ; defineConstString

    :" [value,dalin]-associate said:
       ``My function-type is
	 (* [value, type], head[address, <dalin-like>] --
	    associate-pair[address, <pair-like>] or [Null, <null>] *)
	 But in the middle of recursion
	 I found the dalin is not an associated-dalin
	 the following is what I found
	 I will not touch it and call debuger''
       --> "
    : String,[value,dalin]-associate,type-error,in-the-middle
    ; defineConstString

    : help,[value,dalin]-associate
      (* [value, type], head[address, <dalin-like>], or [Null, <null>] --
	 associate-pair[address, <pair-like>] or [Null, <null>] *)
      dup <null> == if
	(* if associate fail, return null *)
	xx|swap|xx drop2 Exit
      then
      dup2
      car dup <not-pair-like>? if
	String,[value,dalin]-associate,type-error,in-the-middle print-string
	dup printTypeTag cr
	debuger Exit
      then
      car
      (* [value, type], head[address, <dalin-like>], car-car[value, type] *)
      xx|over|xxxx eq? if
	xx|swap|xx drop2
	car Exit
      then
      ->  help,[value,dalin]-associate
      Exit
    ; defineRecursiveFunction

    : [value,dalin]-associate
      (* [value, type], head[address, <dalin-like>] --
	 associate-pair[address, <pair-like>] or [Null, <null>] *)
      dup <not-dalin-like>? if
	String,[value,dalin]-associate,type-error,at-first print-string
	dup printTypeTag cr
	debuger Exit
      then
      help,[value,dalin]-associate
      Exit
    ; define-function



    : [value,dalin]-member?
      (* [value, type], [address, <dalin-like>] -- True or False *)
      dup <null> == if
	drop2 drop2 False Exit
      then
      dup2 car
      xx|over|xxxx eq? if
	drop2 drop2 True Exit
      then
      ->  [value,dalin]-member?
      Exit
    ; defineRecursiveFunction
    #+end_src
*** ^_^
    the following function is very important
    it for dalin is as the ``cons'' for list
    but also really different
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" ^_^ said:
       ``My function-type is
	 (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
	     rigth[address, <dalin-like>] *)
	 If I view the 1st argument as a type-tag,
	 it will be as the following,
	 I will not touch it and call debuger.''
       --> "
    : String,^_^,1st-type-error ; defineConstString

    :" ^_^ said:
       ``My function-type is
	 (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
	     rigth[address, <dalin-like>] *)
	 If I view the 3rd argument as a type-tag,
	 it will be as the following,
	 I will not touch it and call debuger.''
       --> "
    : String,^_^,3rd-type-error ; defineConstString


    (* the following ``little-smile-face'' is ``link-dalin'' *)
    : ^_^
      (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
	 rigth[address, <dalin-like>] *)
      (* where: left[address, <dalin-like>] could be a null *)
      dup <not-dalin-like>? if
	String,^_^,1st-type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      x|over|xx <null> == if
	xx|tuck|xx (* leave the return value *)
	cdr xx|over|xx set-car! drop2
	drop2
	Exit
      then
      x|over|xx <not-dalin-like>? if
	String,^_^,3rd-type-error print-string
	x|over|xx printTypeTag cr
	debuger Exit
      then
      xx|tuck|xx (* leave the return value *)
      cdr xx|over|xx set-car! drop2
      cdr xx|over|xx set-cdr! drop2
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    cr

    { 1 2 3 } list->*dalin*
    dup printTypeTag (* <dalin> *) cr


    (* test: tail[address, <dalin>] *) cr
    dup2
      ,*dalin? . (* 0 *) cr
    dup2
      dalin*? . (* 1 *) cr
    dup2
      car printTypeTag writeSpace . (* <fixnum> 3 *) cr
    dup2
      ->
      printTypeTag writeSpace . (* <null> 0 *) cr
    dup2
      <-
      car printTypeTag writeSpace . (* <fixnum> 2 *) cr
    dup2
      <-
      <-
      car printTypeTag writeSpace . (* <fixnum> 1 *) cr
    dup2
      <-
      <-
      ->
      car printTypeTag writeSpace . (* <fixnum> 2 *) cr
    drop2


    (* test: head[address, <dalin>] *) cr
    dup2
      ,*dalin? . (* 1 *) cr
    dup2
      dalin*? . (* 0 *) cr
    dup2
      car printTypeTag writeSpace . (* <fixnum> 1 *) cr
    dup2
      <-
      printTypeTag writeSpace . (* <null> 0 *) cr
    dup2
      ->
      car printTypeTag writeSpace . (* <fixnum> 2 *) cr
    dup2
      ->
      ->
      car printTypeTag writeSpace . (* <fixnum> 3 *) cr
    dup2
      ->
      ->
      <-
      car printTypeTag writeSpace . (* <fixnum> 2 *) cr
    dup2
      ->
      ->
      <-
      <-
      car printTypeTag writeSpace . (* <fixnum> 1 *) cr
    drop2


    (* ----------------------------------------------------- *)

    (* test: nested-list *) cr
    { 1 { 2 3 } 4 } nested-list->*dalin
    dup printTypeTag (* <dalin> *) cr


    (* test: head[address, <dalin>] *) cr
    dup2
      ,*dalin? . (* 1 *) cr
    dup2
      dalin*? . (* 0 *) cr
    dup2
      car printTypeTag writeSpace . (* <fixnum> 1 *) cr
    dup2
      <-
      printTypeTag writeSpace . (* <null> 0 *) cr

    dup2
      ->
      ->
      car printTypeTag writeSpace . (* <fixnum> 4 *) cr

    dup2
      ->
      ->
      <-
      <-
      car printTypeTag writeSpace . (* <fixnum> 1 *) cr

    dup2
      ->
      car
      dup printTypeTag (* <dalin> *) cr
      dup2
	,*dalin? . (* 1 *) cr
      dup2
	car printTypeTag writeSpace . (* <fixnum> 2 *) cr
      dup2
	<-
	printTypeTag writeSpace . (* <null> 0 *) cr
      dup2
	->
	car printTypeTag writeSpace . (* <fixnum> 3 *) cr
      dup2
	->
	<-
	->
	car printTypeTag writeSpace . (* <fixnum> 3 *) cr

    drop2



    (* ----------------------------------------------- *)
    (* the following test must be done after read-*dalin *)
    (* test: [value,dalin]-associate *)
    2 <fixnum>
    [ { 1 . a } { 2 . b } { 3 . b } ]
    [value,dalin]-associate
      dup printTypeTag (* <list> *) cr
      car  printTypeTag (* <fixnum> *) cr
      writeDecNumber (* 2 *) cr

    (* the following test must be done in symbolREPL *)
    ::x
    [ { 1 . a } { ::x . xxx } { 3 . b } ]
    [value,dalin]-associate
      cdr write (* xxx *)
    #+end_src
** read-dalin & write-dalin
*** read-*dalin
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,read-*dalin
      (* tail[address, <dalin>] -- head[address, <dalin>] *)
      (* where:
	   the <- of ``tail'' is setted,
	   need to set the -> of ``tail'' *)
      read-word
      dup2 String,ending-*dalin equal-string? if
	drop2
	dup <null> == if
	  Exit (* so [ ] null will be read as null *)
	then
	dup2
	  cdr
	    null  set-cdr!
	  drop2
	head<-dalin
	Exit
      then
      execute-word,for-list-reader
      cons drop <dalin>
	xx|swap|xx  set-car!
	cons        set-cdr!
      ^_^
      help,read-*dalin
      Exit
    ; defineRecursiveFunction


    : read-*dalin (* -- head[address, <dalin>] *)
      null
      help,read-*dalin
      Exit
    ; define-function

    : [ read-*dalin Exit ; define-function
    #+end_src
*** write-*dalin
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,write-*dalin
      (* [address, <dalin>] -- *)
      dup2 dalin*? if
	car write Exit
      then
      dup2
	car write
      -> help,write-*dalin Exit
    ; defineRecursiveFunction


    :" write-*dalin said:
       ``My function-type is (* [address, <dalin>] -- *)
	 But the 1st argument is the following
	 I will not touch it and call debuger.''
       --> "
    : String,write-*dalin,type-error ; defineConstString

    : write-*dalin (* [address, <dalin>] -- *)
      dup <dalin> =/= if
	String,write-*dalin,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      String,begining-*dalin print-string writeSpace
      help,write-*dalin
      String,ending-*dalin print-string writeSpace
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    [ ] printTypeTag (* <null> *) cr
    writeDecNumber (* 0 *) cr

    [ 1 ] write-*dalin

    [ 1 2 3 4 5 6 7 8 9 0 ] write-*dalin

    [ 1
      [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
	xxx 3 4 5
      [ 1 2 3 4 5  6 ] 6 ]
    write-*dalin

    [ 1
      [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
	xxx 3 4 5
      { a b c }
      [ 1 2 3 4 5  6 ] 6 ]
    write-*dalin

    [ a [ a b c ]
      b [ a b c ]
      c [ a b c
	    [ a [ a b c ] [ a b c ] lambda
	      b [ a b c ]
	      c [ a b c ] ] ] ]
    write-*dalin

    [ [ a b c ] a b c ]
    write-*dalin

    [ [ [ [ :x ] ] ] ]
    write-*dalin

    [ [ [ :x ] ]
      [ [ :x ] ] ]
    write-*dalin

    [ [ [ [ :x ] ] ]
      [ [ [ :x ] ] ] ]
    write-*dalin

    [ [ [ [ :x :x @ ] :x :x @ ] lambda :y @ ]
      [ [ :x :x @ ] lambda :y @ ] ]
    write-*dalin

    [ 1 { 2 . 3 } 4 ]
    dup2 write
    -> car
    dup printTypeTag (* <list> *) cr
    car printTypeTag (* <fixnum> *) cr
    writeDecNumber (* 2 *) cr
    #+end_src
** stack & list & dalin
*** note
it is hard to convert a list of value in the ArgumentStack
say, [1, 2, 3], to a real list { 3 2 1 }
for during recursive calls
there will be lots ``cons'' leaved in the ArgumentStack
or:
1. you convert [1, 2, 3] to { 1 2 3 }
2. you use LambdaStack for help
3. you use dalin but not list
------------------------------------------
I implement the following:
1. FIAF denotes first in at first
2. LIAF denotes last in at first
   LIAF version uses the LambdaStack
   which is very funny
*** stack->list
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,stack-LIAF->list
      (* ..., number --  *)
      (* LambdaStack::
	 [address, <list>] -- *)
      dup zero? if
	drop (* drop Zero *)
	getBack null set-cdr!
	drop2 Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      dup2
	getBack [cdr,cons]! drop2
      ready
      help,stack-LIAF->list
      Exit
    ; defineRecursiveFunction

    : stack-LIAF->list
      (* ..., number -- [address, <list>] *)
      dup zero? if
	drop null Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      dup2 ready (* leave the return *)
      ready
	help,stack-LIAF->list
      getBack Exit
    ; define-function


    : help,stack-FIAF->list
      (* ..., number -- *)
      (* LambdaStack::
	 [address, <list>] -- [address, <list>] *)
      dup zero? if
	drop (* drop Zero *)
	Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      getBack [cons,cdr]! ready
      help,stack-FIAF->list
      Exit
    ; defineRecursiveFunction

    : stack-FIAF->list
      (* ..., number -- [address, <list>] *)
      dup zero? if
	drop null Exit
      then
      null
      ready
	help,stack-FIAF->list
      getBack
      Exit
    ; define-function
    #+end_src
*** stack->dalin
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,stack-LIAF->dalin
      (* ..., number -- [address, <list>] *)
      (* LambdaStack::
	 [address, <list>] -- *)
      dup zero? if
	drop (* drop Zero *)
	getBack
	dup2 cdr
	null set-cdr!
	drop2
	head<-dalin
	Exit
      then
      sub1
      swap <fixnum>  cons drop <dalin>  [car,cons]!
      cons  [cons,cdr]!
      getBack
	xx|swap|xx ^_^
      ready
      help,stack-LIAF->dalin
      Exit
    ; defineRecursiveFunction

    : stack-LIAF->dalin
      (* ..., number -- [address, <dalin>] *)
      dup zero? if
	drop null Exit
      then
      null
      ready
      help,stack-LIAF->dalin
      Exit
    ; define-function


    : help,stack-FIAF->dalin
      (* ..., number -- [address, <list>] *)
      (* LambdaStack::
	 [address, <list>] -- *)
      dup zero? if
	drop (* drop Zero *)
	getBack
	dup2 cdr
	null set-car!
	drop2 Exit
      then
      sub1
      swap <fixnum>  cons drop <dalin>  [car,cons]!
      cons  [cons,cdr]!
      getBack
	^_^ <-
      ready
      help,stack-FIAF->dalin
      Exit
    ; defineRecursiveFunction

    : stack-FIAF->dalin
      (* ..., number -- [address, <dalin>] *)
      (* ..., number -- [address, <dalin>] *)
      dup zero? if
	drop null Exit
      then
      sub1
      swap <fixnum>  cons drop <dalin>
      [car,cons]!
	null set-cdr-to-{cdr.x}!
      ready
      help,stack-FIAF->dalin
      Exit
    ; define-function
    #+end_src
*** list->stack
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" stack<-FIAF-list said:
       ``My function type is (* [address, <list>] -- ... *)
	 the list should be a list of <not-pair-like> value
	 But in the middle of recursion
	 the following is what I found
	 I will not touch it and call debuger''
       --> "
    : String,stack<-FIAF-list,error ; defineConstString

    :" stack<-FIAF-list said:
       ``My function type is (* [address, <list>] -- ... *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,stack<-FIAF-list,type-error ; defineConstString

    : help,stack<-FIAF-list
      (* -- ... *)
      (* LambdaStack::
	 [address, <list>] -- *)
      getBack
      dup <null> == if
	drop2 Exit
      then
      dup2
	cdr ready
      car
      dup <pair-like>? if
	String,stack<-FIAF-list,error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop a <not-pair-like> type-tag *)
      (* leave the value of the [value, <not-pair-like>] *)
      help,stack<-FIAF-list
      Exit
    ; defineRecursiveFunction

    : stack<-FIAF-list
      (* [address, <list>] -- ... *)
      dup <list> =/= if
	String,stack<-FIAF-list,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      ready
      help,stack<-FIAF-list
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    cr
    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-LIAF->list write (* { 0 9 8 7 6 5 4 3 2 1 } *) cr
    . (* 666 *) cr
    1  1 stack-LIAF->list write (* { 1 } *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-FIAF->list write (* { 1 2 3 4 5 6 7 8 9 0 } *) cr
    . (* 666 *) cr
    1  1 stack-FIAF->list write (* { 1 } *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-LIAF->dalin write (* [ 0 9 8 7 6 5 4 3 2 1 ] *) cr
    . (* 666 *) cr
    1  1 stack-LIAF->dalin write (* [ 1 ] *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-FIAF->dalin write (* [ 1 2 3 4 5 6 7 8 9 0 ] *) cr
    . (* 666 *) cr
    1  1 stack-FIAF->dalin write (* [ 1 ] *) cr
    cr

    666 { 1 } stack<-FIAF-list
     . (* 1 *) . (* 666 *) cr
    666 { 1 2 3 4 } stack<-FIAF-list
     . . . . (* 4 3 2 1 *) . (* 666 *) cr
    cr
    #+end_src
** symbol types
*** helper funciton
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : charDenoteNumberOrAlphabetOrOutOfAscii?
      (* char -- True of False *)
      dup literal 48 < if     drop False Exit
      then
      dup literal 57 <= if    drop True Exit
      then
      dup literal 65 < if     drop False Exit
      then
      dup literal 90 <= if    drop True Exit
      then
      dup literal 97 < if     drop False Exit
      then
      dup literal 122 <= if   drop True Exit
      then
      dup literal 128 < if    drop False Exit
      then
      drop True Exit
    ; define-function
    #+end_src
*** BoundVariable
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* `:' followed by a number or alphabet is a symbolDenoteBoundVariable
       ascii: 48 -- 57, 65 -- 90, 97 -- 122, 128 -- ...
       this set maybe change in the future *)

    : stringDenoteBoundVariableOne?
      (* [address, length] -- True or False *)
      tailAndHeadOfString
      ':' =/= if
	drop2 False (* Exit *)
      else
	dup Zero == if
	  drop2 False (* Exit *)
	else
	  tailAndHeadOfString
	  charDenoteNumberOrAlphabetOrOutOfAscii? if
	    drop2 True (* Exit *)
	  else
	    drop2 False (* Exit *)
	  then
	then
      then
      Exit
    ; define-function

    :" an error occurs!
    symbolDenoteBoundVariableOne? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteBoundVariableOne?,type-error ; defineConstString
    : symbolDenoteBoundVariableOne?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteBoundVariableOne?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteBoundVariableOne?
      Exit
    ; define-function



    : stringDenoteBoundVariableTwo?
      (* [address, length] -- True or False *)
      dup Two <= if
	drop2 False Exit
      then
      tailAndHeadOfString ':' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableOne? Exit
      Exit
    ; define-function

    :" an error occurs!
    symbolDenoteBoundVariableTwo? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteBoundVariableTwo?,type-error ; defineConstString
    : symbolDenoteBoundVariableTwo?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteBoundVariableTwo?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteBoundVariableTwo?
      Exit
    ; define-function




    : stringDenoteBoundVariableThree?
      (* [address, length] -- True or False *)
      dup Three <= if
	drop2 False Exit
      then
      tailAndHeadOfString ':' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableTwo? Exit
      Exit
    ; define-function

    :" an error occurs!
    symbolDenoteBoundVariableThree? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteBoundVariableThree?,type-error ; defineConstString
    : symbolDenoteBoundVariableThree?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteBoundVariableThree?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteBoundVariableThree?
      Exit
    ; define-function



    : stringDenoteBoundVariableFour?
      (* [address, length] -- True or False *)
      dup Four <= if
	drop2 False Exit
      then
      tailAndHeadOfString ':' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableThree? Exit
      Exit
    ; define-function

    :" an error occurs!
    symbolDenoteBoundVariableFour? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteBoundVariableFour?,type-error ; defineConstString
    : symbolDenoteBoundVariableFour?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteBoundVariableFour?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteBoundVariableFour?
      Exit
    ; define-function




    : stringDenoteBoundVariable?
      (* [address, length] -- True or False *)
      dup2 stringDenoteBoundVariableOne? if
	drop2 True Exit
      then
      dup2 stringDenoteBoundVariableTwo? if
	drop2 True Exit
      then
      dup2 stringDenoteBoundVariableThree? if
	drop2 True Exit
      then
      dup2 stringDenoteBoundVariableFour? if
	drop2 True Exit
      then
      drop2 False Exit
    ; define-function

    :" an error occurs!
    symbolDenoteBoundVariable? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteBoundVariable?,type-error ; defineConstString
    : symbolDenoteBoundVariable?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteBoundVariable?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteBoundVariable?
      Exit
    ; define-function
    #+end_src
*** Wody
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* string begin with a number or alphabet
       and end with `:' following a number or alphabet
       is a symbolDenoteWody *)

    : stringDenoteWody?
      (* [address, length] -- True or False *)
      dup Two < if
	drop2 False Exit
      then
      dup2 headOfString
      charDenoteNumberOrAlphabetOrOutOfAscii? false? if
	drop2 False Exit
      then
      dup2  sub1 +  fetch-byte ':' =/= if
	drop2 False Exit
      then
      dup2  sub2 +  fetch-byte
      charDenoteNumberOrAlphabetOrOutOfAscii? false? if
	drop2 False Exit
      then
      drop2 True Exit
    ; define-function

    :" an error occurs!
    symbolDenoteWody? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteWody?,type-error ; defineConstString
    : symbolDenoteWody?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteWody?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteWody?
      Exit
    ; define-function
    #+end_src
*** LambdaArgument
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* `<' plus a stringDenoteBoundVariableOne *)
    : stringDenoteLambdaArgumentOne?
      (* [address, length] -- True or False *)
      dup Two <= if
	drop2 False Exit
      then
      tailAndHeadOfString '<' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableOne? Exit
    ; define-function

    :" an error occurs!
    symbolDenoteLambdaArgumentOne? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteLambdaArgumentOne?,type-error ; defineConstString
    : symbolDenoteLambdaArgumentOne?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteLambdaArgumentOne?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteLambdaArgumentOne?
      Exit
    ; define-function



    (* `<' plus a stringDenoteBoundVariableTwo *)
    : stringDenoteLambdaArgumentTwo?
      (* [address, length] -- True or False *)
      dup Three <= if
	drop2 False Exit
      then
      tailAndHeadOfString '<' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableTwo? Exit
    ; define-function

    :" an error occurs!
    symbolDenoteLambdaArgumentTwo? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteLambdaArgumentTwo?,type-error ; defineConstString
    : symbolDenoteLambdaArgumentTwo?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteLambdaArgumentTwo?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteLambdaArgumentTwo?
      Exit
    ; define-function




    (* `<' plus a stringDenoteBoundVariableThree *)
    : stringDenoteLambdaArgumentThree?
      (* [address, length] -- True or False *)
      dup Four <= if
	drop2 False Exit
      then
      tailAndHeadOfString '<' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableThree? Exit
    ; define-function

    :" an error occurs!
    symbolDenoteLambdaArgumentThree? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteLambdaArgumentThree?,type-error ; defineConstString
    : symbolDenoteLambdaArgumentThree?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteLambdaArgumentThree?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteLambdaArgumentThree?
      Exit
    ; define-function




    (* `<' plus a stringDenoteBoundVariableFour *)
    : stringDenoteLambdaArgumentFour?
      (* [address, length] -- True or False *)
      dup Five <= if
	drop2 False Exit
      then
      tailAndHeadOfString '<' =/= if
	drop2 False Exit
      then
      stringDenoteBoundVariableFour? Exit
    ; define-function

    :" an error occurs!
    symbolDenoteLambdaArgumentFour? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteLambdaArgumentFour?,type-error ; defineConstString
    : symbolDenoteLambdaArgumentFour?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteLambdaArgumentFour?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteLambdaArgumentFour?
      Exit
    ; define-function



    : stringDenoteLambdaArgument?
      (* [address, length] -- True or False *)
      dup2 stringDenoteLambdaArgumentOne? if
	drop2 True Exit
      then
      dup2 stringDenoteLambdaArgumentTwo? if
	drop2 True Exit
      then
      dup2 stringDenoteLambdaArgumentThree? if
	drop2 True Exit
      then
      dup2 stringDenoteLambdaArgumentFour? if
	drop2 True Exit
      then
      drop2 False Exit
    ; define-function

    :" an error occurs!
    symbolDenoteLambdaArgument? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
	 But the type I received is the following,
	 I will not touch it and call debuger.''
       --> "
    : String,symbolDenoteLambdaArgument?,type-error ; defineConstString
    : symbolDenoteLambdaArgument?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
	String,symbolDenoteLambdaArgument?,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      stringDenoteLambdaArgument?
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    :" xxx"   string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 0 *) cr
    :" :xxx"  string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 1 *) cr
    :" ::"    string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 0 *) cr
    :" :"     string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 0 *) cr
    :" :1"    string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 1 *) cr
    :" :中文" string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 1 *) cr
    cr
    :" :xxx"   string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 0 *) cr
    :" ::xxx"  string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 1 *) cr
    :" :::"    string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 0 *) cr
    :" ::"     string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 0 *) cr
    :" ::1"    string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 1 *) cr
    :" ::中文" string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 1 *) cr
    cr
    :" xxx"   string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" :xxx"  string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" ::"    string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" :"     string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" :1"    string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" :中文" string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    cr
    :" xxx::" string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" xxx:"  string-hash->index <symbol> symbolDenoteWody? . (* 1 *) cr
    :" 1:"    string-hash->index <symbol> symbolDenoteWody? . (* 1 *) cr
    :" :1:"   string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
    :" 中文:" string-hash->index <symbol> symbolDenoteWody? . (* 1 *) cr
    cr
    :" <:xxx::" string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
    :" <:xxx:"  string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
    :" <:1:"    string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
    :" <::1:"   string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 0 *) cr
    :" <:中文:" string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
    cr
    :" <:xxx::" string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
    :" <:xxx:"  string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
    :" <:1:"    string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
    :" <::1:"   string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 1 *) cr
    :" <:中文:" string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
    cr

    (* ----------------------------------------------------- *)
    cr
    :" xxx"    stringDenoteBoundVariableOne? . (* 0 *) cr
    :" :xxx"   stringDenoteBoundVariableOne? . (* 1 *) cr
    :" ::"     stringDenoteBoundVariableOne? . (* 0 *) cr
    :" :"      stringDenoteBoundVariableOne? . (* 0 *) cr
    :" :1"     stringDenoteBoundVariableOne? . (* 1 *) cr
    :" :中文"  stringDenoteBoundVariableOne? . (* 1 *) cr
    cr
    :" :xxx"    stringDenoteBoundVariableTwo? . (* 0 *) cr
    :" ::xxx"   stringDenoteBoundVariableTwo? . (* 1 *) cr
    :" :::"     stringDenoteBoundVariableTwo? . (* 0 *) cr
    :" ::"      stringDenoteBoundVariableTwo? . (* 0 *) cr
    :" ::1"     stringDenoteBoundVariableTwo? . (* 1 *) cr
    :" ::中文"  stringDenoteBoundVariableTwo? . (* 1 *) cr
    cr
    :" xxx"    stringDenoteWody? . (* 0 *) cr
    :" :xxx"   stringDenoteWody? . (* 0 *) cr
    :" ::"     stringDenoteWody? . (* 0 *) cr
    :" :"      stringDenoteWody? . (* 0 *) cr
    :" :1"     stringDenoteWody? . (* 0 *) cr
    :" :中文"  stringDenoteWody? . (* 0 *) cr
    cr
    :" xxx::"  stringDenoteWody? . (* 0 *) cr
    :" xxx:"   stringDenoteWody? . (* 1 *) cr
    :" 1:"     stringDenoteWody? . (* 1 *) cr
    :" :1:"    stringDenoteWody? . (* 0 *) cr
    :" 中文:"  stringDenoteWody? . (* 1 *) cr
    cr
    :" <:xxx::"  stringDenoteLambdaArgumentOne? . (* 1 *) cr
    :" <:xxx:"   stringDenoteLambdaArgumentOne? . (* 1 *) cr
    :" <:1:"     stringDenoteLambdaArgumentOne? . (* 1 *) cr
    :" <::1:"    stringDenoteLambdaArgumentOne? . (* 0 *) cr
    :" <:中文:"  stringDenoteLambdaArgumentOne? . (* 1 *) cr
    cr
    :" <:xxx::"  stringDenoteLambdaArgumentTwo? . (* 0 *) cr
    :" <:xxx:"   stringDenoteLambdaArgumentTwo? . (* 0 *) cr
    :" <:1:"     stringDenoteLambdaArgumentTwo? . (* 0 *) cr
    :" <::1:"    stringDenoteLambdaArgumentTwo? . (* 1 *) cr
    :" <:中文:"  stringDenoteLambdaArgumentTwo? . (* 0 *) cr
    cr
    (* ----------------------------------------------------- *)

    (* test: type-error *)
    null symbolDenoteWody?          basic-REPL
    null symbolDenoteBoundVariableOne?  basic-REPL
    #+end_src
** read-wodyli & write-wodyli
*** note
1. wodyli denotes wordy-list
2. wodyli is a dalin of list
3. lambda will use ``bound-variable-wodyli''
*** read-wodyli
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,with-word,read-wody-or-bound-variable
      (* -- [address, <list>] *)
      (* LambdaStack::
	 -- wody[address, length] *)
      read-word
      dup2 stringDenoteWody? if
	ready
	null Exit
      then
      dup2 stringDenoteBoundVariable? if
	ready
	null Exit
      then
      dup2 String,ending-wodyli equal-string? if
	ready
	null Exit
      then
      dup2 String,dot equal-string? if
	drop2
	help,with-word,read-wody-or-bound-variable car
	(* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
	Exit
      then
      execute-word,for-list-reader
      cons drop <list>
	xx|swap|xx  set-car!
	  help,with-word,read-wody-or-bound-variable
	set-cdr!
      Exit
    ; defineRecursiveFunction


    : with-word,read-wody-or-bound-variable
      (* word[address, length] -- [address, <wody>], word[address, length] *)
      (* LambdaStack:: <wody> -- *)
      (* or *)
      (* word[address, length] -- [address, <bound-variable>], word[address, length] *)
      (* LambdaStack:: <bound-variable> -- *)
      string-hash->index <symbol>
      cons drop popLambdaStack
	[car,cons]!
	  help,with-word,read-wody-or-bound-variable
	[cons,cdr]!
      getBack
      (* return the next ``wody'' word
	 it must be handled in help,read-wodyli *)
      Exit
    ; define-function



    :" help,read-wodyli said:
       ``My function type is
	 (* [address, <wodyli>], word[address, length] -- head[address, <wodyli>] *)
	 the `word' must be `)' or denotes `wody' or denotes `bound-variable'
	 But the following is what I meet
	 I will not touch it and call debuger''
       --> "
    : String,help,read-wodyli,error ; defineConstString

    (* a ``with-word'' reader *)
    : help,read-wodyli
      (* [address, <wodyli>], word[address, length] -- head[address, <wodyli>] *)
      (* where:
	   the <- of [address, <wodyli>] is setted,
	   need to set the -> of [address, <wodyli>] *)
      dup2 String,ending-wodyli equal-string? if
	drop2
	dup2
	  cdr
	    null  set-cdr!
	  drop2
	head<-dalin
	Exit
      then
      dup2 stringDenoteWody? if
	<wody> pushLambdaStack
      else
	dup2 stringDenoteBoundVariable? if
	  <bound-variable> pushLambdaStack
	else
	  String,help,read-wodyli,error print-string
	  print-string cr
	  debuger Exit
	then
      then
      with-word,read-wody-or-bound-variable
      (* [address, <wodyli>], [address, <wody>], word[address, length] *)
      (* or *)
      (* [address, <wodyli>], [address, <bound-variable>], word[address, length] *)
      xxxx|swap|xx
      cons drop <wodyli>
	xx|swap|xx  set-car!
	cons        set-cdr!
      ^_^
      xx|swap|xx
      help,read-wodyli
      Exit
    ; defineRecursiveFunction



    : read-wodyli (* -- head[address, <wodyli>] *)
      null
      read-word
      dup2 String,ending-wodyli equal-string? if
	(* return ``null'' on ( ) *)
	drop2 Exit
      then
      help,read-wodyli
      Exit
    ; define-function

    : ( read-wodyli Exit ; define-function
    #+end_src
*** write-wody & write-wodyli
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" write-wody-or-bound-variable said:
       ``My function-type is (* [address, <wody> or <bound-variable>] -- *)
	 But the 1st argument is the following
	 I will not touch it and call debuger.''
       --> "
    : String,write-wody-or-bound-variable,type-error ; defineConstString

    : write-wody-or-bound-variable
      (* [address, <wody> or <bound-variable>] -- *)
      dup <wody> =/=
      over <bound-variable> =/=
      bitwise-and if
	String,write-wody-or-bound-variable,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      dup2
	car write
      cdr help,write-list
      Exit
    ; define-function



    : help,write-wodyli
      (* [address, <wodyli>] -- *)
      dup <null> == if
	drop2 Exit
      then
      dup2
	car write
      -> help,write-wodyli Exit
    ; defineRecursiveFunction


    :" write-wodyli said:
       ``My function-type is (* [address, <wodyli>] -- *)
	 But the 1st argument is the following
	 I will not touch it and call debuger.''
       --> "
    : String,write-wodyli,type-error ; defineConstString

    : write-wodyli
      (* [address, <wodyli>] -- *)
      dup <wodyli> =/= if
	String,write-wodyli,type-error print-string
	dup printTypeTag cr
	debuger Exit
      then
      String,begining-wodyli print-string writeSpace
      help,write-wodyli
      String,ending-wodyli print-string writeSpace
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    ( x: ( a: 1 2 3 b: 4 5 6 )
      a: 1 2 3
      b: 4 5 6 )
     write

    ( a: b: 6 ) write-wodyli

    ( :a 1 :b 2 ) write-wodyli
    #+end_src
** ><><>< wodyli processing
** execute-word [redefine] & symbolREPL & lambda-argument
*** note
    1. to read different types of symbols
    2. to handle <:x <::x <:::x <::::x
    3. print better ErrorInfo for ExecuteWord
*** implementation
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : <lambda-argument-one>   ; definePairLikeDataType
    : <lambda-argument-two>   ; definePairLikeDataType
    : <lambda-argument-three> ; definePairLikeDataType
    : <lambda-argument-four>  ; definePairLikeDataType

    : <lambda-argument>?
      (* type-tag -- True or False *)
      dup <lambda-argument-one> == if
	drop True Exit
      then
      dup <lambda-argument-two> == if
	drop True Exit
      then
      dup <lambda-argument-three> == if
	drop True Exit
      then
      dup <lambda-argument-four> == if
	drop True Exit
      then
      drop False Exit
    ; define-function
    
    (* ><><>< the following comment should be rewritten *)
    (* redefine execute-word to handle the following symbols
       <:x   ::    value       -- [{ :x  . { ... } }, <lambda-argument-one>]
       <::x  ::  [value, type] -- [{ ::x . { ... } }, <lambda-argument-two>]
       ...
       examples:
       [{ :x       . { 1 } },             <lambda-argument-one>]
       [{ ::null   . { Null <null> } },   <lambda-argument-two>]
       [{ ::number . { 666 <fixnum> } },  <lambda-argument-two>]
       note that:
	 every value in list must have a type
	 so in every list above, type of a car is setted to <fixnum>
     ,*)

    : execute-word (* string[address, length] -- unknown *)
      dup2
      string-denote-number? if
	number drop Exit
      then

      dup2 stringDenoteBoundVariableOne? if
	string-hash->index <symbol> Exit
      then
      dup2 stringDenoteBoundVariableTwo? if
	string-hash->index <symbol> Exit
      then
      dup2 stringDenoteBoundVariableThree? if
	string-hash->index <symbol> Exit
      then
      dup2 stringDenoteBoundVariableFour? if
	string-hash->index <symbol> Exit
      then

      dup2 stringDenoteLambdaArgumentOne? if
	tailOfString
	string-hash->index <symbol>
	cons drop <lambda-argument-one>
	  xx|swap|xx set-car!
	  ready
	    One stack-FIAF->list
	  getBack
	  xx|swap|xx set-cdr!
	Exit
      then
      dup2 stringDenoteLambdaArgumentTwo? if
	tailOfString
	string-hash->index <symbol>
	cons drop <lambda-argument-two>
	  xx|swap|xx set-car!
	  ready
	    Two stack-FIAF->list
	  getBack
	  xx|swap|xx set-cdr!
	Exit
      then
      dup2 stringDenoteLambdaArgumentThree? if
	tailOfString
	string-hash->index <symbol>
	cons drop <lambda-argument-three>
	  xx|swap|xx set-car!
	  ready
	    Three stack-FIAF->list
	  getBack
	  xx|swap|xx set-cdr!
	Exit
      then
      dup2 stringDenoteLambdaArgumentFour? if
	tailOfString
	string-hash->index <symbol>
	cons drop <lambda-argument-four>
	  xx|swap|xx set-car!
	  ready
	    Four stack-FIAF->list
	  getBack
	  xx|swap|xx set-cdr!
	Exit
      then
      dup2 find dup not-zero? if
	xx|swap|x drop2
	word-link->word-explainer execute Exit
      then
      drop (* drop the Zero that denotes finding-error *)
      String,undefined-word print-string
      print-string (* print the word *) cr
      Exit
    ; define-function

    (* if wished
     ,*   one needs to use help,symbolREPL to do the recursive
     ,*   and reset the two pointers in symbolREPL
     ,* Return-stack-top reset-return-stack-pointer
     ,* Argument-stack-top reset-argument-stack-pointer *)

    : symbolREPL (* unknown -- unknown *)
      read-word-for-runtime
      execute-word
      symbolREPL
      Exit
    ; defineRecursiveFunction
    #+end_src
*** test
    #+begin_src cicada
    symbolREPL 1 2 + . (* 3 *) cr
    cr

    :xxx printTypeTag (* <symbol> *) cr
    index-hashback->string print-string (* :xxx *) cr
    cr

    ::xxx printTypeTag (* <symbol> *) cr
    index-hashback->string print-string (* ::xxx *) cr
    cr

    :::xxx printTypeTag (* <symbol> *) cr
    index-hashback->string print-string (* :::xxx *) cr
    cr

    ::::xxx printTypeTag (* <symbol> *) cr
    index-hashback->string print-string (* ::::xxx *) cr
    cr
    #+end_src
** using the symbolREPL now !
   #+begin_src cicada :tangle ../play/english-core.ccd 
   symbolREPL
   #+end_src
** ><><><><><><><><><><><><><><><><><><><
** lambda
*** note
**** ABOUT lambda-calculus
1. lambda is a function which uses two dalin
   to compose a anonymous function
   (not compile to the dictionary)
   apply is a function which
   explain (or eval) the anonymous function composed by lambda
2. ``compose(撰写)'' is different from ``compile(编撰)''
3. the essence is
   ``compose and explain''
   or ``compile and explain''
   1) what(syntax) to be composed ?
   2) compose to what ?
   3) how to explain(or eval) the result of the composition
4. in cicada
   apply is linear
   lambda is almost linear
   ``linear'' means a loop walk through a dalin
   but not a recursive function traverse a nested dalin
   only the function that calculates the scope of a lambda is recursive
5. a bound-variable of a lambda function
   is used to label the place in the lambda-body
   into where you want to substitute a argument
   when lambda-body is nested
   the scope of bound-variables need to be handled
   scheme use closure to handle this
   cicada use simple graph processing to handle this
6. during lambda-application,
   one <lambda-argument-N> substitute into
   one <bound-variable>
7. from lisp to cicada
   I am dispersing the works of parsing all the time
**** ABOUT lazy-eval
1. in cicada use explicit lazy-eval
   use ()lambda or ()λ
   to make a lambda-function without arguments
   to use explicit lazy-eval
2. lazy-eval has better theoretical feature in lambda-calculus
   but it makes computation unpredictable
**** ABOUT substitution
note that you can only use bound-variable (such as ::x :n) in a lambda-body
bot NOT a dalin or list or wodyli
*** data-types
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : <lambda>               ; definePairLikeDataType
    : <explainer-pair>       ; definePairLikeDataType
    : <explainer>            ; defineDataType
    #+end_src
*** helper functions
    used to decide the type error of lambda
    and to decide when I need to calculate lambda-scope
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : bound-variable-wodyli?
      (* head[address, <wodyli>] -- True or False *)
      dup <wodyli> =/= if
	drop2 False Exit
      then
      dup2 car  swap drop
      <bound-variable> =/= if
	drop2 False Exit
      then
      dup2 dalin*? if
	drop2 True Exit
      then
      ->  bound-variable-wodyli?
      Exit
    ; defineRecursiveFunction


    (*
     ,* the following function return `True'
     ,* on the following dalin as a tail
     ,*   [ [address, <dalin>]
     ,*     bound-variable-wodyli[address, <wodyli>]
     ,*    ]
     ,* and
     ,*   [ [address, <dalin>]
     ,*     null
     ,*    ]
     ,*)

    : meet-lambda-abstraction-in-lambda-body-dalin?
      (* tail[address, <dalin>] -- True or False *)
      dup <dalin> =/= if
	drop2 False Exit
      then
      dup2 car
      dup2       bound-variable-wodyli?
      xx|swap|x  null?
      bitwise-or if
	<- dup <dalin> =/= if
	  drop2 False Exit
	then
	  car <dalin> =/= if
	    drop False Exit
	  then
	    drop True Exit
      then
      drop2 False Exit
    ; define-function

    (*
     ,* test:
     ,*
     ,* [ [ 1 ] ( :x ) ] dalin->tail
     ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
     ,* [ [ 1 ] null ] dalin->tail
     ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
     ,* [ [ 1 ] ( ) ] dalin->tail
     ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
     ,* cr
     ,* [ [ 1 ] ( x: ) ] dalin->tail
     ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 0 *\) cr
     *)
    #+end_src
*** bound-variable-wodyli-subtraction (for calculating lambda-scope)
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : help,bound-variable-wodyli-subtraction
      (* LambdaStack::
	 (a-b) [address, <wodyli>] -- *)
      (* b [address, <wodyli>], a [address, <wodyli>] --
	 (a-b) [address, <wodyli>] *)
      dup <null> == if
	drop2 drop2
	getBack
	dup <null> == if
	  Exit
	then
	dup2 cdr null [cons,cdr]! drop2
	head<-dalin
	Exit
      then
      dup2
	car car   xx|over|xxxx
	[value,dalin]-associate
	dup <null> =/= if
	(* if this bound-variable is ``blocked'',
	   it should not be ``cons'' to the new bound-variable-wodyli *)
	drop2 (* drop the associate-pair *)
	->  help,bound-variable-wodyli-subtraction Exit
      then
      drop2 (* drop the associate-pair *)
      (* b [address, <wodyli>], a [address, <wodyli>] *)
      dup2 car
      (* a wody as a whole is ``cons''ed to the new bound-variable-wodyli *)
      cons drop <wodyli>
	[car,cons]!
	cons [cons,cdr]!
      getBack
	xx|swap|xx  ^_^
	(* so the order of bound-variable-wodyli will be preserved *)
      ready
      ->  help,bound-variable-wodyli-subtraction Exit
    ; defineRecursiveFunction


    (* the following function will creat a new wodyli, maybe ``null'' *)
    : bound-variable-wodyli-subtraction
      (* a [address, <wodyli>], b [address, <wodyli>] --
	 (a-b) [address, <wodyli>] *)
      x|over|xx <null> == if
	(* a == null, (a-b) == a == null *)
	drop2 Exit
      then
      dup <null> == if
	(* b == null, (a-b) == a *)
	drop2 Exit
      then
      null ready
      xx|swap|xx
      (* b [address, <wodyli>], a [address, <wodyli>] *)
      (* LambdaStack::  [Null, <null>] *)
      help,bound-variable-wodyli-subtraction
      Exit
    ; define-function


    (*
     ,*  test:
     ,*
     ,* 666
     ,* ( ::a ::b ::c )
     ,* ( ::a ::c ::x )
     ,* bound-variable-wodyli-subtraction
     ,* write (\* ( ::b )  *\)
     ,*
     ,* . (\* 666 *\)
     *)
    #+end_src
*** lambda
    #+begin_src cicada :tangle ../play/english-core.ccd 
    :" lambda" string-hash->index
    : SymbolIndex,lambda ; defineConst

    :" λ" string-hash->index
    : SymbolIndex,λ ; defineConst


    (* the following two functions are side-effects through a dalin
     ,* in the direction of ``<-''

     ,* some special-types of elements in the lambda-body
     ,* should be setted for ``apply''

     ,* note that: (currently)
     ,*   <fixnum> <list> <dalin> <wodyli> <symbol>
     ,*   are the only types of value
     ,*   that could be readed into a dalin

     ,*   only all <symbol> in this dalin
     ,*   and some <symbol> that denote-bound-variable nestedly existed in this dalin
     ,*   will be handled by the following functions

     ,*   while
     ,*   in the ``apply''
     ,*   when meet [666, <fixnum>]
     ,*     666 ( ONLY ONE VALUE ) will be push to ArgumentStack
     ,*   when meet [address, <list>]
     ,*     [address, <list>] will be push to ArgumentStack
     ,*   when meet [address, <dalin>]
     ,*     [address, <dalin>] will be push to ArgumentStack
     ,*   when meet [address, <wodyli>]
     ,*     [address, <wodyli>] will be push to ArgumentStack
     ,*)


    : help,lambda,set-bound-variables (* calculating lambda-scope *)
      (* [address, <wodyli>], [address, <dalin>] -- *)
      dup <null> == if
	(* drop all the arguments here *)
	drop2 drop2 Exit
      then
      dup2 car

      (* [address, <wodyli>], [address, <dalin>], car[value, type] *)
      dup <symbol> =/= if
	(* types of value other then <symbol>
	   will be leaved in the lambda-body as they are *)
	drop2
	<-  help,lambda,set-bound-variables Exit
      then

      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 symbolDenoteBoundVariable? if
	xx|over|xxxx
	dup <null> == if
	  (* when bound-variable-wodyli is null
	     symbolDenoteBoundVariable can not be bound by this lambda
	     just leave them in the lambda-body as they are *)
	  drop2 (* drop [Null, <null>] *)
	  drop2 (* drop [index, <symbol>] *)
	  <-  help,lambda,set-bound-variables Exit
	then
	[value,dalin]-associate
	dup <null> == if
	  (* symbolDenoteBoundVariable that can not be bound by this lambda
	     will be leaved in the lambda-body as they are *)
	  drop2
	  <-  help,lambda,set-bound-variables Exit
	then
	(* [address, <wodyli>], [address, <dalin>], [address, <bound-variable>] *)
	[cons,car]!
	<-  help,lambda,set-bound-variables Exit
      then

      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 drop
	dup   SymbolIndex,lambda ==
	swap  SymbolIndex,λ ==
      bitwise-or if
	drop2
	<-
	(* make a special treatment only when
	   ``meet-lambda-abstraction-in-lambda-body-dalin'' *)
	dup2
	meet-lambda-abstraction-in-lambda-body-dalin?
	false? if
	  help,lambda,set-bound-variables Exit
	then
	(* [address, <wodyli>], [address, <dalin>] *)
	  (* prepare the arguments for a non-tail-recursive call of help,lambda,set-bound-variables *)
	  xx|over|xx xx|over|xx
	    car bound-variable-wodyli-subtraction
	  xx|over|xx
	    (* note that: the 2ed arg of help,lambda,set-bound-variables is a tail-dalin *)
	    <-  car  dalin->tail
	  help,lambda,set-bound-variables
	  (* after then : *)
	  <- <-  help,lambda,set-bound-variables Exit
      then

      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      (* here is general symbol *)
      drop2
      <-  help,lambda,set-bound-variables Exit
    ; defineRecursiveFunction


    : help,lambda,set-function-body
      (* [address, <wodyli>], [address, <dalin>] -- *)
      dup <null> == if
	(* drop all the arguments here *)
	drop2 drop2 Exit
      then
      dup2 car
      (* [address, <wodyli>], [address, <dalin>], car[value, type] *)
      dup <symbol> =/= if
	(* types of value other then <symbol>
	   will be leaved in the lambda-body as they are *)
	drop2
	<-  help,lambda,set-function-body Exit
      then
      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 symbolDenoteLambdaArgument? if
	(* i.e. symbols like ``<:x''
	   will be leaved in the lambda-body as they are
	   they will be handled by ``apply'' *)
	drop2
	<-  help,lambda,set-function-body Exit
      then
      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 symbolDenoteBoundVariable? if
	(* i.e. symbols like ``:x''
	   will be leaved in the lambda-body as they are
	   ``help,lambda,set-bound-variables'' take care of them
	   when ``apply'' is executed there should be none of them *)
	drop2
	<-  help,lambda,set-function-body Exit
      then
      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      (* here is general symbol *)
      over
	index-hashback->string
	find (* ><><>< error handling when not found *)
	word-link->word-explainer
	<explainer>
      cons drop <explainer-pair>
	[cdr,cons]!  [car,cons]!
      [cons,car]!
      <-  help,lambda,set-function-body Exit
    ; defineRecursiveFunction




    : help,lambda,make-lambda-function
      (* [address, <wodyli>], [address, <dalin>] --
	 [address, <lambda>] *)
      cons drop <lambda>
	xx|swap|xx set-cdr!
	xx|swap|xx set-car!
      Exit
    ; define-function




    :" lambda said:
       ``My function type is
	 (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
	 (* or *)
	 (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
	 But the 1st argument is the following
	 I will not touch it and call debuger''
       --> "
    : String,lambda,type-error,1st ; defineConstString

    :" lambda said:
       ``My function type is
	 (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
	 (* or *)
	 (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
	 The 1st argument is a wodyli but not a bound-variable-wodyli
	 I will not touch it and call debuger''"
    : String,lambda,type-error,1st,not-bound-variable-wodyli
    ; defineConstString

    :" lambda said:
       ``My function type is
	 (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
	 (* or *)
	 (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
	 But the 3rd argument is the following
	 I will not touch it and call debuger''
       --> "
    : String,lambda,type-error,3rd ; defineConstString

    : lambda
      (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
      (* or *)
      (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
      dup <wodyli> =/=
      over <null> =/=
      bitwise-and if
	String,lambda,type-error,1st print-string
	dup printTypeTag cr
	debuger Exit
      then
      dup <wodyli> ==
      xx|over|x bound-variable-wodyli? false?
      bitwise-and if
	String,lambda,type-error,1st,not-bound-variable-wodyli
	print-string cr
	debuger Exit
      then
      x|over|xx <dalin> =/= if
	String,lambda,type-error,3rd print-string
	x|over|xx printTypeTag cr
	debuger Exit
      then
      xx|tuck|xx  xx|over|xx
      dalin->tail
      (* [address, <wodyli>], [address, <dalin>],
	 [address, <wodyli>], tail[address, <dalin>] *)
      xx|over|xx  xx|over|xx
      help,lambda,set-bound-variables
      (* multi-pass *)
      help,lambda,set-function-body
      (* [address, <wodyli>], [address, <dalin>] *)
      help,lambda,make-lambda-function
      Exit
    ; define-function

    : λ lambda Exit ; define-function
    #+end_src
*** test
    #+begin_src cicada
    [              :b negate
	4 :a :c * *
	    :b :b *  -  ><><><sqrt  +
			2 :a  *  / ] dup2 write cr
    ( :a :b :c ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ::x ) lambda ] dup2 write cr
    ( ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ) lambda ] dup2 write cr
    ( ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ::x ) lambda ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ ::x ::x ::x ] ( ::x ) lambda ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda
       ::y
      [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda  ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda ::y
      [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda @ ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2
    #+end_src
** apply
*** note
1. 对lambda-body的正确求值
   是依赖于``绑定''对这个lambda所作的副作用的
   那么在作用的过程中就不能破坏(更改)对这些约束变元的绑定
   只要每次lambda的作用都会更新 <lambda> pair 中的约束变元dalin
   也就是说在一个lambda-body中不能引用这个lambda-body本身
   这也许是合理的
2. 并且上面的特点所带来的一个效果就是
   每个lambda都会保存着它上次作用时进行的绑定
   也许这种效果能被有趣地利用起来
3. maybe I can support cc here !
*** lambda-body-stack
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* note that:
	 when a explainer is been executed
	 only the arguments of the word to be explained
	 should be in the ArgumentStack or LambdaStack *)

    (* a stack as list
       list of dalin
       in which a dalin denotes a lambda-body *)
    null : lambda-body-stack ; define

    : push,lambda-body-stack
      (* [address, <wodyli>] -- *)
      cons drop <list>  [car,cons]!
      lambda-body-stack fetch2
      [cons,cdr]!
      lambda-body-stack save2
      Exit
    ; define-function

    : drop,lambda-body-stack
      (* -- *)
      lambda-body-stack fetch2
      cdr
      lambda-body-stack save2
      Exit
    ; define-function
    #+end_src
*** help,apply,eval-lambda-body
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* the following function
       do side-effect to the car of the lambda-body-stack *)

    : <end-of-one-lambda-body> ; defineDataType
    : <end-of-all-lambda-body> ; defineDataType

    : lambda-forth
      (* -- [value, type] or <end-of-lambda-body> or <>] *)
      lambda-body-stack fetch2
      dup <null> == if
	drop2
	<end-of-all-lambda-body>
	Exit
      then
      dup2 car
	(* [address, <list>], [address, <dalin>] or null *)
	dup <null> == if
	drop2 drop2
	<end-of-one-lambda-body>
	drop,lambda-body-stack
	Exit
      then
      (* [address, <list>], [address, <dalin>] *)
      xx|tuck|xx
      (* [address, <dalin>],
	 [address, <list>], [address, <dalin>] *)
      ->  (* up date the 1st lambda-body in lambda-body-stack *)
      [cons,car]! drop2
      car
      Exit
    ; define-function


    :" help,apply,eval-lambda-body said:
       ``My function type is (* unknow -- unknow *)
	 I call `lambda-forth' to do side-effect on lambda-body-stack
	 The symbol I meet should always DenoteLambdaArgument
	 But I meet the following symbol
	 I will not touch it and call debuger''
       --> "
    : String,help,apply,eval-lambda-body,error,symbol
    ; defineConstString

    : help,apply,eval-lambda-body
      (* unknow -- unknow *)
      lambda-forth
      dup <end-of-one-lambda-body> == if
	drop Exit
      then

      (* examples:
	   [{ :x  . { 100 } }, <bound-variable>]
	   [{ ::x . { 666 <fixnum> } }, <bound-variable>] *)
      dup <bound-variable> == if
	cdr
	stack<-FIAF-list
	help,apply,eval-lambda-body
	Exit
      then

      (* example:
	   [{ word-name . word-explainer }, <explainer-pair>] *)
      dup <explainer-pair> == if
	cdr
	drop (* drop type-tag: <explainer> *)
	execute
	help,apply,eval-lambda-body
	Exit
      then

      (* example:
	   [index, <symbol>] *)
      dup <symbol> == if
	dup2 symbolDenoteLambdaArgument? if
	  drop (* drop <symbol> *)
	  index-hashback->string
	  execute-word
	  help,apply,eval-lambda-body
	  Exit
	then
	String,help,apply,eval-lambda-body,error,symbol print-string
	dup2 write cr
	debuger
	Exit
      then

      (* example:
	   [666, <fixnum>] *)
      dup <fixnum> == if
	drop (* drop type-tag: <fixnum> *)
	help,apply,eval-lambda-body
	Exit
      then

      (* examples:
	   [address, <list>]
	   [address, <dalin>]
	   [address, <wodyli>]
	 and all other types
	 leave the value and the type in the stack *)
      help,apply,eval-lambda-body
      Exit
    ; defineRecursiveFunction
    #+end_src
*** apply
    #+begin_src cicada :tangle ../play/english-core.ccd 
    (* examples of <lambda-argument>:
	 { :x       . { 1 } }
	 { ::null   . { Null <null> } }
	 { ::number . { 666 <fixnum> } }
       example of bound-variable-wodyli
	 ( :a ::b :::c )
	 [ { :a    . ... }
	   { ::b   . ... }
	   { ::::c . ... } ]
     ,*)


    : help-to-rec,help,apply,set-variables
      (* ArgumentStack::
	 ..., [address, <lambda-argument-N>] -- *)
      (* LambdaStack::
	 [address, <wodyli>] -- [address, <wodyli>] *)
      dup <lambda-argument>? false? if
	Exit
      then
      dup2   car    getBack dup2 ready
      (* [address, <lambda-argument-N>], [index, <symbol>], [address, <wodyli>] *)
      [value,dalin]-associate
      dup <null> == if
	drop2 Exit
      then
      (* [address, <lambda-argument-N>], [..., <bound-variable>] *)
      xx|swap|xx   cdr
      [cons,cdr]!  drop2
      help-to-rec,help,apply,set-variables
      Exit
    ; defineRecursiveFunction


    : help,apply,set-variables
      (* ..., [address, <lambda-argument>], [address, <wodyli>] -- *)
      ready
	help-to-rec,help,apply,set-variables
      getBack drop2 Exit
    ; define-function



    :" apply said:
       ``My function type is
	 (* LambdaStack::  [address, <lambda>] -- unknow *)
	 (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
	 But the value in the LambdaStack is of the following type
	 I will not touch it and call debuger''
       --> "
    : String,apply,type-error ; defineConstString
    : apply
      (* LambdaStack::  [address, <lambda>] -- unknow *)
      (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
      getBack dup2 ready
      dup <lambda> == if
	car dup <null> == if
	  drop2
	else
	  help,apply,set-variables
	then
	getBack  cdr
	push,lambda-body-stack
	help,apply,eval-lambda-body
	Exit
      then
      String,apply,type-error print-string
      printTypeTag cr
      drop (* drop the the value been getted back *)
      debuger Exit
    ; define-function
    #+end_src
*** syntax sugar
    #+begin_src cicada :tangle ../play/english-core.ccd 
    : @
      (* ...,
	 [address, <lambda-argument>],
	 [address, <lambda>]
	 ---------------------------
	 unknow *)
      ready apply Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    [ :x 1 + ]  (* push a dalin to ArgumentStack *)
    ( :x )      (* push a symbol `:x' to ArgumentStack *)
    λ           (* digests some symbols and a dalin in the ArgumentStack,
		   and return a lambda-function by them *)
    ready (* pop ArgumentStack, push the lambda-function to LambdaStack *)

    3   (* push 3 into the ArgumentStack *)
    <:x (* make a typed value of type : <lambda-argument-one> *)

    apply (* apply a lambda-function in the LambdaStack function
	     to the ArgumentStack,
	     the arguments of the above lambda-function is labeled with a symbol `:x',
	     so if there are many arguments, order will be not important *)

    writeDecNumber (* 4 *) cr

    (* -------------------------------------------------------------- *)

    [ + + + ] ( :x ) λ ready
    1 2 3 4  apply
    writeDecNumber (* 10 *) cr

    [ :x 1 2 3 * + + ] ( :x ) λ ready
    100 <:x
    apply
    writeDecNumber (* 107 *) cr

    [ 1 :x 2 3 + + + ] ( :x ) λ ready
    100 <:x
    apply
    writeDecNumber (* 106 *) cr

    [ 1 2 3 + :x + + ] ( :x ) λ ready
    100 <:x
    apply
    writeDecNumber (* 106 *) cr

    [ :::x + + ] ( :::x ) λ ready
    1 2 3 <:::x
    apply
    writeDecNumber (* 6 *) cr

    [ ::x + ] ( ::x ) λ ready
    1 2 <::x
    apply
    writeDecNumber (* 3 *) cr

    [ :x * + + ] ( :x ) λ ready
    1 2 3
    100 <:x
    apply
    writeDecNumber (* 303 *) cr

    [ :x + + + ] ( :x ) λ ready
    1 2 3
    100 <:x
    apply
    writeDecNumber (* 106 *) cr


    (* ------------------------------------ *)
    (* the following tests are with scope *)

    [ [ :x + + + ] ( :x ) λ ready
      1 2 3
      100 <:x
      apply :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    writeDecNumber (* 116 *) cr

    [ 1 2 3
      100 <:x [ :x + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    writeDecNumber (* 116 *) cr

    [ 1 2 3
      100 <:x [ :x :x + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    writeDecNumber (* 216 *) cr

    [ 1 2 3
      100 <:x [ :y + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    writeDecNumber (* 26 *) cr

    [ 1 2 3
      100 <:x [ :y :x + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    writeDecNumber (* 126 *) cr

    [ 1 2 3
      100 <:x [ :x :y + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    writeDecNumber (* 126 *) cr

    [ 1 2 3
      100 <:x [ :y :y + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply writeDecNumber (* 36 *) cr

    [ 1 2 3 [ :y :y + + + + . ] null λ @ ]
    ( :y ) λ ready
    1000 <:y
    apply  (* 2006 *) cr


    [ 1 2 3 [ :y :y + + + + ] null λ @ ]
    ( :y ) λ ready
    1000 <:y
    apply writeDecNumber (* 2006 *) cr

    [ 1 2 3 [ :y :y + + + + ] ( ) λ @ ]
    ( :y ) λ ready
    1000 <:y
    apply writeDecNumber (* 2006 *) cr


    (* ----------------------------------- *)
    (* explicit lazy-eval  *)
    666
    1 2 3 4
     [ + + + ] ( ) λ @
     . (* 10 *) cr
    . (* 666 *) cr

    666
    1 2 3 4
     [ + + + ] null λ @
     . (* 10 *) cr
    . (* 666 *) cr


    (* ============================================== *)


    (* ----------------------------------- *)
    (* the following tests need flow-point-number
       for we need to define ``sqrt'' *)

    (*
     ,* the following shows the problem that people argued at:
     ,* http://lambda-the-ultimate.org/node/900

     ,* -b  +/- sqrt(b^2 - 4 * a * c)
     ,* -----------------------------
     ,*            2 * a
     ,*)


    (*
     ,* [              :b negate
     ,*     4 :a :c * *
     ,*         :b :b *  -  sqrt  +
     ,*                     2 :a  *  / ] dup2 write
     ,* ( :a :b :c ) dup2 write
     ,* λ ready
     ,*
     ,* 1 <:a  2 <:b  1 <:c
     ,*
     ,* apply writeDecNumber cr (\* -1 *\)
     *)
    #+end_src
** play with lambda
*** note
    1. it is very important to remember
       that lazy-eval must be explicit
    2. and again
       about substitution
       note that you can only use bound-variable (such as ::x :n) in a lambda-body
       bot NOT a dalin or list or wodyli
*** play
    #+begin_src cicada
    [ ::x ]
    ( ::x 3 4 ) λ
    : Var,I ; define
    : I Var,I fetch2 Exit ; define-function

    1 2 I @
    . . . . (* 4 3 2 1 *) cr
    cr

    1 2 <::x I @
    . . (* 2 1 *) cr
    cr

    1 2 I @
    . . . . (* 2 1 2 1 *) cr
    cr


    [ ::x ]
    ( ::x 3 4 ) λ
    : I ; define
    : I I fetch2 Exit ; define-function

    1 2 I @
    . . . . (* 4 3 2 1 *) cr
    cr

    1 2 <::x I @
    . . (* 2 1 *) cr
    cr

    1 2 I @
    . . . . (* 2 1 2 1 *) cr
    cr



    [ [ ::T @ ]
      ( ::F ) λ ]
    ( ::T ) λ
    : Var,T ; define
    : T Var,T fetch2 Exit ; define-function

    [ 1 2 3 . . . ] ( ) λ <::T
    T @ ready
    [ 7 8 9 . . . ] ( ) λ <::F
    apply (* 3 2 1 *) cr

    [ 1 2 3 . . . ] null λ <::T
    [ 7 8 9 . . . ] null λ <::F
    T @ @ (* 3 2 1 *) cr

    [ 7 8 9 . . . ] ( ) λ <::F
    [ 1 2 3 . . . ] ( ) λ <::T
    T @ @ (* 3 2 1 *) cr

    cr

    [ [ ::F @ ]
      ( ::F ) λ ]
    ( ::T ) λ
    : Var,F ; define
    : F Var,F fetch2 Exit ; define-function

    [ 1 2 3 . . . ] null λ <::T
    F @ ready
    [ 7 8 9 . . . ] null λ <::F
    apply (* 9 8 7 *) cr

    cr


    : make-lambda-bool
      (* True or False -- T or F *)
      true? if
	T Exit
      then F Exit
    ; define-function

    [ [ ::true <::T :if make-lambda-bool @ ready
	::false <::F apply ]
      ( :if ) λ ]
    ( ::true ::false ) λ
    : Var,IF ; define
    : IF Var,IF fetch2 Exit ; define-function

    True <:if
    [ 1 2 3 . . . ] null λ <::true
    [ 7 8 9 . . . ] null λ <::false
      IF @
    @ (* 3 2 1 *) cr

    [ 1 2 3 . . . ] null λ <::true
    [ 7 8 9 . . . ] null λ <::false
      IF @ ready
    True <:if apply (* 3 2 1 *) cr

    [ 7 8 9 . . . ] null λ <::false
    [ 1 2 3 . . . ] null λ <::true
      IF @ ready
    True <:if apply (* 3 2 1 *) cr

    [ 7 8 9 . . . ] null λ <::false
    [ 1 2 3 . . . ] null λ <::true
      IF @ ready
    False <:if apply (* 9 8 7 *) cr

    cr

    (* Y-combinator
       using explicit lazy-eval
       for cicada's semantic is eager-eval
       because lazy-eval is not natural to postfix-notation
     ,*)

    (*
     ,* in λ-cal:
     ,* Y = (λy.(λx.y(xx))(λx.y(xx)))
     ,*
     ,* in daedalus:
     ,* (def Y
     ,*   (λ (y)
     ,*     ((λ (x) (y (x x)))
     ,*      (λ (x) (y (x x))))))
     ,*)

    (* in cicada: *)


    [ [ [ ::x <::x ::x @ ] null λ <::rec ::y @ ]  ( ::x ) λ <::x
      [ [ ::x <::x ::x @ ] null λ <::rec ::y @ ]  ( ::x ) λ @ ]
    ( ::y ) λ
    : Var,Y ; define
    : Y Var,Y fetch2 Exit ; define-function


    [ [ [ One ] null λ <::true
	[ :n :n sub1 <:n ::rec @ @ * ] null λ <::false
	 IF @ ready
	:n one? <:if apply ]
      ( :n ) λ ]
    ( ::rec ) λ  <::y  Y @
    : Var,factorial ; define
    : factorial Var,factorial fetch2 Exit ; define-function

    1 <:n factorial @ .
    2 <:n factorial @ .
    3 <:n factorial @ .
    4 <:n factorial @ .
    5 <:n factorial @ .
    6 <:n factorial @ .
    7 <:n factorial @ .
    8 <:n factorial @ .
    cr

    (* ================================================== *)
    (* TODO the heuristic about Y *)

    [ [ One ] null λ <::true
      [ :n :n sub1

	  <:n
	  [ [ One ] null λ <::true
	    [ :n :n sub1

	    <:n
	    [ [ One ] null λ <::true
	      [ :n :n sub1

		  ,* ]
	    null λ <::false
	       IF @ ready
	      :n one? <:if apply ]
	    ( :n ) λ @

		,* ]
	  null λ <::false
	     IF @ ready
	    :n one? <:if apply ]
	  ( :n ) λ @

	     ,* ]
       null λ <::false
       IF @ ready
      :n one? <:if apply ]
    ( :n ) λ

    dup2 ready
    1 <:n apply . (* 1 *) cr
    dup2 ready
    2 <:n apply . (* 2 *) cr
    dup2 ready
    3 <:n apply . (* 3 *) cr
    drop2
    cr
    #+end_src
** >< interface for lambda
*** note
*** implementation
    #+begin_src cicada
    [ ::x ]
    ( ::x 3 4 ) λ
    : I ; defineLambda


    : Var,I ; define
    : I Var,I fetch2 Exit ; define-function


    : defineLambda,byString
      (* [value, type], string[address, length] -- *)

      Exit
    ; define-function

    : defineLambda,byString
      (* [value, type], wordlist[address, number of words] -- *)
      head-of-word-list
      defineLambda,byString
      Exit
    ; define-function
    #+end_src
** --------------------------------------
** >< memory allocation
*** note
    make good use of lambda
*** implementation (new lexicographers)
    #+begin_src cicada
    constants:
    (StackName),Size (* unit: Cell-width *)
    (StackName),Bottom
    (StackName),Top

    variables:
    (StackName),Pointer

    functions:
    push,(StackName)
    pop,(StackName)
    empty?(StackName)



    : defineStack (*  -- *)
    ; define-function

    : defineHeap (*  -- *)
    ; define-function

    : defineArray (*  -- *)
    ; define-function

    : defineBuffer (*  -- *)
    ; define-function
    #+end_src
** --------------------------------------
** ok & bye
   for the REPL is actually a REL which does not print
   so I provide a word to check that the cicada is working properly
   #+begin_src cicada :tangle ../play/english-core.ccd 
   :" yes"
   : String,yes ; defineConstString
   : ok (* -- *)
     String,yes print-string
     writeSpace
     Exit
   ; define-function

   :" byebye ^_^"
   : String,byebye ; defineConstString
   (*
    ,* : bye (\* -- THE END *\)
    ,*   writeSpace
    ,*   String,byebye print-string
    ,*   ><><><
    ,*   Exit
    ,* ; define-function
    *)
   #+end_src
** --------------------------------------
** welcome
   #+begin_src cicada :tangle ../play/english-core.ccd 
   :"    welcome to cicada ^_^"
   : String,welcome ; defineConstString
   : welcome (* -- *)
     String,welcome print-string cr
     Exit
   ; define-function

   cr

   welcome

   cr

   (* report the User-data-area size *)
   ."  the size of User-data-area is: " cr
   writeSpace
   End-of-user-data-area  User-data-area  -  writeDecNumber
   ."  bytes" cr

   writeSpace
   End-of-user-data-area  Here fetch  -  writeDecNumber
   ."  bytes free" cr

   writeSpace
   Here fetch  User-data-area  -  writeDecNumber
   ."  bytes used" cr

   cr

   ."  you are in symbolREPL
    in this REPL some types of symbol will be processed specially" cr

   cr
   #+end_src
** --------------------------------------
** cicada-editor
*** x & k
    - x :: 被读入的text是被结构化地保存的
	   显示的时候也可以根据结构高亮
    - x :: 每个命令都是一个 string-processing function
	   有一个命令的缓冲区 也就是说并不是每个命令都会马上被执行
	   这样在显示方面就要多费些功夫
	   显示与命令的执行分离
	   命令的执行也通过缓冲区与这些命令作为 string-processing function 的功能分离
	   这样整个文本编辑器就是cicada的string-processing的应用了
	   只是在cicada的string-processing上面添加了一个函数缓冲还有显示而已
	   cicada的string-processing中的函数有两种类型
	   一种是副作用类型的
	   一种是利用原有的字符串构造新的字符串的(函数式编程范式)
	   我将首先只实现函数式的那一种
	   也就是说对于一个字符串 插入 删除 替换 等操作都会生成一个全新的字符串
	   这也许非常耗费内存 但是其能行性值得被实验一下
	   注意
	   我必须利用缓冲下来的很多命令来形成一个字符处理函数
	   ;-- 这样就需要设计一个"编辑命令"到"字符串处理数"的转换器
	   ;-- 然而这样的在两个层次之间做转换的转换器的存在的前提是
	   ;-- 必须对两个层次都作出特殊的设计
	   因为每个字符处理函数都是要申请很多内存 来保存一行字符的
	   这也要求我设计很多新的字符串处理的语法
	   还要实现对这些语法的处理
	   这是最难的部分
	   注意
	   另一个重要的 操作是 匹配
	   它的函数类型与上面的不同
	   注意
	   这里可能需要加强cicada对字符串的实现方式
	   尤其是需要考虑gc
    - k :: 太好了!
	   你已经有一个大致的思路了
	   我们可以先假装gc没有问题然后去实现这些想法试试
    - x :: 没错
	   我之前说过
	   字符串处理 模块系统 文档系统 文本编辑器 都应该被同时设计
	   但是现在我明白了
	   应该被同时设计的是
	   字符串处理 和 文本编辑器
	   而 模块系统 文档系统 其实应该与集成开发环境的用户接口一起设计
	   模块系统涉及到对命名空间的控制
	   当用hash-table来实现find的时候这并不难做到
	   模块系统还涉及到 如何定义什么是一个模块
	   非常简单 就是一个词的集合而已 其中可以有 任何类型的词
*** x & k 2
    - x :: 还有一个重要的需要考虑的问题就是关于文本编辑的数据类型
	   我想对于下手实现我还有些犹豫
	   就是因为这个数据类型我还没有设计好
    - k :: 这里需要借鉴emacs
	   尽管对字符串的处理将是函数式的
	   但是对于文本编辑器而言数据类型将以dalin和wodyli为核心
    - x :: 没错
	   现在很多wodyli处理函数还没有写好
	   在实现文本编辑器的过程中我会完善它们
	   我的设计是这样的
	   就文本编辑而言核心的数据结构将是被结构化的文本
	   每个语言mode都必须实现自己的parser
	   [mode] :: string =parser=> structured-string
	   类比过去这里类似buffer的数据结构就是structured-string
	   每个structured-string都会有附属于它的ScreenBuffer
	   将会有附属于structured-string的editing-pointer
	   对于每个mode必须还有一个专门用于显示的函数
	   structured-string =structure-displayer=> ScreenBuffer
	   这个函数还必须处理editing-pointer
	   以让它与ScreenBuffer的Cursor对应
    - k :: 这样其实就形成了一个mode的模板
	   也许我们应该重新命名这些概念
	   不叫mode而叫做structure
	   这里的structure其实就是sexp不是吗?
	   只不过list被换成了dalin
	   以适应对文本的副作用
    - x :: 而且我有wodyli
	   它是专门用来补足sexp不适合用来自定义数据结构这一弱点的
*** note
    1. the loop :
       1) read a key (a char)
       2) according to some global variables
	  dispatch a key to a function and execute
	  the execution of a function
	  will edit the datastructure for text
	  and  edit the datastructure for display
       3) update display
       4) loop
       so it is a ``REDL''
    2. two datastructures for cicada-editor
       one for text
       one for display
    3. key binding :
       every key can be bound to any function
*** string->line-dalin
    every mode has its parser
    string->line-dalin is the parser of fundamental-mode
    #+begin_src cicada
    : find-char-address
      (* char, [address, length] -- address or -1 *)
      dup zero? if
	drop2 drop
	One negate
	Exit
      then
      tailAndHeadOfString
      x|over|xxx == if
	drop swap drop
	sub1 Exit
      then
      find-char-address
      Exit
    ; defineRecursiveFunction

    : find-char-index
      (* char, [address, length] -- index or -1 *)
      (* index start from Zero *)
      over
      xxx|swap|x
      find-char-address
      dup Zero < if
	swap drop Exit
      then
      swap -
      Exit
    ; define-function


    (* little test:
     ,* 'k' s" k" find-char-index . (\* 0 *\) cr
     ,* 'k' s" kkk" find-char-index . (\* 0 *\) cr
     ,* 'k' s" skkk" find-char-index . (\* 1 *\) cr
     ,* 'k' s"  kkk" find-char-index . (\* 1 *\) cr
     ,* 'k' s" 0123456789k" find-char-index . (\* 10 *\) cr
     ,* 'k' s" 0123456789" find-char-index . (\* -1 *\) cr
     ,*)



    : help,string->line-dalin
      (* [address, length] -- head[address, <dalin>] *)
      (* LambdaStack:: [address, <dalin>] -- *)
      dup zero? if
	getBack
	dup2
	  cdr null [cons,cdr]!
	  drop2
	head<-dalin
	Exit
      then
      dup2
      'linefeed' xx|over|x find-char-index
      dup Zero < if
	(* this means if a string is not end with 'linefeed'
	   a 'linefeed' will be added at the end *)
	drop
	dup substring
	xx|tuck|x
	swap copy-byte-string
	<substring>
	cons drop <dalin>
	[car,cons]!
	  cons null [cons,cdr]!
	[cons,cdr]!
	getBack
	xx|swap|xx
	^_^
	head<-dalin
	Exit
      then
      (* [address, length], index-of-linefeed *)
      x|over|xx over + add1
      xxx|swap|x (* leave the new address *)
      swap over - sub1
      xx|swap|x (* leave the new length *)
      (* [new address, new length], address, index-of-linefeed *)
      dup zero? if
	(* 'linefeed' is the 1st char of the string
	   so we meet an empty line, it will be stored as `null' in dalin *)
	drop2
	null
      else
	(* index-of-linefeed is just the length of substring *)
	dup substring
	xx|tuck|x
	swap copy-byte-string
	<substring>
      then
      cons drop <dalin>
      [car,cons]!
	cons null [cons,cdr]!
      [cons,cdr]!
      getBack
	xx|swap|xx
	^_^
      ready
      help,string->line-dalin
      Exit
    ; defineRecursiveFunction

    : string->line-dalin
      (* [address, length] -- head[address, <dalin>] *)
      (* which parses a string and return a dalin of substring
	 one substring denotes one line of text
	 empty line is stored as `null' in dalin *)
      null ready
      help,string->line-dalin
      Exit
    ; define-function
    #+end_src
*** test: string->line-dalin
    #+begin_src cicada
    s" kkk" string->line-dalin
    car printTypeTag (* <substring> *) cr
    dup getLengthOfString
    print-string (* kkk *) cr

    s" kkk
    " string->line-dalin
    dup2 dalin*? . (* 1 *) cr
    car printTypeTag (* <substring> *) cr
    dup getLengthOfString
    print-string (* kkk *) cr

    s" kkk
    aaa" string->line-dalin
    dup2 dalin*? . (* 0 *) cr
    dup2
    car printTypeTag (* <substring> *) cr
    dup getLengthOfString
    print-string (* kkk *) cr
    ->
    car printTypeTag (* <substring> *) cr
    dup getLengthOfString
    print-string (* aaa *) cr

    s" kkk
    aaa
    " string->line-dalin
    dup2 dalin*? . (* 0 *) cr
    dup2
    car printTypeTag (* <substring> *) cr
    dup getLengthOfString
    print-string (* kkk *) cr
    ->
    car printTypeTag (* <substring> *) cr
    dup getLengthOfString
    print-string (* aaa *) cr
    #+end_src
*** >< reduce text-editing to line-editing
    #+begin_src cicada
    (* buffer: ==
	 [address]
       line: ==
	 buffer[address, length], cursors[address, <list>]
       where:
	 cursor is a Zero-based-index, from Zero to length *)


    0 : Var,LineBuffer ; defineVar

    Here fetch Var,LineBuffer save
    1000 Here add-save

    : LineBuffer (*  -- buffer[address] *)
      Var,LineBuffer fetch
      Exit
    ; define-function


    0 : Var,Tmp,LineBuffer ; defineVar

    Here fetch Var,Tmp,LineBuffer save
    1000 Here add-save

    : Tmp,LineBuffer (*  -- buffer[address] *)
      Var,Tmp,LineBuffer fetch
      Exit
    ; define-function


    : copyStringToBuffer
      (* string[address, length], buffer[address] --
	 buffer[address, length] *)
      pushLambdaStack
      tuck
      popLambdaStack dup pushLambdaStack
      swap copy-byte-string
      popLambdaStack
      swap
      Exit
    ; define-function

    : copyStringToLine
      (* string[address, length], buffer[address] --
	 buffer[address, length], cursors[address, <list>] *)
      copyStringToBuffer
      cons drop <list>
      Zero <fixnum>
      [cons,car]!
      Exit
    ; define-function


    : line,move-cursor-right
      (* buffer[address, length], cursors[address, <list>], number --
	 buffer[address, length], cursors[address, <list>] *)
      xx|over|x car drop (* drop <fixnum> *)
      +  <fixnum> [cons,car]!
      Exit
    ; define-function

    : line,move-cursor-left
      (* buffer[address, length], cursors[address, <list>], number --
	 buffer[address, length], cursors[address, <list>] *)
      xx|over|x car drop (* drop <fixnum> *)
      -  <fixnum> [cons,car]!
      Exit
    ; define-function

    : line,move-cursor-to-col
      (* buffer[address, length], cursors[address, <list>], index --
	 buffer[address, length], cursors[address, <list>] *)
      <fixnum> [cons,car]!
      Exit
    ; define-function


    (* ><><><
       the following two functions need better factoring *)

    : insertString
      (* string[address, length],
	 buffer[address, length], cursors[address, <list>] --
	 buffer[address, length], cursors[address, <list>] *)
      dup2 ready
      xx|over|xx ready
      car drop (* drop <fixnum> *)
      tuck -
      xx|swap|x +
	dup pushLambdaStack (* address of middle buffer *)
      swap
      Tmp,LineBuffer copyStringToBuffer
      xx|swap|xx
      popLambdaStack copyStringToBuffer
	dup pushLambdaStack (* length of string *)
      + copyStringToBuffer
      drop2
      popLambdaStack
      getBack x|swap|xx dup pushLambdaStack
      +
      popLambdaStack
      getBack
      x|tuck|xx car drop (* <fixnum> *)
      + <fixnum> [cons,car]!
      Exit
    ; define-function

    (*
     ,* test:
     ,* s"  xxx "
     ,* s"  kkk " LineBuffer copyStringToLine
     ,* 2 line,move-cursor-right
     ,* insertString
     ,* car write (\* 7 *\) cr
     ,* print-string (\*  k xxx kk  *\) cr
     ,*)

    : insertChar
      (* char,
	 buffer[address, length], cursors[address, <list>] --
	 buffer[address, length], cursors[address, <list>] *)
      dup2 ready
      xx|over|xx ready
      car drop (* drop <fixnum> *)
      tuck -
      xx|swap|x +
	dup pushLambdaStack (* address of middle buffer *)
      swap
      Tmp,LineBuffer copyStringToBuffer
      x|swap|xx
      popLambdaStack tuck save-byte
      add1
      copyStringToBuffer
      drop2
      getBack add1
      getBack dup2 car drop (* <fixnum> *)
      add1 <fixnum> [cons,car]!
      Exit
    ; define-function


    (*
     ,* test:
     ,* 'x'
     ,* s"  kkk " LineBuffer copyStringToLine
     ,* 2 line,move-cursor-right
     ,* insertChar
     ,* car write (\* 3 *\) cr
     ,* print-string (\*  kxkk  *\) cr
     ,*)


    : deleteChars
      (* buffer[address, length], cursors[address, <list>], number --
	 buffer[address, length], cursors[address, <list>] *)
      xx|tuck|x
      xx|swap|x dup2 ready
      car drop (* drop <fixnum> *)
      +
      (* buffer[address, length], number, number + cursors *)
      xx|swap|x  -
      (* buffer[address], number + cursors, length - number *)
      x|over|xx swap ready
      (* buffer[address], number + cursors *)
      +
      xx|swap|x

      Exit
    ; define-function

    : line,kill-line (* erase-half-line-to-end *)
      (* buffer[address, length], cursors[address, <list>] --
	 buffer[address, length], cursors[address, <list>] *)
      Exit
    ; define-function







    (*
     ,* : text,move-cursor-up (\* number -- *\)
     ,* ; define-function
     ,*
     ,* : text,move-cursor-down (\* number -- *\)
     ,* ; define-function
     ,*
     ,* : text,move-cursor-down-&-to-the-begin-of-line (\* number -- *\)
     ,* ; define-function
     ,*
     ,* : text,move-cursor-up-&-to-the-begin-of-line (\* number -- *\)
     ,* ; define-function
     ,*)




    (*
     ,* : text,move-cursor-to-row (\* row-index -- *\)
     ,* ; define-function
     ,*
     ,* : text,move-cursor-to-row-&-col (\* row-index, col-index -- *\)
     ,* ; define-function
     ,*)


    (* the position of the cursor
     ,* is also as an argument of the following functions
     ,* but the cursor do not move when these functions are executed
     ,*)



    (*
     ,* : delete-lines (\* number -- *\)
     ,* ; define-function
     ,*)



    (*
     ,* : erase-half-screen-to-end (\* -- *\)
     ,* ; define-function
     ,*
     ,* : erase-half-screen-to-start (\* -- *\)
     ,* ; define-function
     ,*
     ,* : erase-screen (\* -- *\)
     * ; define-function
     *)
    #+end_src
*** >< tryREDL
    just use the ``read-char''
    #+begin_src cicada
    :" 1234567890"
    : InitString,for-update-display ; defineConstString

    InitString,for-update-display
    : Var-string,for-update-display ; define


    : update-display
      (*  --  *)
      terminal,clearScreen
      Var-string,for-update-display
      fetch2 print-string cr
      Exit
    ; define-function


    :" kkk
    : tryREDL (*  --  *)
      setTerminalToReadKey
      help,tryREDL
      Exit
    ; define-function
    "
    : String-for,kkk ; defineConstString

    :" kkk" string-hash->index
    : SymbolIndex,kkk ; defineConst
    : kkk (*  -- *)
      String-for,kkk
      Var-string,for-update-display
      save2
      Exit
    ; define-function

    :" aaa

    : help,tryREDL (*  --  *)
      (* D *)
      update-display
      (* R *)
      read-char  (* writeSpace writeDecNumber cr *)
      (* E *)
      char->function-name-symbol
      executeSymbol
      (* L *)
      help,tryREDL
      Exit
    ; defineRecursiveFunction
    "
    : String-for,aaa
    ; defineConstString

    :" aaa" string-hash->index
    : SymbolIndex,aaa ; defineConst
    : aaa (*  -- *)
      String-for,aaa
      Var-string,for-update-display
      save2
      Exit
    ; define-function



    (* in the future this funciton must see a lot of global variables *)
    : char->function-name-symbol
      (* char -- [index, <symbol>] *)
      dup 'k' == if
	drop SymbolIndex,kkk <symbol> Exit
      then
      dup 'a' == if
	drop SymbolIndex,aaa <symbol> Exit
      then
      Exit
    ; define-function


    :" executeSymbol said:
       ``My function-type is (* [index, <symbol>] -- unknown *)
	 But I meet the following type
	 I will not touch it and call debuger.''
       --> "
    : String,executeSymbol,type-error ; defineConstString
    : executeSymbol (* [index, <symbol>] -- unknown *)
      dup <symbol> =/= if
	String,executeSymbol,type-error print-string
	dup printTypeTag cr
	debuger
	Exit
      then
      drop (* drop <symbol> *)
      index-hashback->string
      execute-word
      Exit
    ; define-function



    : help,tryREDL (*  --  *)
      (* D *)
      update-display
      (* R *)
      read-char
      (* E *)
      char->function-name-symbol
      executeSymbol
      (* L *)
      help,tryREDL
      Exit
    ; defineRecursiveFunction

    : tryREDL (*  --  *)
      setTerminalToReadKey
      help,tryREDL
      Exit
    ; define-function

    : t tryREDL Exit ; define-function
    #+end_src
* ==================================================
