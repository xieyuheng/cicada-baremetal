#+TITLE: 蝉语的汉语核
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 笔记
** 十诫
   1. 任何戒律在需要的时候都可以被打破
      但是你一定要明白为什需要打破这些戒律
      并且在打破旧的戒律的同时
      你要探寻新的规则
      不是要用这些规则限制自己
      而是要在观察中总结规律
      以形成更好的认识
   2. 每个函数的参数个数不应该很多
      多于三个的时候就要仔细检查必要性了
   3. 写一个大函数的时候发现需要把它分解成小函数
      然后你就去写那些小函数
      重要的是每写完一个小函数的时候
      如果这个函数的正确性不是显然的
      那么就马上去测试这个小函数的正确性
      因为当回到大函数的时候 就很难发现是那里错误了
      + 其实不难发现是哪里错了
        当理解了 蝉语 的工作方式之后
        如果一段函数的执行出错了
        找到真正出错的那个函数的过程非常容易
   4. 上面这个是非常重要的一诫
      我的感受是
      在没有类型系统的条件下
      当运行的时候出现了一个错误
      通常在十分钟之内就能找到引起错误的函数
      这一诫的有趣之处在于 我几乎不可能去遵守这条戒律
      在写下一个函数的时候
      我总是想单纯地通过看着这个函数就相信这个函数是正确的
      要想忽视这条戒律
      那么你就必须找出很好的设计函数接口的方式
      并且找出一组 好的 用来描述你想要解决的问题的 词
      也许忽视这条戒律 并且 摒弃类型推导系统
      就能鞭策你作出更简洁设计
   5. 如果要使用计数器
      那么等被计数的那件事干完了之后再增加或减少计数器
      而不要先更改计数器再去做计数器所计数的工作
   6. 每次更改含有 "转" 的函数的时候
      要记得更新 "转" 后面的 "位移"
   7. 小心地检查 在某个新写完的函数执行之后
      栈中 有没有 多出 或 减少 值
      在一次计算之后 栈中所保存的应该只是我所需要的返回值
      + 在集成开发环境 的帮助下 这一点将很容易检查
** 关于垃圾回收器
   1. this gc is a incremental-gc
      a marking-gc for pair
      a copy-gc for string
   2. 要知道 既然是PairConstruction所组成的数组
      那么从人类的角度来说
      那个二叉有向图中的点之间就是有一个全序关系的
   3. 以我的方式实现的动态内存管理其实已经不适合被称作垃圾回收了
      它的工作方式是这样的:
      1) 它是有一个工作周期的
         除了第一个工作周期之外
         一个工作周期的开始和结束都是在
         cons把LastPairConstruction这块内存空间分配给程序之后
         + 我把这个地方称为``工作循环点''
      2) 有三个部分在配合工作来完成我所需要让它们完成的任务
         一个marking 一个finding 还有一个cleaning
         其中cleaning的工作是伴随finding而进行的
         而marking会在这个工作周期中标记出那些
         它认为不能在下一个工作周期被finding找到的PairConstructions
         要知道在上面的二叉有向图中
         指定一些根节点
         就赋予了每个节点一个性质: <reachable> 或 <non-reachable>
         reachable当热是就那些被指定的根节点而言的
         而marking所做的就是在这个工作周期中标记出那些它认为<reachable>的点
         然后剩下的点就是<non-reachable>的
         也就是可以被finding找到而被重新利用的
      3) marking其实有点笨
         如果它能精确的标记出所有的<reachable>的点就最好了
         但是其实
         每次它所标记出的不能被下一个工作周期的finding找到的点中
         在包含了所有的<reachable>的点的同时
         也可能会错误地包含了很多<non-reachable>的点
         + 但是只要它能标记出所有的<reachable>的点
           那么它的这点笨拙就不会影响整个工作的正确性
         + 并且被它在这个工作周期中错误地标记了的<non-reachable>的点
           总是有机会在下一个工作周期被marking认为是<non-reachable>的而不去标记
           也就是说marking总是有在下一个工作周期改正自己错误的机会
           所以也许marking没有笨到无可救药的地步
      4) 首先每个PairConstruction中包含三个可以被``染色''的bit
         1. 一个为本次工作周期中的marking
            这是为了下一个工作周期中的finding准备的
         2. 一个为本次工作周期中的finding
            在这个工作周期中finding用完它们之后它们就没用了
            在下一个工作周期就可以把它们交给cleaning来处理了
         3. 一个为本次工作周期中的cleaning
            这是为了下一个工作周期中的marking准备的
      5) 所以在每个工作循环点
         只需要对这三个bits做一个置换就可以了
         所使用的置换显然是三阶置换群中的两个三循环置换之一
      6) marking和finding的工作是相互独立的
         这在于它们读写的color-bit不同
         还在于finding的工作被CurrFreePairConstruction这个全局变量来指示
         + 也就是说finding依赖于上面提到的二叉有向图的节点之间的全序关系
         而marking的工作被GreyPairStack这个栈中的元素和这些元素的个数而指示
   4. marking对一个PairConstruction的标记就在于
      去把这个PairConstruction的为marking所准备的bit染黑(即 把这个bit set为1)
      而GreyPairStack是用来记录marking的工作进度的
      用black,grey,white三种颜色去描述marking的工作方式就很形象
   5. ><><>< 有一个问题
      在每个工作周期循环点
      在初始化GreyPairStack的时候
      ArgumtStack中已经保存的pair并不会被加入GreyPairStack !!!
      ><><>< 我必须引入额外的机制吗 ???
      初始化GreyPairStack的时候 不可能到ArgumtStack中去把所有的pair都找出来
      但是我好像必须要这样做才行
      要注意每次调用cons的时候
      都可能是在一个工作循环点
      因而触发对GreyPairStack的初始化
      但是每次调用cons的时候栈可能已经被递归地非常深了
      + 所有这些困难的产生都在于我没有用一个free-list来记录能被我使用的点
      所以这种寻找可能会非常消耗计算
      并且我所使用的动态类型系统并不足以以严格的方式来判断那些东西是<pair>
      如果重新初始化GreyPairStack的过程中没有考虑到栈中的这些cons那会有什么后果呢?
      这些cons其实是可以被引用到的
      毕竟它们在栈中呢
      但是finding所见的它们却是可以被重新利用的
      还有一个问题就是如果我把栈中的cons初始化入了GreyPairStack中
      那么marking就可能错误标记很多节点了
      因为 毕竟这些在栈中的点都可能只有很短的生存时间而已
      在一个工作周期循环点
      栈中的这些cons应该是在下一个工作周期的finding所不能找到的点
      而不是下一个功能工作周期marking应该标记的点
      所以初始化GreyPairStack的时候不用将这些东西全部都放到GreyPairStack中
      将这些cons的color-bit-for-finding涂黑就行了
      这样就保证了整个工作的正确性
      但是每当垃圾回收的时候还是要扫描整个ArgumtStack !!!
      >< 我先这样来实现我的gc系统吧
   6. 一个工作周期结束之后
      在工作周期循环点
      <reachable-note> 是那些不应该被下一个工作周期的finding找到的点
      而我所设计的gc系统中
      不能被下一个工作周期的finding找到的点有两个来源
      一个是上一个工作周期的marking所标记的黑点
      一个是在工作周期循环点的时候 ArgumtStack中的所有cons
      所以在工作周期循环点
      所需要做的额外工作就是在ArgumtStack中找到所有的cons
      然后把它们为下一个工作周期的finding涂黑
   7. >< gc的这种工作方式是可以接受的吗 ???
      这就需要更多的测试和实际的使用才能知道
      也许是可以的
      因为ArgumtStack的深度应该总是远远小于整个PairConstructionsArray的大小
   8. 上面扫描整个栈的那些计算
      对与forth的垃圾回收器来说可能是不可避免的
      这种不可避免性其实来源于我的垃圾回收器的这样一种性质
      那就是工作循环点的位置是固定的
      在工作循环点有要很多额外的工作要做
      其实在我遵从的垃圾回收器的这中设计方式下的垃圾回收器
      总是要在工作周期的循环点集中地做很多工作的
      而渐进性就在于把这些被集中地做的工作中的某一些分散到别的地方
      我完全分散了marking部分工作
      并且我完全消除了传统的垃圾回收器中的sweep部分的工作
      但是我的设计也可能是失败的
      因为看来我引入了(是我引入的吗??)其他的需要被集中进行的工作
   9. 在栈中的或者是保存在变元中的cons
      永远不会被垃圾回收器回收
   10. ><><>< 也许我应该仔细学习更多的别的gc的设计与实现方式
   11. ><><>< 关于上面的问题
       forth系统中如何使用局部变量 !!!
       关于forth中的局部变量的思考是否能启示我解决上面的问题的更好的方法
   12. 总结一下数据类型:
       <value>是我的forth系统中所有的动态类型的量的集合
       而<atom>是这些动态的量中除了<pair>之外的所有动态类型的量的集合
       #+begin_src bnf
       <value> ::= <pair> | <atom>
       <pair>  ::= <reachable-note>
       <reachable-note>
               ::= 可能是从根节点可以引用到的点
                     比如: (car <variable>)
                   也可能是在栈中的点
                     比如: (cons <value> <value>)
       #+end_src
       上面的(cons <value> <value>)其实就是把一个<pair>返回到栈中
       而这些在栈中的<pair>就被看作是<reachable-note>
   13. 促使marking去标记一个PairConstruction的列表处理操作
       有且只有下面两种(三个)(涉及到set-car!&set-cdr!的时候我只用set-car!作为例子)
       我同时用scheme和cicada这两种语言来描述这些操作
       1) scheme :
          #+begin_src scheme
          (set-car! <pair> <value>)
          #+end_src
          cicada :
          #+begin_src cicada
          <pair>[address, type] <value>[value, type] set-car!
          #+end_src
          + 如果<pair>的color-bit-for-marking是黑色的
            又如果<value>也是<pair>
            那么就尝试去染灰<pair>的color-bit-for-marking
       2) scheme :
          #+begin_src scheme
          (set! <variable> <pair>)
          #+end_src
          cicada :
          #+begin_src cicada
          <variable>[address] <pair>[address, type] set!
          #+end_src
          + 如果<value>是<pair>
            那么就尝试去染灰<pair>的color-bit-for-marking
   14. 申请一个可用的内存空间(一个自由的PairConstruction)
       并且促使finding去寻找下一个可用的内存空间的列表处理操作
       有且只有下面一个
       scheme :
       #+begin_src scheme
       (cons <value> <value>)
       #+end_src
       cicada :
       #+begin_src cicada
       cons <value>[value, type] set-car!
            <value>[value, type] set-cdr!
       #+end_src
       + 在古典的lisp中每当构造子cons像上面这样构造完一个pair之后
         都只有且只有一次机会来引用所构造的pair
         那就是在嵌套的sexp中调用cons的那个位置上
         那个位置上返回的值就是所构造的pair
       + 而在我的cicada中引用那个cons的方式极为灵活
       + 比如 如果我要编译一个类scheme语言到cicada的话
         我就可以又类似下面的语法
         在下面的两个<sexp>中也可以引用到这个cons将要构建好的pair
         #+begin_src scheme
         (cons :set-address-to xxx
               :car <sexp>
               :cdr <sexp>)
         #+end_src
       + >< 但是一个问题是上面的语法用到了局部变量
         不知到局部变量的问题如何在类forth语言中解决 ???
   15. forth是如此灵活以至于我根本没必要实现common-lisp中的那种广义引用
       比如为了实现类似的效果 我复制一下被解构子解构的pair的地址就行了
   16. 在使用scheme的时候我从来没有想像过对数据结构的使用能够像在forth中这样灵活
       但是就目前的实现进度而言与scheme相比我还缺少:
       1) λ-abstraction
       2) 局部变量
       3) 局部变量与λ-abstraction是等价的吗 ???
          我已经知道用λ-abstraction(closure)就可以实现局部变量了
          反过来也行吗 ???
       也许我可以在forth中实现这些东西
       因为我能够单纯地用列表处理来实现整个λ-cal(惰性求值的)
       用列表处理实现λ-cal之后 我只需要实现一个类似apply的函数就行了
       可以说forth的语法是就``函数的复合''而优化的
       而scheme的语法是就``函数的作用''而优化的
       但是两种语义显然是能够互相表示的
       要知道 当把forth中的所有的word都理解为一栈为参数的一元函数的时候
       其实那些单纯地把一个量入栈的函数 也可以被理解为参数
       而后面的函数与这些函数的复合可以被理解为这些函数对参数的作用(当然了,这才是古典的理解)
       也就是说对forth的理解是非常灵活的
       + 对于被当作二元运算的二元函数来说
         只有当这种二元运算满足结合律的时候使用infix才是令人满意的
         + 比如: + * max min gcd `函数的复合' `字符串的并联' 等等
         这正是joy所想要表达的
       + 对二元运算的结合性的证明 可以被转化为对一种特殊的交换性的证明
         #+begin_src
         (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
         或者:
         (p + q) + r  ==  p + (q + r)  <==>
         p q + r +    ==  p q r + +    <==>
         + r +        ==  r + +
         #+end_src
       + 再考虑一下别的运算律 简直有趣极了
         #+begin_src
         分配律(或者说对某种同态变换的描述):
         中缀表达式: (a+b)*c == (a*c)+(b*c)  <==>
         后缀表达式: ab+c* == ac*bc*+  <==>  ???
         但是至少我知道 +(c*) =/= (c*)+
         要想填上上面的问号 可能就需要 λ-abstraction 的抽象性
         否则我根本没法描述某些东西

         交换律:
         a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

         +* =/= *+
         abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
         #+end_src
       + 把后缀表达式考虑为对栈的操作是自然的
         并且这样的理解方式所带来的一个很大的好处就是实在性
         这就又回到了哪个``小孩玩积木''的比喻了
         比如我的十三岁的弟弟可以问我"那个函数的参数是从哪来的?"
         我就告诉他是从栈里拿出来了
         "那个函数的结果去哪了?"
         我就告诉他结果放回到栈里了
         数学 和 编程 就都像一个小孩在玩积木一样
         对了 他还可以问我这个函数是从哪里来的
         我就说是从词典里找来的
   17. forth是最有趣的结合代数
       利用这个结合代数似乎可以模拟任何代数结构(甚至是非结合代数)
       1) 比如上面对函数作用的模拟(尽管函数的作用不是结合的)
       2) 又比如我可以把两个矩阵入栈
          然后一个矩阵乘法函数可以像"*"乘两个数一样为我返回矩阵的积(尽管矩阵乘法不是结合的)
       3) 又比如列表处理可以用来实现digrap
          而digrap已经出离代数的范畴之外了
          但是它还是能够被forth的结合代数所模拟
   18. 如果让我写scheme编译器的话 我会让每个表达式都返回一个值
       正因为如此 在cicada中
       我才把set!,set-clr!,set-car!,set-cdr!等等函数实现为它们现在的这种样子
** 关于字符串
   1. 可以用压缩式的垃圾回收器来实现对字符串的动态内存管理
      因为string的长度可变
      所以简单的marking-gc是不适用的
   2. 在marking工作的时候 如果看见<string>
      就更改引用点 并且复制字符串
      + makeing是知道引用点是哪个的
   3. 如果string的堆比pair的堆先耗尽
      这时就必须重启gc
      所以应该把string的堆设置的充分大 以避免这种情况
   4. 一个问题是
      应该如何在 比如说 定义一个词典中的函数的时候
      在这个定义中使用string-literal还有list-literal
      比如debuger那一节的函数就包含了很多要打印出来的字符串
      如果这些字符串是不被别的地方引用的
      那么用``defineConstString''来定义它们就是不合理的
   5. 要知道被定义到词典中的东西是永远不能被删除的
      因此也就是不需要被垃圾回收的
      所以让这gc去mark这些量是不合理的
      所以就像在汇编中一样
      每个函数中的结构化的literal量 就是这个函数的数据段
      在编译函数的时候应该把这些数据也写到词典里
   6. 所以 string-literal 和 string-processing
      采用了两种不同的方式来使用string
      string-processing 中所使用的string必须是动态分配内存的
      ``readStringInToBuffer'' 这个函数所提供的 string buffer
      是一种能力非常有限的动态分配内存的方式
      而这里的 利用gc来实现的<string> 是一种更好的方式
   7. string[address, length] 之外另一种字符串的表示方式是
      [address, <string>]
      此时address的前面必须保存length
      我用4byte来保存这个length
* ==================================================
* 记
  1. 要求是 中文核 不依赖于 英文核
  2. 这一小节中
     直接从英文翻译而来的
     都是一些 需要定义在汇编中的基本词汇
     需要的时候很容易把它们重新定义到汇编中
  3. 有些 重要的全局变量 不能有两个版本
     因此 保持这些 英文的 名词
     这是可以接受的
     毕竟 我不是一个想要把所有东西都汉化的
     狭隘的 民族主义者
     这种词包括 :
     1) Here
     2) First-word-in-dictionary
     3) Lambda-stack-pointer
* 名词
** 重要的名词
   #+begin_src cicada :tangle chinese-core.cicada
   (* Here 这个名词 还是必须使用英文版本的 *)
   夫 单元大小 Cell-width 者 也
   #+end_src
** 真 假
   #+begin_src cicada :tangle chinese-core.cicada
   夫 假 False 者 也
   夫 真 True  者 也
   #+end_src
** 诠释者
   #+begin_src cicada :tangle chinese-core.cicada
   夫 动词诠释者 Verb-explainer 者 也
   夫 名词诠释者 Noun-explainer 者 也
   #+end_src
* 动词
** 定长整数
*** 记
    1. "取反加一"
       是 定长整数 的集合上的方幂为零的变换
       这个变换以自身为逆变换 因而是 双射
       并且它是 [定长整数, +] 上面的同构变换
    2. 而要知道 [自然数, +] 上的同构变换只有乘法
       而上面的 "取反加一" 作为乘法就是乘以负一
    3. 但是其实不是的
       因为 [定长整数, +] 并不是一个代数结构
       但是它已经很接近一个代数结构了
       只有当 CUP 的 overflow 旗子被举起来的时候
       这种近似才出现了错误
       + 而利用举起旗子所传达出来的信息我们可以探测到并且更正这种错误
       因此 "取反加一" 是 类 [自然数, +] 集合上的同构变换
       这个变换的语义是 "乘以负一"
*** 实现
    #+begin_src cicada :tangle chinese-core.cicada
    夫 加       add      已矣 者 动词也
    夫 减       sub      已矣 者 动词也
    夫 乘       mul      已矣 者 动词也
    夫 除       div      已矣 者 动词也
    夫 模       mod      已矣 者 动词也
    夫 除模     divmod   已矣 者 动词也
    夫 模除     moddiv   已矣 者 动词也
    夫 负       negate   已矣 者 动词也
    夫 幂       power    已矣 者 动词也
    #+end_src
** 存储空间
   #+begin_src cicada :tangle chinese-core.cicada
   (* 一般的 存取 所作用于 的是 一单元 大小 的存储空间
    * 小的 存取 所作用于 的是 一比特 大小 的存储空间
    *)

   (* 多个值 而 存取 的作用 如下
    *   在存储空间中 :
    *     ||  1 : 值-1  ||
    *     ||  1 : 值-2  ||
    *     ||  1 : 值-3  ||
    *     ...
    *   在栈中 :
    *     (* 值-1, 值-2, 值-3, ... *)
    * 即 从上到下 对应 从左到右
    * 这样就和 名词 的结构保持了一致
    * 此时 取 很简单 但是 存 需要特殊处理
    *)

   夫 存         save              已矣 者 动词也
   夫 小存       save-byte         已矣 者 动词也
   夫 而存       n-save            已矣 者 动词也
   夫 而小存     n-save-byte       已矣 者 动词也


   夫 取         fetch             已矣 者 动词也
   夫 小取       fetch-byte        已矣 者 动词也
   夫 而取       n-fetch           已矣 者 动词也
   夫 而小取     n-fetch-byte      已矣 者 动词也


   夫 加存       add-save          已矣 者 动词也
   夫 减存       sub-save          已矣 者 动词也

   夫 复制比特串 copy-byte-string  已矣 者 动词也
   #+end_src
** 测试
   #+begin_src cicada
   夫 k 1 2 3 者 也

   ok

   k . . . (* 3 2 1 *) cr ok
   7 8 9 址 k 3 而存

   k . . . (* 7 8 9 *) cr ok

   址 k 3 而取  . . . (* 7 8 9 *) cr ok
   #+end_src
** 参数栈
*** 指针
    #+begin_src cicada :tangle chinese-core.cicada
    夫 做自引用值于参数栈
       make-self-reference-value,in-argument-stack
       已矣
    者 动词也

    夫 取参数栈指针
       fetch-argument-stack-pointer
       已矣
    者 动词也

    夫 重置参数栈指针
       reset-argument-stack-pointer
       已矣
    者 动词也
    #+end_src
*** 记
    1. 这其实是 一个有趣的结合代数
       任取一个 有限阶置换群
       都存在 这个有趣的结合代数的子代数 与 所取的有限阶置换群 同构
       下面的某些栈处理函数就是某些低阶的有限置换群中的元素
*** 弃
    #+begin_src cicada :tangle chinese-core.cicada
    夫 弃     drop      已矣 者 动词也
    夫 而弃   n-drop    已矣 者 动词也
    #+end_src
*** 复
    #+begin_src cicada :tangle chinese-core.cicada
    夫 复     dup       已矣 者 动词也
    夫 而复   n-dup     已矣 者 动词也
    #+end_src
*** 跃
    #+begin_src cicada :tangle chinese-core.cicada
    夫 跃       over       已矣 者 动词也
    夫 而跃     x-y-over   已矣 者 动词也
    #+end_src
*** 藏
    #+begin_src cicada :tangle chinese-core.cicada
    夫 藏       tuck       已矣 者 动词也
    夫 而藏     x-y-tuck   已矣 者 动词也
    #+end_src
*** 换
    #+begin_src cicada :tangle chinese-core.cicada
    夫 换       swap       已矣 者 动词也
    夫 而换     x-y-swap   已矣 者 动词也
    #+end_src
** 木答栈
*** 栈之功能
    1. 为函数的复合 来传递参数
    2. 记函数调用结束后 将要返回的位置
    3. 临时的保存某些值
       让这些值必要干扰参数的传递
    4. 这其中的第三个功能
       可以 用为了第一个功能而准备的栈来
       但是 这样不方便
       所以这里给出 Lambda-stack
       来以更直观地方式 实现第三个功能
*** 实现
    #+begin_src cicada :tangle chinese-core.cicada
    (* 入栈时 栈的指针 向低地址移动 *)
    夫 入木答栈
       (* 参数栈:: 值 --> 木答栈:: 值 *)
       单元大小 址 Lambda-stack-pointer 减存
       Lambda-stack-pointer 存
       已矣
    者 动词也

    夫 出木答栈
       (* 木答栈:: 值 --> 参数栈:: 值 *)
       Lambda-stack-pointer 取
       单元大小 址 Lambda-stack-pointer 加存
       已矣
    者 动词也


    夫 准备
       (* 参数栈:: a, b --> 木答栈:: a, b *)
       (* 注意 参数的顺序 *)
       换 入木答栈 入木答栈
       已矣
    者 动词也

    夫 召回
       (* 木答栈:: a, b --> 参数栈:: a, b *)
       (* 注意 参数的顺序 *)
       出木答栈 出木答栈 换
       已矣
    者 动词也
    #+end_src
** 谓词
*** 关于 真 假
    #+begin_src cicada :tangle chinese-core.cicada
    夫 真乎       true?   已矣 者 动词也
    夫 假乎       false?  已矣 者 动词也
    #+end_src
*** 关于 定长整数
    #+begin_src cicada :tangle chinese-core.cicada
    夫 相等       ==       已矣 者 动词也
    夫 不等       =/=      已矣 者 动词也

    夫 小于       <        已矣 者 动词也
    夫 不大于     <=       已矣 者 动词也

    夫 大于       >        已矣 者 动词也
    夫 不小于     >=       已矣 者 动词也

    夫 零乎       zero?    已矣 者 动词也
    夫 一乎       one?     已矣 者 动词也
    #+end_src
** 位运算
   #+begin_src cicada :tangle chinese-core.cicada
   (* 默认 位 指 二进制数的一位 *)
   夫 位与    bitwise-and       已矣 者 动词也
   夫 位或    bitwise-or        已矣 者 动词也
   夫 位异或  bitwise-xor       已矣 者 动词也
   夫 位反    bitwise-invert    已矣 者 动词也
   #+end_src
** 输入 与 输出
   #+begin_src cicada :tangle chinese-core.cicada
   夫 读比特 read-byte  已矣 者 动词也
   夫 写比特 write-byte 已矣 者 动词也
   #+end_src
** 比特串
   #+begin_src cicada :tangle chinese-core.cicada
   夫 比特串相等      equal-string?            已矣 者 动词也
   夫 比特串之首      head-of-string           已矣 者 动词也
   夫 比特串之尾      tail-of-string           已矣 者 动词也
   夫 比特串之尾与首  tail-and-head-of-string  已矣 者 动词也
   ok

   夫 比特串全为空白乎
      (* 比特串[地址, 长度] -- 真 或 假 *)
      复 零乎 则
         2 而弃 真 已矣
      再 比特串之尾与首
      32 (* ASCII-space *)
      <= 则
         比特串全为空白乎 已矣
      再 2 而弃  假 已矣
   者 动词也

   夫 写比特串
      (* 比特串[地址, 长度] -- *)
      复 零乎 则
         2 而弃 已矣
      再
      1 减 换
      复 小取 写比特
      1 加 换
      写比特串
      已矣
   者 动词也

   ok

   夫 换行
      (* -- *)
      10 (* ASCII-space *)
      写比特
      已矣
   者 动词也
   #+end_src
* 比特串->整数,与误
** 记
   1. >< 这里 我偷懒了
      只是简单的映射过来而已
** 比特串代表整数乎
   #+begin_src cicada :tangle chinese-core.cicada
   夫 比特串代表整数乎
      (* 比特串[地址, 长度] -- 真 或 假 *)
      string-denote-integer?
      已矣
   者 动词也
   #+end_src
** 比特串->整数,与误
   #+begin_src cicada :tangle chinese-core.cicada
   夫 比特串->整数,与误
      (* 比特串[地址, 长度] -- 整数, 真 *)
      (* 或 *)
      (* 比特串[地址, 长度] -- 0, 假 *)
      string->integer,with-error
      已矣
   者 动词也
   #+end_src
* 词典 与 词典编撰者
** 记
   1. 词典的编撰
      是由很多的 词典编撰者 分工完成的
      一个 词典的编撰者 在编撰词典的时候
      会用一些 词 来定义 一个新的 词
      并且给这个新的 词 指定一个 诠释者
      这样的描述过程和对诠释者的指定过程
      就是定义一个 新词 的过程
      而当查词典的时候
      这个词的诠释者
      会为查词典的人 来诠释 词典编撰者 对这个词的定义
   2. 这一节重新定义了 中文的词典编撰者
      1) 作为 对系统的测试
      2) 为将来的编译做准备
** 执行
   #+begin_src cicada :tangle chinese-core.cicada
   夫 执行       execute     已矣 者 动词也
   #+end_src
** 记 词之结构
   单位是 "单元大小"
   | 1 | 名字头       |
   | m | 名字         |
   | 1 | 大小         |
   | 1 | 标识         |
   | 1 | 链接         |
   | 1 | 类型         |
   | 1 | 名字头的地址 |
   | 1 | 诠释者       |
   | n | 定义         |
   其中
   | 1 | 类型 |
   ==
   | 位63 | ... | 位1 | 位0 |
   位63 is for HiddenWord
   位0,1,2 are for word type
   0 -- function
   1 -- key word
** 词->词之域
   #+begin_src cicada :tangle chinese-core.cicada
   夫 词->大小
      (* 词的链接[地址] -- 大小 *)
      单元大小 -2 乘 加 取
      已矣
   者 动词也

   夫 词->大小之地址
      (* 词的链接[地址] -- 大小之地址 *)
      单元大小 -2 乘 加
      已矣
   者 动词也

   夫 词->标识
      (* 词的链接[地址] -- 既是值又是地址 *)
      单元大小 -1 乘 加
      已矣
   者 动词也

   夫 词->类型
      (* 词的链接[地址] -- 类型 *)
      单元大小 加 取
      已矣
   者 动词也

   夫 词->类型之地址
      (* 词的链接[地址] -- 类型之地址 *)
      单元大小 加
      已矣
   者 动词也

   夫 词->名字
      (* 词的链接[地址] -- 比特串[地址, 长度] *)
      单元大小 2 乘 加
      取 复
      单元大小 加 (* 地址 *)
      换 取 (* 长度 *)
      已矣
   者 动词也

   夫 词->诠释者
      (* 词的链接[地址] -- 诠释者[地址] *)
      单元大小 3 乘 加
      已矣
   者 动词也

   夫 词->定义
      (* 词的链接[地址] -- 定义[地址] *)
      单元大小 4 乘 加
      已矣
   者 动词也

   ok
   #+end_src
** 查词典
   #+begin_src cicada :tangle chinese-core.cicada
   夫 助,查词典
      (* 词串[地址, 长度], 词之链接[地址] --
         词之链接[地址] 或 0 *)
      复 零乎 则
         3 而弃
         0 已矣
      再
      复 入木答栈
      词->名字  2 2 而跃  比特串相等 则
         2 而弃
         出木答栈
         已矣
      再
      出木答栈 取
      助,查词典
      已矣
   者 动词也
   ok

   夫 查词典
      (* 词串[地址, 长度] --
         词之链接[地址] 或 0 *)
      First-word-in-dictionary
      助,查词典
      已矣
   者 动词也
   ok
   #+end_src
** 比特串代表虚词乎
   #+begin_src cicada :tangle chinese-core.cicada
   夫 比特串代表虚词乎
      (* 比特串[地址, 长度] -- 真 或 假 *)
      查词典
      复 0 == 则 已矣
      再 词->类型
      2#111 位与  1 == 则
        真 已矣
      再 假 已矣
   者 动词也
   #+end_src
** 找词界
   #+begin_src cicada :tangle chinese-core.cicada
   夫 找词界之地址,首
      (* [地址, 长度] -- 地址 或 -1 *)
      复 零乎 则
         2 而复
         -1
         已矣
      再
      比特串之尾与首
      32 (* ASCII space *)
      大于 则
        弃 1 减
        已矣
      再
      找词界之地址,首
      已矣
   者 动词也


   (*
    * 下面的函数 对于 长度为 0 的词串的处理方式 与上面不同
    * 这使得对 尾 之寻找 总会成功
    * 所以 当 使用寻找到的结果 来做副作用时 要小心
    *)

   夫 助,找词界之地址,尾
      (* [地址, 长度] -- 地址 或 -1 *)
      复 零乎 则
         弃
         已矣
      再
      比特串之尾与首
      32 (* ASCII space *)
      <= 则
         弃 1 减
         已矣
      再
      助,找词界之地址,尾
      已矣
   者 动词也

   ok

   夫 找词界之地址,尾
      (* [地址, 长度] -- 地址 或 -1 *)
      (*
       * 对第一个做特殊处理 以保证 不在词内部时 也能有效
       * 所以 要 使用 "助,找词界之地址,尾" 这个帮助函数
       *)
      复 零乎 则
         弃
         已矣
      再
      比特串之尾与首
      32 (* ASCII space *)
      <= 则
         (* 不在词内部时 先进入词的内部 *)
         2 而复  找词界之地址,首
         复 -1 == 则
            3 而弃
            -1
            已矣
         再
         (* [地址, 长度], 首部词界之地址 *)
         (* 利用所找到的地址 计算一个词的内部的地址 *)
         2 1 而藏
         1 2 而换
         减 减
      再
      (*
       * 第一个非 空白的 比特 已经被 弃了
       * 现在 要么 已经在 词之内了
       * 要么 就已经在 尾部词界 了
       *)
      助,找词界之地址,尾
      已矣
   者 动词也

   ok

   (* 索引起始于 0 *)

   夫 找词界之索引,首
      (* [地址, 长度] -- 索引 或 -1 *)
      跃 换
      找词界之地址,首
      复 -1 == 则
         换 弃 (* 把 -1 留下 *)
         已矣
      再
      换 减
      已矣
   者 动词也

   夫 找词界之索引,尾
      (* [地址, 长度] -- 索引 或 -1 *)
      跃 换
      找词界之地址,尾
      复 -1 == 则
         换 弃 (* 把 -1 留下 *)
         已矣
      再
      换 减
      已矣
   者 动词也

   ok
   #+end_src
** 词串之尾与首
   #+begin_src cicada :tangle chinese-core.cicada
   (* 下面的三个函数 不能作用于 全为空白 的 比特串
    * 在使用这些函数之前应该保证参数不是 全为空白 的 比特串
    *)

   夫 词串之首
      (* 词串[地址, 长度] -- 名[地址, 长度] *)
      2 而复  找词界之地址,首
      (* 先不做错误处理 而假设上面的函数能够返回正确的地址 *)
      2 1 而换
      找词界之地址,尾
      跃 减
      已矣
   者 动词也

   夫 词串之尾
      (* 词串[地址, 长度] -- 词串[地址, 长度] *)
      2 而复  找词界之索引,尾
      (* 先不做错误处理 而假设上面的函数能够返回正确的地址 *)
      藏 减
      2 1 而换
      加 换
      已矣
   者 动词也

   ok


   夫 词串之尾与首
      (* 词串[地址, 长度] -- 词串[地址, 长度], 名[地址, 长度] *)
      2 而复
      词串之尾
      2 2 而换
      词串之首
      已矣
   者 动词也

   ok
   #+end_src
** 编撰词之定义于字典
   #+begin_src cicada :tangle chinese-core.cicada
   夫 编撰数于字典
      (* 数 -- *)
      (* 编撰:: 数 *)
      Here 存
      Here 单元大小 加
      址 Here 存
      已矣
   者 动词也

   ok

   (*
    * 注意:
    * 比特串在栈中是: [地址, 长度]
    * 而在内存中是:
    *   | 1 (单元) : 长度 |
    *   | n (比特) : 比特串 |
    *   | 1 (比特) : 0 |
    *)

   夫 编撰比特串于字典
      (* 比特串[地址, 长度] -- *)
      复 入木答栈
         复 编撰数于字典
         Here 换 复制比特串
      (* 更新 Here 全局变量 *)
      出木答栈
      Here 加
      0 跃 小存
      1 加
      址 Here 存
      已矣
   者 动词也

   ok

   夫 助,编撰词之定义于字典,数
      (* 比特串[地址, 长度] -- *)
      (* >< 这里 没有就 string-to-integer,with-error 的返回值
       * 做错误处理 *)
      即 _即 编撰数于字典
      比特串->整数,与误 弃
      编撰数于字典
      已矣
   者 动词也

   夫 助,编撰词之定义于字典,虚词
      (* 词串[地址, 长度], 比特串[地址, 长度] -- 词串[地址, 长度] *)
      (* >< 这里 没有就 "查词典" 的返回值
       * 做错误处理 *)
      查词典 词->诠释者 执行
      已矣
   者 动词也

   夫 助,编撰词之定义于字典,词
      (* 词[地址] -- *)
      词->诠释者 编撰数于字典
      已矣
   者 动词也

   ok


   夫 编撰词之定义于字典
      (* 词串[地址, 长度] -- *)
      2 而复  比特串全为空白乎 则
        2 而弃
        已矣
      再

      词串之尾与首

      (* 下面这句是 找错误的时候用的 *)
      (* 2 而复 写比特串 换行 *)

      2 而复  比特串代表整数乎 则
        助,编撰词之定义于字典,数
        编撰词之定义于字典 已矣
      再

      2 而复  比特串代表虚词乎 则
        助,编撰词之定义于字典,虚词
        编撰词之定义于字典 已矣
      再

      2 而复  查词典
      复 0 == 假乎 则
         2 1 而换  2 而弃
         助,编撰词之定义于字典,词
         编撰词之定义于字典 已矣
      再

      (* 下面的错误处理是不好的 今后将予以改进 *)
      弃
      换行
      夫 未定义的词: 者 写比特串
      写比特串 换行
      夫 余下的词: 者 写比特串 换行
      写比特串 换行
      已矣
   者 动词也

   ok
   #+end_src
** 记 递归函数
   1. 当在函数定义内引用自身的时候
      总会形成递归调用
      如果词典中已经 有要定义的函数了 也不会去找它
      唯一 使得这种特性变得不理想 的情形是:
      你在重新定义一个词的时候 需要调用旧的词本身
      这种情况非常少 并且出现的时候也很容易解决
** 词典编撰者 之 辅助函数
   #+begin_src cicada :tangle chinese-core.cicada
   夫 作词头
      (* 比特串[地址, 长度] -- 词[地址] *)
      Here 入木答栈 (* 为了 名字头的地址 *)
        编撰比特串于字典
        0    编撰数于字典 (* 词之大小 *)
        Here 编撰数于字典 (* 词之标识 *)
        Here (* 留下 词之链接 作为 返回值 *)
        0    编撰数于字典 (* 词之链接 *)
        0    编撰数于字典 (* 词之类型 *)
      出木答栈 编撰数于字典 (* 词之名字头的地址 *)
      已矣
   者 动词也

   夫 添加新词入词典
      (* 词[地址] -- *)
      (* 需要更新 First-word-in-dictionary 使它指向新加入字典的词 *)
      复 First-word-in-dictionary
      换 存 址 First-word-in-dictionary 存
      已矣
   者 动词也

   (*
    * 下面的函数必须 在定义词的函数的末尾被调用
    * 即 在 编撰词之定义于字典 之后
    * 因为 它把 Here 作为一个 隐含的参数
    *)

   夫 设置词之大小
      (* 词[地址] -- *)
      复 词->定义
      Here 换 减
      单元大小 除
      换 词->大小之地址
      存
      已矣
   者 动词也

   ok
   #+end_src
** 动词也
   #+begin_src cicada :tangle chinese-core.cicada
   (* 下面利用 两个同名的函数来互相重新定义对方 *)

   夫 函数也
      (* 词串[地址, 长度] -- *)
      词串之尾与首
      作词头
      复 入木答栈
         添加新词入词典
         动词诠释者 编撰数于字典
         编撰词之定义于字典
      出木答栈
      设置词之大小
      已矣
   者 动词也

   ok


   夫 动词也
      (* 词串[地址, 长度] -- *)
      词串之尾与首
      作词头
      复 入木答栈
         添加新词入词典
         动词诠释者 编撰数于字典
         编撰词之定义于字典
      出木答栈
      设置词之大小
      已矣
   者 函数也

   ok
   #+end_src
** >< 也
** 虚词也
   #+begin_src cicada :tangle chinese-core.cicada
   夫 虚词也
      (* 词串[地址, 长度] -- *)
      词串之尾与首
      作词头
      复 入木答栈
         添加新词入词典
         动词诠释者 编撰数于字典
         编撰词之定义于字典
      出木答栈
      复 设置词之大小
      词->大小之地址
      1 换 小存
      已矣
   者 动词也

   ok
   #+end_src
* --------------------------------------------------
* *测试*
  #+begin_src cicada
  夫 阶乘 (* n -- n! *)
     复 一乎 则
        已矣
     再
     复 1 减 阶乘 乘
     已矣
  者 动词也
  ok

  1 阶乘 .
  2 阶乘 .
  3 阶乘 .
  ok
  #+end_src
* 字
  #+begin_src cicada
  (*
   * 用 UTF-8 编码来处理汉字
   * 当 发现比特串所包含的不是单一的 UTF-8 字时
   * 需要 特殊处理或报错
   * 这里 先不做这些处理 而只取第一个 UTF-8 字
   *)

  (* 字者 于机器而言 即 字之编码 *)
  夫 比特串->字
     (* 比特串[地址, 长度] -- 字之编码 *)
     ><
     已矣
  者 动词也

  ok

  夫 字
     (* 词串[地址, 长度] -- 词串[地址, 长度] *)
     (* 编撰::
          _即[诠释者之地址], 字之编码 *)
     即 _即 编撰数于字典
     词串之尾与首
     比特串->字 编撰数于字典
     已矣
  者 虚词也

  ok
  #+end_src
* ==================================================
