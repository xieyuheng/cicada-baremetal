#+TITLE: 蝉语的汉语核
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 旧笔记
** 笔记
   1. 用抽象的数学来描述那些
      超出我们直观的想像能力的东西
      是非常重要的
      每个个体的人的直观想像能力的局限性
      决定了他对抽象方法的需要
      同时
      我们的想像能力本身却又是可以拓展的
      就像一个潜水者通过长期的练习就能够更熟悉水的性质一样
      对某种语言的学习
      或者对某种新的表达方式的学习
      也能帮我们去熟悉一种新的思考方式
      但是我们应该如何来看待我们所学到的某种新的思考方式呢?
      我们拓展了我们的直观想像?
      还是我们获取了新的抽象技巧?
   2. 为什么有的人把function中的word的find推迟到运行的时候再进行呢?
      要知道 当有lexical-scope的时候 两种方式是没有区别的
      因为这样定义函数就可以不按顺序来了
      而且因为使用hash-table来作查找
      所以对运行速度的影响不大
      并且 否则的话
      当真正想要重新定义一个函数的时候
      就不得不重新编译所有依赖于它的函数
      想要突破这个弱点就要把find推迟
      这在蟬語中也不难实现
   3. 名词的word会将一些值入栈
      而某些形成副作用的动词的word
      1) 其主语是`我'
      2) 宾语是它所接受的参数
      3) 间接宾语是被它的副作用所影响到的世界
   4. in cicada, a ``word'' can not begin with [0-9]
      and can not begin with a `-' follows [0-9]
   5. 在cicada中
      在用户空间所形成的字典中定义的word是可以被覆盖
      但是没法被删除的
      这可以说是所有的类forth语言的特点
   6. 由于cicada的简洁性
      想要对cicada的行为方式形成透彻的理解是非常容易的
      要知道 对一个程序语言的行为方式的理解的偏失是非常可怕的
      形成完整的理解之后
      想要灵活地使用它就很简单
      想要扩展它也很简单
      想要以它为基础(或以它为工具)设计自己的语言也就很简单
   7. ``avoiding syntactic complexity
      results in maximum flexibility''
      在设计语言的时候
      避免去解析复杂的语法
      使用简洁到几乎不用解析的语法
      就获得了使用语言的最大的灵活性
      在cicada或forth中
      是后缀表达式使得我能够几乎完全不用语法分析
      而线性的解读源代码
   8. 诠释者 诠释 字典编撰者 所编撰的东西
      只要换一个``诠释者''一段编译好的程序就可以被解释成一段数据了
   9. 以 lambda-calculus 或 combinatory logic 为基础的语言具有数学上的纯洁性
      而wordy-lisp能够提供实用的应用级别的函数式编程语言
      而digrap能够带来数学上的混乱
   10. 约定:
       1) 变元名或地址名 开头字母用大写 用大写来断词 比如 CellWidth
          像德语中的名词一样
       2) 子程名或宏名 开头字母用小写 用大写来断词 比如 next, explainFunctionBody
          动词
       3) 只有某些地方不得已时,才使用下划线来断词
   11. expression  -- interpret
       description -- explain
   12. 所有的函数都是以栈为参数以栈为返回值的函数
       之后当然就没有高阶函数了 !!!
       但是类似高阶函数的语义可以通过列表这个数据结构外加一个解释器来实现
       也就是说稍微丰富一下数据结构
       然后 我们就在 具有结合性的 最纯粹的 程序语言中
       获得了类似λ-abstraction的语义
   13. joy的所谓的``用combinator来作抽象''
       可以很容易地用lambda-term来实现
       并且这样作的灵活性要强的多
       而不把lmabda-cal暴露给用户的combinator是不灵活的
   14. joy强调要消除λ-ap 因为它不结合
       但是在我看来这是愚蠢的
       因为对我来说λ-ap的语义非常实用而灵活
   15. joy强调要消除λ-ap 因为它不结合
       digrap也能消除λ-ap 但是提供出来的可能是一种``更不结合''的代数
       (并且digrap能够消除所有约束变元)
       但是其实digrap所提供的根本就不是代数
       因为想要谈一个代数的结合性
       那个代数必须是二元的 当然了 代数都是二元的
       但是digrap是三元的
** 十诫
   1. marco里的jmp 必须用匿名标签 要不然就重复了
      这导致在别的代码里不能跨越macro来使用匿名标签
      所以规则是只在marco中使用匿名标签
      在任何其他地方都不要使用匿名标签
      + 尤其是当你使用很多macro的时候尤其要注意这条戒律
   2. 在汇编中用defCode定义函数时 后面要加next
      在汇编中用defWord定义函数时 后面要加Exit (除非是非常特殊的函数才不用加Exit)
      在汇编中使用forth中的变元时 处理的是这个地址:[<var> + CellWidth]
   3. 每个函数的参数个数不应该很多 多于三个的时候就要仔细检查必要性了
   4. 用一个想像中的类型系统来帮助自己编程
      (其实这种类型推到应该被机器完成)
      当branch的时候注意类型的一致
   5. 写一个大函数的时候发现需要把它分解成小函数
      然后你就去写那些小函数
      重要的是每写完一个小函数的时候 如果这个函数的正确性不是显然的
      那么就马上去测试这个小函数的正确性
      因为当回到大函数的时候 就很难发现是那里错误了
      + 其实不难发现是哪里错了
        因为forth系统的线性性
        使得当一段函数的执行出错了的时候
        找到真正出错的那个函数的过程非常容易
   6. 如果要使用计数器
      那么等被计数的那件事干完了之后再增加或减少计数器
      而不要先更改计数器再去做计数器所计数的工作
   7. 每次更改含有branch的函数的时候
      要记得更新branch后面的offset
   8. 当变量保存的是地址的时候
      + 即 变量是一个指针的时候
      在呼唤这个变量的名字而得到这个变量的地址之后
      不要忘记在后面加一个fetch
      这样才能得到这个变量所保存的地址
   9. 任何戒律在需要的时候都可以被打破
      但是你一定要明白为什需要打破这些戒律
      并且在打破旧的戒律的同时
      你要探寻新的规则
      不是要用这些规则限制自己
      而是要在观察中总结自然的规律
      以形成对自然的更好的认识
** *the dictionary*
*** note
    1. 字典的编撰是很多的字典编撰者们(lexicographers)分工协作完成的
       一个字典的编撰者在编撰字典的时候
       会用一些words来描述(description)一个新的word
       并且给这个新的word指定一个诠释者(explainer)
       这样的描述过程和对诠释者的指定过程 就是定义一个新的word的过程
       而当一个查字典的人查到某一个word的时候
       这个word的诠释者会为查字典的人来诠释字典编撰者对这个word的描述
       正式这些描述构成了对这个word的定义
    2. 注意由于汇编语言(fasm)的语法的限制
       有某些word在汇编中的名字 和在forth中的名字不一致
       每一个名字不一致的地方
       都应该在这里被集中地进行警告
       有一下几种情况:
       1) for syntax sugar :
          defWord ":", readWordListForLexicographer
          defCode "x|swap|xx", xswapxx
          (还有其他跟swap有关的)
          defWord ".", printLittleNumber
       2) for already used label-name :
          defConst "ReturnStackTop", ReturnStackTop, TheReturnStackTop
          (还有其他需要暴露给forth系统的label值)
*** word-types & explainers & next & execute
    1. 每一个类型的word都需要一个诠释者
       explainer (or elucidator)
    2. word是有类型的
       这在于有些word可以共用一个诠释者
       但是它们的语义却不同
       比如作为变量的word的诠释者
       和作为数组的word的诠释者可以相同
       但是这确实两种不同类型的word它们的字典编撰者可能不同
       处理它们的函数也可能不同
    3. 所以这里我又要维护一个类型编码表
       加上动态类型的类型编码表
       这个forth中已经有两个这样的表了
*** primitive functions
**** note
     1. 每次在实现一个forth系统的时候
        定义primitive functions的集合的过程
        其实就是挖掘机器的能力的过程
     2. 尽管如此
        如果想用primitive functions的集合来捕捉复杂指令集的CPU的所有指令
        那么所需要的primitive functions也太多了
        所以最好内嵌一个汇编器
     3. 尽管每个机器都有自己的forth系统
        但是还是有方法能够让你来确定那些东西是可移植的那些东西是不可移植的
     4. 定义各种primitive
        因为常常不用考虑嵌套
        所以就不用考虑各个primitive之间的影响
     5. 注意在下面定义的所有primitive中
        就forth系统的编程而言 本质重要的有:
        1) stack processing
           可以发现
           这里实现的基本的对栈出处理都可以被看作二元函数
           因为在forth中
           一些基本的数据结构通常是一个地址和一个描述量
           比如:
           string[address, length]
           wordList[address, number of words]
        2) fixnum
           保持无类型的对fixnum的处理
           而数据结构都在用户级别实现
        3) memory
           现在只有一块静态的定义了就不能收回的空间
           这是为了以此为基础写出一些基本的word来在forth中实现动态内存管理
**** stack processing
     1. forth系统提供了一个有趣的结合代数
        任取一个 有限阶置换群
        都存在 这个有趣的结合代数的子代数 与 所取的有限阶置换群 同构
        下面的某些栈处理函数就是某些低阶的有限置换群中的元素
     2. 当函数的前面有two这种数字前缀的时候
        其行为就像是把函数map到了list上
     3. 而数字后缀却像是函数的参数
**** fixnum
     关于符号数的二进制补码编码:
     1. 二进制补码对符号数的编码的特点是
        fixnum的运算方式不变 但是却能够巧妙地形成负数的语义
     2. 注意: CPU只会做fixnum的运算
        可以把这种运算抽象地看作是bit patterns上的二元变换
        + 即不必在意这种变换是如何实现的
        符号数与超出fixnum限制的数的语义是通过旗子来完成的
     3. 注意: CPU是会做fixnum的减法的
        我以前一直以为它不会
     4. ``取反加一''是(任意一个)fixnum的集合上的方幂为零的变换(双射)
        即这个变换以自身为逆变换
        并且它是[fixnum, +]上面的同构变换
     5. 而要知道[Nature number, +]上的同构变换只有乘法
        而上面的``取反加一''作为乘法就是乘以负一
     6. 但是其实不是的
        因为[fixnum, +]并不是一个代数结构
        但是它已经很接近一个代数结构了
        只有当CUP的overflow旗子被举起来的时候
        这种近似才出现了错误
        + 而利用举起旗子所传达出来的信息我们可以探测到并且更正这种错误
        因此``取反加一''是类[Nature number, +]集合上的同构变换
        这个变换的语义是``乘以负一''
**** bitwise operations
     bitwiseAnd 与 bitwiseOr 都是具有交换性的二元运算
     每次二元运算的两个参数中的任意一个都可以被看作是筛子
     而另一个被看作是要被筛子筛的东西
     1. bitwiseAnd
        被筛的东西是1
        筛子上的1会让1穿过 而0会把1挡住
     2. bitwiseOr
        被筛的东西是0
        筛子上的0会让0穿过 而1会把0挡住
     3. ``mask''技巧正是利用了上面这种有趣的语义
     3. bitwiseInvert 是
        [BitwiseNumbers, bitwiseAnd] 与 [BitwiseNumbers, bitwiseOr]
        之间的同构映射
        x y bitwiseAnd
        ==
        x bitwiseInvert y bitwiseInvert bitwiseOr bitwiseInvert
**** single bit operations
     bitwiseAnd bitwiseOr 等等都是64 bits的
     下面需要定义函数来方便对二进制数的逐bit的操作
     注意 下面的函数 需要对参数 step 和 offset 进行异常处理
     0 <= offset <= 63 (offset is of LSB)
     1 <=  step  <= 64
** 关于self-hosting
   1. 纯粹的解释型语言的 incremental developing
      一定会导致我必须在前面的某些部分中
      用并不完美的方式来解决某些问题(定义某些函数)
      比如:
      ``cons''的定义中想要用到``debuger''
     但是定义``debuger''的时候
     还没有动态分配内存的 string 因为还没有gc
   2. 要想实现真正的self-hosting 就必须形成编译语义
      在我看来 有两种方法来形成编译语义
      1) 在cicada内实现本地码的汇编其器
         可移植性 == 移植的简单性 == 在cicada中写一个汇编器的简单性
         这将非常简单 只差对文件的基本输入输出 我就可以开始写了
         但是其实最好在完成了良好的列表处理语义之后再写
         需要学习的是可执行文件的格式
         + 注意写完一个本地码汇编器之后
           还要用所实现的汇编语言实现一个cicada才算移植的完成
           这里有很大的灵活性
           但是可能每次所需要重写的cicada都非常不同
           >< 只有在充分实践之后才能回答这些问题
      2) 设计一个栈处理机的cpu架构
         此时移植的简单性是最强的
         可移植性 == 移植的简单性 == 在目标平台的语言中写一个bytecode解释器的简单性
         并且可以很容易的嵌入用别的语言写成的程序而形成扩展语言 等等
         但是 虚拟机很难被设计成可扩展的
         尤其是考虑到在嵌入高级语言的同时
         还要作为汇编语言与源语言之间的中间语言
         并且 此时基本上无法真正地针对效率来优化编译器
         我不喜欢这种方式 因为:
         1. 这并不是在展示cicada这个语言本身的能力
            尤其是嵌入其他主流语言的行为 简直是在向主流语言臣服
         2. 有了cicada之后我基本上就不需要其他的语言了
** incremental-gc & <pair> & <string>
*** note
    1. this gc is a incremental-gc
       a marking-gc for pair
       a copy-gc for string
    2. 要知道 既然是PairConstruction所组成的数组
       那么从人类的角度来说
       那个二叉有向图中的点之间就是有一个全序关系的
    3. 以我的方式实现的动态内存管理其实已经不适合被称作垃圾回收了
       它的工作方式是这样的:
       1) 它是有一个工作周期的
          除了第一个工作周期之外
          一个工作周期的开始和结束都是在
          cons把LastPairConstruction这块内存空间分配给程序之后
          + 我把这个地方称为``工作循环点''
       2) 有三个部分在配合工作来完成我所需要让它们完成的任务
          一个marking 一个finding 还有一个cleaning
          其中cleaning的工作是伴随finding而进行的
          而marking会在这个工作周期中标记出那些
          它认为不能在下一个工作周期被finding找到的PairConstructions
          要知道在上面的二叉有向图中
          指定一些根节点
          就赋予了每个节点一个性质: <reachable> 或 <non-reachable>
          reachable当热是就那些被指定的根节点而言的
          而marking所做的就是在这个工作周期中标记出那些它认为<reachable>的点
          然后剩下的点就是<non-reachable>的
          也就是可以被finding找到而被重新利用的
       3) marking其实有点笨
          如果它能精确的标记出所有的<reachable>的点就最好了
          但是其实
          每次它所标记出的不能被下一个工作周期的finding找到的点中
          在包含了所有的<reachable>的点的同时
          也可能会错误地包含了很多<non-reachable>的点
          + 但是只要它能标记出所有的<reachable>的点
            那么它的这点笨拙就不会影响整个工作的正确性
          + 并且被它在这个工作周期中错误地标记了的<non-reachable>的点
            总是有机会在下一个工作周期被marking认为是<non-reachable>的而不去标记
            也就是说marking总是有在下一个工作周期改正自己错误的机会
            所以也许marking没有笨到无可救药的地步
       4) 首先每个PairConstruction中包含三个可以被``染色''的bit
          1. 一个为本次工作周期中的marking
             这是为了下一个工作周期中的finding准备的
          2. 一个为本次工作周期中的finding
             在这个工作周期中finding用完它们之后它们就没用了
             在下一个工作周期就可以把它们交给cleaning来处理了
          3. 一个为本次工作周期中的cleaning
             这是为了下一个工作周期中的marking准备的
       5) 所以在每个工作循环点
          只需要对这三个bits做一个置换就可以了
          所使用的置换显然是三阶置换群中的两个三循环置换之一
       6) marking和finding的工作是相互独立的
          这在于它们读写的color-bit不同
          还在于finding的工作被CurrFreePairConstruction这个全局变量来指示
          + 也就是说finding依赖于上面提到的二叉有向图的节点之间的全序关系
          而marking的工作被GreyPairStack这个栈中的元素和这些元素的个数而指示
    4. marking对一个PairConstruction的标记就在于
       去把这个PairConstruction的为marking所准备的bit染黑(即 把这个bit set为1)
       而GreyPairStack是用来记录marking的工作进度的
       用black,grey,white三种颜色去描述marking的工作方式就很形象
    5. ><><>< 有一个问题
       在每个工作周期循环点
       在初始化GreyPairStack的时候
       ArgumtStack中已经保存的pair并不会被加入GreyPairStack !!!
       ><><>< 我必须引入额外的机制吗 ???
       初始化GreyPairStack的时候 不可能到ArgumtStack中去把所有的pair都找出来
       但是我好像必须要这样做才行
       要注意每次调用cons的时候
       都可能是在一个工作循环点
       因而触发对GreyPairStack的初始化
       但是每次调用cons的时候栈可能已经被递归地非常深了
       + 所有这些困难的产生都在于我没有用一个free-list来记录能被我使用的点
       所以这种寻找可能会非常消耗计算
       并且我所使用的动态类型系统并不足以以严格的方式来判断那些东西是<pair>
       如果重新初始化GreyPairStack的过程中没有考虑到栈中的这些cons那会有什么后果呢?
       这些cons其实是可以被引用到的
       毕竟它们在栈中呢
       但是finding所见的它们却是可以被重新利用的
       还有一个问题就是如果我把栈中的cons初始化入了GreyPairStack中
       那么marking就可能错误标记很多节点了
       因为 毕竟这些在栈中的点都可能只有很短的生存时间而已
       在一个工作周期循环点
       栈中的这些cons应该是在下一个工作周期的finding所不能找到的点
       而不是下一个功能工作周期marking应该标记的点
       所以初始化GreyPairStack的时候不用将这些东西全部都放到GreyPairStack中
       将这些cons的color-bit-for-finding涂黑就行了
       这样就保证了整个工作的正确性
       但是每当垃圾回收的时候还是要扫描整个ArgumtStack !!!
       >< 我先这样来实现我的gc系统吧
    6. 一个工作周期结束之后
       在工作周期循环点
       <reachable-note> 是那些不应该被下一个工作周期的finding找到的点
       而我所设计的gc系统中
       不能被下一个工作周期的finding找到的点有两个来源
       一个是上一个工作周期的marking所标记的黑点
       一个是在工作周期循环点的时候 ArgumtStack中的所有cons
       所以在工作周期循环点
       所需要做的额外工作就是在ArgumtStack中找到所有的cons
       然后把它们为下一个工作周期的finding涂黑
    7. >< gc的这种工作方式是可以接受的吗 ???
       这就需要更多的测试和实际的使用才能知道
       也许是可以的
       因为ArgumtStack的深度应该总是远远小于整个PairConstructionsArray的大小
    8. 上面扫描整个栈的那些计算
       对与forth的垃圾回收器来说可能是不可避免的
       这种不可避免性其实来源于我的垃圾回收器的这样一种性质
       那就是工作循环点的位置是固定的
       在工作循环点有要很多额外的工作要做
       其实在我遵从的垃圾回收器的这中设计方式下的垃圾回收器
       总是要在工作周期的循环点集中地做很多工作的
       而渐进性就在于把这些被集中地做的工作中的某一些分散到别的地方
       我完全分散了marking部分工作
       并且我完全消除了传统的垃圾回收器中的sweep部分的工作
       但是我的设计也可能是失败的
       因为看来我引入了(是我引入的吗??)其他的需要被集中进行的工作
    9. 在栈中的或者是保存在变元中的cons
       永远不会被垃圾回收器回收
    10. ><><>< 也许我应该仔细学习更多的别的gc的设计与实现方式
    11. ><><>< 关于上面的问题
        forth系统中如何使用局部变量 !!!
        关于forth中的局部变量的思考是否能启示我解决上面的问题的更好的方法
    12. 总结一下数据类型:
        <value>是我的forth系统中所有的动态类型的量的集合
        而<atom>是这些动态的量中除了<pair>之外的所有动态类型的量的集合
        #+begin_src bnf
        <value> ::= <pair> | <atom>
        <pair>  ::= <reachable-note>
        <reachable-note>
                ::= 可能是从根节点可以引用到的点
                      比如: (car <variable>)
                    也可能是在栈中的点
                      比如: (cons <value> <value>)
        #+end_src
        上面的(cons <value> <value>)其实就是把一个<pair>返回到栈中
        而这些在栈中的<pair>就被看作是<reachable-note>
    13. 促使marking去标记一个PairConstruction的列表处理操作
        有且只有下面两种(三个)(涉及到set-car!&set-cdr!的时候我只用set-car!作为例子)
        我同时用scheme和cicada这两种语言来描述这些操作
        1) scheme :
           #+begin_src scheme
           (set-car! <pair> <value>)
           #+end_src
           cicada :
           #+begin_src cicada
           <pair>[address, type] <value>[value, type] set-car!
           #+end_src
           + 如果<pair>的color-bit-for-marking是黑色的
             又如果<value>也是<pair>
             那么就尝试去染灰<pair>的color-bit-for-marking
        2) scheme :
           #+begin_src scheme
           (set! <variable> <pair>)
           #+end_src
           cicada :
           #+begin_src cicada
           <variable>[address] <pair>[address, type] set!
           #+end_src
           + 如果<value>是<pair>
             那么就尝试去染灰<pair>的color-bit-for-marking
    14. 申请一个可用的内存空间(一个自由的PairConstruction)
        并且促使finding去寻找下一个可用的内存空间的列表处理操作
        有且只有下面一个
        scheme :
        #+begin_src scheme
        (cons <value> <value>)
        #+end_src
        cicada :
        #+begin_src cicada
        cons <value>[value, type] set-car!
             <value>[value, type] set-cdr!
        #+end_src
        + 在古典的lisp中每当构造子cons像上面这样构造完一个pair之后
          都只有且只有一次机会来引用所构造的pair
          那就是在嵌套的sexp中调用cons的那个位置上
          那个位置上返回的值就是所构造的pair
        + 而在我的cicada中引用那个cons的方式极为灵活
        + 比如 如果我要编译一个类scheme语言到cicada的话
          我就可以又类似下面的语法
          在下面的两个<sexp>中也可以引用到这个cons将要构建好的pair
          #+begin_src scheme
          (cons :set-address-to xxx
                :car <sexp>
                :cdr <sexp>)
          #+end_src
        + >< 但是一个问题是上面的语法用到了局部变量
          不知到局部变量的问题如何在类forth语言中解决 ???
    15. forth是如此灵活以至于我根本没必要实现common-lisp中的那种广义引用
        比如为了实现类似的效果 我复制一下被解构子解构的pair的地址就行了
    16. 在使用scheme的时候我从来没有想像过对数据结构的使用能够像在forth中这样灵活
        但是就目前的实现进度而言与scheme相比我还缺少:
        1) λ-abstraction
        2) 局部变量
        3) 局部变量与λ-abstraction是等价的吗 ???
           我已经知道用λ-abstraction(closure)就可以实现局部变量了
           反过来也行吗 ???
        也许我可以在forth中实现这些东西
        因为我能够单纯地用列表处理来实现整个λ-cal(惰性求值的)
        用列表处理实现λ-cal之后 我只需要实现一个类似apply的函数就行了
        可以说forth的语法是就``函数的复合''而优化的
        而scheme的语法是就``函数的作用''而优化的
        但是两种语义显然是能够互相表示的
        要知道 当把forth中的所有的word都理解为一栈为参数的一元函数的时候
        其实那些单纯地把一个量入栈的函数 也可以被理解为参数
        而后面的函数与这些函数的复合可以被理解为这些函数对参数的作用(当然了,这才是古典的理解)
        也就是说对forth的理解是非常灵活的
        + 对于被当作二元运算的二元函数来说
          只有当这种二元运算满足结合律的时候使用infix才是令人满意的
          + 比如: + * max min gcd `函数的复合' `字符串的并联' 等等
          这正是joy所想要表达的
        + 对二元运算的结合性的证明 可以被转化为对一种特殊的交换性的证明
          #+begin_src
          (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
          或者:
          (p + q) + r  ==  p + (q + r)  <==>
          p q + r +    ==  p q r + +    <==>
          + r +        ==  r + +
          #+end_src
        + 再考虑一下别的运算律 简直有趣极了
          #+begin_src
          分配律(或者说对某种同态变换的描述):
          中缀表达式: (a+b)*c == (a*c)+(b*c)  <==>
          后缀表达式: ab+c* == ac*bc*+  <==>  ???
          但是至少我知道 +(c*) =/= (c*)+
          要想填上上面的问号 可能就需要 λ-abstraction 的抽象性
          否则我根本没法描述某些东西

          交换律:
          a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

          +* =/= *+
          abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
          #+end_src
        + 把后缀表达式考虑为对栈的操作是自然的
          并且这样的理解方式所带来的一个很大的好处就是实在性
          这就又回到了哪个``小孩玩积木''的比喻了
          比如我的十三岁的弟弟可以问我"那个函数的参数是从哪来的?"
          我就告诉他是从栈里拿出来了
          "那个函数的结果去哪了?"
          我就告诉他结果放回到栈里了
          数学 和 编程 就都像一个小孩在玩积木一样
          对了 他还可以问我这个函数是从哪里来的
          我就说是从字典里找来的
    17. forth是最有趣的结合代数
        利用这个结合代数似乎可以模拟任何代数结构(甚至是非结合代数)
        1) 比如上面对函数作用的模拟(尽管函数的作用不是结合的)
        2) 又比如我可以把两个矩阵入栈
           然后一个矩阵乘法函数可以像"*"乘两个数一样为我返回矩阵的积(尽管矩阵乘法不是结合的)
        3) 又比如列表处理可以用来实现digrap
           而digrap已经出离代数的范畴之外了
           但是它还是能够被forth的结合代数所模拟
    18. 如果让我写scheme编译器的话 我会让每个表达式都返回一个值
        正因为如此 在cicada中
        我才把set!,set-clr!,set-car!,set-cdr!等等函数实现为它们现在的这种样子
*** note about <string>
  1. 可以用压缩式的垃圾回收器来实现对字符串的动态内存管理
     因为string的长度可变
     所以简单的marking-gc是不适用的
  2. 在marking工作的时候 如果看见<string>
     就更改引用点 并且复制字符串
     + makeing是知道引用点是哪个的
  3. 如果string的堆比pair的堆先耗尽
     这时就必须重启gc
     所以应该把string的堆设置的充分大 以避免这种情况
  4. 一个问题是
     应该如何在 比如说 定义一个字典中的函数的时候
     在这个定义中使用string-literal还有list-literal
     比如debuger那一节的函数就包含了很多要打印出来的字符串
     如果这些字符串是不被别的地方引用的
     那么用``defineConstString''来定义它们就是不合理的
  5. 要知道被定义到字典中的东西是永远不能被删除的
     因此也就是不需要被垃圾回收的
     所以让这gc去mark这些量是不合理的
     所以就像在汇编中一样
     每个函数中的结构化的literal量 就是这个函数的数据段
     在编译函数的时候应该把这些数据也写到字典里
  6. 所以 string-literal 和 string-processing
     采用了两种不同的方式来使用string
     string-processing 中所使用的string必须是动态分配内存的
     ``readStringInToBuffer'' 这个函数所提供的 string buffer
     是一种能力非常有限的动态分配内存的方式
     而这里的 利用gc来实现的<string> 是一种更好的方式
  7. string[address, length] 之外另一种字符串的表示方式是
     [address, <string>]
     此时address的前面必须保存length
     我用4byte来保存这个length
* --------------------------------------------------
* 蝉语十诫
  1. 后面用到的函数和word要在前面先定义好
     一个 helper-function 一定要定义在被帮助的函数前面
  2. if <body-1> then <body-2> 中
     1) <body-1>后面如果没有跟Exit
        那么<body-1>是一个在特定的条件下被执行的副作用
        那么它就一定不能变更栈的状态 即必须要有 <body-1> (* -- *)
     2) 而当<body-1>后面跟Exit的时候就可以实现真正的分支结构
        Exit是一个标记
        它表明在它前面的函数执行完毕之后就退出对这个函数的调用
        就这个函数而言这是一个全局退出
        也就是说if,then,Exit的组合控制机器运行方式的能力
        比if,else,then要弱
     在使用这种if,then,Exit的组合时
     没有嵌套的if
     必须用帮助函数(子程)来实现类似的效果
  3. 尽管没有对命名空间的管理和保护
     但是那些只被某些特殊函数所使用的变量的名字
     却可以被取得很短
     这是因为在编译的时候
     这些word的地址被找(find函数)好了
     + 这样就实现了与closure所实现的lexical-scope类似的效果
  4. 注意所有数据结构的实现方式
     因为可能有多种方式(比如:多个地址) 都能代表同一个数据结构
     而对这些不同的表示方式 又有不同的处理函数
     现在系统中的主要数据结构只有两个:
     1) Word in Directory
        表示方式有:
        word[address of link]
        word[address of explainer]
     2) PairConstruction in PairConstructionsArray
        表示方式有:
        <pair>[address, type]
        pair[address]
     这种同一个数据结构的多种表示方式
     也许应该被看成是非常不好的编程风格
     但是至少在上面这两个例子当中
     这种风格的使用是自然的
     + 并且我想这种风格在很多其他地方的使用也是自然的
       因此要注意这一条戒律
  5. 写一个大函数的时候发现需要把它分解成小函数
     然后你就去写那些小函数
     重要的是每写完一个小函数的时候 如果这个函数的正确性不是显然的
     那么就马上去测试这个小函数的正确性
     因为当回到大函数的时候 就很难发现是那里错误了
     + 其实不难发现是哪里错了
       因为forth系统的线性性
       使得当一段函数的执行出错了的时候
       找到真正出错的那个函数的过程非常容易
     + 给函数加上类型声明
       然后给某些字典编撰者加上对类型的静态分析
       就很容易避免很多错误
     上面这个是非常重要的一诫
     我的感受是
     在没有类型系统的条件下
     当运行的时候出现了一个错误
     通常在十分钟之内就能找到引起错误的函数
     然后发现一个可笑的bug我自己都笑了
     这一诫的有趣之处在于我几乎不可能去遵守这条戒律
     在写下一个函数的时候
     我总是想单纯地通过看着这个函数就相信这个函数是正确的
     要想忽视这条戒律
     那么你就必须找出很好的设计函数接口的方式
     并且找出(发明出)一组极好的用来描述你想要解决的问题的words
     也许忽视这条戒律 并且 摒弃类型推导系统
     就能鞭策你设计出更优雅而简洁的程序呢 !!!
  6. 在cicada中使用cons的方式和在scheme中很不同
     因为在scheme中一个表达式的返回值会直接被打印出来
     而在cicada中一个表达式的返回值会被放到ArgumtStack中
     因为被放到栈中的cons还可能被引用到 所以不能够被垃圾回收
     这就引出了forth编程中非常重要的一条戒律
     那就是要管理好自己的栈
     在一次计算之后 栈中所保存的应该只是我所需要的返回值
* ==================================================
* 将英文字典中的基本词翻译成中文
** 名词
*** 重要的名词
    #+begin_src cicada :tangle chinese-core.cicada
    (* Here 这个名词 还是必须使用英文版本的 *)
    夫 单元 Cell-width 者 也
    #+end_src
*** 真 假
    #+begin_src cicada :tangle chinese-core.cicada
    夫 假 False 者 也
    夫 真 True  者 也
    #+end_src
** 动词
*** 定长整数
    #+begin_src cicada :tangle chinese-core.cicada
    夫 加       add      已矣 者 动词也
    夫 减       sub      已矣 者 动词也
    夫 乘       mul      已矣 者 动词也
    夫 除       div      已矣 者 动词也
    夫 模       mod      已矣 者 动词也
    夫 除模     divmod   已矣 者 动词也
    夫 模除     moddiv   已矣 者 动词也
    夫 负       negate   已矣 者 动词也
    夫 幂       power    已矣 者 动词也
    #+end_src
*** 存储空间
    #+begin_src cicada :tangle chinese-core.cicada
    (* 一般的 存取 所作用于 的是 一单元 大小 的存储空间
     ,* 小的 存取 所作用于 的是 一字节 大小 的存储空间
     ,*)

    (* 多个值 而 存取 的作用 如下
     ,*   在存储空间中 :
     ,*     ||  1 : 值-1  ||
     ,*     ||  1 : 值-2  ||
     ,*     ||  1 : 值-3  ||
     ,*     ...
     ,*   在栈中 :
     ,*     (* 值-1, 值-2, 值-3, ... *)
     ,* 即 从上到下 对应 从左到右
     ,* 这样就和 名词 的结构保持了一致
     ,* 此时 取 很简单 但是 存 需要特殊处理
     ,*)

    夫 存         save              已矣 者 动词也
    夫 小存       save-byte         已矣 者 动词也
    夫 而存       n-save            已矣 者 动词也
    夫 而小存     n-save-byte       已矣 者 动词也


    夫 取         fetch             已矣 者 动词也
    夫 小取       fetch-byte        已矣 者 动词也
    夫 而取       n-fetch           已矣 者 动词也
    夫 而小取     n-fetch-byte      已矣 者 动词也


    夫 加存       add-save          已矣 者 动词也
    夫 减存       sub-save          已矣 者 动词也

    夫 复制字节串 copy-byte-string  已矣 者 动词也
    #+end_src
*** 测试
    #+begin_src cicada
    夫 k 1 2 3 者 也 
    ok
    k . . . ok (* 3 2 1 *)
    7 8 9 address k 3 而存
    k . . . (* 7 8 9 *)
    ok
    address k 3 而取  . . . (* 7 8 9 *) ok
    #+end_src
*** >< Argument-stack
**** >< pointer
**** 弃 复
     #+begin_src cicada :tangle chinese-core.cicada
     夫 弃     drop      已矣 者 动词也
     夫 而弃   n-drop    已矣 者 动词也
                          
     夫 复     dup       已矣 者 动词也
     夫 而复   n-dup     已矣 者 动词也
     #+end_src
**** 跃
     #+begin_src cicada :tangle chinese-core.cicada
     夫 跃       over       已矣 者 动词也
     (* 夫 而跃     x_y_over       已矣 者 动词也 *)
     #+end_src     
**** 藏
     #+begin_src cicada :tangle chinese-core.cicada
     夫 藏       tuck       已矣 者 动词也
     (* 夫 而藏     x_y_tuck       已矣 者 动词也 *)
     #+end_src
**** 换
     #+begin_src cicada :tangle chinese-core.cicada
     夫 换       swap       已矣 者 动词也
     (* 夫 而换     x_y_swap       已矣 者 动词也 *)
     #+end_src
*** Return-stack
*** 
*** 谓词
**** 关于 真 假
     #+begin_src cicada :tangle chinese-core.cicada
     夫 真乎       true?   已矣 者 动词也
     夫 假乎       false?  已矣 者 动词也
     #+end_src
**** 关于 定长整数
     #+begin_src cicada :tangle chinese-core.cicada
     夫 相等       ==       已矣 者 动词也
     夫 不等       =/=      已矣 者 动词也
                            
     夫 小于       <        已矣 者 动词也
     夫 不大于     <=       已矣 者 动词也
                            
     夫 大于       >        已矣 者 动词也
     夫 不小于     >=       已矣 者 动词也

     夫 零乎       zero?    已矣 者 动词也
     夫 一乎       one?     已矣 者 动词也
     #+end_src
*** 
** ok
   #+begin_src cicada :tangle chinese-core.cicada
   ok
   #+end_src
* ==================================================
* 字典编撰者
** ok
   #+begin_src cicada :tangle chinese-core.cicada
   ok
   #+end_src
* *测试*
  #+begin_src cicada
  夫 阶乘 (* n -- n! *)
     复 一乎 则
        已矣
     再
     复 1 减 阶乘 乘
     已矣
  者 动词也
ok
  1 阶乘 .
  2 阶乘 .
  3 阶乘 .
ok
  #+end_src
* ==================================================
