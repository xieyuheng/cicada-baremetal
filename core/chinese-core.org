#+TITLE: 蝉语的汉语核
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 旧笔记
** 十诫
   1. 每个函数的参数个数不应该很多 多于三个的时候就要仔细检查必要性了
   2. 用一个想像中的类型系统来帮助自己编程
      (其实这种类型推到应该被机器完成)
      当branch的时候注意类型的一致
   3. 写一个大函数的时候发现需要把它分解成小函数
      然后你就去写那些小函数
      重要的是每写完一个小函数的时候 如果这个函数的正确性不是显然的
      那么就马上去测试这个小函数的正确性
      因为当回到大函数的时候 就很难发现是那里错误了
      + 其实不难发现是哪里错了
        因为forth系统的线性性
        使得当一段函数的执行出错了的时候
        找到真正出错的那个函数的过程非常容易
   4. 如果要使用计数器
      那么等被计数的那件事干完了之后再增加或减少计数器
      而不要先更改计数器再去做计数器所计数的工作
   5. 每次更改含有branch的函数的时候
      要记得更新branch后面的offset
   6. 当变量保存的是地址的时候
      + 即 变量是一个指针的时候
      在呼唤这个变量的名字而得到这个变量的地址之后
      不要忘记在后面加一个fetch
      这样才能得到这个变量所保存的地址
   7. 任何戒律在需要的时候都可以被打破
      但是你一定要明白为什需要打破这些戒律
      并且在打破旧的戒律的同时
      你要探寻新的规则
      不是要用这些规则限制自己
      而是要在观察中总结自然的规律
      以形成对自然的更好的认识      
** incremental-gc & <pair> & <string>
*** note
    1. this gc is a incremental-gc
       a marking-gc for pair
       a copy-gc for string
    2. 要知道 既然是PairConstruction所组成的数组
       那么从人类的角度来说
       那个二叉有向图中的点之间就是有一个全序关系的
    3. 以我的方式实现的动态内存管理其实已经不适合被称作垃圾回收了
       它的工作方式是这样的:
       1) 它是有一个工作周期的
          除了第一个工作周期之外
          一个工作周期的开始和结束都是在
          cons把LastPairConstruction这块内存空间分配给程序之后
          + 我把这个地方称为``工作循环点''
       2) 有三个部分在配合工作来完成我所需要让它们完成的任务
          一个marking 一个finding 还有一个cleaning
          其中cleaning的工作是伴随finding而进行的
          而marking会在这个工作周期中标记出那些
          它认为不能在下一个工作周期被finding找到的PairConstructions
          要知道在上面的二叉有向图中
          指定一些根节点
          就赋予了每个节点一个性质: <reachable> 或 <non-reachable>
          reachable当热是就那些被指定的根节点而言的
          而marking所做的就是在这个工作周期中标记出那些它认为<reachable>的点
          然后剩下的点就是<non-reachable>的
          也就是可以被finding找到而被重新利用的
       3) marking其实有点笨
          如果它能精确的标记出所有的<reachable>的点就最好了
          但是其实
          每次它所标记出的不能被下一个工作周期的finding找到的点中
          在包含了所有的<reachable>的点的同时
          也可能会错误地包含了很多<non-reachable>的点
          + 但是只要它能标记出所有的<reachable>的点
            那么它的这点笨拙就不会影响整个工作的正确性
          + 并且被它在这个工作周期中错误地标记了的<non-reachable>的点
            总是有机会在下一个工作周期被marking认为是<non-reachable>的而不去标记
            也就是说marking总是有在下一个工作周期改正自己错误的机会
            所以也许marking没有笨到无可救药的地步
       4) 首先每个PairConstruction中包含三个可以被``染色''的bit
          1. 一个为本次工作周期中的marking
             这是为了下一个工作周期中的finding准备的
          2. 一个为本次工作周期中的finding
             在这个工作周期中finding用完它们之后它们就没用了
             在下一个工作周期就可以把它们交给cleaning来处理了
          3. 一个为本次工作周期中的cleaning
             这是为了下一个工作周期中的marking准备的
       5) 所以在每个工作循环点
          只需要对这三个bits做一个置换就可以了
          所使用的置换显然是三阶置换群中的两个三循环置换之一
       6) marking和finding的工作是相互独立的
          这在于它们读写的color-bit不同
          还在于finding的工作被CurrFreePairConstruction这个全局变量来指示
          + 也就是说finding依赖于上面提到的二叉有向图的节点之间的全序关系
          而marking的工作被GreyPairStack这个栈中的元素和这些元素的个数而指示
    4. marking对一个PairConstruction的标记就在于
       去把这个PairConstruction的为marking所准备的bit染黑(即 把这个bit set为1)
       而GreyPairStack是用来记录marking的工作进度的
       用black,grey,white三种颜色去描述marking的工作方式就很形象
    5. ><><>< 有一个问题
       在每个工作周期循环点
       在初始化GreyPairStack的时候
       ArgumtStack中已经保存的pair并不会被加入GreyPairStack !!!
       ><><>< 我必须引入额外的机制吗 ???
       初始化GreyPairStack的时候 不可能到ArgumtStack中去把所有的pair都找出来
       但是我好像必须要这样做才行
       要注意每次调用cons的时候
       都可能是在一个工作循环点
       因而触发对GreyPairStack的初始化
       但是每次调用cons的时候栈可能已经被递归地非常深了
       + 所有这些困难的产生都在于我没有用一个free-list来记录能被我使用的点
       所以这种寻找可能会非常消耗计算
       并且我所使用的动态类型系统并不足以以严格的方式来判断那些东西是<pair>
       如果重新初始化GreyPairStack的过程中没有考虑到栈中的这些cons那会有什么后果呢?
       这些cons其实是可以被引用到的
       毕竟它们在栈中呢
       但是finding所见的它们却是可以被重新利用的
       还有一个问题就是如果我把栈中的cons初始化入了GreyPairStack中
       那么marking就可能错误标记很多节点了
       因为 毕竟这些在栈中的点都可能只有很短的生存时间而已
       在一个工作周期循环点
       栈中的这些cons应该是在下一个工作周期的finding所不能找到的点
       而不是下一个功能工作周期marking应该标记的点
       所以初始化GreyPairStack的时候不用将这些东西全部都放到GreyPairStack中
       将这些cons的color-bit-for-finding涂黑就行了
       这样就保证了整个工作的正确性
       但是每当垃圾回收的时候还是要扫描整个ArgumtStack !!!
       >< 我先这样来实现我的gc系统吧
    6. 一个工作周期结束之后
       在工作周期循环点
       <reachable-note> 是那些不应该被下一个工作周期的finding找到的点
       而我所设计的gc系统中
       不能被下一个工作周期的finding找到的点有两个来源
       一个是上一个工作周期的marking所标记的黑点
       一个是在工作周期循环点的时候 ArgumtStack中的所有cons
       所以在工作周期循环点
       所需要做的额外工作就是在ArgumtStack中找到所有的cons
       然后把它们为下一个工作周期的finding涂黑
    7. >< gc的这种工作方式是可以接受的吗 ???
       这就需要更多的测试和实际的使用才能知道
       也许是可以的
       因为ArgumtStack的深度应该总是远远小于整个PairConstructionsArray的大小
    8. 上面扫描整个栈的那些计算
       对与forth的垃圾回收器来说可能是不可避免的
       这种不可避免性其实来源于我的垃圾回收器的这样一种性质
       那就是工作循环点的位置是固定的
       在工作循环点有要很多额外的工作要做
       其实在我遵从的垃圾回收器的这中设计方式下的垃圾回收器
       总是要在工作周期的循环点集中地做很多工作的
       而渐进性就在于把这些被集中地做的工作中的某一些分散到别的地方
       我完全分散了marking部分工作
       并且我完全消除了传统的垃圾回收器中的sweep部分的工作
       但是我的设计也可能是失败的
       因为看来我引入了(是我引入的吗??)其他的需要被集中进行的工作
    9. 在栈中的或者是保存在变元中的cons
       永远不会被垃圾回收器回收
    10. ><><>< 也许我应该仔细学习更多的别的gc的设计与实现方式
    11. ><><>< 关于上面的问题
        forth系统中如何使用局部变量 !!!
        关于forth中的局部变量的思考是否能启示我解决上面的问题的更好的方法
    12. 总结一下数据类型:
        <value>是我的forth系统中所有的动态类型的量的集合
        而<atom>是这些动态的量中除了<pair>之外的所有动态类型的量的集合
        #+begin_src bnf
        <value> ::= <pair> | <atom>
        <pair>  ::= <reachable-note>
        <reachable-note>
                ::= 可能是从根节点可以引用到的点
                      比如: (car <variable>)
                    也可能是在栈中的点
                      比如: (cons <value> <value>)
        #+end_src
        上面的(cons <value> <value>)其实就是把一个<pair>返回到栈中
        而这些在栈中的<pair>就被看作是<reachable-note>
    13. 促使marking去标记一个PairConstruction的列表处理操作
        有且只有下面两种(三个)(涉及到set-car!&set-cdr!的时候我只用set-car!作为例子)
        我同时用scheme和cicada这两种语言来描述这些操作
        1) scheme :
           #+begin_src scheme
           (set-car! <pair> <value>)
           #+end_src
           cicada :
           #+begin_src cicada
           <pair>[address, type] <value>[value, type] set-car!
           #+end_src
           + 如果<pair>的color-bit-for-marking是黑色的
             又如果<value>也是<pair>
             那么就尝试去染灰<pair>的color-bit-for-marking
        2) scheme :
           #+begin_src scheme
           (set! <variable> <pair>)
           #+end_src
           cicada :
           #+begin_src cicada
           <variable>[address] <pair>[address, type] set!
           #+end_src
           + 如果<value>是<pair>
             那么就尝试去染灰<pair>的color-bit-for-marking
    14. 申请一个可用的内存空间(一个自由的PairConstruction)
        并且促使finding去寻找下一个可用的内存空间的列表处理操作
        有且只有下面一个
        scheme :
        #+begin_src scheme
        (cons <value> <value>)
        #+end_src
        cicada :
        #+begin_src cicada
        cons <value>[value, type] set-car!
             <value>[value, type] set-cdr!
        #+end_src
        + 在古典的lisp中每当构造子cons像上面这样构造完一个pair之后
          都只有且只有一次机会来引用所构造的pair
          那就是在嵌套的sexp中调用cons的那个位置上
          那个位置上返回的值就是所构造的pair
        + 而在我的cicada中引用那个cons的方式极为灵活
        + 比如 如果我要编译一个类scheme语言到cicada的话
          我就可以又类似下面的语法
          在下面的两个<sexp>中也可以引用到这个cons将要构建好的pair
          #+begin_src scheme
          (cons :set-address-to xxx
                :car <sexp>
                :cdr <sexp>)
          #+end_src
        + >< 但是一个问题是上面的语法用到了局部变量
          不知到局部变量的问题如何在类forth语言中解决 ???
    15. forth是如此灵活以至于我根本没必要实现common-lisp中的那种广义引用
        比如为了实现类似的效果 我复制一下被解构子解构的pair的地址就行了
    16. 在使用scheme的时候我从来没有想像过对数据结构的使用能够像在forth中这样灵活
        但是就目前的实现进度而言与scheme相比我还缺少:
        1) λ-abstraction
        2) 局部变量
        3) 局部变量与λ-abstraction是等价的吗 ???
           我已经知道用λ-abstraction(closure)就可以实现局部变量了
           反过来也行吗 ???
        也许我可以在forth中实现这些东西
        因为我能够单纯地用列表处理来实现整个λ-cal(惰性求值的)
        用列表处理实现λ-cal之后 我只需要实现一个类似apply的函数就行了
        可以说forth的语法是就``函数的复合''而优化的
        而scheme的语法是就``函数的作用''而优化的
        但是两种语义显然是能够互相表示的
        要知道 当把forth中的所有的word都理解为一栈为参数的一元函数的时候
        其实那些单纯地把一个量入栈的函数 也可以被理解为参数
        而后面的函数与这些函数的复合可以被理解为这些函数对参数的作用(当然了,这才是古典的理解)
        也就是说对forth的理解是非常灵活的
        + 对于被当作二元运算的二元函数来说
          只有当这种二元运算满足结合律的时候使用infix才是令人满意的
          + 比如: + * max min gcd `函数的复合' `字符串的并联' 等等
          这正是joy所想要表达的
        + 对二元运算的结合性的证明 可以被转化为对一种特殊的交换性的证明
          #+begin_src
          (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
          或者:
          (p + q) + r  ==  p + (q + r)  <==>
          p q + r +    ==  p q r + +    <==>
          + r +        ==  r + +
          #+end_src
        + 再考虑一下别的运算律 简直有趣极了
          #+begin_src
          分配律(或者说对某种同态变换的描述):
          中缀表达式: (a+b)*c == (a*c)+(b*c)  <==>
          后缀表达式: ab+c* == ac*bc*+  <==>  ???
          但是至少我知道 +(c*) =/= (c*)+
          要想填上上面的问号 可能就需要 λ-abstraction 的抽象性
          否则我根本没法描述某些东西

          交换律:
          a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

          +* =/= *+
          abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
          #+end_src
        + 把后缀表达式考虑为对栈的操作是自然的
          并且这样的理解方式所带来的一个很大的好处就是实在性
          这就又回到了哪个``小孩玩积木''的比喻了
          比如我的十三岁的弟弟可以问我"那个函数的参数是从哪来的?"
          我就告诉他是从栈里拿出来了
          "那个函数的结果去哪了?"
          我就告诉他结果放回到栈里了
          数学 和 编程 就都像一个小孩在玩积木一样
          对了 他还可以问我这个函数是从哪里来的
          我就说是从词典里找来的
    17. forth是最有趣的结合代数
        利用这个结合代数似乎可以模拟任何代数结构(甚至是非结合代数)
        1) 比如上面对函数作用的模拟(尽管函数的作用不是结合的)
        2) 又比如我可以把两个矩阵入栈
           然后一个矩阵乘法函数可以像"*"乘两个数一样为我返回矩阵的积(尽管矩阵乘法不是结合的)
        3) 又比如列表处理可以用来实现digrap
           而digrap已经出离代数的范畴之外了
           但是它还是能够被forth的结合代数所模拟
    18. 如果让我写scheme编译器的话 我会让每个表达式都返回一个值
        正因为如此 在cicada中
        我才把set!,set-clr!,set-car!,set-cdr!等等函数实现为它们现在的这种样子
*** note about <string>
    1. 可以用压缩式的垃圾回收器来实现对字符串的动态内存管理
       因为string的长度可变
       所以简单的marking-gc是不适用的
    2. 在marking工作的时候 如果看见<string>
       就更改引用点 并且复制字符串
       + makeing是知道引用点是哪个的
    3. 如果string的堆比pair的堆先耗尽
       这时就必须重启gc
       所以应该把string的堆设置的充分大 以避免这种情况
    4. 一个问题是
       应该如何在 比如说 定义一个词典中的函数的时候
       在这个定义中使用string-literal还有list-literal
       比如debuger那一节的函数就包含了很多要打印出来的字符串
       如果这些字符串是不被别的地方引用的
       那么用``defineConstString''来定义它们就是不合理的
    5. 要知道被定义到词典中的东西是永远不能被删除的
       因此也就是不需要被垃圾回收的
       所以让这gc去mark这些量是不合理的
       所以就像在汇编中一样
       每个函数中的结构化的literal量 就是这个函数的数据段
       在编译函数的时候应该把这些数据也写到词典里
    6. 所以 string-literal 和 string-processing
       采用了两种不同的方式来使用string
       string-processing 中所使用的string必须是动态分配内存的
       ``readStringInToBuffer'' 这个函数所提供的 string buffer
       是一种能力非常有限的动态分配内存的方式
       而这里的 利用gc来实现的<string> 是一种更好的方式
    7. string[address, length] 之外另一种字符串的表示方式是
       [address, <string>]
       此时address的前面必须保存length
       我用4byte来保存这个length
** 旧蝉语十诫
   1. 后面用到的函数和word要在前面先定义好
      一个 helper-function 一定要定义在被帮助的函数前面
   2. if <body-1> then <body-2> 中
      1) <body-1>后面如果没有跟Exit
         那么<body-1>是一个在特定的条件下被执行的副作用
         那么它就一定不能变更栈的状态 即必须要有 <body-1> (* -- *)
      2) 而当<body-1>后面跟Exit的时候就可以实现真正的分支结构
         Exit是一个标记
         它表明在它前面的函数执行完毕之后就退出对这个函数的调用
         就这个函数而言这是一个全局退出
         也就是说if,then,Exit的组合控制机器运行方式的能力
         比if,else,then要弱
      在使用这种if,then,Exit的组合时
      没有嵌套的if
      必须用帮助函数(子程)来实现类似的效果
   3. 尽管没有对命名空间的管理和保护
      但是那些只被某些特殊函数所使用的变量的名字
      却可以被取得很短
      这是因为在编译的时候
      这些word的地址被找(find函数)好了
      + 这样就实现了与closure所实现的lexical-scope类似的效果
   4. 注意所有数据结构的实现方式
      因为可能有多种方式(比如:多个地址) 都能代表同一个数据结构
      而对这些不同的表示方式 又有不同的处理函数
      现在系统中的主要数据结构只有两个:
      1) Word in Directory
         表示方式有:
         word[address of link]
         word[address of explainer]
      2) PairConstruction in PairConstructionsArray
         表示方式有:
         <pair>[address, type]
         pair[address]
      这种同一个数据结构的多种表示方式
      也许应该被看成是非常不好的编程风格
      但是至少在上面这两个例子当中
      这种风格的使用是自然的
      + 并且我想这种风格在很多其他地方的使用也是自然的
        因此要注意这一条戒律
   5. 写一个大函数的时候发现需要把它分解成小函数
      然后你就去写那些小函数
      重要的是每写完一个小函数的时候 如果这个函数的正确性不是显然的
      那么就马上去测试这个小函数的正确性
      因为当回到大函数的时候 就很难发现是那里错误了
      + 其实不难发现是哪里错了
        因为forth系统的线性性
        使得当一段函数的执行出错了的时候
        找到真正出错的那个函数的过程非常容易
      + 给函数加上类型声明
        然后给某些词典编撰者加上对类型的静态分析
        就很容易避免很多错误
      上面这个是非常重要的一诫
      我的感受是
      在没有类型系统的条件下
      当运行的时候出现了一个错误
      通常在十分钟之内就能找到引起错误的函数
      然后发现一个可笑的bug我自己都笑了
      这一诫的有趣之处在于我几乎不可能去遵守这条戒律
      在写下一个函数的时候
      我总是想单纯地通过看着这个函数就相信这个函数是正确的
      要想忽视这条戒律
      那么你就必须找出很好的设计函数接口的方式
      并且找出(发明出)一组极好的用来描述你想要解决的问题的words
      也许忽视这条戒律 并且 摒弃类型推导系统
      就能鞭策你设计出更优雅而简洁的程序呢 !!!
   6. 在cicada中使用cons的方式和在scheme中很不同
      因为在scheme中一个表达式的返回值会直接被打印出来
      而在cicada中一个表达式的返回值会被放到ArgumtStack中
      因为被放到栈中的cons还可能被引用到 所以不能够被垃圾回收
      这就引出了forth编程中非常重要的一条戒律
      那就是要管理好自己的栈
      在一次计算之后 栈中所保存的应该只是我所需要的返回值
* ==================================================
* 记
  1. 这一小节中
     直接从英文翻译而来的
     都是一些 需要定义在汇编中的基本词汇
     需要的时候很容易把它们重新定义到汇编中
  2. 有些 重要的全局变量 不能有两个版本
     因此 保持这些 英文的 名词
     这是可以接受的
     毕竟 我不是一个想要把所有东西都汉化的
     狭隘的 民族主义者
     这种词包括 :
     1) Here
     2) First-word-in-dictionary
* 名词
** 重要的名词
   #+begin_src cicada :tangle chinese-core.cicada
   (* Here 这个名词 还是必须使用英文版本的 *)
   夫 单元大小 Cell-width 者 也
   #+end_src
** 真 假
   #+begin_src cicada :tangle chinese-core.cicada
   夫 假 False 者 也
   夫 真 True  者 也
   #+end_src
* 动词
** 定长整数
*** 记
    1. "取反加一"
       是fixnum的集合上的方幂为零的变换      
       这个变换以自身为逆变换 因而是 双射
       并且它是[fixnum, +]上面的同构变换
    2. 而要知道[Nature number, +]上的同构变换只有乘法
       而上面的 "取反加一" 作为乘法就是乘以负一
    3. 但是其实不是的
       因为[fixnum, +]并不是一个代数结构
       但是它已经很接近一个代数结构了
       只有当CUP的overflow旗子被举起来的时候
       这种近似才出现了错误
       + 而利用举起旗子所传达出来的信息我们可以探测到并且更正这种错误
       因此 "取反加一" 是 类[Nature number, +]集合上的同构变换
       这个变换的语义是 "乘以负一"
*** 实现
    #+begin_src cicada :tangle chinese-core.cicada
    夫 加       add      已矣 者 动词也
    夫 减       sub      已矣 者 动词也
    夫 乘       mul      已矣 者 动词也
    夫 除       div      已矣 者 动词也
    夫 模       mod      已矣 者 动词也
    夫 除模     divmod   已矣 者 动词也
    夫 模除     moddiv   已矣 者 动词也
    夫 负       negate   已矣 者 动词也
    夫 幂       power    已矣 者 动词也
    #+end_src
** 存储空间
   #+begin_src cicada :tangle chinese-core.cicada
   (* 一般的 存取 所作用于 的是 一单元 大小 的存储空间
    ,* 小的 存取 所作用于 的是 一字节 大小 的存储空间
    ,*)

   (* 多个值 而 存取 的作用 如下
    ,*   在存储空间中 :
    ,*     ||  1 : 值-1  ||
    ,*     ||  1 : 值-2  ||
    ,*     ||  1 : 值-3  ||
    ,*     ...
    ,*   在栈中 :
    ,*     (* 值-1, 值-2, 值-3, ... *)
    ,* 即 从上到下 对应 从左到右
    ,* 这样就和 名词 的结构保持了一致
    ,* 此时 取 很简单 但是 存 需要特殊处理
    ,*)

   夫 存         save              已矣 者 动词也
   夫 小存       save-byte         已矣 者 动词也
   夫 而存       n-save            已矣 者 动词也
   夫 而小存     n-save-byte       已矣 者 动词也


   夫 取         fetch             已矣 者 动词也
   夫 小取       fetch-byte        已矣 者 动词也
   夫 而取       n-fetch           已矣 者 动词也
   夫 而小取     n-fetch-byte      已矣 者 动词也


   夫 加存       add-save          已矣 者 动词也
   夫 减存       sub-save          已矣 者 动词也

   夫 复制字节串 copy-byte-string  已矣 者 动词也
   #+end_src
** 测试
   #+begin_src cicada
   夫 k 1 2 3 者 也

   ok

   k . . . (* 3 2 1 *) cr ok
   7 8 9 址 k 3 而存

   k . . . (* 7 8 9 *) cr ok

   址 k 3 而取  . . . (* 7 8 9 *) cr ok
   #+end_src
** 参数栈
*** 指针
    #+begin_src cicada :tangle chinese-core.cicada
    夫 做自引用值于参数栈
       make-self-reference-value,in-argument-stack
       已矣
    者 动词也

    夫 取参数栈指针
       fetch-argument-stack-pointer
       已矣
    者 动词也

    夫 重置参数栈指针
       reset-argument-stack-pointer
       已矣
    者 动词也
    #+end_src
*** 记
    1. 这其实是 一个有趣的结合代数
       任取一个 有限阶置换群
       都存在 这个有趣的结合代数的子代数 与 所取的有限阶置换群 同构
       下面的某些栈处理函数就是某些低阶的有限置换群中的元素
*** 弃
    #+begin_src cicada :tangle chinese-core.cicada
    夫 弃     drop      已矣 者 动词也
    夫 而弃   n-drop    已矣 者 动词也
    #+end_src
*** 复
    #+begin_src cicada :tangle chinese-core.cicada
    夫 复     dup       已矣 者 动词也
    夫 而复   n-dup     已矣 者 动词也
    #+end_src
*** 跃
    #+begin_src cicada :tangle chinese-core.cicada
    夫 跃       over       已矣 者 动词也
    夫 而跃     x-y-over   已矣 者 动词也
    #+end_src
*** 藏
    #+begin_src cicada :tangle chinese-core.cicada
    夫 藏       tuck       已矣 者 动词也
    夫 而藏     x-y-tuck   已矣 者 动词也
    #+end_src
*** 换
    #+begin_src cicada :tangle chinese-core.cicada
    夫 换       swap       已矣 者 动词也
    夫 而换     x-y-swap   已矣 者 动词也
    #+end_src
** >< Lambda-stack 应该怎么翻译 ???
** 比特串
   #+begin_src cicada :tangle chinese-core.cicada
   夫 比特串相等    equal-string?            已矣 者 动词也
   夫 比特串之首    head-of-string           已矣 者 动词也
   夫 比特串之尾    tail-of-string           已矣 者 动词也
   夫 比特串之首尾  tail-and-head-of-string  已矣 者 动词也
   #+end_src
** 谓词
*** 关于 真 假
    #+begin_src cicada :tangle chinese-core.cicada
    夫 真乎       true?   已矣 者 动词也
    夫 假乎       false?  已矣 者 动词也
    #+end_src
*** 关于 定长整数
    #+begin_src cicada :tangle chinese-core.cicada
    夫 相等       ==       已矣 者 动词也
    夫 不等       =/=      已矣 者 动词也

    夫 小于       <        已矣 者 动词也
    夫 不大于     <=       已矣 者 动词也

    夫 大于       >        已矣 者 动词也
    夫 不小于     >=       已矣 者 动词也

    夫 零乎       zero?    已矣 者 动词也
    夫 一乎       one?     已矣 者 动词也
    #+end_src
* 词典 与 词典编撰者
** 记
   1. 词典的编撰 
      是由很多的 词典编撰者 分工完成的
      一个 词典的编撰者 在编撰词典的时候
      会用一些 词 来定义 一个新的 词
      并且给这个新的 词 指定一个 诠释者
      这样的描述过程和对诠释者的指定过程
      就是定义一个 新词 的过程
      而当查词典的时候
      这个词的诠释者
      会为查词典的人 来诠释 词典编撰者 对这个词的定义
   2. 这一节重新定义了 中文的词典编撰者
      1) 作为 对系统的测试
      2) 为将来的编译做准备
** 执行
   #+begin_src cicada :tangle chinese-core.cicada
   夫 执行       execute     已矣 者 动词也
   #+end_src
** 词之结构
   单位是 "单元大小"
   | 1 | 名字头       |
   | m | 名字         |
   | 1 | 大小         |
   | 1 | 标识         |
   | 1 | 链接         |
   | 1 | 类型         |
   | 1 | 名字头的地址 |
   | 1 | 诠释者       |
   | n | 定义         |
   其中
   | 1 | 类型 |
   ==
   | 位63 | ... | 位1 | 位0 |
   位63 is for HiddenWord
   位0,1,2 are for word type
   0 -- function
   1 -- key word
** 词->词之域
   #+begin_src cicada :tangle chinese-core.cicada
   夫 词->大小
      (* 词的链接[地址] -- 大小 *)
      单元大小 -2 乘 加 取
      已矣
   者 动词也

   夫 词->大小之地址
      (* 词的链接[地址] -- 大小之地址 *)
      单元大小 -2 乘 加
      已矣
   者 动词也

   夫 词->标识
      (* 词的链接[地址] -- 既是值又是地址 *)
      单元大小 -1 乘 加
      已矣
   者 动词也

   夫 词->类型
      (* 词的链接[地址] -- 类型 *)
      单元大小 加 取
      已矣
   者 动词也

   夫 词->类型之地址
      (* 词的链接[地址] -- 类型之地址 *)
      单元大小 加
      已矣
   者 动词也

   夫 词->名字
      (* 词的链接[地址] -- 比特串[地址, 长度] *)
      单元大小 2 乘 加
      取 复
      单元大小 加 (* 地址 *)
      换 取 (* 长度 *)
      已矣
   者 动词也

   夫 词->诠释者
      (* 词的链接[地址] -- 诠释者[地址] *)
      单元大小 3 乘 加
      已矣
   者 动词也

   夫 词->定义
      (* 词的链接[地址] -- 定义[地址] *)
      单元大小 4 乘 加
      已矣
   者 动词也
   #+end_src
** ok
   #+begin_src cicada :tangle chinese-core.cicada
   ok
   #+end_src
** 查词典
   #+begin_src cicada :tangle chinese-core.cicada
   夫 助,查词典
      (* 词串[地址, 长度], 词之链接[地址] --
         词之链接[地址] 或 0 *)
      复 零乎 则
         弃 2 而弃
         0 已矣
      再
      push-lambda-stack
      词->名字 2 2 而跃 比特串相等 则
         2 而弃
         pop-lambda-stack
         已矣
      再
      pop-lambda-stack
      助,查词典
      已矣
   者 动词也

   ok
   夫 查词典
      (* 词串[地址, 长度] --
         词之链接[地址] 或 0 *)
      First-word-in-dictionary
      助,查词典
      已矣
   者 动词也
   ok
   #+end_src
* 记
  1. 与英文核不同的是
     这里 渐进编译器 已经运行起来了
     所以 汇编中的
     专门为了 把 渐进编译器 运行起来的代码就没有必要了
  2. 只有在需要的时候才翻译 英文
* ok
  #+begin_src cicada :tangle chinese-core.cicada
  ok
  #+end_src
* --------------------------------------------------
* *测试*
  #+begin_src cicada
  夫 阶乘 (* n -- n! *)
     复 一乎 则
        已矣
     再
     复 1 减 阶乘 乘
     已矣
  者 动词也
  ok

  1 阶乘 .
  2 阶乘 .
  3 阶乘 .
  ok
  #+end_src
* 字
  #+begin_src cicada
  (* 用 UTF-8 编码来处理汉字
   * 当 发现比特串所包含的不是单一的 UTF-8 字时
   * 需要 特殊处理或报错
   * 这里 先不做这些处理 而只取第一个 UTF-8 字
   *)
  : 比特串->字
    (* 比特串[地址, 长度] -- 字 *)
    drop fetch-byte
    Exit
  ; define-verb
  ok

  夫 字
     (* word-string[address, length] -- word-string[address, length] *)
     (* compile::
          _literal[address of explainer], char *)
     即 _即 append-number-to-here
     tail-and-head-of-word-string
     比特串->字 append-number-to-here
     已矣
  者 虚词也
  ok
  #+end_src
* ==================================================
