#+TITLE: cicada english core
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* basic
** define-variable & define-constant (new lexicographers)
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    : define-variable,by-string
      (* initial-value, String[address, length] -- *)
      create-word-header
      Variable-explainer append-number-to-here
      swap (* leave wordHeader *)
      append-number-to-here (* the initial-value of Var *)
      add-new-word-to-dictionary
      Exit
    ; define-function

    : define-variable (* byWordList *)
      (* initial-value, WordList[address, the number of words] -- *)
      head-of-word-list
      define-variable,by-string
      Exit
    ; define-function

    : define-constant,by-string
      (* initial-value, WordList[address, the number of words] -- *)
      create-word-header
      Constant-explainer append-number-to-here
      swap (* leave wordHeader *)
      append-number-to-here (* the initial-value of Const *)
      add-new-word-to-dictionary
      Exit
    ; define-function

    : define-constant (* byWordList *)
      (* initial-value, WordList[address, the number of words] -- *)
      head-of-word-list
      define-constant,by-string
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    0 : Yi ; define-variable

    Yi fetch . (* 0 *) cr
    1 Yi save
    Yi fetch . (* 1 *) cr

    7 : Qi ; define-constant
    Qi . (* 7 *) cr

    : QiJiaYi (* -- *)
      Qi Yi fetch + .
      Exit
    ; define-function
    QiJiaYi (* 8 *) cr
    #+end_src
** fixnum
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    : /mod (* a, b -- quotient, a mod b *)
      mod/ swap
      Exit
    ; define-function

    : / (* a, b -- quotient *)
      /mod drop
      Exit
    ; define-function

    : mod (* a, b -- a mod b *)
      mod/ drop
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    10 3 / . (* 3 *)
    10 3 mod . (* 1 *)
    #+end_src
** ASCII chars
   #+begin_src cicada :tangle english-core.cicada
   9   : 'tab'      ; define-constant
   10  : 'linefeed' ; define-constant
   10  : 'newline'  ; define-constant
   27  : 'esc'      ; define-constant
   27  : 'escape'   ; define-constant
   32  : 'space'    ; define-constant
   127 : 'delete'   ; define-constant

   33 : '!' ; define-constant
   34 : '"' ; define-constant
   35 : '#' ; define-constant
   36 : '$' ; define-constant
   37 : '%' ; define-constant
   38 : '&' ; define-constant
   39 : ''' ; define-constant
   40 : '(' ; define-constant
   41 : ')' ; define-constant
   42 : '*' ; define-constant
   43 : '+' ; define-constant
   44 : ',' ; define-constant
   45 : '-' ; define-constant
   46 : '.' ; define-constant
   47 : '/' ; define-constant

   48 : '0' ; define-constant
   49 : '1' ; define-constant
   50 : '2' ; define-constant
   51 : '3' ; define-constant
   52 : '4' ; define-constant
   53 : '5' ; define-constant
   54 : '6' ; define-constant
   55 : '7' ; define-constant
   56 : '8' ; define-constant
   57 : '9' ; define-constant

   58 : ':' ; define-constant
   59 : ';' ; define-constant
   60 : '<' ; define-constant
   61 : '=' ; define-constant
   62 : '>' ; define-constant
   63 : '?' ; define-constant
   64 : '@' ; define-constant

   65 : 'A' ; define-constant
   66 : 'B' ; define-constant
   67 : 'C' ; define-constant
   68 : 'D' ; define-constant
   69 : 'E' ; define-constant
   70 : 'F' ; define-constant
   71 : 'G' ; define-constant
   72 : 'H' ; define-constant
   73 : 'I' ; define-constant
   74 : 'J' ; define-constant
   75 : 'K' ; define-constant
   76 : 'L' ; define-constant
   77 : 'M' ; define-constant
   78 : 'N' ; define-constant
   79 : 'O' ; define-constant
   80 : 'P' ; define-constant
   81 : 'Q' ; define-constant
   82 : 'R' ; define-constant
   83 : 'S' ; define-constant
   84 : 'T' ; define-constant
   85 : 'U' ; define-constant
   86 : 'V' ; define-constant
   87 : 'W' ; define-constant
   88 : 'X' ; define-constant
   89 : 'Y' ; define-constant
   90 : 'Z' ; define-constant

   91 : '[' ; define-constant
   92 : '\' ; define-constant
   93 : ']' ; define-constant
   94 : '^' ; define-constant
   95 : '_' ; define-constant
   96 : '`' ; define-constant

   97  : 'a' ; define-constant
   98  : 'b' ; define-constant
   99  : 'c' ; define-constant
   100 : 'd' ; define-constant
   101 : 'e' ; define-constant
   102 : 'f' ; define-constant
   103 : 'g' ; define-constant
   104 : 'h' ; define-constant
   105 : 'i' ; define-constant
   106 : 'j' ; define-constant
   107 : 'k' ; define-constant
   108 : 'l' ; define-constant
   109 : 'm' ; define-constant
   110 : 'n' ; define-constant
   111 : 'o' ; define-constant
   112 : 'p' ; define-constant
   113 : 'q' ; define-constant
   114 : 'r' ; define-constant
   115 : 's' ; define-constant
   116 : 't' ; define-constant
   117 : 'u' ; define-constant
   118 : 'v' ; define-constant
   119 : 'w' ; define-constant
   120 : 'x' ; define-constant
   121 : 'y' ; define-constant
   122 : 'z' ; define-constant

   123 : '{' ; define-constant
   124 : '|' ; define-constant
   125 : '}' ; define-constant
   126 : '~' ; define-constant
   #+end_src
** ><>< string & define-constant-string (new lexicographer)
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    : :" (* -- string[address of Basic-string-buffer, length] *)
      read-string-into-buffer
      Exit
    ; define-function

    : ." (* -- string[address of Basic-string-buffer, length] *)
      read-string-into-buffer print-string
      Exit
    ; define-function

    : define-constant-string,by-string
      (* initial-string[address, length],
         string[address, length], the number of words] -- *)
      create-word-header
      Constant-string-explainer append-number-to-here
      xx|swap|x (* leave wordHeader *)
      append-string-to-here (* initial-string *)
      add-new-word-to-dictionary
      Exit
    ; define-function

    : define-constant-string (* byWordList *)
      (* string[address, length],
         wordList[address, the number of words] -- *)
      head-of-word-list
      define-constant-string,by-string
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    :" xxx"
    : k ; define-constant-string
    k print-string (* xxx *)
    #+end_src
** recursive function & decision (new lexicographers)
*** note
    one predicate can make two branchs
    three predicates can make four branchs
    three predicates may only make three branchs
    but indeed there must be an invisible branch
*** implementation
    bug:
    if there is one ``if,then'' pair mismatch
    there will be crazy bug which is very hard to test !!
    #+begin_src cicada :tangle english-core.cicada
    (* the following is a basic function
       that allow you to define recursive function with tail call optimization *)
    : define-recursive-function
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      add-new-word-to-dictionary
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      Exit
    ; define-function

    :" if"    : Key-word:if   ; define-constant-string
    :" else"  : Key-word:else ; define-constant-string
    :" then"  : Key-word:then ; define-constant-string

    (* the following is an old function
       direct literal number is not handled
       it is no big deal, for this function is only used once *)

    : append-word-description-to-here,with-if&then
      (* wordList[address, the number of words] -- *)
      dup zero? false?branch 3
        drop2 Exit

      tail-and-head-of-word-list

      dup2 Key-word:if equal-string? false?branch 12
        drop2
        literal false?branch append-number-to-here
        Here fetch xx|swap|x
        Zero append-number-to-here (* leave a place *)
        append-word-description-to-here,with-if&then Exit

      dup2 Key-word:then equal-string? false?branch 13
        drop2
        x|swap|xx
        Here fetch over -  Cell-width /
        swap save
        append-word-description-to-here,with-if&then Exit

      dup2 string-denote-integer? false?branch 6
        string->integer,with-error drop append-number-to-here
        append-word-description-to-here,with-if&then Exit

        find word-link->word-explainer append-number-to-here
        append-word-description-to-here,with-if&then Exit
    ; define-recursive-function

    : define-recursive-function,with-if&then
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      add-new-word-to-dictionary
      Function-body-explainer append-number-to-here
      append-word-description-to-here,with-if&then
      Exit
    ; define-function


    (* redefine append-word-description-to-here add "else"
       this also can be viewed as a basic test of new implemented "if&then"
       and this time, I use Lambda-stack *)

    : help:append-word-description-to-here,if
      (* string if [address, length] -- *)
      drop2
      literal false?branch append-number-to-here
      Here fetch xx|swap|x
      Zero append-number-to-here (* leave a place *)
      Exit
    ; define-function

    : help:append-word-description-to-here,else
      (* string else [address, length] -- *)
      drop2
      literal branch append-number-to-here
      Here fetch xxx|swap|x
      Zero append-number-to-here (* leave a place *)
      x|swap|xx
      Here fetch over -  Cell-width /
      swap save
      Exit
    ; define-function

    : help:append-word-description-to-here,then
      (* string then [address, length] -- *)
      drop2
      x|swap|xx
      Here fetch over -  Cell-width /
      swap save
      Exit
    ; define-function

    : append-word-description-to-here
      (* wordList[address, the number of words] -- *)
      dup zero? if
        drop2
        Exit
      then
      tail-and-head-of-word-list
      dup2 Key-word:if equal-string? if
        help:append-word-description-to-here,if
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:else equal-string? if
        help:append-word-description-to-here,else
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:then equal-string? if
        help:append-word-description-to-here,then
        append-word-description-to-here
        Exit
      then
      dup2 string-denote-literal&branch? if
        help:append-word-description-to-here,literal&branch
        append-word-description-to-here
        Exit
      then
      dup2 string-denote-integer? if
        help:append-word-description-to-here,number
        append-word-description-to-here
        Exit
      then
      help:append-word-description-to-here,word
      append-word-description-to-here
      Exit
    ; define-recursive-function,with-if&then


    (* redefine define-recursive-function & define-function *)

    : define-function
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      xx|swap|x
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      add-new-word-to-dictionary
      Exit
    ; define-function

    : define-recursive-function
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      add-new-word-to-dictionary
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    : factorial (* n -- n! *)
      dup one? if
        Exit
      then
      dup sub1 factorial * Exit
    ; define-recursive-function



    1 factorial .
    2 factorial .
    3 factorial .
    4 factorial .
    5 factorial .
    6 factorial .
    7 factorial .
    8 factorial .
    9 factorial .
    10 factorial .
    11 factorial .
    12 factorial .
    13 factorial .
    14 factorial .
    15 factorial .
    16 factorial .
    17 factorial .
    18 factorial .
    19 factorial .
    20 factorial .



    : .12 (* 1 2 -- *)
      2 == if
        '2' write-char
        1 == if
          '1' write-char
        else
          '_' write-char
        then
      else
        '_' write-char
        1 == if
          '1' write-char
        else
          '_' write-char
        then
      then
      Exit
    ; define-function

    1 2 .12 cr
    6 2 .12 cr
    1 6 .12 cr
    6 6 .12 cr
    #+end_src
** predicates
   #+begin_src cicada :tangle english-core.cicada
   : special-key-word? (* word[explainer] -- True or False *)
     dup literal literal           == if drop True Exit then
     dup literal branch            == if drop True Exit then
     dup literal zero?branch       == if drop True Exit then
     dup literal false?branch      == if drop True Exit then
     dup literal not-false?branch  == if drop True Exit then
     drop False
     Exit
   ; define-function
   #+end_src
** writers of number
*** note
    1. it is great if want a reader can read
       is identical to what a writer would write
       and what a writer write
       could be read by reader without any changes
       I will try to achieve this
    2. due to the lack of the ``semantic of substitution''
       to achieve the following functions
       I have to copy lots of code
       instead of just using lambda-abstraction
*** implementation
**** write-dec-number
     #+begin_src cicada :tangle english-core.cicada
     : write-dec-number-char (* byte -- *)
       '0' + write-char
       Exit
     ; define-function
          
     : help:write-dec-number,push-chars
       (* ... , number of small DecNumbers, fixnum --
          ... , number of small DecNumbers *)
       10 mod/
       dup zero? if
         drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help:write-dec-number,push-chars
       Exit
     ; define-recursive-function
          
     : help:write-dec-number,write-chars
       (* ... , number of small DecNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-dec-number-char
       help:write-dec-number,write-chars
       Exit
     ; define-recursive-function
          
          
     : write-dec-number,unsign (* fixnum -- *)
       Zero swap
       help:write-dec-number,push-chars
       help:write-dec-number,write-chars
       Exit
     ; define-function
          
     : write-dec-number,sign (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-dec-number,unsign
       Exit
     ; define-function
          
     : write-dec-number
       write-dec-number,sign
       Exit
     ; define-function
     #+end_src
**** write-bin-number
     #+begin_src cicada :tangle english-core.cicada
     : write-bin-number-char (* byte -- *)
       '0' + write-char
       Exit
     ; define-function

     : help:write-bin-number,push-chars
       (* ... , number of small BinNumbers, fixnum --
          ... , number of small BinNumbers *)
       2 mod/
       dup zero? if
         drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help:write-bin-number,push-chars
       Exit
     ; define-recursive-function

     : help:write-bin-number,write-chars
       (* ... , number of small BinNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-bin-number-char
       help:write-bin-number,write-chars
       Exit
     ; define-recursive-function

     : write-bin-number,unsign (* fixnum -- *)
       Zero swap
       help:write-bin-number,push-chars
       help:write-bin-number,write-chars
       Exit
     ; define-function

     : write-bin-number,sign (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-bin-number,unsign
       Exit
     ; define-function

     : write-bin-number
       write-bin-number,sign
       Exit
     ; define-function
     #+end_src
**** write-oct-number
     #+begin_src cicada :tangle english-core.cicada
     : write-oct-number-char (* byte -- *)
       '0' + write-char
       Exit
     ; define-function

     : help:write-oct-number,push-chars
       (* ... , number of small OctNumbers, fixnum --
          ... , number of small OctNumbers *)
       8 mod/
       dup zero? if
         drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help:write-oct-number,push-chars
       Exit
     ; define-recursive-function

     : help:write-oct-number,write-chars
       (* ... , number of small OctNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-oct-number-char
       help:write-oct-number,write-chars
       Exit
     ; define-recursive-function

     : write-oct-number,unsign (* fixnum -- *)
       Zero swap
       help:write-oct-number,push-chars
       help:write-oct-number,write-chars
       Exit
     ; define-function

     : write-oct-number,sign (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-oct-number,unsign
       Exit
     ; define-function

     : write-oct-number
       write-oct-number,sign
       Exit
     ; define-function
     #+end_src
**** write-hex-number
     #+begin_src cicada :tangle english-core.cicada
     : write-hex-number-char (* byte -- *)
       dup Ten < if
         '0' + write-char Exit
       then
       Ten -
       'a' + write-char
       Exit
     ; define-function

     : write-hex-number-char,capital (* byte -- *)
       dup Ten < if
         '0' + write-char Exit
       then
       Ten -
       'A' + write-char
       Exit
     ; define-function

     : help:write-hex-number,push-chars
       (* ... , number of small HexNumbers, fixnum --
          ... , number of small HexNumbers *)
       16 mod/
       dup zero? if
         drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help:write-hex-number,push-chars
       Exit
     ; define-recursive-function

     : help:write-hex-number,write-chars
       (* ... , number of small HexNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-hex-number-char
       help:write-hex-number,write-chars
       Exit
     ; define-recursive-function

     : help:write-hex-number,write-chars,capital
       (* ... , number of small HexNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-hex-number-char,capital
       help:write-hex-number,write-chars,capital
       Exit
     ; define-recursive-function

     : write-hex-number,unsign (* fixnum -- *)
       Zero swap
       help:write-hex-number,push-chars
       help:write-hex-number,write-chars
       Exit
     ; define-function

     : write-hex-number,capital (* fixnum -- *)
       Zero swap
       help:write-hex-number,push-chars
       help:write-hex-number,write-chars,capital
       Exit
     ; define-function

     : write-hex-number,sign (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-hex-number,unsign
       Exit
     ; define-function

     : write-hex-number,sign,capital (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-hex-number,capital
       Exit
     ; define-function

     : write-hex-number
       write-hex-number,sign
       Exit
     ; define-function
     #+end_src
**** write-aph-number
     #+begin_src cicada :tangle english-core.cicada
     : write-aph-number-char (* byte -- *)
       dup Ten < if
         '0' + write-char Exit
       then
       Ten -
       'a' + write-char
       Exit
     ; define-function
     
     : write-aph-number-char,capital (* byte -- *)
       dup Ten < if
         '0' + write-char Exit
       then
       Ten -
       'A' + write-char
       Exit
     ; define-function
     
     : help:write-aph-number,push-chars
       (* ... , number of small AphNumbers, fixnum --
          ... , number of small AphNumbers *)
       36 mod/
       dup zero? if
         drop swap add1 Exit
       then
       xx|swap|x xx|swap|x add1 swap
       help:write-aph-number,push-chars
       Exit
     ; define-recursive-function
     
     : help:write-aph-number,write-chars
       (* ... , number of small AphNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-aph-number-char
       help:write-aph-number,write-chars
       Exit
     ; define-recursive-function
     
     : help:write-aph-number,write-chars,capital
       (* ... , number of small AphNumbers -- *)
       dup zero? if drop Exit
       then
       sub1 swap write-aph-number-char,capital
       help:write-aph-number,write-chars,capital
       Exit
     ; define-recursive-function
     
     : write-aph-number,unsign (* fixnum -- *)
       Zero swap
       help:write-aph-number,push-chars
       help:write-aph-number,write-chars
       Exit
     ; define-function
     
     : write-aph-number,capital (* fixnum -- *)
       Zero swap
       help:write-aph-number,push-chars
       help:write-aph-number,write-chars,capital
       Exit
     ; define-function
     
     : write-aph-number,sign (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-aph-number,unsign
       Exit
     ; define-function
     
     : write-aph-number,sign,capital (* fixnum -- *)
       dup Zero < if
         '-' write-char
         negate
       then
       write-aph-number,capital
       Exit
     ; define-function
     
     : write-aph-number
       write-aph-number,sign 
       Exit
     ; define-function
     #+end_src
**** usage
     #+begin_src cicada :tangle english-core.cicada
     : .unsign (* fixnum -- *)
       write-dec-number
       'space' write-char
       Exit
     ; define-function

     : .sign (* fixnum -- *)
       write-dec-number,sign
       'space' write-char
       Exit
     ; define-function


     : . .sign Exit ; define-function


     : .bin (* fixnum -- *)
       write-bin-number
       'space' write-char
       Exit
     ; define-function

     : .bin,sign (* fixnum -- *)
       write-bin-number,sign
       'space' write-char
       Exit
     ; define-function

     : .oct (* fixnum -- *)
       write-oct-number
       'space' write-char
       Exit
     ; define-function

     : .oct,sign (* fixnum -- *)
       write-oct-number,sign
       'space' write-char
       Exit
     ; define-function

     : .hex (* fixnum -- *)
       write-hex-number
       'space' write-char
       Exit
     ; define-function

     : .hex,sign (* fixnum -- *)
       write-hex-number,sign
       'space' write-char
       Exit
     ; define-function

     : .hex,capital (* fixnum -- *)
       write-hex-number,capital
       'space' write-char
       Exit
     ; define-function

     : .hex,sign,capital (* fixnum -- *)
       write-hex-number,sign,capital
       'space' write-char
       Exit
     ; define-function


     : .aph (* fixnum -- *)
       write-aph-number
       'space' write-char
       Exit
     ; define-function

     : .aph,sign (* fixnum -- *)
       write-aph-number,sign
       'space' write-char
       Exit
     ; define-function

     : .aph,capital (* fixnum -- *)
       write-aph-number,capital
       'space' write-char
       Exit
     ; define-function

     : .aph,sign,capital (* fixnum -- *)
       write-aph-number,sign,capital
       'space' write-char
       Exit
     ; define-function

     : cr (* -- *)
       'newline' write-char Exit
     ; define-function


     : write-space (* -- *)
       'space' write-char Exit
     ; define-function

     : write-some-space (* n -- *)
       dup zero? if
         drop Exit
       then
       sub1
       write-space
       write-some-space
       Exit
     ; define-recursive-function
     #+end_src
*** test
    #+begin_src cicada
    123 321 123321 . . .
    -123 321 -123321 . . .
    -123 321 -123321 .sign .sign .sign
    -123 321 -123321 .unsign .unsign .unsign

    123 321 123321 .bin .bin .bin
    -123 321 -123321 .bin,sign .bin,sign .bin,sign

    123 321 123321 .oct .oct .oct
    -123 321 -123321 .oct,sign .oct,sign .oct,sign

    123 321 123321 .hex .hex .hex
    123 321 123321 .hex,capital .hex,capital .hex,capital
    -123 321 -123321 .hex,sign .hex,sign .hex,sign
    -123 321 -123321 .hex,sign,capital .hex,sign,capital .hex,sign,capital

    123 321 123321 .aph .aph .aph
    123 321 123321 .aph,capital .aph,capital .aph,capital
    -123 321 -123321 .aph,sign .aph,sign .aph,sign
    -123 321 -123321 .aph,sign,capital .aph,sign,capital .aph,sign,capital
    #+end_src
** print-string,null-terminated
   #+begin_src cicada :tangle english-core.cicada
   : print-string,null-terminated
     (* null-terminated-string[address] -- *)
     dup fetch-byte zero? if
       drop
       Exit
     then
     dup fetch-byte write-char
     add1
     print-string,null-terminated
     Exit
   ; define-recursive-function
   #+end_src
* debuger
** debuger-REPL & trace-function
*** note
    1. "debuger" should be placed in Function-body
       when called, it pause the calculation of the function
       bring you into the debuger-REPL
    2. after type tag encoding
       we should handle type error as possible as we could
    3. the ``IdentificationOf#Word'' in ``def*'' macros is for ``debuger''
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    : count-return-stack (* -- the length of ReturnStack *)
      Return-stack-top fetch-return-stack-pointer -
      Eight /
      sub1 (* for we are in this function call *)
      Exit
    ; define-function

    : count-argument-stack (* -- the length of ArgumentStack *)
      Argument-stack-top fetch-argument-stack-pointer -
      Eight /
      Exit
    ; define-function


    0 : Return-stack-position   ; define-variable
    0 : Argument-stack-position ; define-variable

    (* the following two function are as interface *)
    : debuger,fetch-from-return-stack (* n -- *)
      sub1 Eight *
      Return-stack-position fetch +
      fetch
      Exit
    ; define-function

    : debuger,fetch-from-argument-stack (* n -- *)
      sub1 Eight *
      Argument-stack-position fetch +
      fetch
      Exit
    ; define-function


    :" bye"
    : Message:bye ; define-constant-string

    : execute-word (* string[address, length] -- unknown *)
      dup2
      string-denote-integer? if
        string->integer,with-error drop
        Exit
      then
      dup2 find dup not-zero? if
        xx|swap|x drop2
        word-link->word-explainer execute
        Exit
      then
      drop
      Message:undefined-word print-string
      print-string cr
      Exit
    ; define-function

    : debuger-REPL (* unknown -- unknown *)
      read-word-for-runtime
      dup2
      Message:bye equal-string? if
        drop2
        Exit
      then
      execute-word
      debuger-REPL
      Exit
    ; define-recursive-function

    :" debuger said: ``Welcome! Hope you find what's wrong.''"
    : Message:debuger,welcome ; define-constant-string

    :" the length of Return-stack is: "
    : Message:debuger,the-length-of-returnstack ; define-constant-string

    :" the length of Argument-stack is: "
    : Message:debuger,the-length-of-argument-stack ; define-constant-string

    :" debuger said: ``Good bye! The computation will go on!''"
    : Message:debuger,goodbye ; define-constant-string

    : debuger (* unknown -- unknown *)
      Message:debuger,welcome print-string cr
      Three write-some-space Message:debuger,the-length-of-returnstack print-string
        count-return-stack write-dec-number cr
      Three write-some-space Message:debuger,the-length-of-argument-stack print-string
        count-argument-stack write-dec-number cr
      fetch-return-stack-pointer Return-stack-position save
      fetch-argument-stack-pointer Argument-stack-position save
      Input-buffer Current-reading save
      Input-buffer Reading-boundary save
      debuger-REPL
      Message:debuger,goodbye print-string cr
      Exit
    ; define-function

    (* ><><>< bug ><><>< *)
    (* ``1 fetch'' will cause core dump *)
    : identification-of-word? (* an address in a word -- *)
      dup fetch ==
      Exit
    ; define-function

    (* ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     * || m(bytes) : name-string  ||
     * ||  1 : size of function body  ||
     * ||  1 : identification  ||
     * ||  1 : link  ||
     * ||  1 : type  ||
     * ||  1 : address-of-name-string-header  ||
     * ||  1 : address-of-explainer  ||
     * ||  n : body  ||
     *)

    : word,body->id
      (* [an address of a cell in a word] -- word[identification] *)
      dup
      identification-of-word? if
        Exit
      then
      Cell-width -
      word,body->id
      Exit
    ; define-recursive-function

    : word,id->name
      (* word[identification] -- string[address, length] *)
      Cell-width Three * +
      fetch dup
      add8 swap
      fetch
      Exit
    ; define-function

    : word,id->explainer
      (* word[identification] -- explainer *)
      Cell-width Four * +
      fetch
      Exit
    ; define-function

    : word,id->body-size
      (* word[identification] -- body-size *)
      Cell-width -
      fetch
      Exit
    ; define-function

    : word,id->body-list
      (* word[identification] -- body-list[address, length] *)
      dup
        Cell-width Five * +
      swap
      word,id->body-size
      Exit
    ; define-function

    : print-name-of-explainer (* explainer -- *)
      dup Function-body-explainer == if
        literal Function-body-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Variable-explainer == if
        literal Variable-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Constant-explainer == if
        literal Constant-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Constant-string-explainer == if
        literal Constant-string-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      drop
      Exit
    ; define-function

    : print-function-body-list (* body-list[address, length] -- *)
      dup zero? if
        drop2 Exit
      then
      Six write-some-space
      over fetch word,body->id word,id->name print-string cr
      sub1 swap
      Cell-width + swap
      print-function-body-list
      Exit
    ; define-recursive-function

    :"  -->  "
    : Message:_-->__ ; define-constant-string

    (* the following function is the first function
       on which I must use ``if,else,then'' *)
    : with-pointer,print-function-body-list
      (* [an address of a cell in a word], body-list[address, length] -- *)
      dup zero? if
        drop2 drop Exit
      then
      x|over|xx x|over|xx == if
        Message:_-->__ print-string
      else
        Six write-some-space
      then
      over
      dup fetch special-key-word? if
        fetch word,body->id word,id->name print-string cr
        sub2 swap
        dup
        Six write-some-space
        Cell-width + fetch write-dec-number cr
        Cell-width Two * + swap
        with-pointer,print-function-body-list
        Exit
      then
      fetch word,body->id word,id->name print-string cr
      sub1 swap
      Cell-width + swap
      with-pointer,print-function-body-list
      Exit
    ; define-recursive-function


    :" trace-function said: ``Ya! Let's trace a function!''"
    : Message:trace-function,welcome ; define-constant-string

    :" The function we use to trace is:"
    : Message:trace-function,function-to-trace ; define-constant-string

    :" The function be traced to is:"
    : Message:trace-function,function-be-traced-to ; define-constant-string

    :" The size of the body of this function is:"
    : Message:trace-function,function-body-size ; define-constant-string

    :" The body of this function is:"
    : Message:trace-function,function-body ; define-constant-string

    :" trace-function said: ``The end of a tracing.''"
    : Message:trace-function,goodbye ; define-constant-string

    : trace-function
      (* [an address of a cell in a word] -- *)
      Message:trace-function,welcome print-string cr
      dup
        Three write-some-space Message:trace-function,function-to-trace print-string cr
        Six write-some-space fetch word,body->id word,id->name print-string cr
      dup (* with-pointer,print-function-body-list still uses original arg *)
      word,body->id
        dup
          Three write-some-space Message:trace-function,function-be-traced-to print-string cr
          Six write-some-space word,id->name print-string cr
        dup
          Three write-some-space Message:trace-function,function-body-size print-string cr
          Six write-some-space word,id->body-size write-dec-number cr
        Three write-some-space Message:trace-function,function-body print-string cr
        word,id->body-list with-pointer,print-function-body-list
      Message:trace-function,goodbye print-string cr
      Exit
    ; define-function
    #+end_src
*** simple trace
    #+begin_src cicada :tangle english-core.cicada
    : trace (* n -- *)
      debuger,fetch-from-return-stack
      trace-function
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    (* test: trace-function *)

    : xxx (* n, m -- *)
       debuger
       +
       666 .
       .
       Exit
    ; define-function

    10 1 xxx
      1 debuger,fetch-from-return-stack  trace-function
      2 debuger,fetch-from-return-stack  trace-function
      bye
    (* 666 11 *)


    : factorial (* n -- n! *)
        dup one? if
          debuger
          Exit
        then
        dup sub1 factorial * Exit
    ; define-recursive-function

    10 factorial
      1 debuger,fetch-from-return-stack
        trace-function
      9 debuger,fetch-from-return-stack
        trace-function
      10 debuger,fetch-from-return-stack
        trace-function
      bye
    . (* 3628800 *)



    (* about tail call *)
    : write-some-space (* n -- *)
        dup zero? if
          drop Exit
        then
        sub1
        'space' write-char
        debuger
        write-some-space
        Exit
    ; define-recursive-function

    100 write-some-space
      1 debuger,fetch-from-return-stack
        trace-function
      2 debuger,fetch-from-return-stack
        trace-function
      bye
    (* Ya! you can never say ``bye'' to this call of ``debuger'' *)
    (* when ever you call ``debuger'' in front of a recursive call, this happens *)
    basic-REPL
    count-argument-stack . (* 0 *)
    count-return-stack . (* 0 *)
    #+end_src
** new lexicographers with debuger
*** note
    1. the following redefined ``append-word-description-to-here''
       will call debuger if it meets a undefined word
    2. there will be syntax-check after the implementation of ``list''
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    : print-word-list (* WordList[address, the number of words] -- *)
      dup zero? if
        drop2
        cr Exit
      then
      Three write-some-space
      tail-and-head-of-word-list print-string cr
      print-word-list
      Exit
    ; define-recursive-function


    :" an error occurs!
    append-word-description-to-here said:
       ``I am a tail-recursive-function.
         My function-type is (* WordList[address, the number of words] -- *)
         `define-recursive-function' and `define-function' call me.
         The following word is undefined.
         I will print the rest of the Word-list and call debuger.''
       --> "
    : Message:append-word-description-to-here,meet-undefined-word
    ; define-constant-string

    :" The length of the rest of the Word-list is: "
    : Message:append-word-description-to-here,length-of-the-rest-of-the-word-list
    ; define-constant-string

    :" The rest of the Word-list is: "
    : Message:append-word-description-to-here,the-rest-of-the-word-list
    ; define-constant-string


    : append-word-description-to-here
      (* WordList[address, the number of words] -- *)
      dup zero? if
        drop2
        Exit
      then
      tail-and-head-of-word-list
      dup2 Key-word:if equal-string? if
        help:append-word-description-to-here,if
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:else equal-string? if
        help:append-word-description-to-here,else
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:then equal-string? if
        help:append-word-description-to-here,then
        append-word-description-to-here
        Exit
      then
      dup2 string-denote-literal&branch? if
        help:append-word-description-to-here,literal&branch
        append-word-description-to-here
        Exit
      then
      dup2 string-denote-integer? if
        help:append-word-description-to-here,number
        append-word-description-to-here
        Exit
      then
      dup2 find dup not-zero? if
        word-link->word-explainer append-number-to-here
        drop2 (* drop the string[address, length], which is for debuger *)
        append-word-description-to-here
        Exit
      then
      drop (* drop the Zero *)
      Message:append-word-description-to-here,meet-undefined-word print-string
      print-string cr
      Message:append-word-description-to-here,length-of-the-rest-of-the-word-list
      print-string dup write-dec-number cr
      Message:append-word-description-to-here,the-rest-of-the-word-list print-string cr
      print-word-list
      debuger
      Exit
    ; define-recursive-function


    : define-function
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      xx|swap|x
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      add-new-word-to-dictionary
      Exit
    ; define-function

    : define-recursive-function
      (* wordList[address, the number of words] -- *)
      tail-and-head-of-word-list
      create-word-header-for-function
      set-size-of-function-body
      add-new-word-to-dictionary
      Function-body-explainer append-number-to-here
      append-word-description-to-here
      Exit
    ; define-function

    (*
     ,* (\* wordy version for testing *\)
     ,* : define-function
     ,*   (\* wordList[address, the number of words] -- *\)
     ,*   tail-and-head-of-word-list
     ,*     dup2 print-string
     ,*     'newline' write-char
     ,*   create-word-header-for-function
     ,*   set-size-of-function-body
     ,*   xx|swap|x
     ,*   Function-body-explainer append-number-to-here
     ,*   append-word-description-to-here
     ,*   add-new-word-to-dictionary
     ,*   Exit
     ,* ; define-function
     ,*
     ,* : define-recursive-function
     ,*   (\* wordList[address, the number of words] -- *\)
     ,*   tail-and-head-of-word-list
     ,*     dup2 print-string
     ,*     'newline' write-char
     ,*   create-word-header-for-function
     ,*   set-size-of-function-body
     ,*   add-new-word-to-dictionary
     ,*   Function-body-explainer append-number-to-here
     ,*   append-word-description-to-here
     ,*   Exit
     * ; define-function
     *)
    #+end_src
* hash
** note
   1. ``string-hash->index index-hashback->string''
      is a identity function
      and if the argumt is a index returned by ``string-hash->index''
      ``index-hashback->string string-hash->index''
      also is a identity function
   2. you can set a 8 bytes value
      to every symbol in this hash-table
      by:
      [value, index] index->address save
      dynamic type system make use of it
      for I implement type-tag as a special symbol
      but you should NOT set a pair to a symbol
      for I can not afford to let gc scan the whole hash-table to mark it
   3. hash-function (string)
      ==> (sum-up [byte_n * 2^n]) mod Number-of-symbol-entrys
      + where:
        0 <= n < Symbol-max-length
        and the Number-of-symbol-entrys is a prime number
      after sum-up, the greatest number < 2^(Symbol-max-length + 8)
      so I let Symbol-max-length == 64 - 8 == 56
      only first Symbol-max-length of the string is used by the hash-function
** string-hash->index & index-hashback->string
   #+begin_src cicada :tangle english-core.cicada
   (* a Symbol-entry [unit : byte]
    * ==========================
    *  ||   8 : Symbol-value   ||
    * --------------------------
    *  ||   1 : Symbol-length  ||
    * --------------------------
    *  || 56+ : Symbol-string  ||
    * ==========================
    * where Symbol-max-length = 56 *)

   :" an error occurs!
   index->address said:
      ``My function-type is (* index -- address *)
        The following unsign-number is not a index of the hash-table
        I will not touch it and call debuger.''
      --> "
   : Message:index->address,error ; define-constant-string

   : index->address (* index -- address *)
     dup Number-of-symbol-entrys >= if
       Message:index->address,error print-string
       dup write-dec-number cr
       debuger Exit
     then
     dup Zero < if
       Message:index->address,error print-string
       dup write-dec-number cr
       debuger Exit
     then
     Symbol-entry-bytes-size *
     First-symbol-entry +
     Exit
   ; define-function

   : index-hashback->string
     (* index -- string[address, length] *)
     index->address Eight +
     dup add1 swap
     fetch-byte
     Exit
   ; define-function


   : help:string-hash->index,sum-up
     (* sum-up , string[address, length] -- sum-up *)
     dup zero? if
       drop2 Exit
     then
     tail-and-head-of-string
     over shift-left
     x|swap|xxx  +  xx|swap|x
     help:string-hash->index,sum-up
     Exit
   ; define-recursive-function

   : help:string-hash->index,find-old-or-creat-new
     (* string[address, length], index -- index *)
     xx|tuck|x
     index-hashback->string
     (* index, string[address, length], string-2[address, length] *)
     dup zero? if  (* creat-new *)
       drop
       (* index, string[address, length], destination-address *)
       over over
       (* index, string[address, length], destination-address, length, address *)
       sub1 save-byte
       swap
       (* index,, source-address, destination-address, length *)
       copy-byte-string
       Exit
     then
     (* index, string[address, length], string-2[address, length] *)
     xx|over|xx equal-string? if (* found old *)
       drop2 Exit
     then
     x|swap|xx (* to get next-index *)
     (* string[address, length], index *)
     dup index->address Last-symbol-entry == if
       drop
       Zero
       help:string-hash->index,find-old-or-creat-new
       Exit
     then
     add1
     help:string-hash->index,find-old-or-creat-new
     Exit
   ; define-recursive-function

   : help:string-hash->index,sum-up->index
     (* sum-up -- index *)
     Number-of-symbol-entrys mod
     Exit
   ; define-function

   : string-hash->index
     (* string[address, length] -- index *)
     dup2
       dup Symbol-max-length > if
         drop Symbol-max-length
         (* this means only first Symbol-max-length of the string is used by the hash-function *)
       then
       Zero xx|swap|x
       help:string-hash->index,sum-up
       help:string-hash->index,sum-up->index
     help:string-hash->index,find-old-or-creat-new
     Exit
   ; define-function
   #+end_src
** test
   #+begin_src cicada
   Number-of-symbol-entrys 1 -
   index->address Last-symbol-entry == . (* 1 *)

   -1 index->address
   basic-REPL
   1000000000 index->address
   basic-REPL

   :" a" string-hash->index . cr
   :" b" string-hash->index . cr
   :" c" string-hash->index . cr

   :" k" string-hash->index . cr
   :" kk" string-hash->index . cr
   :" xxx" string-hash->index . cr
   :" xxxk" string-hash->index . cr
   :" xxxkk" string-hash->index . cr
   :" xxxxxx" string-hash->index . cr
   :" xxxxxxk" string-hash->index . cr
   :" xxxxxxkk" string-hash->index . cr
   :" xxxxxxxxx" string-hash->index . cr
   :" xxxxxxxxxk" string-hash->index . cr
   :" xxxxxxxxxkk" string-hash->index . cr
   :" xxxxxxxxxxxx" string-hash->index . cr
   :" xxxxxxxxxxxxk" string-hash->index . cr
   :" xxxxxxxxxxxxkk" string-hash->index . cr
   :" xxxxxxxxxxxxxxx" string-hash->index . cr
   :" xxxxxxxxxxxxxxxk" string-hash->index . cr
   :" xxxxxxxxxxxxxxxkk" string-hash->index . cr


   (* Number-of-symbol-entrys : 10_0333 , 10_0003
      97      97
      98      98
      99      99
      107     107
      321     321
      749     749
      1605    1605
      3317    3317
      6741    6741
      13589   13589
      27285   27285
      54677   54677
      9128    9458
      18363   19023
      36833   38153
      73773   76413
      47320   52930
      94747   5964
      89268   12035
      78310   24177
    *)


   (* test: collision *)
   (*  'A'*2 + 'c' = 'B'*2 + 'a' *)
   :" Ac" string-hash->index . cr (* 229 *)
   :" Ba" string-hash->index . cr (* 230 *)

   :" A"
     string-hash->index index-hashback->string
   print-string

   :" Ac"
     string-hash->index index-hashback->string
   print-string

   :" Ba"
     string-hash->index index-hashback->string
   print-string

   (* test: rounding *)

   (* when: Number-of-symbol-entrys = 10_0003 *)
   10_0003 .bin (* 11000011010100011 *)

   (* when: Number-of-symbol-entrys = 10_0333 *)
   10_0333 .bin (* 11000011111101101 *)


   (* I do not want to solve two funny equations about ascii-chars,
    * just to test the two ``Number-of-symbol-entrys'' above !!!???
    * so, to test this, I reset ``Number-of-symbol-entrys'' to 230, in assembler,
    * then the greatest index == 229,
    * then to test collision is to test rounding
    *)


   :" Ac" string-hash->index . cr (* 229 *)
   :" Ba" string-hash->index . cr (* 0 *)

   :" Ac"
     string-hash->index index-hashback->string
   print-string

   :" Ba"
     string-hash->index index-hashback->string
   print-string
   #+end_src
* dynamic type system
** >< [OLD] note
   1. I make the following stipulations about creating cicada words:
      1 constants) and variables are nouns,
         the first letter of them should be capitalized.
         (just as in Deutsch)
      2) functions are verbs,
         the first letter of them should be NOT capitalized.
      3) I use compoundWordByCamelCase
         when the word is about non-typed value.
         examples:
         print-string print-type-tag define-function
      4) I use compound-word-with-dashes
         when the word is about typed value.
         examples:
         cons car cdr set-car! set-cdr! list-copy
      5) I use <this-kind-of-word>
         when the word is about type.
         examples:
         <pair> <pair-like>? <graph> <lambda> <fixnum> <type>
      6) I do not use compound_word_with_underscores
   2. atom :
      TypedValue[valus, type tag]
   3. non-atom :
      TypedValue[address, type tag]
   4. this is really a flexible and dangerous way to use dynamic-type-value
   5. this is dangerous,
      for you can meet semantic overload sometimes
      for example,
      True-Bool == [1, <bool>]
      True == 1
      that means you have two syntaxes to denote one semantic
      then, how should you implement ``if,else,then'' ???
      this is really not acceptable !!!
   6. this is flexible,
      for you can easily define different kinds of <pair-like> values:
      1) <list>
      2) <alist> (associated-list)
      3) <dalin> (double-linked-list)
      4) <wodyli> (wodyli)
      5) <graph>
      6) and more
   7. to implement gc
      one have to (and only have to)
      be able to distinguish <pair> and <non-pair>
   8. every new data type implemented by <pair>
      have to be handled by gc as <pair>
   9. I do not need type-inherit at all
      for I can easily convert one type to another
      say, I have <xxx-list>
      a function apply on <list> will not apply on <xxx-list>
      but if I use <xxx-list> as a list
      which every cdr is of type <list>
      only the first type is change from <list> to <xxx-list>
      then, when I want to treat this <xxx-list> as a <list>
      I just ``drop <list>''
** implementation
   #+begin_src cicada :tangle english-core.cicada
   (* if 1 is setted to a symbol, this symbol is a fixnum like data type
      if 2 is setted to a symbol, this symbol is a pair like data type *)

   : define-data-type
     (* wordList[address, the number of words] -- *)
     dup2
       head-of-word-list
       string-hash->index
       dup
         index->address One swap save
       xx|swap|x
     define-constant
     Exit
   ; define-function

   : define-pair-like-data-type
     (* wordList[address, the number of words] -- *)
     dup2
       head-of-word-list
       string-hash->index
       dup
         index->address Two swap save
       xx|swap|x
     define-constant
     Exit
   ; define-function


   (* every word can be used as a name of a data type
      the following are my convention *)

   : <fixnum>    ; define-data-type
   : <bool>      ; define-data-type
   : <type>      ; define-data-type
   : <char>      ; define-data-type
   : <symbol>    ; define-data-type
   : <substring> ; define-data-type
   : <null>      ; define-data-type


   : <fixnum-like>? (* type -- True or False *)
       index->address fetch One ==
       Exit
   ; define-function


   0 : Null ; define-constant

   : null Null <null> Exit ; define-function

   : null? (* [value, type] -- True or False *)
     <null> == if
       Null == if
         True Exit
       then
       False Exit
     then
     drop False Exit
   ; define-function




   : True-Bool  True  <bool> Exit ; define-function
   : False-Bool False <bool> Exit ; define-function



   : <pair>    ; define-pair-like-data-type
   : <string>  ; define-pair-like-data-type
   : <list>    ; define-pair-like-data-type

   : <dalin>   ; define-pair-like-data-type

   : <wody>           ; define-pair-like-data-type
   : <bound-variable> ; define-pair-like-data-type
   : <wodyli>         ; define-pair-like-data-type


   : <pair-like>? (* type -- True or False *)
       index->address fetch Two ==
       Exit
   ; define-function

   : <not-pair-like>? (* type -- True or False *)
       index->address fetch Two =/=
       Exit
   ; define-function


   : <dalin-like>? (* type -- True or False *)
     dup <dalin> == if
       drop True Exit
     then
     dup <wodyli> == if
       drop True Exit
     then
     drop False Exit
   ; define-function


   : <not-dalin-like>? (* type -- True or False *)
     dup <dalin> == if
       drop False Exit
     then
     dup <wodyli> == if
       drop False Exit
     then
     drop True Exit
   ; define-function




   :" an error occurs!
   print-type-tag said:
      ``My function-type is (* type-tag[index of hash-table] -- *)
        The following index is not a type-tag
        I will not touch it and call debuger.''
      --> "
   : Message:print-type-tag,error ; define-constant-string

   : print-type-tag
     (* type-tag[index of hash-table] -- *)
     dup
     index->address fetch One == if
       index-hashback->string print-string Exit
     then
     dup
     index->address fetch Two == if
       index-hashback->string print-string Exit
     then
     Message:print-type-tag,error print-string
     write-dec-number cr
     debuger Exit
   ; define-function


   : eq? (* [value, type], [value, type] -- True or False *)
     x|over|xx =/= if
       drop drop2 False Exit
     then
     x|over|xx =/= if
       drop2 False Exit
     then
     drop2 True Exit
   ; define-function
   #+end_src
** dictionary operations
*** >< note
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    (*
     * a word in the dictionary [unit : Cell-width = 8 bytes]
     *   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     *   ||  m : name-string  ||
     *   ||  1 : SizeOfFunctionBody ||
     *   ||  1 : identification  ||
     *   ||  1 : link  ||
     *   ||  1 : type  ||
     *   ||  1 : address-of-name-string-header  ||
     *   ||  1 : address-of-explainer  ||
     *   ||  n : body  ||
     * where
     *   ||  1 : type  ||
     * ==
     *   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
     * type-bit-0 is for HiddenWord
     * type-bit-1 is for VariableOfTypedValue [DynamicVar]
     *)

    : last-word-in-dictionary? (* word[address of link] -- True or False *)
        zero? Exit
    ; define-function

    : next-word-in-dictionary
      (* word[address of link] -- next-word[address of link] *)
        fetch Exit
    ; define-function

    : fetch-word-type (* word[address of link] -- WordType *)
        add8 fetch
        Exit
    ; define-function

    : save-word-type (* word[address of link], WordType -- *)
        swap add8 save
        Exit
    ; define-function


    0 : Offset-for-hidden-word          ; define-constant
    1 : Offset-for-dynamic-variable-word ; define-constant

    : dynamic-variable-word? (* word[address of link] -- True or False *)
        fetch-word-type Offset-for-dynamic-variable-word fetch-bit one?
        Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    : ~ (* word[address of link] -- word[address of link] *)
        dup dynamic-variable-word? .
        (* dup last-word-in-dictionary? . *)
        next-word-in-dictionary
      Exit
    ; define-function

    first-word-in-dictionary fetch

    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    #+end_src
* incremental-gc of <pair> & <string>
** note
   1. this gc is a incremental-gc
      a marking-gc for pair
      a copy-gc for string
   2. if string-heap is used up
      before PairConstructionsArray is used up
      gc must be restart
      so string-heap should be large to avoid this
   3. there are two way to represent string now:
      1) [address, length]
      2) [address, <string>]
         in this one,
         there must be 4-bytes in address-4
         to save the length of the string
** dynamic-allocation of string
*** try,copy-substring,from->to
    #+begin_src cicada :tangle english-core.cicada
    (* example of a substring stored in string-heap :
       || 4 : length of substring  ||
       || n : substring  ||
     *)

    String-heap-1 : Pointer:String-heap,from ; define-variable
    String-heap-2 : Pointer:string-heap,to   ; define-variable

    String-heap-1 : Current-free-string-address,from ; define-variable
    String-heap-2 : Current-free-string-address,to   ; define-variable



    (*
     * : fetch-four-bytes (\* address -- value *\)
     *   Zero fetch-argument-stack-pointer
     *   x|over|xx swap
     *   Four copy-byte-string
     *   swap drop
     *   Exit
     * ; define-function
     *
     * : save-four-bytes (\* value, address -- *\)
     *   swap fetch-argument-stack-pointer
     *   x|over|xx
     *   Four copy-byte-string
     *   drop2
     *   Exit
     * ; define-function
     *)



    : get-length-of-string (* string[address] -- length *)
      sub4 fetch-four-bytes
      Exit
    ; define-function

    : string-in?string-heap,from (* string[address] -- True or False *)
      Pointer:String-heap,from fetch
      over over
      Size-of-string-heap +  <
      xx|swap|x  >=
      bitwise-and
      Exit
    ; define-function

    : string-in?string-heap,to (* string[address] -- True or False *)
      Pointer:string-heap,to fetch
      over over
      Size-of-string-heap +  <
      xx|swap|x  >=
      bitwise-and
      Exit
    ; define-function

    : with-length,copy-byte-string
      (* source address, destination address, length -- *)
      dup x|over|xx save-four-bytes
      swap add4 swap
      copy-byte-string
      Exit
    ; define-function

    : try,copy-substring,from->to
      (* [address, <substring>] -- [address, <substring>] *)
      (*
       * dup <substring> =/= if
       *   Exit
       * then
       *)
      over dup
      string-in?string-heap,to if
        drop Exit
      then
      Current-free-string-address,to fetch
      over get-length-of-string
      with-length,copy-byte-string
      (* set return value *)
      Current-free-string-address,to fetch add4
      |123->321|
      (* update Current-free-string-address,to *)
      get-length-of-string add4
      Current-free-string-address,to add-save
      Exit
    ; define-function

    (* test: *)
    (*
     * Current-free-string-address,to fetch
     *   s" xxx " dup2 print-string (\* xxx *\)
     *   drop <substring>
     *   try,copy-substring,from->to
     *   drop2
     * add4 dup
     * get-length-of-string
     * print-string (\* xxx *\)
     *)


    : try,copy-substring,from->to,for-car
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      over fetch2 (* this line is as car *)
      dup <substring> =/= if
        drop2 (* drop car *)
        Exit
      then
      try,copy-substring,from->to
      x|over|xxx save2 (* this line is as set-car! *)
      Exit
    ; define-function

    : try,copy-substring,from->to,for-cdr
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      over Car-bytes-size + fetch2 (* this line is as cdr *)
      dup <substring> =/= if
        drop2 (* drop cdr *)
        Exit
      then
      try,copy-substring,from->to
      x|over|xxx Car-bytes-size + save2 (* this line is as set-cdr! *)
      Exit
    ; define-function


    (*
     * {* s" xxx" drop <substring>
     *    s" ppp" drop <substring> *}
     *
     * dup2
     *   car print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* xxx *\)
     * dup2
     *   cdr print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* ppp *\)
     *
     * dup2
     *   car drop .hex cr (\* >< *\)
     * dup2
     *   cdr drop .hex cr (\* >< *\)
     *
     * dup2
     *   try,copy-substring,from->to,for-car
     *   try,copy-substring,from->to,for-cdr
     *
     * dup2
     *   car print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* xxx *\)
     * dup2
     *   cdr print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* ppp *\)
     *
     * (\* the two hex numbers must be different *\)
     * dup2
     *   car drop .hex cr (\* >< *\)
     * dup2
     *   cdr drop .hex cr (\* >< *\)
     *
     * drop2
     *)
    #+end_src
*** read-string
    #+begin_src cicada :tangle english-core.cicada
    : read-non-string-ending-char (* -- FirstNonBlankChar or Zero *)
      read-char
      dup '"' == if
        drop Zero
      then Exit
    ; define-function

    : help:read-string,loop (* begin-address -- end-address *)
      read-non-string-ending-char
      dup zero? if
        drop Exit
      then
      over save-byte
      add1
      help:read-string,loop
      Exit
    ; define-recursive-function

    : read-string (* -- string[address, length] *)
      Current-free-string-address,from fetch add4
      dup (* leave begin-address *)
        help:read-string,loop
      dup (* leave end-address *)
        Current-free-string-address,from save
      over -
      dup (* return: length *)
      x|over|xx (* return: address *)
      sub4 save-four-bytes
      Exit
    ; define-function

    : s" (* -- string[address, length] *)
      read-string Exit
    ; define-function

    (* test: *)
    (* s" 123 xxx aaa !!! @@@ ###" print-string *)
    #+end_src
** gc & <pair> & <string>
*** notation
    Lisp was originally implemented on the IBM 704 computer, in the late 1950s.
    The 704 hardware had special support for
    splitting a 36-bit machine word into four parts:
    1. address part   : 15 bits
    2. decrement part : 15 bits
    3. prefix part    : 3 bits
    4. tag part       : 3 bits
    Precursors to Lisp included the following functions:
    (The term "register" in the following context refers to "memory location")
    1. car : Contents of the Address part of Register number
    2. cdr : Contents of the Decrement part of Register number
    3. cpr : Contents of the Prefix part of Register number
    4. ctr : Contents of the Tag part of Register number
    --------------------------------------------------------
    in my cicada, for my PairConstruction
    I introduce the following c*r functions:
    (maybe more in the future, if needed)
    1. clr : color byte
       for garbage-collection
    2. car : contents of the address part of a PairConstruction
       as the first typed-value of a pair
    3. cdr : contents of the decrement part of a PairConstruction
       as the second typed-value of a pair
*** the construction & clr, car, cdr
    #+begin_src cicada :tangle english-core.cicada
    (* the construction of pair : [unit : byte]
     * clr:
     *     ||  1 : color     ||
     * car:
     *     ||  8 : type tag  ||
     *     ||  8 : value     ||
     * cdr:
     *     ||  8 : type tag  ||
     *     ||  8 : value     ||
     *)

    (* the following constants are defined in assembler:
     * Cons-bytes-size == 33
     * Clr-bytes-size  ==  1
     * Car-bytes-size  == 16
     * Cdr-bytes-size  == 16
     *)

    :" clr said:
       ``My function-type is (* [address, <pair-like>] -- color-byte *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:clr,type-error ; define-constant-string
    : clr (* [address, <pair-like>] -- color-byte *)
      dup <not-pair-like>? if
        Message:clr,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      sub1 fetch-byte Exit
    ; define-function


    :" car said:
       ``My function-type is (* [address, <pair-like>] -- [value, type] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:car,type-error ; define-constant-string
    : car (* [address, <pair-like>] -- [value, type] *)
      dup <not-pair-like>? if
        Message:car,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      fetch2 Exit
    ; define-function


    :" cdr said:
       ``My function-type is (* [address, <pair-like>] -- [value, type] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:cdr,type-error ; define-constant-string
    : cdr (* [address, <pair-like>] -- [value, type] *)
      dup <not-pair-like>? if
        Message:cdr,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      Car-bytes-size + fetch2 Exit
    ; define-function
    #+end_src
*** color & set-clr!
    two colors is enough
    a black pair in GreyPairStackTop is as a ``grey'' pair
    a grey-pair denotes front of the spreading black sub-graph
    these nodes maybe at the junction of black and white (maybe not)
    #+begin_src cicada :tangle english-core.cicada
    0 : White ; define-constant
    1 : Black ; define-constant


    (* set three offsets used by fetch-byte, set-bit, clear-bit *)
    0 : Mutative-color-offset-for-finding  ; define-variable
    1 : Mutative-color-offset-for-marking  ; define-variable
    2 : Mutative-color-offset-for-cleaning ; define-variable
    : Color-offset-for-finding  Mutative-color-offset-for-finding  fetch Exit ; define-function
    : Color-offset-for-marking  Mutative-color-offset-for-marking  fetch Exit ; define-function
    : Color-offset-for-cleaning Mutative-color-offset-for-cleaning fetch Exit ; define-function

    :" set-clr! said:
       ``My function-type is (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-clr!,type-error ; define-constant-string
    : set-clr! (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
      over dup  <not-pair-like>? if
        Message:set-clr!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      x|over|xx sub1 save-byte Exit
    ; define-function
    #+end_src
*** marking
    #+begin_src cicada :tangle english-core.cicada
    : white-color-for-marking? (* color-byte -- True or False *)
      Color-offset-for-marking fetch-bit White == Exit
    ; define-function

    : black-color-for-marking? (* color-byte -- True or False *)
      Color-offset-for-marking fetch-bit Black == Exit
    ; define-function

    : black-<pair>? (* [address, <pair-like>] -- True or False *)
      clr black-color-for-marking? Exit
    ; define-function


    (* the following function is the only function who push-grey-pair-stack
     * and this function is called by one,grey->black and so on *)
    :" try,white->grey said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:try,white->grey,type-error ; define-constant-string
    : try,white->grey (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
        Message:try,white->grey,type-error print-string
        dup print-type-tag cr
        debuger
        Exit
      then
      dup2 clr
      dup
      white-color-for-marking? if
        Color-offset-for-marking set-bit set-clr!

        try,copy-substring,from->to,for-car
        try,copy-substring,from->to,for-cdr
        over push-grey-pair-stack
        Exit
      then
      drop (* drop the color-byte *) Exit
    ; define-function


    : one,try,grey->black (* -- *)
      empty-grey-pair-stack? if
        Exit
      then
      pop-grey-pair-stack dup
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
        Car-bytes-size +
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
      Exit
    ; define-function


    (* the following is a help-function of all,grey->black
     * the GreyPairStack must not be empty when it is called *)

    : one,grey->black (* -- *)
      pop-grey-pair-stack dup
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
        Car-bytes-size +
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
      Exit
    ; define-function

    : all,grey->black (* -- *)
      empty-grey-pair-stack? if
        Exit
      then
      one,grey->black
      all,grey->black Exit
    ; define-recursive-function
    #+end_src
*** set!, set-car!, set-cdr!
    in cicada, to make the gc to be incremental
    there are many strategies you can use
    the following shows one of them
    #+begin_src cicada :tangle english-core.cicada
    : set!
      (* VarForTypedValue[address], [value, type] -- VarForTypedValue[address] *)
      dup <pair-like>? if
        all,grey->black (* to be incremental-gc is to call this function here *)
        try,white->grey
      then
      x|over|xx save2
      Exit
    ; define-function


    : help:set-car!&set-cdr!,for-black-<pair>
      (* [valus, type] -- [valus, type] *)
      dup <pair-like>? if
        all,grey->black (* to be incremental-gc is to call this function here *)
        try,white->grey
      then
      Exit
    ; define-function


    :" set-car! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car!,type-error ; define-constant-string

    : set-car!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:set-car!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx save2
      Exit
    ; define-function


    :" set-cdr! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-cdr!,type-error ; define-constant-string

    : set-cdr!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:set-cdr!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx Car-bytes-size + save2
      Exit
    ; define-function


    (* ------------------------------------------------- *)


    :" [cons,car]! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[cons,car]!,type-error ; define-constant-string

    : [cons,car]!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:[cons,car]!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx save2
      Exit
    ; define-function


    :" [cons,cdr]! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[cons,cdr]!,type-error ; define-constant-string

    : [cons,cdr]!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:[cons,cdr]!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx Car-bytes-size + save2
      Exit
    ; define-function


    (* ------------------------------------------------- *)


    :" [car,cons]! said:
       ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
         If I view the first argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[car,cons]!,type-error ; define-constant-string

    : [car,cons]!
      (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
      (* you can read this as ``car-cons-set'' *)
      dup <not-pair-like>? if
        Message:[car,cons]!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 black-<pair>? if
        xx|swap|xx help:set-car!&set-cdr!,for-black-<pair> xx|swap|xx
      then
      xx|tuck|xx
      drop save2
      Exit
    ; define-function


    :" [cdr,cons]! said:
       ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
         If I view the first argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[cdr,cons]!,type-error ; define-constant-string

    : [cdr,cons]!
      (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
      (* you can read this as ``cdr-cons-set'' *)
      dup <not-pair-like>? if
        Message:[cdr,cons]!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 black-<pair>? if
        xx|swap|xx help:set-car!&set-cdr!,for-black-<pair> xx|swap|xx
      then
      xx|tuck|xx
      drop Car-bytes-size + save2
      Exit
    ; define-function
    #+end_src
*** marking & define
    define and set! are the interface of dynamic-typed-value
    #+begin_src cicada :tangle english-core.cicada
    (* recall
     * a word in the dictionary [unit : Cell-width = 8 bytes]
     *   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     *   ||  m : name-string  ||
     *   ||  1 : SizeOfFunctionBody  ||
     *   ||  1 : identification  ||
     *   ||  1 : link  ||
     *   ||  1 : type  ||
     *   ||  1 : address-of-name-string-header  ||
     *   ||  1 : address-of-explainer  ||
     *   ||  n : body  ||
     * where
     *   ||  1 : type  ||
     * ==
     *   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
     * type-bit-0 is for HiddenWord
     * type-bit-1 is for VariableOfTypedValue
     *)

    : create-word-header-for-typed-value
      (* string[address, length] -- word[address of link] *)
      Here fetch xx|swap|x (* address-of-name-string-header *)
      append-string-to-here
      Here fetch append-number-to-here (* identification *)
      Here fetch (* leave the word[link] *)
      Zero append-number-to-here (* link *)
      Two append-number-to-here  (* type *)
      swap
      append-number-to-here (* address-of-name-string-header *)
      Exit
    ; define-function

    : define,by-string
      (* [value, type], string[address, length] -- *)
      create-word-header-for-typed-value
      Variable-explainer append-number-to-here
      xx|swap|x  (* leave wordHeader *)
      dup <pair-like>? if
        try,white->grey
      then
      append-number-to-here append-number-to-here
      add-new-word-to-dictionary
      Exit
    ; define-function

    : define
      (* [value, type], wordList[address, the number of words] -- *)
      head-of-word-list
      define,by-string
      Exit
    ; define-function
    #+end_src
*** finding & cons : constructor of <pair>
    #+begin_src cicada :tangle english-core.cicada
    (* the following functions are helping cons *)

    : clear-color-bit-of-pair-for-cleaning (* pair[address] -- pair[address] *)
      <pair>
      dup2 clr
      Color-offset-for-cleaning clear-bit
      set-clr!
      drop
      Exit
    ; define-function

    : white-color-for-finding? (* color-byte -- True or False *)
      Color-offset-for-finding fetch-bit White ==
      Exit
    ; define-function

    : find-next-free-pair-construction
      (* pair[address] -- Zero or NextFreePairConstruction[address] *)
      dup Last-pair-construction == if
        drop Zero Exit
      then
      Cons-bytes-size +
      clear-color-bit-of-pair-for-cleaning
      dup <pair> clr
      white-color-for-finding? if
        Exit
      then
      find-next-free-pair-construction
      Exit
    ; define-recursive-function



    (* a cyclic permutation
     * of the two three period cyclic permutation
     * in the third-order permutation group
     Mutative-color-offset-for-finding  --> Mutative-color-offset-for-cleaning
     Mutative-color-offset-for-marking  --> Mutative-color-offset-for-finding
     Mutative-color-offset-for-cleaning --> Mutative-color-offset-for-marking
     *)
    : reset-color-offsets (* -- *)
      Mutative-color-offset-for-finding  fetch
      Mutative-color-offset-for-marking  fetch
      Mutative-color-offset-for-cleaning fetch
      Mutative-color-offset-for-marking  save
      Mutative-color-offset-for-finding  save
      Mutative-color-offset-for-cleaning save
      Exit
    ; define-function


    : dynamic-variable-word-for-<pair-like>?
      (* word[address of link] -- True or False *)
      dup dynamic-variable-word? if
      word-link->word-explainer execute fetch2
      swap drop
      <pair-like>?
      Exit
      then
      drop False Exit
    ; define-function

    : help:push-all-root-node-into-grey-pair-stack
      (* word[address of link] -- *)
      dup last-word-in-dictionary? if
        drop Exit
      then
      dup dynamic-variable-word-for-<pair-like>? if
      dup word-link->word-explainer execute fetch2
      try,white->grey drop2
      then
      next-word-in-dictionary
      help:push-all-root-node-into-grey-pair-stack
      Exit
    ; define-recursive-function

    : push-all-root-node-into-grey-pair-stack (* -- *)
        first-word-in-dictionary fetch
        help:push-all-root-node-into-grey-pair-stack
        Exit
    ; define-function



    (* the following function is not intrinsic
       but I have to use it this way *)

    (* a value meet the following three conditions is an AddressOfPair
     *  (the following is infix notations)
     * 1. Value >= First-pair-construction
     * 2. Value <= Last-pair-construction
     * 3. [Value - First-pair-construction] mod Cons-bytes-size == 0
     *)

    : addressOfPair? (* value -- True or False *)
        dup First-pair-construction < if
          drop False Exit
        then
        dup Last-pair-construction > if
          drop False Exit
        then
        First-pair-construction - Cons-bytes-size mod zero?
        Exit
    ; define-function



    : help:all-pairs-in-argument-stack,try,white->grey
      (* address of a Cell in ArgumentStack -- *)
        dup Argument-stack-top > if
          drop Exit
        then
        dup fetch addressOfPair? if
          dup fetch
          <pair> try,white->grey
          drop2
        then
        Cell-width +
        help:all-pairs-in-argument-stack,try,white->grey
        Exit
    ; define-recursive-function

    : all-pairs-in-argument-stack,try,white->grey (* -- *)
        fetch-argument-stack-pointer
        help:all-pairs-in-argument-stack,try,white->grey
        Exit
    ; define-function


    : help:all-pairs-in-lambda-stack,try,white->grey
      (* address of a Cell in LambdaStack -- *)
      dup Lambda-stack-top > if
        drop Exit
      then
      dup fetch addressOfPair? if
        dup fetch
        <pair> try,white->grey
        drop2
      then
      Cell-width +
      help:all-pairs-in-lambda-stack,try,white->grey
      Exit
    ; define-recursive-function

    : all-pairs-in-lambda-stack,try,white->grey (* -- *)
      Lambda-stack-pointer fetch
      help:all-pairs-in-lambda-stack,try,white->grey
      Exit
    ; define-function



    : resetVariablesAboutString (* -- *)
      Current-free-string-address,to fetch Current-free-string-address,from save
      Pointer:String-heap,from       fetch Current-free-string-address,to   save
      Pointer:string-heap,to         fetch Pointer:String-heap,from         save
      Current-free-string-address,to fetch Pointer:string-heap,to           save
      Exit
    ; define-function


    :"  :gc: "
    : Message:gc ; define-constant-string

    :" cons said: ``Memory for cons is used up! No value is returned!''"
    : Message:cons,memory-is-used-up ; define-constant-string

    : cons (* -- [address, <pair>] *)
        Current-free-pair-construction fetch <pair> (* leave the return <value> *)
        Current-free-pair-construction fetch find-next-free-pair-construction
        dup not-zero? (* Zero denotes fail to find *) if
          Current-free-pair-construction save
          Exit
        then drop (* drop the Zero, which denotes fail to find, need gc *)
        all-pairs-in-argument-stack,try,white->grey
        all,grey->black
        reset-color-offsets resetVariablesAboutString (* note the timing to reset *)
        push-all-root-node-into-grey-pair-stack
        In-front-of-the-first-pair-construction find-next-free-pair-construction
        dup not-zero? if
          Current-free-pair-construction save
          Message:gc print-string
          Exit
        then drop
        (* if after gc still fail to find, we know the memory is used up *)
        drop2
        Message:cons,memory-is-used-up print-string cr
        debuger
        Exit
    ; define-function
    #+end_src
*** substring & string : constructor of <substring> & <string>
    #+begin_src cicada :tangle english-core.cicada
    : read-string (* -- [address, <string>] *)
      cons drop (* drop <pair> *) <string>
      s" drop (* drop length *) <substring>
      set-car!
      null set-cdr!
      Exit
    ; define-function

    : ::" (* -- [address, <string>] *)
      read-string Exit
    ; define-function


    :" write-string said:
       ``My function-type is ( [address, <string>] -- ).
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:write-string,type-error ; define-constant-string

    : write-string (* [address, <string>] -- *)
      dup <string> =/= if
        Message:write-string,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      car drop (* drop <substring> *)
      dup get-length-of-string print-string
      Exit
    ; define-function

    : substring (* length -- address *)
      (* allocate a substring of the given length *)
      Current-free-string-address,from fetch add4 swap (* leave begin-address *)
      dup Current-free-string-address,from fetch save-four-bytes
      Four + Current-free-string-address,from add-save
      Exit
    ; define-function

    : string (* length -- [address, <string>] *)
      (* allocate a string of the given length *)
      substring <substring>
      null
      cons drop <string>
      [cdr,cons]!
      [car,cons]!
      Exit
    ; define-function
    #+end_src
*** about test
    #+begin_src cicada :tangle english-core.cicada
    (* for test *)
    : print-type-of-it (* type -- *)
      print-type-tag ':' write-char write-space Exit
    ; define-function

    (* test: gc *)
    : ask-for-lots-of-cons (* n -- *)
        dup zero? if drop Exit
        then
        sub1
        cons
          555 <fixnum> set-car!
          666 <fixnum> set-cdr!
        drop2
        ask-for-lots-of-cons
        Exit
    ; define-recursive-function

    : ask-for-lots-of-cons,leave-them-on-the-argument-stack (* n -- *)
        dup zero? if drop Exit
        then
        sub1
        cons
          555 <fixnum> set-car!
          666 <fixnum> set-cdr!
        x|swap|xx
        ask-for-lots-of-cons,leave-them-on-the-argument-stack
        Exit
    ; define-recursive-function
    #+end_src
** test
   #+begin_src cicada
   : {* cons Exit ; define-function
   : *} xx|swap|xxxx [cdr,cons]! [car,cons]! Exit ; define-function


   (* test: define *)
   6 <fixnum> : Liu-fixnum ; define
   Liu-fixnum fetch2 print-type-of-it . cr (* <fixnum>: 6 *)

   (* test: cons *)
   cons 9 <fixnum> set-car!
        8 <fixnum> set-cdr!
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2

   {* 9 <fixnum>  8 <fixnum> *}
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2

   (* test: cons *)
   9 <fixnum>  8 <fixnum>  cons
   [cdr,cons]! [car,cons]!
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2


   (* test: define a pair *)
   cons 9 <fixnum> set-car!
        8 <fixnum> set-cdr!
   : Simple-pair ; define
   Simple-pair fetch2
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2


   (* test: set-car! & set-cdr! *)
   Simple-pair fetch2
     {* 7 <fixnum>   6 <fixnum> *}
   set-car!
   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)
   drop2




   Simple-pair fetch2
     {* 5 <fixnum>
        {* 4 <fixnum>  3 <fixnum> *} *}
   set-cdr!

   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)
   dup2
     cdr car print-type-of-it . cr (* <fixnum>: 5 *)
   dup2
     cdr cdr car print-type-of-it . cr (* <fixnum>: 4 *)
   dup2
     cdr cdr cdr print-type-of-it . cr (* <fixnum>: 3 *)
   drop2




   (* test: all,grey->black *)
     empty-grey-pair-stack? . cr (* 0 *)
     all,grey->black
     empty-grey-pair-stack? . cr (* 1 *)


   (* test: marking *)
     Simple-pair fetch2
     cdr cdr clr Color-offset-for-marking fetch-bit . cr (* 1 *)




   all,grey->black


   (* test: reset set-cdr! *)
   Simple-pair fetch2
     {* 1 <fixnum>
        {* 2 <fixnum>  3 <fixnum> *} *}
   set-cdr!

   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)

   dup2
     cdr car print-type-of-it . cr (* <fixnum>: 1 *)
   dup2
     cdr cdr car print-type-of-it . cr (* <fixnum>: 2 *)
   dup2
     cdr cdr cdr print-type-of-it . cr (* <fixnum>: 3 *)
   drop2



   (* test: gc *)
   : ask-for-lots-of-cons (* n -- *)
       dup zero? if drop Exit
       then
       sub1
       {* 555 <fixnum>
          666 <fixnum> *}
       drop2
       ask-for-lots-of-cons
       Exit
   ; define-recursive-function


   Number-of-pair-constructions ask-for-lots-of-cons

   Number-of-pair-constructions 30 * ask-for-lots-of-cons




   (* after gc the Simple-pair must still be ok *)
   Simple-pair fetch2

   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)
   dup2
     cdr car print-type-of-it . cr (* <fixnum>: 1 *)
   dup2
     cdr cdr car print-type-of-it . cr (* <fixnum>: 2 *)
   dup2
     cdr cdr cdr print-type-of-it . cr (* <fixnum>: 3 *)
   drop2



   (* ----------------------------------------------------------- *)
   (* after gc the values in the stack must still be ok *)

   {* {* 147 <fixnum>
         258 <fixnum> *}
      369 <fixnum> *}

   Number-of-pair-constructions 30 * ask-for-lots-of-cons

   dup2

   cr
   dup2
      car car print-type-of-it . cr (* <fixnum>: 147 *)
   dup2
      car cdr print-type-of-it . cr (* <fixnum>: 258 *)
   dup2
      cdr print-type-of-it . cr (* <fixnum>: 369 *)
   drop2
   ok

   Number-of-pair-constructions 30 * ask-for-lots-of-cons

   cr
   dup2
      car car print-type-of-it . cr (* <fixnum>: 147 *)
   dup2
      car cdr print-type-of-it . cr (* <fixnum>: 258 *)
   dup2
      cdr print-type-of-it . cr (* <fixnum>: 369 *)
   drop2
   ok





   (* ----------------------------------------------------------- *)
   (* about string *)
   (* after gc the values in the stack must still be ok *)


   ::" 111 "
   Number-of-pair-constructions  ask-for-lots-of-cons
   ::" 222 "
   Number-of-pair-constructions  ask-for-lots-of-cons
   ::" 333 "
   Number-of-pair-constructions  ask-for-lots-of-cons
   Number-of-pair-constructions  ask-for-lots-of-cons
   cr ok

   write-string write-string write-string (* 333 222 111 *)
   cr


   ::" aaa "
   : Simple-string ; define
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   ::" AAA "
   ::" AAA "
   Number-of-pair-constructions 20 * ask-for-lots-of-cons
   ok (* yse *)

   Simple-string fetch2 write-string (* aaa *)

   Number-of-pair-constructions  ask-for-lots-of-cons
   write-string write-string write-string (* AAA AAA AAA *)
   cr
   Number-of-pair-constructions  ask-for-lots-of-cons
   write-string write-string write-string (* AAA AAA AAA *)
   cr





   (* ----------------------------------------------------------- *)
   (* about using up memory *)


   (*
    ,* Number-of-pair-constructions
    ,* ask-for-lots-of-cons,leave-them-on-the-argument-stack
    ,*
    ,*
    ,* (\* in debuger-REPL: *\)
    ,*   1 debuger,fetch-from-return-stack trace-function
    ,*   2 debuger,fetch-from-return-stack trace-function
    ,*
    ,* basic-REPL count-argument-stack . cr (\* 0 *\)
    *)
   #+end_src
* list-processing
** about list-processing
*** note
    1. I mimic the naming conventions
       of the bra-ket notation in quantum mechanics
    2. I use ``bracket'' to denotes all kinds of brackets :
       - round  :: ()
       - square :: []
       - flower :: {}
       - angle  :: <>
       - note that, they all have lots of other names
         the above will be used by me
       - it feels so bad that only these brackets are available in ASCII
       - punctuations ":" and ";" as a pair
         are also used as ``brackets'' by me
         I call them ``cosemi''
       - more pairs of sequences of two or more characters
         will be used by me in the future
       - and "." is called a ``mid''
    3. but the value you put into a list or a dalin
       should always be converted to dynamic-typed-value
       while they should always be read as simple as possible
    4. I found out that to parse post-lambda expression easily
       we have to always use dalin
       so dalin should be the default-list used in cicada
    5. so I have the following notations about list-processing :
       | { } | list   | single-linked-list |
       | [ ] | dalin  | double-linked-list |
       | ( ) | wodyli | wordy-list         |
    6. if I define ``['' and ``{'' as readers
       then, as functions the have to call each other
       due to the semantic of cicada
       this calls can not be compiled into the function-bodys of them
       unless I introduce new syntaxes
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    :" {" : Bra:flower ; define-constant-string
    :" }" : Ket:flower ; define-constant-string

    :" ." : Mid:dot ; define-constant-string

    :" (esc" : Bra:round-escape ; define-constant-string
    :" )"    : Ket:round-escape ; define-constant-string

    :" [" : Bra:square ; define-constant-string
    :" ]" : Ket:square ; define-constant-string

    :" (" : Bra:round ; define-constant-string
    :" )" : Ket:round ; define-constant-string
    #+end_src
** write
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    :" write-list"    : Message:write-list   ; define-constant-string
    :" write-*dalin"  : Message:write-*dalin ; define-constant-string
    :" write-wodyli"  : Message:write-wodyli ; define-constant-string
    :" write-wody-or-bound-variable"
    : Message:write-wody-or-bound-variable ; define-constant-string

    :" null"  : Message:null ; define-constant-string

    :" write said:
       ``I do not know how to write the following type of value,
         I will not touch it and call debuger.''
       --> "
    : Message:write,type-error ; define-constant-string

    : write (* [value, type] -- *)
      dup <fixnum> == if drop (* drop type-tag *)
        write-dec-number  write-space
        Exit
      then
      dup <symbol> == if drop (* drop type-tag *)
        index-hashback->string print-string  write-space
        Exit
      then
      dup <null> == if drop (* drop type-tag *)
        drop
        Message:null print-string write-space
        Exit
      then
      dup <list> == if
        Message:write-list find word-link->word-explainer execute
        Exit
      then
      dup <dalin> == if
        Message:write-*dalin find word-link->word-explainer execute
        Exit
      then
      dup <wody> ==
      over <bound-variable> ==
      bitwise-or if
        Message:write-wody-or-bound-variable find word-link->word-explainer execute
        Exit
      then
      dup <wodyli> == if
        Message:write-wodyli find word-link->word-explainer execute
        Exit
      then
      Message:write,type-error print-string
      dup print-type-tag cr
      debuger Exit
    ; define-function
    #+end_src
** read-list & write-list
*** note
    1. this is the old good lisp-like single-linked-list
    2. like the language shen
       I do not use '() to quote a list (as in LISP)
       but use {} and []
       [ 1 (esc + 1 1 ) 3 ] or
       { 1 (esc + 1 1 ) 3 } as
       `(1 ,(+ 1 1) 3) in LISP
       because ``quote'' in LISP is just to provide you
       a convenient mechanism to read a list
    3. the good about LISP's way is that
       you can quote a symbol out side the list as 'a-symbol
       otherwise the symbol will be treated as a variable
    4. while in shen
       if one type ``a-symbol'' into the REPL
       it will be treated as a symbol
       you have to use a explicit way
       to treat it as a variable i.e. ``(value a-symbol)''
    5. in cicada things are very different
       no analogy should be drawed here
    6. the ``list-escape'' is very interesting
       it is to call a another reader in a list-reader
       and get back to the list-reader when finished
       it looks like the classic forth REPL
       which have two modes
       at first in the implementation of cicada
       I try to avoid many modes in REPL
       but now the list-leader brings me back to the classic forth
*** execute-word,for-list-reader
    #+begin_src cicada :tangle english-core.cicada
    : string-denote-list-reader?
      (* string[address, length] -- True or False *)
      dup2 Bra:flower equal-string? if
        drop2 True Exit
      then
      dup2 Bra:round-escape equal-string? if
        drop2 True Exit
      then
      dup2 Bra:square equal-string? if
        drop2 True Exit
      then
      dup2 Bra:round equal-string? if
        drop2 True Exit
      then
      drop2 False Exit
    ; define-function

    (* then we need mutually recursive call *)
    : execute-word,for-list-reader
      (* string[address, length] -- [value, type] *)
      dup2 string-denote-list-reader? if
        find word-link->word-explainer execute
        Exit
      then
      dup2 string-denote-integer? if
        string->integer,with-error drop <fixnum>
        Exit
      then
      dup2 Message:null equal-string? if
        drop2 null
        Exit
      then
      string-hash->index <symbol>
      Exit
    ; define-function
    #+end_src
*** list-escape-REPL
    #+begin_src cicada :tangle english-core.cicada
    : list-escape-REPL
      (* could  be: unknown -- unknown *)
      (* should be:  -- [value, type] *)
      read-word-for-runtime
      dup2
      string-denote-integer? if
        string->integer,with-error drop
        list-escape-REPL
        Exit
      then
      dup2
      Ket:round-escape equal-string? if
        drop2
        Exit
      then
      dup2 find dup not-zero? if
        xx|swap|x drop2
        word-link->word-explainer execute
        list-escape-REPL
        Exit
      then
      drop
      Message:undefined-word print-string
      print-string cr
      list-escape-REPL
      Exit
    ; define-recursive-function

    : (esc list-escape-REPL Exit ; define-function
    #+end_src
*** read-list
    #+begin_src cicada :tangle english-core.cicada
    : read-list (* -- [address, <list>] *)
      read-word
      dup2 Ket:flower equal-string? if
        drop2
        null Exit
      then
      dup2 Mid:dot equal-string? if
        drop2
        read-list car
        (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
        Exit
      then
      execute-word,for-list-reader
      cons drop <list>
        xx|swap|xx  set-car!
        read-list   set-cdr!
      Exit
    ; define-recursive-function

    : { read-list Exit ; define-function
    #+end_src
*** write-list
    #+begin_src cicada :tangle english-core.cicada
    : help:write-list (* [address, <list>] or [Null, <null>] -- *)
      dup <null> == if
        drop2 Exit
      then
      dup <pair-like>? if
        dup2
        car write
        cdr help:write-list
        Exit
      then
      Mid:dot print-string write-space
      write
      Exit
    ; define-recursive-function


    :" write-list said:
       ``My function-type is (* [address, <list>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-list,type-error ; define-constant-string

    : write-list (* [address, <list>] -- *)
      dup <list> =/= if
        Message:write-list,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      Bra:flower print-string write-space
      help:write-list
      Ket:flower print-string write-space
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    { 1
      { 1 2 3 4 5   { 1 2 3 4 5  6 }  6  }
        xxx 3 4 5
      { 1 2 3 4 5  6 } 6 }
    write-list

    { 1 . 2 } write-list
    { 1 2 3 4 5 6 7 8 9 . 0 } write-list
    { 1 . { 1 . 2 } } write-list
    { 1 . { 1 . (esc 2 <fixnum> ) } } write-list
    { 1 . { 1 . (esc 2 <fixnum> ) } } write


    (* beware of the following,
       error will not occurs ! *)

    { 1 . 2 3 }
    write-list  (* { 1 . 2 } *)

    { 1 . 2 { 1 . 2 3 } }
    write-list  (* { 1 . 2 } *)


    (* test: mutually recursive call *)
    { 1 [ 1 2 3 ] { 1 . (esc 2 <fixnum> ) } } write
    { 1 [ 1 2 3 ] . { 1 . (esc 2 <fixnum> ) } } write
    #+end_src
** set-*!
*** >< note
    the name of the following functions should be changed
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    :" set-car-to-{car}! said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{car}!,type-error ; define-constant-string
    (* [car.cdr]->[[car].cdr] *)
    : set-car-to-{car}!
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
        Message:set-car-to-{car}!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2
      car cons
        xx|swap|xx set-car!
        null set-cdr!
      set-car!
      Exit
    ; define-function


    :" set-car-to-{cdr}! said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{cdr}!,type-error ; define-constant-string
    (* [car.cdr]->[car.[cdr]] *)
    : set-cdr-to-{cdr}!
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
        Message:set-car-to-{cdr}!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2
      cdr cons
        xx|swap|xx set-car!
        null set-cdr!
      set-cdr!
      Exit
    ; define-function




    :" set-car-to-{car.x}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{car.x}!,type-error ; define-constant-string

    : set-car-to-{car.x}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{car.x}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      car cons
        xx|swap|xx set-car!
        xx|swap|xx set-cdr!
      set-car!
      Exit
    ; define-function


    :" set-car-to-{cdr.x}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{cdr.x}!,type-error ; define-constant-string

    (* [car.cdr],x->[car.[cdr.x]]! *)
    : set-cdr-to-{cdr.x}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{cdr.x}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      cdr cons
        xx|swap|xx set-car!
        xx|swap|xx set-cdr!
      set-cdr!
      Exit
    ; define-function


    :" set-car-to-{x.car}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{x.car}!,type-error ; define-constant-string

    : set-car-to-{x.car}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{x.car}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      car cons
        xx|swap|xx set-cdr!
        xx|swap|xx set-car!
      set-car!
      Exit
    ; define-function


    :" set-car-to-{x.cdr}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{x.cdr}!,type-error ; define-constant-string

    : set-cdr-to-{x.cdr}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{x.cdr}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      cdr cons
        xx|swap|xx set-cdr!
        xx|swap|xx set-car!
      set-cdr!
      Exit
    ; define-function
    #+end_src
** dalin processing
*** <- & ->
    #+begin_src cicada :tangle english-core.cicada
    :" <- said:
       ``My function-type is (* [address, <dalin-like>] -- [address, <dalin>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:<-,type-error ; define-constant-string

    : <- (* [address, <dalin-like>] -- [address, <dalin>] *)
      dup <not-dalin-like>? if
        Message:<-,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      cdr car Exit
    ; define-function


    :" -> said:
       ``My function-type is (* [address, <dalin-like>] -- [address, <dalin>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:->,type-error ; define-constant-string

    : -> (* [address, <dalin-like>] -- [address, <dalin>] *)
      dup <not-dalin-like>? if
        Message:->,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      cdr cdr Exit
    ; define-function
    #+end_src
*** list->dalin
    #+begin_src cicada :tangle english-core.cicada
    (* note that:
       in the following, I am using side-effect to change a existed list
       but NOT to form a new dalin from scratch *)

    : help:list->dalin
      (* [address, <dalin>], left[address, <dalin>] -- [address, <dalin>] *)
      (* or *)
      (* [address, <dalin>], [value, <non-dalin>] -- [address, <dalin>] *)
      set-cdr-to-{x.cdr}! (* set the ``left'' *)
      dup2 cdr
        dup2 cdr <not-pair-like>? if
          drop (* drop the non-pair-value *)
          null set-cdr!
          (* this means the 3 in { 1 2 . 3 } will be droped *)
          drop2 Exit
        then
        (* change the type-tag of the cdr of the old list, from <list> to <dalin> *)
        (* the pair-like-value is still here *) <dalin> set-cdr!
        cdr
      (* [address, <dalin>], [address, <pair-like>] *)
      xx|swap|xx
      help:list->dalin
      Exit
    ; define-recursive-function


    :" list->*dalin* said:
       ``My function-type is
         (* [address, <list>] -- head[address, <dalin>], tail[address, <dalin>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:list->*dalin*,type-error ; define-constant-string

    : list->*dalin*
      (* [address, <list>] -- head[address, <dalin>], tail[address, <dalin>] *)
      dup <list> =/= if
        Message:list->*dalin*,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dalin>
      dup2 (* leave the return value *)
      null
      help:list->dalin
      Exit
    ; define-function


    :" list->dalin* said:
       ``My function-type is (* [address, <list>] -- tail[address, <dalin>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:list->dalin*,type-error ; define-constant-string

    : list->dalin*
      (* [address, <list>] -- tail[address, <dalin>] *)
      dup <list> =/= if
        Message:list->dalin*,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dalin>
      null
      help:list->dalin
      Exit
    ; define-function


    :" list->*dalin said:
       ``My function-type is (* [address, <list>] -- head[address, <dalin>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:list->*dalin,type-error ; define-constant-string

    : list->*dalin
      (* [address, <list>] -- head[address, <dalin>] *)
      dup <list> =/= if
        Message:list->*dalin,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dalin>
      dup2 (* leave the return value *)
      null
      help:list->dalin
      drop2
      Exit
    ; define-function
    #+end_src
*** *dalin? & dalin*?
    #+begin_src cicada :tangle english-core.cicada
    : *dalin? (* [address, <dalin>] -- True or False *)
      <- null? if
        True Exit
      then
      False Exit
    ; define-function

    : dalin*? (* [address, <dalin>] -- True or False *)
      -> null? if
        True Exit
      then
      False Exit
    ; define-function
    #+end_src
*** nested-list->dalin
    #+begin_src cicada :tangle english-core.cicada
    : help:nested-list->dalin
      (* [address, <dalin>], left[address, <dalin>] -- [address, <dalin>] *)
      (* or *)
      (* [address, <dalin>], [value, <non-dalin>] -- [address, <dalin>] *)
      set-cdr-to-{x.cdr}! (* set the ``left'' *)
      dup2 car dup <list> == if
        list->*dalin set-car!
      else
        drop2
      then
      dup2 cdr
        dup2 cdr <not-pair-like>? if
          drop (* drop the non-pair-value *)
          null set-cdr!
          (* this means the 3 in { 1 2 . 3 } will be droped *)
          drop2 Exit
        then
        (* change the type-tag of the cdr of the old list, from <list> to <dalin> *)
        (* the pair-like-value is still here *) <dalin> set-cdr!
        cdr
      (* [address, <dalin>], [address, <pair-like>] *)
      xx|swap|xx
      help:nested-list->dalin
      Exit
    ; define-recursive-function


    :" nested-list->*dalin said:
       ``My function-type is (* [address, <list>] -- head[address, <dalin>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:nested-list->*dalin,type-error ; define-constant-string

    : nested-list->*dalin
      (* [address, <list>] -- head[address, <dalin>] *)
      dup <list> =/= if
        Message:nested-list->*dalin,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dalin>
      dup2 (* leave the return value *)
      null
      help:nested-list->dalin
      drop2
      Exit
    ; define-function
    #+end_src
*** dalin->tail & head<-dalin
    #+begin_src cicada :tangle english-core.cicada
    :" dalin->tail said:
       ``My function-type is
         (* [address, <dalin-like>] -- tail[address, <dalin-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:dalin->tail,type-error ; define-constant-string

    : dalin->tail
      (* [address, <dalin-like>] -- tail[address, <dalin-like>] *)
      dup <not-dalin-like>? if
        Message:dalin->tail,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 dalin*? if
        Exit
      then
      ->  dalin->tail
      Exit
    ; define-recursive-function


    :" head<-dalin said:
       ``My function-type is
         (* [address, <dalin-like>] -- head[address, <dalin-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:head<-dalin,type-error ; define-constant-string

    : head<-dalin
      (* [address, <dalin-like>] -- head[address, <dalin-like>] *)
      dup <not-dalin-like>? if
        Message:head<-dalin,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 *dalin? if
        Exit
      then
      <-  head<-dalin
      Exit
    ; define-recursive-function
    #+end_src
*** [value,dalin]-associate & [value,dalin]-member?
    #+begin_src cicada :tangle english-core.cicada
    :" [value,dalin]-associate said:
       ``My function-type is
         (* [value, type], head[address, <dalin-like>] --
            associate-pair[address, <pair-like>] or [Null, <null>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[value,dalin]-associate,type-error,at-first
    ; define-constant-string

    :" [value,dalin]-associate said:
       ``My function-type is
         (* [value, type], head[address, <dalin-like>] --
            associate-pair[address, <pair-like>] or [Null, <null>] *)
         But in the middle of recursion
         I found the dalin is not an associated-dalin
         the following is what I found
         I will not touch it and call debuger''
       --> "
    : Message:[value,dalin]-associate,type-error,in-the-middle
    ; define-constant-string

    : help:[value,dalin]-associate
      (* [value, type], head[address, <dalin-like>], or [Null, <null>] --
         associate-pair[address, <pair-like>] or [Null, <null>] *)
      dup <null> == if
        (* if associate fail, return null *)
        xx|swap|xx drop2 Exit
      then
      dup2
      car dup <not-pair-like>? if
        Message:[value,dalin]-associate,type-error,in-the-middle print-string
        dup print-type-tag cr
        debuger Exit
      then
      car
      (* [value, type], head[address, <dalin-like>], car-car[value, type] *)
      xx|over|xxxx eq? if
        xx|swap|xx drop2
        car Exit
      then
      ->  help:[value,dalin]-associate
      Exit
    ; define-recursive-function

    : [value,dalin]-associate
      (* [value, type], head[address, <dalin-like>] --
         associate-pair[address, <pair-like>] or [Null, <null>] *)
      dup <not-dalin-like>? if
        Message:[value,dalin]-associate,type-error,at-first print-string
        dup print-type-tag cr
        debuger Exit
      then
      help:[value,dalin]-associate
      Exit
    ; define-function



    : [value,dalin]-member?
      (* [value, type], [address, <dalin-like>] -- True or False *)
      dup <null> == if
        drop2 drop2 False Exit
      then
      dup2 car
      xx|over|xxxx eq? if
        drop2 drop2 True Exit
      then
      ->  [value,dalin]-member?
      Exit
    ; define-recursive-function
    #+end_src
*** ^_^
    the following function is very important
    it for dalin is as the ``cons'' for list
    but also really different
    #+begin_src cicada :tangle english-core.cicada
    :" ^_^ said:
       ``My function-type is
         (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
             rigth[address, <dalin-like>] *)
         If I view the 1st argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:^_^,1st-type-error ; define-constant-string

    :" ^_^ said:
       ``My function-type is
         (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
             rigth[address, <dalin-like>] *)
         If I view the 3rd argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:^_^,3rd-type-error ; define-constant-string


    (* the following ``little-smile-face'' is ``link-dalin'' *)
    : ^_^
      (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
         rigth[address, <dalin-like>] *)
      (* where: left[address, <dalin-like>] could be a null *)
      dup <not-dalin-like>? if
        Message:^_^,1st-type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      x|over|xx <null> == if
        xx|tuck|xx (* leave the return value *)
        cdr xx|over|xx set-car! drop2
        drop2
        Exit
      then
      x|over|xx <not-dalin-like>? if
        Message:^_^,3rd-type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|tuck|xx (* leave the return value *)
      cdr xx|over|xx set-car! drop2
      cdr xx|over|xx set-cdr! drop2
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    cr

    { 1 2 3 } list->*dalin*
    dup print-type-tag (* <dalin> *) cr


    (* test: tail[address, <dalin>] *) cr
    dup2
      *dalin? . (* 0 *) cr
    dup2
      dalin*? . (* 1 *) cr
    dup2
      car print-type-tag write-space . (* <fixnum> 3 *) cr
    dup2
      ->
      print-type-tag write-space . (* <null> 0 *) cr
    dup2
      <-
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    dup2
      <-
      <-
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    dup2
      <-
      <-
      ->
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    drop2


    (* test: head[address, <dalin>] *) cr
    dup2
      *dalin? . (* 1 *) cr
    dup2
      dalin*? . (* 0 *) cr
    dup2
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    dup2
      <-
      print-type-tag write-space . (* <null> 0 *) cr
    dup2
      ->
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    dup2
      ->
      ->
      car print-type-tag write-space . (* <fixnum> 3 *) cr
    dup2
      ->
      ->
      <-
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    dup2
      ->
      ->
      <-
      <-
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    drop2


    (* ----------------------------------------------------- *)

    (* test: nested-list *) cr
    { 1 { 2 3 } 4 } nested-list->*dalin
    dup print-type-tag (* <dalin> *) cr


    (* test: head[address, <dalin>] *) cr
    dup2
      *dalin? . (* 1 *) cr
    dup2
      dalin*? . (* 0 *) cr
    dup2
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    dup2
      <-
      print-type-tag write-space . (* <null> 0 *) cr

    dup2
      ->
      ->
      car print-type-tag write-space . (* <fixnum> 4 *) cr

    dup2
      ->
      ->
      <-
      <-
      car print-type-tag write-space . (* <fixnum> 1 *) cr

    dup2
      ->
      car
      dup print-type-tag (* <dalin> *) cr
      dup2
        *dalin? . (* 1 *) cr
      dup2
        car print-type-tag write-space . (* <fixnum> 2 *) cr
      dup2
        <-
        print-type-tag write-space . (* <null> 0 *) cr
      dup2
        ->
        car print-type-tag write-space . (* <fixnum> 3 *) cr
      dup2
        ->
        <-
        ->
        car print-type-tag write-space . (* <fixnum> 3 *) cr

    drop2



    (* ----------------------------------------------- *)
    (* the following test must be done after read-*dalin *)
    (* test: [value,dalin]-associate *)
    2 <fixnum>
    [ { 1 . a } { 2 . b } { 3 . b } ]
    [value,dalin]-associate
      dup print-type-tag (* <list> *) cr
      car  print-type-tag (* <fixnum> *) cr
      write-dec-number (* 2 *) cr

    (* the following test must be done in symbol-REPL *)
    ::x
    [ { 1 . a } { ::x . xxx } { 3 . b } ]
    [value,dalin]-associate
      cdr write (* xxx *)
    #+end_src
** read-dalin & write-dalin
*** read-*dalin
    #+begin_src cicada :tangle english-core.cicada
    : help:read-*dalin
      (* tail[address, <dalin>] -- head[address, <dalin>] *)
      (* where:
           the <- of ``tail'' is setted,
           need to set the -> of ``tail'' *)
      read-word
      dup2 Ket:square equal-string? if
        drop2
        dup <null> == if
          Exit (* so [ ] null will be read as null *)
        then
        dup2
          cdr
            null  set-cdr!
          drop2
        head<-dalin
        Exit
      then
      execute-word,for-list-reader
      cons drop <dalin>
        xx|swap|xx  set-car!
        cons        set-cdr!
      ^_^
      help:read-*dalin
      Exit
    ; define-recursive-function


    : read-*dalin (* -- head[address, <dalin>] *)
      null
      help:read-*dalin
      Exit
    ; define-function

    : [ read-*dalin Exit ; define-function
    #+end_src
*** write-*dalin
    #+begin_src cicada :tangle english-core.cicada
    : help:write-*dalin
      (* [address, <dalin>] -- *)
      dup2 dalin*? if
        car write Exit
      then
      dup2
        car write
      -> help:write-*dalin Exit
    ; define-recursive-function


    :" write-*dalin said:
       ``My function-type is (* [address, <dalin>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-*dalin,type-error ; define-constant-string

    : write-*dalin (* [address, <dalin>] -- *)
      dup <dalin> =/= if
        Message:write-*dalin,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      Bra:square print-string write-space
      help:write-*dalin
      Ket:square print-string write-space
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    [ ] print-type-tag (* <null> *) cr
    write-dec-number (* 0 *) cr

    [ 1 ] write-*dalin

    [ 1 2 3 4 5 6 7 8 9 0 ] write-*dalin

    [ 1
      [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
        xxx 3 4 5
      [ 1 2 3 4 5  6 ] 6 ]
    write-*dalin

    [ 1
      [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
        xxx 3 4 5
      { a b c }
      [ 1 2 3 4 5  6 ] 6 ]
    write-*dalin

    [ a [ a b c ]
      b [ a b c ]
      c [ a b c
            [ a [ a b c ] [ a b c ] lambda
              b [ a b c ]
              c [ a b c ] ] ] ]
    write-*dalin

    [ [ a b c ] a b c ]
    write-*dalin

    [ [ [ [ :x ] ] ] ]
    write-*dalin

    [ [ [ :x ] ]
      [ [ :x ] ] ]
    write-*dalin

    [ [ [ [ :x ] ] ]
      [ [ [ :x ] ] ] ]
    write-*dalin

    [ [ [ [ :x :x @ ] :x :x @ ] lambda :y @ ]
      [ [ :x :x @ ] lambda :y @ ] ]
    write-*dalin

    [ 1 { 2 . 3 } 4 ]
    dup2 write
    -> car
    dup print-type-tag (* <list> *) cr
    car print-type-tag (* <fixnum> *) cr
    write-dec-number (* 2 *) cr
    #+end_src
** stack & list & dalin
*** note
    it is hard to convert a list of value in the ArgumentStack
    say, [1, 2, 3], to a real list { 3 2 1 }
    for during recursive calls
    there will be lots ``cons'' leaved in the ArgumentStack
    or:
    1. you convert [1, 2, 3] to { 1 2 3 }
    2. you use LambdaStack for help
    3. you use dalin but not list
    ------------------------------------------
    I implement the following:
    1. FIAF denotes first in at first
    2. LIAF denotes last in at first
       LIAF version uses the LambdaStack
       which is very funny
*** stack->list
    #+begin_src cicada :tangle english-core.cicada
    : help:stack-LIAF->list
      (* ..., number --  *)
      (* LambdaStack::
         [address, <list>] -- *)
      dup zero? if
        drop (* drop Zero *)
        get-back null set-cdr!
        drop2 Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      dup2
        get-back [cdr,cons]! drop2
      ready
      help:stack-LIAF->list
      Exit
    ; define-recursive-function

    : stack-LIAF->list
      (* ..., number -- [address, <list>] *)
      dup zero? if
        drop null Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      dup2 ready (* leave the return *)
      ready
        help:stack-LIAF->list
      get-back Exit
    ; define-function


    : help:stack-FIAF->list
      (* ..., number -- *)
      (* LambdaStack::
         [address, <list>] -- [address, <list>] *)
      dup zero? if
        drop (* drop Zero *)
        Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      get-back [cons,cdr]! ready
      help:stack-FIAF->list
      Exit
    ; define-recursive-function

    : stack-FIAF->list
      (* ..., number -- [address, <list>] *)
      dup zero? if
        drop null Exit
      then
      null
      ready
        help:stack-FIAF->list
      get-back
      Exit
    ; define-function
    #+end_src
*** stack->dalin
    #+begin_src cicada :tangle english-core.cicada
    : help:stack-LIAF->dalin
      (* ..., number -- [address, <list>] *)
      (* LambdaStack::
         [address, <list>] -- *)
      dup zero? if
        drop (* drop Zero *)
        get-back
        dup2 cdr
        null set-cdr!
        drop2
        head<-dalin
        Exit
      then
      sub1
      swap <fixnum>  cons drop <dalin>  [car,cons]!
      cons  [cons,cdr]!
      get-back
        xx|swap|xx ^_^
      ready
      help:stack-LIAF->dalin
      Exit
    ; define-recursive-function

    : stack-LIAF->dalin
      (* ..., number -- [address, <dalin>] *)
      dup zero? if
        drop null Exit
      then
      null
      ready
      help:stack-LIAF->dalin
      Exit
    ; define-function


    : help:stack-FIAF->dalin
      (* ..., number -- [address, <list>] *)
      (* LambdaStack::
         [address, <list>] -- *)
      dup zero? if
        drop (* drop Zero *)
        get-back
        dup2 cdr
        null set-car!
        drop2 Exit
      then
      sub1
      swap <fixnum>  cons drop <dalin>  [car,cons]!
      cons  [cons,cdr]!
      get-back
        ^_^ <-
      ready
      help:stack-FIAF->dalin
      Exit
    ; define-recursive-function

    : stack-FIAF->dalin
      (* ..., number -- [address, <dalin>] *)
      (* ..., number -- [address, <dalin>] *)
      dup zero? if
        drop null Exit
      then
      sub1
      swap <fixnum>  cons drop <dalin>
      [car,cons]!
        null set-cdr-to-{cdr.x}!
      ready
      help:stack-FIAF->dalin
      Exit
    ; define-function
    #+end_src
*** list->stack
    #+begin_src cicada :tangle english-core.cicada
    :" stack<-FIAF-list said:
       ``My function type is (* [address, <list>] -- ... *)
         the list should be a list of <not-pair-like> value
         But in the middle of recursion
         the following is what I found
         I will not touch it and call debuger''
       --> "
    : Message:stack<-FIAF-list,error ; define-constant-string

    :" stack<-FIAF-list said:
       ``My function type is (* [address, <list>] -- ... *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:stack<-FIAF-list,type-error ; define-constant-string

    : help:stack<-FIAF-list
      (* -- ... *)
      (* LambdaStack::
         [address, <list>] -- *)
      get-back
      dup <null> == if
        drop2 Exit
      then
      dup2
        cdr ready
      car
      dup <pair-like>? if
        Message:stack<-FIAF-list,error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop a <not-pair-like> type-tag *)
      (* leave the value of the [value, <not-pair-like>] *)
      help:stack<-FIAF-list
      Exit
    ; define-recursive-function

    : stack<-FIAF-list
      (* [address, <list>] -- ... *)
      dup <list> =/= if
        Message:stack<-FIAF-list,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      ready
      help:stack<-FIAF-list
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    cr
    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-LIAF->list write (* { 0 9 8 7 6 5 4 3 2 1 } *) cr
    . (* 666 *) cr
    1  1 stack-LIAF->list write (* { 1 } *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-FIAF->list write (* { 1 2 3 4 5 6 7 8 9 0 } *) cr
    . (* 666 *) cr
    1  1 stack-FIAF->list write (* { 1 } *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-LIAF->dalin write (* [ 0 9 8 7 6 5 4 3 2 1 ] *) cr
    . (* 666 *) cr
    1  1 stack-LIAF->dalin write (* [ 1 ] *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-FIAF->dalin write (* [ 1 2 3 4 5 6 7 8 9 0 ] *) cr
    . (* 666 *) cr
    1  1 stack-FIAF->dalin write (* [ 1 ] *) cr
    cr

    666 { 1 } stack<-FIAF-list
     . (* 1 *) . (* 666 *) cr
    666 { 1 2 3 4 } stack<-FIAF-list
     . . . . (* 4 3 2 1 *) . (* 666 *) cr
    cr
    #+end_src
** symbol types
*** helper funciton
    #+begin_src cicada :tangle english-core.cicada
    : char-denote-number,or-alphabet,or-out-of-ascii?
      (* char -- True of False *)
      dup  48 < if     drop False Exit
      then
      dup  57 <= if    drop True Exit
      then
      dup  65 < if     drop False Exit
      then
      dup  90 <= if    drop True Exit
      then
      dup  97 < if     drop False Exit
      then
      dup  122 <= if   drop True Exit
      then
      dup  128 < if    drop False Exit
      then
      drop True Exit
    ; define-function
    #+end_src
*** Bound-variable
    #+begin_src cicada :tangle english-core.cicada
    (* `:' followed by a number or alphabet is a symbolDenoteBoundVariable
       ascii: 48 -- 57, 65 -- 90, 97 -- 122, 128 -- ...
       this set maybe change in the future *)

    : string-denote-bound-variable,one?
      (* [address, length] -- True or False *)
      tail-and-head-of-string
      ':' =/= if
        drop2 False (* Exit *)
      else
        dup Zero == if
          drop2 False (* Exit *)
        else
          tail-and-head-of-string
          char-denote-number,or-alphabet,or-out-of-ascii? if
            drop2 True (* Exit *)
          else
            drop2 False (* Exit *)
          then
        then
      then
      Exit
    ; define-function

    :" an error occurs!
    symbol-denote-bound-variable,one? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,one?,type-error ; define-constant-string
    : symbol-denote-bound-variable,one?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,one?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,one?
      Exit
    ; define-function



    : string-denote-bound-variable,two?
      (* [address, length] -- True or False *)
      dup Two <= if
        drop2 False Exit
      then
      tail-and-head-of-string ':' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,one? Exit
      Exit
    ; define-function

    :" an error occurs!
    symbol-denote-bound-variable,two? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,two?,type-error ; define-constant-string
    : symbol-denote-bound-variable,two?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,two?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,two?
      Exit
    ; define-function




    : string-denote-bound-variable,three?
      (* [address, length] -- True or False *)
      dup Three <= if
        drop2 False Exit
      then
      tail-and-head-of-string ':' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,two? Exit
      Exit
    ; define-function

    :" an error occurs!
    symbol-denote-bound-variable,three? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,three?,type-error ; define-constant-string
    : symbol-denote-bound-variable,three?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,three?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,three?
      Exit
    ; define-function



    : string-denote-bound-variable,four?
      (* [address, length] -- True or False *)
      dup Four <= if
        drop2 False Exit
      then
      tail-and-head-of-string ':' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,three? Exit
      Exit
    ; define-function

    :" an error occurs!
    symbol-denote-bound-variable,four? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,four?,type-error ; define-constant-string
    : symbol-denote-bound-variable,four?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,four?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,four?
      Exit
    ; define-function




    : string-denote-bound-variable?
      (* [address, length] -- True or False *)
      dup2 string-denote-bound-variable,one? if
        drop2 True Exit
      then
      dup2 string-denote-bound-variable,two? if
        drop2 True Exit
      then
      dup2 string-denote-bound-variable,three? if
        drop2 True Exit
      then
      dup2 string-denote-bound-variable,four? if
        drop2 True Exit
      then
      drop2 False Exit
    ; define-function

    :" an error occurs!
    symbol-denote-bound-variable? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable?,type-error ; define-constant-string
    : symbol-denote-bound-variable?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable?
      Exit
    ; define-function
    #+end_src
*** Wody
    #+begin_src cicada :tangle english-core.cicada
    (* string begin with a number or alphabet
       and end with `:' following a number or alphabet
       is a symbolDenoteWody *)

    : string-denote-wody?
      (* [address, length] -- True or False *)
      dup Two < if
        drop2 False Exit
      then
      dup2 head-of-string
      char-denote-number,or-alphabet,or-out-of-ascii? false? if
        drop2 False Exit
      then
      dup2  sub1 +  fetch-byte ':' =/= if
        drop2 False Exit
      then
      dup2  sub2 +  fetch-byte
      char-denote-number,or-alphabet,or-out-of-ascii? false? if
        drop2 False Exit
      then
      drop2 True Exit
    ; define-function

    :" an error occurs!
    symbol-denote-wody? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-wody?,type-error ; define-constant-string
    : symbol-denote-wody?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-wody?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-wody?
      Exit
    ; define-function
    #+end_src
*** LambdaArgument
    #+begin_src cicada :tangle english-core.cicada
    (* `<' plus a string-denote-bound-variable,one *)
    : string-denote-lambda-argument,one?
      (* [address, length] -- True or False *)
      dup Two <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,one? Exit
    ; define-function

    :" an error occurs!
    symbol-denote-lambda-argument,one? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,one?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,one?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,one?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,one?
      Exit
    ; define-function



    (* `<' plus a string-denote-bound-variable,two *)
    : string-denote-lambda-argument,two?
      (* [address, length] -- True or False *)
      dup Three <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,two? Exit
    ; define-function

    :" an error occurs!
    symbol-denote-lambda-argument,two? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,two?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,two?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,two?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,two?
      Exit
    ; define-function




    (* `<' plus a string-denote-bound-variable,three *)
    : string-denote-lambda-argument,three?
      (* [address, length] -- True or False *)
      dup Four <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,three? Exit
    ; define-function

    :" an error occurs!
    symbol-denote-lambda-argument,three? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,three?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,three?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,three?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,three?
      Exit
    ; define-function




    (* `<' plus a string-denote-bound-variable,four *)
    : string-denote-lambda-argument,four?
      (* [address, length] -- True or False *)
      dup Five <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,four? Exit
    ; define-function

    :" an error occurs!
    symbol-denote-lambda-argument,four? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,four?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,four?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,four?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,four?
      Exit
    ; define-function



    : string-denote-lambda-argument?
      (* [address, length] -- True or False *)
      dup2 string-denote-lambda-argument,one? if
        drop2 True Exit
      then
      dup2 string-denote-lambda-argument,two? if
        drop2 True Exit
      then
      dup2 string-denote-lambda-argument,three? if
        drop2 True Exit
      then
      dup2 string-denote-lambda-argument,four? if
        drop2 True Exit
      then
      drop2 False Exit
    ; define-function

    :" an error occurs!
    symbol-denote-lambda-argument? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument?,type-error ; define-constant-string
    : symbol-denote-lambda-argument?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument?
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    :" xxx"   string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 0 *) cr
    :" :xxx"  string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 1 *) cr
    :" ::"    string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 0 *) cr
    :" :"     string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 0 *) cr
    :" :1"    string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 1 *) cr
    :" :" string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 1 *) cr
    cr
    :" :xxx"   string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 0 *) cr
    :" ::xxx"  string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 1 *) cr
    :" :::"    string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 0 *) cr
    :" ::"     string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 0 *) cr
    :" ::1"    string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 1 *) cr
    :" ::" string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 1 *) cr
    cr
    :" xxx"   string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" :xxx"  string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" ::"    string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" :"     string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" :1"    string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" :" string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    cr
    :" xxx::" string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" xxx:"  string-hash->index <symbol> symbol-denote-wody? . (* 1 *) cr
    :" 1:"    string-hash->index <symbol> symbol-denote-wody? . (* 1 *) cr
    :" :1:"   string-hash->index <symbol> symbol-denote-wody? . (* 0 *) cr
    :" :" string-hash->index <symbol> symbol-denote-wody? . (* 1 *) cr
    cr
    :" <:xxx::" string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    :" <:xxx:"  string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    :" <:1:"    string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    :" <::1:"   string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 0 *) cr
    :" <::" string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    cr
    :" <:xxx::" string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    :" <:xxx:"  string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    :" <:1:"    string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    :" <::1:"   string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 1 *) cr
    :" <::" string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    cr

    (* ----------------------------------------------------- *)
    cr
    :" xxx"    string-denote-bound-variable,one? . (* 0 *) cr
    :" :xxx"   string-denote-bound-variable,one? . (* 1 *) cr
    :" ::"     string-denote-bound-variable,one? . (* 0 *) cr
    :" :"      string-denote-bound-variable,one? . (* 0 *) cr
    :" :1"     string-denote-bound-variable,one? . (* 1 *) cr
    :" :"  string-denote-bound-variable,one? . (* 1 *) cr
    cr
    :" :xxx"    string-denote-bound-variable,two? . (* 0 *) cr
    :" ::xxx"   string-denote-bound-variable,two? . (* 1 *) cr
    :" :::"     string-denote-bound-variable,two? . (* 0 *) cr
    :" ::"      string-denote-bound-variable,two? . (* 0 *) cr
    :" ::1"     string-denote-bound-variable,two? . (* 1 *) cr
    :" ::"  string-denote-bound-variable,two? . (* 1 *) cr
    cr
    :" xxx"    string-denote-wody? . (* 0 *) cr
    :" :xxx"   string-denote-wody? . (* 0 *) cr
    :" ::"     string-denote-wody? . (* 0 *) cr
    :" :"      string-denote-wody? . (* 0 *) cr
    :" :1"     string-denote-wody? . (* 0 *) cr
    :" :"  string-denote-wody? . (* 0 *) cr
    cr
    :" xxx::"  string-denote-wody? . (* 0 *) cr
    :" xxx:"   string-denote-wody? . (* 1 *) cr
    :" 1:"     string-denote-wody? . (* 1 *) cr
    :" :1:"    string-denote-wody? . (* 0 *) cr
    :" :"  string-denote-wody? . (* 1 *) cr
    cr
    :" <:xxx::"  string-denote-lambda-argument,one? . (* 1 *) cr
    :" <:xxx:"   string-denote-lambda-argument,one? . (* 1 *) cr
    :" <:1:"     string-denote-lambda-argument,one? . (* 1 *) cr
    :" <::1:"    string-denote-lambda-argument,one? . (* 0 *) cr
    :" <::"  string-denote-lambda-argument,one? . (* 1 *) cr
    cr
    :" <:xxx::"  string-denote-lambda-argument,two? . (* 0 *) cr
    :" <:xxx:"   string-denote-lambda-argument,two? . (* 0 *) cr
    :" <:1:"     string-denote-lambda-argument,two? . (* 0 *) cr
    :" <::1:"    string-denote-lambda-argument,two? . (* 1 *) cr
    :" <::"  string-denote-lambda-argument,two? . (* 0 *) cr
    cr
    (* ----------------------------------------------------- *)

    (* test: type-error *)
    null symbol-denote-wody?          basic-REPL
    null symbol-denote-bound-variable,one?  basic-REPL
    #+end_src
** read-wodyli & write-wodyli
*** note
    1. wodyli denotes wordy-list
    2. wodyli is a dalin of list
    3. lambda will use ``bound-variable-wodyli''
*** read-wodyli
    #+begin_src cicada :tangle english-core.cicada
    : help:with-word,read-wody-or-bound-variable
      (* -- [address, <list>] *)
      (* LambdaStack::
         -- wody[address, length] *)
      read-word
      dup2 string-denote-wody? if
        ready
        null Exit
      then
      dup2 string-denote-bound-variable? if
        ready
        null Exit
      then
      dup2 Ket:round equal-string? if
        ready
        null Exit
      then
      dup2 Mid:dot equal-string? if
        drop2
        help:with-word,read-wody-or-bound-variable car
        (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
        Exit
      then
      execute-word,for-list-reader
      cons drop <list>
        xx|swap|xx  set-car!
          help:with-word,read-wody-or-bound-variable
        set-cdr!
      Exit
    ; define-recursive-function


    : with-word,read-wody-or-bound-variable
      (* word[address, length] -- [address, <wody>], word[address, length] *)
      (* LambdaStack:: <wody> -- *)
      (* or *)
      (* word[address, length] -- [address, <bound-variable>], word[address, length] *)
      (* LambdaStack:: <bound-variable> -- *)
      string-hash->index <symbol>
      cons drop pop-lambda-stack
        [car,cons]!
          help:with-word,read-wody-or-bound-variable
        [cons,cdr]!
      get-back
      (* return the next ``wody'' word
         it must be handled in help:read-wodyli *)
      Exit
    ; define-function



    :" help:read-wodyli said:
       ``My function type is
         (* [address, <wodyli>], word[address, length] -- head[address, <wodyli>] *)
         the `word' must be `)' or denotes `wody' or denotes `bound-variable'
         But the following is what I meet
         I will not touch it and call debuger''
       --> "
    : Message:help:read-wodyli,error ; define-constant-string

    (* a ``with-word'' reader *)
    : help:read-wodyli
      (* [address, <wodyli>], word[address, length] -- head[address, <wodyli>] *)
      (* where:
           the <- of [address, <wodyli>] is setted,
           need to set the -> of [address, <wodyli>] *)
      dup2 Ket:round equal-string? if
        drop2
        dup2
          cdr
            null  set-cdr!
          drop2
        head<-dalin
        Exit
      then
      dup2 string-denote-wody? if
        <wody> push-lambda-stack
      else
        dup2 string-denote-bound-variable? if
          <bound-variable> push-lambda-stack
        else
          Message:help:read-wodyli,error print-string
          print-string cr
          debuger Exit
        then
      then
      with-word,read-wody-or-bound-variable
      (* [address, <wodyli>], [address, <wody>], word[address, length] *)
      (* or *)
      (* [address, <wodyli>], [address, <bound-variable>], word[address, length] *)
      xxxx|swap|xx
      cons drop <wodyli>
        xx|swap|xx  set-car!
        cons        set-cdr!
      ^_^
      xx|swap|xx
      help:read-wodyli
      Exit
    ; define-recursive-function



    : read-wodyli (* -- head[address, <wodyli>] *)
      null
      read-word
      dup2 Ket:round equal-string? if
        (* return ``null'' on ( ) *)
        drop2 Exit
      then
      help:read-wodyli
      Exit
    ; define-function

    : ( read-wodyli Exit ; define-function
    #+end_src
*** write-wody & write-wodyli
    #+begin_src cicada :tangle english-core.cicada
    :" write-wody-or-bound-variable said:
       ``My function-type is (* [address, <wody> or <bound-variable>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-wody-or-bound-variable,type-error ; define-constant-string

    : write-wody-or-bound-variable
      (* [address, <wody> or <bound-variable>] -- *)
      dup <wody> =/=
      over <bound-variable> =/=
      bitwise-and if
        Message:write-wody-or-bound-variable,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2
        car write
      cdr help:write-list
      Exit
    ; define-function



    : help:write-wodyli
      (* [address, <wodyli>] -- *)
      dup <null> == if
        drop2 Exit
      then
      dup2
        car write
      -> help:write-wodyli Exit
    ; define-recursive-function


    :" write-wodyli said:
       ``My function-type is (* [address, <wodyli>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-wodyli,type-error ; define-constant-string

    : write-wodyli
      (* [address, <wodyli>] -- *)
      dup <wodyli> =/= if
        Message:write-wodyli,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      Bra:round print-string write-space
      help:write-wodyli
      Ket:round print-string write-space
      Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    ( x: ( a: 1 2 3 b: 4 5 6 )
      a: 1 2 3
      b: 4 5 6 )
     write

    ( a: b: 6 ) write-wodyli

    ( :a 1 :b 2 ) write-wodyli
    #+end_src
** ><><>< wodyli processing
** execute-word [redefine] & symbol-REPL & lambda-argument
*** note
    1. to read different types of symbols
    2. to handle <:x <::x <:::x <::::x
    3. print better ErrorInfo for ExecuteWord
*** implementation
    #+begin_src cicada :tangle english-core.cicada
    : <lambda-argument-one>   ; define-pair-like-data-type
    : <lambda-argument-two>   ; define-pair-like-data-type
    : <lambda-argument-three> ; define-pair-like-data-type
    : <lambda-argument-four>  ; define-pair-like-data-type

    : <lambda-argument>?
      (* type-tag -- True or False *)
      dup <lambda-argument-one> == if
        drop True Exit
      then
      dup <lambda-argument-two> == if
        drop True Exit
      then
      dup <lambda-argument-three> == if
        drop True Exit
      then
      dup <lambda-argument-four> == if
        drop True Exit
      then
      drop False Exit
    ; define-function

    (* ><><>< the following comment should be rewritten *)
    (* redefine execute-word to handle the following symbols
       <:x   ::    value       -- [{ :x  . { ... } }, <lambda-argument-one>]
       <::x  ::  [value, type] -- [{ ::x . { ... } }, <lambda-argument-two>]
       ...
       examples:
       [{ :x       . { 1 } },             <lambda-argument-one>]
       [{ ::null   . { Null <null> } },   <lambda-argument-two>]
       [{ ::number . { 666 <fixnum> } },  <lambda-argument-two>]
       note that:
         every value in list must have a type
         so in every list above, type of a car is setted to <fixnum>
     *)

    : execute-word (* string[address, length] -- unknown *)
      dup2
      string-denote-integer? if
        string->integer,with-error drop Exit
      then

      dup2 string-denote-bound-variable,one? if
        string-hash->index <symbol> Exit
      then
      dup2 string-denote-bound-variable,two? if
        string-hash->index <symbol> Exit
      then
      dup2 string-denote-bound-variable,three? if
        string-hash->index <symbol> Exit
      then
      dup2 string-denote-bound-variable,four? if
        string-hash->index <symbol> Exit
      then

      dup2 string-denote-lambda-argument,one? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-one>
          xx|swap|xx set-car!
          ready
            One stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 string-denote-lambda-argument,two? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-two>
          xx|swap|xx set-car!
          ready
            Two stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 string-denote-lambda-argument,three? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-three>
          xx|swap|xx set-car!
          ready
            Three stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 string-denote-lambda-argument,four? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-four>
          xx|swap|xx set-car!
          ready
            Four stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 find dup not-zero? if
        xx|swap|x drop2
        word-link->word-explainer execute Exit
      then
      drop (* drop the Zero that denotes finding-error *)
      Message:undefined-word print-string
      print-string (* print the word *) cr
      Exit
    ; define-function

    (* if wished
     *   one needs to use help:symbol-REPL to do the recursive
     *   and reset the two pointers in symbol-REPL
     * Return-stack-top reset-return-stack-pointer
     * Argument-stack-top reset-argument-stack-pointer *)

    : symbol-REPL (* unknown -- unknown *)
      read-word-for-runtime
      execute-word
      symbol-REPL
      Exit
    ; define-recursive-function
    #+end_src
*** test
    #+begin_src cicada
    symbol-REPL 1 2 + . (* 3 *) cr
    cr

    :xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* :xxx *) cr
    cr

    ::xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* ::xxx *) cr
    cr

    :::xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* :::xxx *) cr
    cr

    ::::xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* ::::xxx *) cr
    cr
    #+end_src
** using the symbol-REPL now !
   #+begin_src cicada :tangle english-core.cicada
   symbol-REPL
   #+end_src
* lambda-calculus
** lambda
*** note
**** ABOUT lambda-calculus
     1. lambda is a function which uses two dalin
        to compose a anonymous function
        (not compile to the dictionary)
        apply is a function which
        explain (or eval) the anonymous function composed by lambda
     2. ``compose()'' is different from ``compile()''
     3. the essence is
        ``compose and explain''
        or ``compile and explain''
        1) what(syntax) to be composed ?
        2) compose to what ?
        3) how to explain(or eval) the result of the composition
     4. in cicada
        apply is linear
        lambda is almost linear
        ``linear'' means a loop walk through a dalin
        but not a recursive function traverse a nested dalin
        only the function that calculates the scope of a lambda is recursive
     5. a bound-variable of a lambda function
        is used to label the place in the lambda-body
        into where you want to substitute a argument
        when lambda-body is nested
        the scope of bound-variables need to be handled
        scheme use closure to handle this
        cicada use simple graph processing to handle this
     6. during lambda-application,
        one <lambda-argument-N> substitute into
        one <bound-variable>
     7. from lisp to cicada
        I am dispersing the works of parsing all the time
**** ABOUT lazy-eval
     1. in cicada use explicit lazy-eval
        use ()lambda or ()
        to make a lambda-function without arguments
        to use explicit lazy-eval
     2. lazy-eval has better theoretical feature in lambda-calculus
        but it makes computation unpredictable
**** ABOUT substitution
     note that you can only use bound-variable (such as ::x :n) in a lambda-body
     bot NOT a dalin or list or wodyli
*** data-types
    #+begin_src cicada :tangle english-core.cicada
    : <lambda>               ; define-pair-like-data-type
    : <explainer-pair>       ; define-pair-like-data-type
    : <explainer>            ; define-data-type
    #+end_src
*** helper functions
    used to decide the type error of lambda
    and to decide when I need to calculate lambda-scope
    #+begin_src cicada :tangle english-core.cicada
    : bound-variable-wodyli?
      (* head[address, <wodyli>] -- True or False *)
      dup <wodyli> =/= if
        drop2 False Exit
      then
      dup2 car  swap drop
      <bound-variable> =/= if
        drop2 False Exit
      then
      dup2 dalin*? if
        drop2 True Exit
      then
      ->  bound-variable-wodyli?
      Exit
    ; define-recursive-function


    (*
     * the following function return `True'
     * on the following dalin as a tail
     *   [ [address, <dalin>]
     *     bound-variable-wodyli[address, <wodyli>]
     *    ]
     * and
     *   [ [address, <dalin>]
     *     null
     *    ]
     *)

    : meet-lambda-abstraction-in-lambda-body-dalin?
      (* tail[address, <dalin>] -- True or False *)
      dup <dalin> =/= if
        drop2 False Exit
      then
      dup2 car
      dup2       bound-variable-wodyli?
      xx|swap|x  null?
      bitwise-or if
        <- dup <dalin> =/= if
          drop2 False Exit
        then
          car <dalin> =/= if
            drop False Exit
          then
            drop True Exit
      then
      drop2 False Exit
    ; define-function

    (*
     * test:
     *
     * [ [ 1 ] ( :x ) ] dalin->tail
     * meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
     * [ [ 1 ] null ] dalin->tail
     * meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
     * [ [ 1 ] ( ) ] dalin->tail
     * meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
     * cr
     * [ [ 1 ] ( x: ) ] dalin->tail
     * meet-lambda-abstraction-in-lambda-body-dalin? . (\* 0 *\) cr
     *)
    #+end_src
*** bound-variable-wodyli-subtraction (for calculating lambda-scope)
    #+begin_src cicada :tangle english-core.cicada
    : help:bound-variable-wodyli-subtraction
      (* LambdaStack::
         (a-b) [address, <wodyli>] -- *)
      (* b [address, <wodyli>], a [address, <wodyli>] --
         (a-b) [address, <wodyli>] *)
      dup <null> == if
        drop2 drop2
        get-back
        dup <null> == if
          Exit
        then
        dup2 cdr null [cons,cdr]! drop2
        head<-dalin
        Exit
      then
      dup2
        car car   xx|over|xxxx
        [value,dalin]-associate
        dup <null> =/= if
        (* if this bound-variable is ``blocked'',
           it should not be ``cons'' to the new bound-variable-wodyli *)
        drop2 (* drop the associate-pair *)
        ->  help:bound-variable-wodyli-subtraction Exit
      then
      drop2 (* drop the associate-pair *)
      (* b [address, <wodyli>], a [address, <wodyli>] *)
      dup2 car
      (* a wody as a whole is ``cons''ed to the new bound-variable-wodyli *)
      cons drop <wodyli>
        [car,cons]!
        cons [cons,cdr]!
      get-back
        xx|swap|xx  ^_^
        (* so the order of bound-variable-wodyli will be preserved *)
      ready
      ->  help:bound-variable-wodyli-subtraction Exit
    ; define-recursive-function


    (* the following function will creat a new wodyli, maybe ``null'' *)
    : bound-variable-wodyli-subtraction
      (* a [address, <wodyli>], b [address, <wodyli>] --
         (a-b) [address, <wodyli>] *)
      x|over|xx <null> == if
        (* a == null, (a-b) == a == null *)
        drop2 Exit
      then
      dup <null> == if
        (* b == null, (a-b) == a *)
        drop2 Exit
      then
      null ready
      xx|swap|xx
      (* b [address, <wodyli>], a [address, <wodyli>] *)
      (* LambdaStack::  [Null, <null>] *)
      help:bound-variable-wodyli-subtraction
      Exit
    ; define-function


    (*
     *  test:
     *
     * 666
     * ( ::a ::b ::c )
     * ( ::a ::c ::x )
     * bound-variable-wodyli-subtraction
     * write (\* ( ::b )  *\)
     *
     * . (\* 666 *\)
     *)
    #+end_src
*** lambda
    #+begin_src cicada :tangle english-core.cicada
    :" lambda" string-hash->index
    : Symbol-index:lambda ; define-constant

    :" " string-hash->index
    : Symbol-index: ; define-constant


    (* the following two functions are side-effects through a dalin
     * in the direction of ``<-''

     * some special-types of elements in the lambda-body
     * should be setted for ``apply''

     * note that: (currently)
     *   <fixnum> <list> <dalin> <wodyli> <symbol>
     *   are the only types of value
     *   that could be readed into a dalin

     *   only all <symbol> in this dalin
     *   and some <symbol> that denote-bound-variable nestedly existed in this dalin
     *   will be handled by the following functions

     *   while
     *   in the ``apply''
     *   when meet [666, <fixnum>]
     *     666 ( ONLY ONE VALUE ) will be push to ArgumentStack
     *   when meet [address, <list>]
     *     [address, <list>] will be push to ArgumentStack
     *   when meet [address, <dalin>]
     *     [address, <dalin>] will be push to ArgumentStack
     *   when meet [address, <wodyli>]
     *     [address, <wodyli>] will be push to ArgumentStack
     *)


    : help:lambda,set-bound-variables (* calculating lambda-scope *)
      (* [address, <wodyli>], [address, <dalin>] -- *)
      dup <null> == if
        (* drop all the arguments here *)
        drop2 drop2 Exit
      then
      dup2 car

      (* [address, <wodyli>], [address, <dalin>], car[value, type] *)
      dup <symbol> =/= if
        (* types of value other then <symbol>
           will be leaved in the lambda-body as they are *)
        drop2
        <-  help:lambda,set-bound-variables Exit
      then

      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 symbol-denote-bound-variable? if
        xx|over|xxxx
        dup <null> == if
          (* when bound-variable-wodyli is null
             symbol-denote-bound-variable can not be bound by this lambda
             just leave them in the lambda-body as they are *)
          drop2 (* drop [Null, <null>] *)
          drop2 (* drop [index, <symbol>] *)
          <-  help:lambda,set-bound-variables Exit
        then
        [value,dalin]-associate
        dup <null> == if
          (* symbol-denote-bound-variable that can not be bound by this lambda
             will be leaved in the lambda-body as they are *)
          drop2
          <-  help:lambda,set-bound-variables Exit
        then
        (* [address, <wodyli>], [address, <dalin>], [address, <bound-variable>] *)
        [cons,car]!
        <-  help:lambda,set-bound-variables Exit
      then

      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 drop
        dup   Symbol-index:lambda ==
        swap  Symbol-index: ==
      bitwise-or if
        drop2
        <-
        (* make a special treatment only when
           ``meet-lambda-abstraction-in-lambda-body-dalin'' *)
        dup2
        meet-lambda-abstraction-in-lambda-body-dalin?
        false? if
          help:lambda,set-bound-variables Exit
        then
        (* [address, <wodyli>], [address, <dalin>] *)
          (* prepare the arguments for a non-tail-recursive call of help:lambda,set-bound-variables *)
          xx|over|xx xx|over|xx
            car bound-variable-wodyli-subtraction
          xx|over|xx
            (* note that: the 2ed arg of help:lambda,set-bound-variables is a tail-dalin *)
            <-  car  dalin->tail
          help:lambda,set-bound-variables
          (* after then : *)
          <- <-  help:lambda,set-bound-variables Exit
      then

      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      (* here is general symbol *)
      drop2
      <-  help:lambda,set-bound-variables Exit
    ; define-recursive-function


    : help:lambda,set-function-body
      (* [address, <wodyli>], [address, <dalin>] -- *)
      dup <null> == if
        (* drop all the arguments here *)
        drop2 drop2 Exit
      then
      dup2 car
      (* [address, <wodyli>], [address, <dalin>], car[value, type] *)
      dup <symbol> =/= if
        (* types of value other then <symbol>
           will be leaved in the lambda-body as they are *)
        drop2
        <-  help:lambda,set-function-body Exit
      then
      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 symbol-denote-lambda-argument? if
        (* i.e. symbols like ``<:x''
           will be leaved in the lambda-body as they are
           they will be handled by ``apply'' *)
        drop2
        <-  help:lambda,set-function-body Exit
      then
      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      dup2 symbol-denote-bound-variable? if
        (* i.e. symbols like ``:x''
           will be leaved in the lambda-body as they are
           ``help:lambda,set-bound-variables'' take care of them
           when ``apply'' is executed there should be none of them *)
        drop2
        <-  help:lambda,set-function-body Exit
      then
      (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
      (* here is general symbol *)
      over
        index-hashback->string
        find (* ><><>< error handling when not found *)
        word-link->word-explainer
        <explainer>
      cons drop <explainer-pair>
        [cdr,cons]!  [car,cons]!
      [cons,car]!
      <-  help:lambda,set-function-body Exit
    ; define-recursive-function




    : help:lambda,make-lambda-function
      (* [address, <wodyli>], [address, <dalin>] --
         [address, <lambda>] *)
      cons drop <lambda>
        xx|swap|xx set-cdr!
        xx|swap|xx set-car!
      Exit
    ; define-function




    :" lambda said:
       ``My function type is
         (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
         (* or *)
         (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
         But the 1st argument is the following
         I will not touch it and call debuger''
       --> "
    : Message:lambda,type-error,1st ; define-constant-string

    :" lambda said:
       ``My function type is
         (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
         (* or *)
         (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
         The 1st argument is a wodyli but not a bound-variable-wodyli
         I will not touch it and call debuger''"
    : Message:lambda,type-error,1st,not-bound-variable-wodyli
    ; define-constant-string

    :" lambda said:
       ``My function type is
         (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
         (* or *)
         (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
         But the 3rd argument is the following
         I will not touch it and call debuger''
       --> "
    : Message:lambda,type-error,3rd ; define-constant-string

    : lambda
      (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
      (* or *)
      (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
      dup <wodyli> =/=
      over <null> =/=
      bitwise-and if
        Message:lambda,type-error,1st print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup <wodyli> ==
      xx|over|x bound-variable-wodyli? false?
      bitwise-and if
        Message:lambda,type-error,1st,not-bound-variable-wodyli
        print-string cr
        debuger Exit
      then
      x|over|xx <dalin> =/= if
        Message:lambda,type-error,3rd print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|tuck|xx  xx|over|xx
      dalin->tail
      (* [address, <wodyli>], [address, <dalin>],
         [address, <wodyli>], tail[address, <dalin>] *)
      xx|over|xx  xx|over|xx
      help:lambda,set-bound-variables
      (* multi-pass *)
      help:lambda,set-function-body
      (* [address, <wodyli>], [address, <dalin>] *)
      help:lambda,make-lambda-function
      Exit
    ; define-function

    :  lambda Exit ; define-function
    #+end_src
*** test
    #+begin_src cicada
    [              :b negate
        4 :a :c * *
            :b :b *  -  ><><><sqrt  +
                        2 :a  *  / ] dup2 write cr
    ( :a :b :c ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ::x ) lambda ] dup2 write cr
    ( ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ) lambda ] dup2 write cr
    ( ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ::x ) lambda ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ ::x ::x ::x ] ( ::x ) lambda ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda
       ::y
      [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda  ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda ::y
      [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda @ ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2
    #+end_src
** apply
*** note
    1. lambda-body
       ``''lambda
       ()
       lambda <lambda> pair dalin
       lambda-bodylambda-body
       
    2. 
       lambda
       
    3. maybe I can support cc here !
*** lambda-body-stack
    #+begin_src cicada :tangle english-core.cicada
    (* note that:
         when a explainer is been executed
         only the arguments of the word to be explained
         should be in the ArgumentStack or LambdaStack *)

    (* a stack as list
       list of dalin
       in which a dalin denotes a lambda-body *)
    null : lambda-body-stack ; define

    : push,lambda-body-stack
      (* [address, <wodyli>] -- *)
      cons drop <list>  [car,cons]!
      lambda-body-stack fetch2
      [cons,cdr]!
      lambda-body-stack save2
      Exit
    ; define-function

    : drop,lambda-body-stack
      (* -- *)
      lambda-body-stack fetch2
      cdr
      lambda-body-stack save2
      Exit
    ; define-function
    #+end_src
*** help:apply,eval-lambda-body
    #+begin_src cicada :tangle english-core.cicada
    (* the following function
       do side-effect to the car of the lambda-body-stack *)

    : <end-of-one-lambda-body> ; define-data-type
    : <end-of-all-lambda-body> ; define-data-type

    : lambda-forth
      (* -- [value, type] or <end-of-lambda-body> or <>] *)
      lambda-body-stack fetch2
      dup <null> == if
        drop2
        <end-of-all-lambda-body>
        Exit
      then
      dup2 car
        (* [address, <list>], [address, <dalin>] or null *)
        dup <null> == if
        drop2 drop2
        <end-of-one-lambda-body>
        drop,lambda-body-stack
        Exit
      then
      (* [address, <list>], [address, <dalin>] *)
      xx|tuck|xx
      (* [address, <dalin>],
         [address, <list>], [address, <dalin>] *)
      ->  (* up date the 1st lambda-body in lambda-body-stack *)
      [cons,car]! drop2
      car
      Exit
    ; define-function


    :" help:apply,eval-lambda-body said:
       ``My function type is (* unknow -- unknow *)
         I call `lambda-forth' to do side-effect on lambda-body-stack
         The symbol I meet should always DenoteLambdaArgument
         But I meet the following symbol
         I will not touch it and call debuger''
       --> "
    : Message:help:apply,eval-lambda-body,error,symbol
    ; define-constant-string

    : help:apply,eval-lambda-body
      (* unknow -- unknow *)
      lambda-forth
      dup <end-of-one-lambda-body> == if
        drop Exit
      then

      (* examples:
           [{ :x  . { 100 } }, <bound-variable>]
           [{ ::x . { 666 <fixnum> } }, <bound-variable>] *)
      dup <bound-variable> == if
        cdr
        stack<-FIAF-list
        help:apply,eval-lambda-body
        Exit
      then

      (* example:
           [{ word-name . word-explainer }, <explainer-pair>] *)
      dup <explainer-pair> == if
        cdr
        drop (* drop type-tag: <explainer> *)
        execute
        help:apply,eval-lambda-body
        Exit
      then

      (* example:
           [index, <symbol>] *)
      dup <symbol> == if
        dup2 symbol-denote-lambda-argument? if
          drop (* drop <symbol> *)
          index-hashback->string
          execute-word
          help:apply,eval-lambda-body
          Exit
        then
        Message:help:apply,eval-lambda-body,error,symbol print-string
        dup2 write cr
        debuger
        Exit
      then

      (* example:
           [666, <fixnum>] *)
      dup <fixnum> == if
        drop (* drop type-tag: <fixnum> *)
        help:apply,eval-lambda-body
        Exit
      then

      (* examples:
           [address, <list>]
           [address, <dalin>]
           [address, <wodyli>]
         and all other types
         leave the value and the type in the stack *)
      help:apply,eval-lambda-body
      Exit
    ; define-recursive-function
    #+end_src
*** apply
    #+begin_src cicada :tangle english-core.cicada
    (* examples of <lambda-argument>:
         { :x       . { 1 } }
         { ::null   . { Null <null> } }
         { ::number . { 666 <fixnum> } }
       example of bound-variable-wodyli
         ( :a ::b :::c )
         [ { :a    . ... }
           { ::b   . ... }
           { ::::c . ... } ]
     *)


    : help-to-rec,help:apply,set-variables
      (* ArgumentStack::
         ..., [address, <lambda-argument-N>] -- *)
      (* LambdaStack::
         [address, <wodyli>] -- [address, <wodyli>] *)
      dup <lambda-argument>? false? if
        Exit
      then
      dup2   car    get-back dup2 ready
      (* [address, <lambda-argument-N>], [index, <symbol>], [address, <wodyli>] *)
      [value,dalin]-associate
      dup <null> == if
        drop2 Exit
      then
      (* [address, <lambda-argument-N>], [..., <bound-variable>] *)
      xx|swap|xx   cdr
      [cons,cdr]!  drop2
      help-to-rec,help:apply,set-variables
      Exit
    ; define-recursive-function


    : help:apply,set-variables
      (* ..., [address, <lambda-argument>], [address, <wodyli>] -- *)
      ready
        help-to-rec,help:apply,set-variables
      get-back drop2 Exit
    ; define-function



    :" apply said:
       ``My function type is
         (* LambdaStack::  [address, <lambda>] -- unknow *)
         (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
         But the value in the LambdaStack is of the following type
         I will not touch it and call debuger''
       --> "
    : Message:apply,type-error ; define-constant-string
    : apply
      (* LambdaStack::  [address, <lambda>] -- unknow *)
      (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
      get-back dup2 ready
      dup <lambda> == if
        car dup <null> == if
          drop2
        else
          help:apply,set-variables
        then
        get-back  cdr
        push,lambda-body-stack
        help:apply,eval-lambda-body
        Exit
      then
      Message:apply,type-error print-string
      print-type-tag cr
      drop (* drop the the value been getted back *)
      debuger Exit
    ; define-function
    #+end_src
*** syntax sugar
    #+begin_src cicada :tangle english-core.cicada
    : @
      (* ...,
         [address, <lambda-argument>],
         [address, <lambda>]
         ---------------------------
         unknow *)
      ready apply Exit
    ; define-function
    #+end_src
*** test
    #+begin_src cicada
    [ :x 1 + ]  (* push a dalin to ArgumentStack *)
    ( :x )      (* push a symbol `:x' to ArgumentStack *)
               (* digests some symbols and a dalin in the ArgumentStack,
                   and return a lambda-function by them *)
    ready (* pop ArgumentStack, push the lambda-function to LambdaStack *)

    3   (* push 3 into the ArgumentStack *)
    <:x (* make a typed value of type : <lambda-argument-one> *)

    apply (* apply a lambda-function in the LambdaStack function
             to the ArgumentStack,
             the arguments of the above lambda-function is labeled with a symbol `:x',
             so if there are many arguments, order will be not important *)

    write-dec-number (* 4 *) cr

    (* -------------------------------------------------------------- *)

    [ + + + ] ( :x )  ready
    1 2 3 4  apply
    write-dec-number (* 10 *) cr

    [ :x 1 2 3 * + + ] ( :x )  ready
    100 <:x
    apply
    write-dec-number (* 107 *) cr

    [ 1 :x 2 3 + + + ] ( :x )  ready
    100 <:x
    apply
    write-dec-number (* 106 *) cr

    [ 1 2 3 + :x + + ] ( :x )  ready
    100 <:x
    apply
    write-dec-number (* 106 *) cr

    [ :::x + + ] ( :::x )  ready
    1 2 3 <:::x
    apply
    write-dec-number (* 6 *) cr

    [ ::x + ] ( ::x )  ready
    1 2 <::x
    apply
    write-dec-number (* 3 *) cr

    [ :x * + + ] ( :x )  ready
    1 2 3
    100 <:x
    apply
    write-dec-number (* 303 *) cr

    [ :x + + + ] ( :x )  ready
    1 2 3
    100 <:x
    apply
    write-dec-number (* 106 *) cr


    (* ------------------------------------ *)
    (* the following tests are with scope *)

    [ [ :x + + + ] ( :x )  ready
      1 2 3
      100 <:x
      apply :y + ]
    ( :y )  ready
    10 <:y
    apply
    write-dec-number (* 116 *) cr

    [ 1 2 3
      100 <:x [ :x + + + ] ( :x )  @
      :y + ]
    ( :y )  ready
    10 <:y
    apply
    write-dec-number (* 116 *) cr

    [ 1 2 3
      100 <:x [ :x :x + + + + ] ( :x )  @
      :y + ]
    ( :y )  ready
    10 <:y
    apply
    write-dec-number (* 216 *) cr

    [ 1 2 3
      100 <:x [ :y + + + ] ( :x )  @
      :y + ]
    ( :y )  ready
    10 <:y
    apply
    write-dec-number (* 26 *) cr

    [ 1 2 3
      100 <:x [ :y :x + + + + ] ( :x )  @
      :y + ]
    ( :y )  ready
    10 <:y
    apply
    write-dec-number (* 126 *) cr

    [ 1 2 3
      100 <:x [ :x :y + + + + ] ( :x )  @
      :y + ]
    ( :y )  ready
    10 <:y
    apply
    write-dec-number (* 126 *) cr

    [ 1 2 3
      100 <:x [ :y :y + + + + ] ( :x )  @
      :y + ]
    ( :y )  ready
    10 <:y
    apply write-dec-number (* 36 *) cr

    [ 1 2 3 [ :y :y + + + + . ] null  @ ]
    ( :y )  ready
    1000 <:y
    apply  (* 2006 *) cr


    [ 1 2 3 [ :y :y + + + + ] null  @ ]
    ( :y )  ready
    1000 <:y
    apply write-dec-number (* 2006 *) cr

    [ 1 2 3 [ :y :y + + + + ] ( )  @ ]
    ( :y )  ready
    1000 <:y
    apply write-dec-number (* 2006 *) cr


    (* ----------------------------------- *)
    (* explicit lazy-eval  *)
    666
    1 2 3 4
     [ + + + ] ( )  @
     . (* 10 *) cr
    . (* 666 *) cr

    666
    1 2 3 4
     [ + + + ] null  @
     . (* 10 *) cr
    . (* 666 *) cr


    (* ============================================== *)


    (* ----------------------------------- *)
    (* the following tests need flow-point-number
       for we need to define ``sqrt'' *)

    (*
     * the following shows the problem that people argued at:
     * http://lambda-the-ultimate.org/node/900

     * -b  +/- sqrt(b^2 - 4 * a * c)
     * -----------------------------
     *            2 * a
     *)


    (*
     * [              :b negate
     *     4 :a :c * *
     *         :b :b *  -  sqrt  +
     *                     2 :a  *  / ] dup2 write
     * ( :a :b :c ) dup2 write
     *  ready
     *
     * 1 <:a  2 <:b  1 <:c
     *
     * apply write-dec-number cr (\* -1 *\)
     *)
    #+end_src
** play with lambda
*** note
    1. it is very important to remember
       that lazy-eval must be explicit
    2. and again
       about substitution
       note that you can only use bound-variable (such as ::x :n) in a lambda-body
       bot NOT a dalin or list or wodyli
*** play
    #+begin_src cicada
    [ ::x ]
    ( ::x 3 4 ) 
    : Var,I ; define
    : I Var,I fetch2 Exit ; define-function

    1 2 I @
    . . . . (* 4 3 2 1 *) cr
    cr

    1 2 <::x I @
    . . (* 2 1 *) cr
    cr

    1 2 I @
    . . . . (* 2 1 2 1 *) cr
    cr


    [ ::x ]
    ( ::x 3 4 ) 
    : I ; define
    : I I fetch2 Exit ; define-function

    1 2 I @
    . . . . (* 4 3 2 1 *) cr
    cr

    1 2 <::x I @
    . . (* 2 1 *) cr
    cr

    1 2 I @
    . . . . (* 2 1 2 1 *) cr
    cr



    [ [ ::T @ ]
      ( ::F )  ]
    ( ::T ) 
    : Var,T ; define
    : T Var,T fetch2 Exit ; define-function

    [ 1 2 3 . . . ] ( )  <::T
    T @ ready
    [ 7 8 9 . . . ] ( )  <::F
    apply (* 3 2 1 *) cr

    [ 1 2 3 . . . ] null  <::T
    [ 7 8 9 . . . ] null  <::F
    T @ @ (* 3 2 1 *) cr

    [ 7 8 9 . . . ] ( )  <::F
    [ 1 2 3 . . . ] ( )  <::T
    T @ @ (* 3 2 1 *) cr

    cr

    [ [ ::F @ ]
      ( ::F )  ]
    ( ::T ) 
    : Var,F ; define
    : F Var,F fetch2 Exit ; define-function

    [ 1 2 3 . . . ] null  <::T
    F @ ready
    [ 7 8 9 . . . ] null  <::F
    apply (* 9 8 7 *) cr

    cr


    : make-lambda-bool
      (* True or False -- T or F *)
      true? if
        T Exit
      then F Exit
    ; define-function

    [ [ ::true <::T :if make-lambda-bool @ ready
        ::false <::F apply ]
      ( :if )  ]
    ( ::true ::false ) 
    : Var,IF ; define
    : IF Var,IF fetch2 Exit ; define-function

    True <:if
    [ 1 2 3 . . . ] null  <::true
    [ 7 8 9 . . . ] null  <::false
      IF @
    @ (* 3 2 1 *) cr

    [ 1 2 3 . . . ] null  <::true
    [ 7 8 9 . . . ] null  <::false
      IF @ ready
    True <:if apply (* 3 2 1 *) cr

    [ 7 8 9 . . . ] null  <::false
    [ 1 2 3 . . . ] null  <::true
      IF @ ready
    True <:if apply (* 3 2 1 *) cr

    [ 7 8 9 . . . ] null  <::false
    [ 1 2 3 . . . ] null  <::true
      IF @ ready
    False <:if apply (* 9 8 7 *) cr

    cr

    (* Y-combinator
       using explicit lazy-eval
       for cicada's semantic is eager-eval
       because lazy-eval is not natural to postfix-notation
     *)

    (*
     * in -cal:
     * Y = (y.(x.y(xx))(x.y(xx)))
     *
     * in daedalus:
     * (def Y
     *   ( (y)
     *     (( (x) (y (x x)))
     *      ( (x) (y (x x))))))
     *)

    (* in cicada: *)


    [ [ [ ::x <::x ::x @ ] null  <::rec ::y @ ]  ( ::x )  <::x
      [ [ ::x <::x ::x @ ] null  <::rec ::y @ ]  ( ::x )  @ ]
    ( ::y ) 
    : Var,Y ; define
    : Y Var,Y fetch2 Exit ; define-function


    [ [ [ One ] null  <::true
        [ :n :n sub1 <:n ::rec @ @ * ] null  <::false
         IF @ ready
        :n one? <:if apply ]
      ( :n )  ]
    ( ::rec )   <::y  Y @
    : Var,factorial ; define
    : factorial Var,factorial fetch2 Exit ; define-function

    1 <:n factorial @ .
    2 <:n factorial @ .
    3 <:n factorial @ .
    4 <:n factorial @ .
    5 <:n factorial @ .
    6 <:n factorial @ .
    7 <:n factorial @ .
    8 <:n factorial @ .
    cr

    (* ================================================== *)
    (* TODO the heuristic about Y *)

    [ [ One ] null  <::true
      [ :n :n sub1

          <:n
          [ [ One ] null  <::true
            [ :n :n sub1

            <:n
            [ [ One ] null  <::true
              [ :n :n sub1

                  * ]
            null  <::false
               IF @ ready
              :n one? <:if apply ]
            ( :n )  @

                * ]
          null  <::false
             IF @ ready
            :n one? <:if apply ]
          ( :n )  @

             * ]
       null  <::false
       IF @ ready
      :n one? <:if apply ]
    ( :n ) 

    dup2 ready
    1 <:n apply . (* 1 *) cr
    dup2 ready
    2 <:n apply . (* 2 *) cr
    dup2 ready
    3 <:n apply . (* 3 *) cr
    drop2
    cr
    #+end_src
** >< interface for lambda
*** note
*** implementation
    #+begin_src cicada
    [ ::x ]
    ( ::x 3 4 ) 
    : I ; defineLambda


    : Var,I ; define
    : I Var,I fetch2 Exit ; define-function


    : defineLambda,byString
      (* [value, type], string[address, length] -- *)

      Exit
    ; define-function

    : defineLambda,byString
      (* [value, type], wordlist[address, number of words] -- *)
      head-of-word-list
      defineLambda,byString
      Exit
    ; define-function
    #+end_src
* >< editor
** x & k
   - x :: text
          
   - x ::  string-processing function
           
          
          
           string-processing function 
          cicadastring-processing
          cicadastring-processing
          cicadastring-processing
          
          ()
          
              
           
          
          
          ;-- """"
          ;-- 
          ;-- 
           
          
          
          
          
            
          
          
          cicada
          gc
   - k :: !
          
          gc
   - x :: 
          
              
          
          
            
             
          
          hash-tablefind
           
             
** x & k 2
   - x :: 
          
          
   - k :: emacs
          
          dalinwodyli
   - x :: 
          wodyli
          
          
          
          modeparser
          [mode] :: string =parser=> structured-string
          bufferstructured-string
          structured-stringScreenBuffer
          structured-stringediting-pointer
          mode
          structured-string =structure-displayer=> ScreenBuffer
          editing-pointer
          ScreenBufferCursor
   - k :: mode
          
          modestructure
          structuresexp?
          listdalin
          
   - x :: wodyli
          sexp
** note
   1. the loop :
      1) read a key (a char)
      2) according to some global variables
         dispatch a key to a function and execute
         the execution of a function
         will edit the datastructure for text
         and  edit the datastructure for display
      3) update display
      4) loop
      so it is a ``REDL''
   2. two datastructures for cicada-editor
      one for text
      one for display
   3. key binding :
      every key can be bound to any function
** string->line-dalin
   every mode has its parser
   string->line-dalin is the parser of fundamental-mode
   #+begin_src cicada
   : find-char-address
     (* char, [address, length] -- address or -1 *)
     dup zero? if
       drop2 drop
       One negate
       Exit
     then
     tail-and-head-of-string
     x|over|xxx == if
       drop swap drop
       sub1 Exit
     then
     find-char-address
     Exit
   ; define-recursive-function

   : find-char-index
     (* char, [address, length] -- index or -1 *)
     (* index start from Zero *)
     over
     xxx|swap|x
     find-char-address
     dup Zero < if
       swap drop Exit
     then
     swap -
     Exit
   ; define-function


   (* little test:
    * 'k' s" k" find-char-index . (\* 0 *\) cr
    * 'k' s" kkk" find-char-index . (\* 0 *\) cr
    * 'k' s" skkk" find-char-index . (\* 1 *\) cr
    * 'k' s"  kkk" find-char-index . (\* 1 *\) cr
    * 'k' s" 0123456789k" find-char-index . (\* 10 *\) cr
    * 'k' s" 0123456789" find-char-index . (\* -1 *\) cr
    *)



   : help:string->line-dalin
     (* [address, length] -- head[address, <dalin>] *)
     (* LambdaStack:: [address, <dalin>] -- *)
     dup zero? if
       get-back
       dup2
         cdr null [cons,cdr]!
         drop2
       head<-dalin
       Exit
     then
     dup2
     'linefeed' xx|over|x find-char-index
     dup Zero < if
       (* this means if a string is not end with 'linefeed'
          a 'linefeed' will be added at the end *)
       drop
       dup substring
       xx|tuck|x
       swap copy-byte-string
       <substring>
       cons drop <dalin>
       [car,cons]!
         cons null [cons,cdr]!
       [cons,cdr]!
       get-back
       xx|swap|xx
       ^_^
       head<-dalin
       Exit
     then
     (* [address, length], index-of-linefeed *)
     x|over|xx over + add1
     xxx|swap|x (* leave the new address *)
     swap over - sub1
     xx|swap|x (* leave the new length *)
     (* [new address, new length], address, index-of-linefeed *)
     dup zero? if
       (* 'linefeed' is the 1st char of the string
          so we meet an empty line, it will be stored as `null' in dalin *)
       drop2
       null
     else
       (* index-of-linefeed is just the length of substring *)
       dup substring
       xx|tuck|x
       swap copy-byte-string
       <substring>
     then
     cons drop <dalin>
     [car,cons]!
       cons null [cons,cdr]!
     [cons,cdr]!
     get-back
       xx|swap|xx
       ^_^
     ready
     help:string->line-dalin
     Exit
   ; define-recursive-function

   : string->line-dalin
     (* [address, length] -- head[address, <dalin>] *)
     (* which parses a string and return a dalin of substring
        one substring denotes one line of text
        empty line is stored as `null' in dalin *)
     null ready
     help:string->line-dalin
     Exit
   ; define-function
   #+end_src
** test: string->line-dalin
   #+begin_src cicada
   s" kkk" string->line-dalin
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr

   s" kkk
   " string->line-dalin
   dup2 dalin*? . (* 1 *) cr
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr

   s" kkk
   aaa" string->line-dalin
   dup2 dalin*? . (* 0 *) cr
   dup2
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr
   ->
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* aaa *) cr

   s" kkk
   aaa
   " string->line-dalin
   dup2 dalin*? . (* 0 *) cr
   dup2
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr
   ->
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* aaa *) cr
   #+end_src
** >< reduce text-editing to line-editing
   #+begin_src cicada
   (* buffer: ==
        [address]
      line: ==
        buffer[address, length], cursors[address, <list>]
      where:
        cursor is a Zero-based-index, from Zero to length *)


   0 : Var,LineBuffer ; define-variable

   Here fetch Var,LineBuffer save
   1000 Here add-save

   : LineBuffer (*  -- buffer[address] *)
     Var,LineBuffer fetch
     Exit
   ; define-function


   0 : Var,Tmp,LineBuffer ; define-variable

   Here fetch Var,Tmp,LineBuffer save
   1000 Here add-save

   : Tmp,LineBuffer (*  -- buffer[address] *)
     Var,Tmp,LineBuffer fetch
     Exit
   ; define-function


   : copyStringToBuffer
     (* string[address, length], buffer[address] --
        buffer[address, length] *)
     push-lambda-stack
     tuck
     pop-lambda-stack dup push-lambda-stack
     swap copy-byte-string
     pop-lambda-stack
     swap
     Exit
   ; define-function

   : copyStringToLine
     (* string[address, length], buffer[address] --
        buffer[address, length], cursors[address, <list>] *)
     copyStringToBuffer
     cons drop <list>
     Zero <fixnum>
     [cons,car]!
     Exit
   ; define-function


   : line,move-cursor-right
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|over|x car drop (* drop <fixnum> *)
     +  <fixnum> [cons,car]!
     Exit
   ; define-function

   : line,move-cursor-left
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|over|x car drop (* drop <fixnum> *)
     -  <fixnum> [cons,car]!
     Exit
   ; define-function

   : line,move-cursor-to-col
     (* buffer[address, length], cursors[address, <list>], index --
        buffer[address, length], cursors[address, <list>] *)
     <fixnum> [cons,car]!
     Exit
   ; define-function


   (* ><><><
      the following two functions need better factoring *)

   : insertString
     (* string[address, length],
        buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     dup2 ready
     xx|over|xx ready
     car drop (* drop <fixnum> *)
     tuck -
     xx|swap|x +
       dup push-lambda-stack (* address of middle buffer *)
     swap
     Tmp,LineBuffer copyStringToBuffer
     xx|swap|xx
     pop-lambda-stack copyStringToBuffer
       dup push-lambda-stack (* length of string *)
     + copyStringToBuffer
     drop2
     pop-lambda-stack
     get-back x|swap|xx dup push-lambda-stack
     +
     pop-lambda-stack
     get-back
     x|tuck|xx car drop (* <fixnum> *)
     + <fixnum> [cons,car]!
     Exit
   ; define-function

   (*
    * test:
    * s"  xxx "
    * s"  kkk " LineBuffer copyStringToLine
    * 2 line,move-cursor-right
    * insertString
    * car write (\* 7 *\) cr
    * print-string (\*  k xxx kk  *\) cr
    *)

   : insertChar
     (* char,
        buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     dup2 ready
     xx|over|xx ready
     car drop (* drop <fixnum> *)
     tuck -
     xx|swap|x +
       dup push-lambda-stack (* address of middle buffer *)
     swap
     Tmp,LineBuffer copyStringToBuffer
     x|swap|xx
     pop-lambda-stack tuck save-byte
     add1
     copyStringToBuffer
     drop2
     get-back add1
     get-back dup2 car drop (* <fixnum> *)
     add1 <fixnum> [cons,car]!
     Exit
   ; define-function


   (*
    * test:
    * 'x'
    * s"  kkk " LineBuffer copyStringToLine
    * 2 line,move-cursor-right
    * insertChar
    * car write (\* 3 *\) cr
    * print-string (\*  kxkk  *\) cr
    *)


   : deleteChars
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|tuck|x
     xx|swap|x dup2 ready
     car drop (* drop <fixnum> *)
     +
     (* buffer[address, length], number, number + cursors *)
     xx|swap|x  -
     (* buffer[address], number + cursors, length - number *)
     x|over|xx swap ready
     (* buffer[address], number + cursors *)
     +
     xx|swap|x

     Exit
   ; define-function

   : line,kill-line (* erase-half-line-to-end *)
     (* buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     Exit
   ; define-function







   (*
    * : text,move-cursor-up (\* number -- *\)
    * ; define-function
    *
    * : text,move-cursor-down (\* number -- *\)
    * ; define-function
    *
    * : text,move-cursor-down-&-to-the-begin-of-line (\* number -- *\)
    * ; define-function
    *
    * : text,move-cursor-up-&-to-the-begin-of-line (\* number -- *\)
    * ; define-function
    *)




   (*
    * : text,move-cursor-to-row (\* row-index -- *\)
    * ; define-function
    *
    * : text,move-cursor-to-row-&-col (\* row-index, col-index -- *\)
    * ; define-function
    *)


   (* the position of the cursor
    * is also as an argument of the following functions
    * but the cursor do not move when these functions are executed
    *)



   (*
    * : delete-lines (\* number -- *\)
    * ; define-function
    *)



   (*
    * : erase-half-screen-to-end (\* -- *\)
    * ; define-function
    *
    * : erase-half-screen-to-start (\* -- *\)
    * ; define-function
    *
    * : erase-screen (\* -- *\)
    * ; define-function
    *)
   #+end_src
** >< tryREDL
   just use the ``read-char''
   #+begin_src cicada
   :" 1234567890"
   : InitString,for-update-display ; define-constant-string

   InitString,for-update-display
   : Var-string,for-update-display ; define


   : update-display
     (*  --  *)
     terminal,clearScreen
     Var-string,for-update-display
     fetch2 print-string cr
     Exit
   ; define-function


   :" kkk
   : tryREDL (*  --  *)
     setTerminalToReadKey
     help:tryREDL
     Exit
   ; define-function
   "
   : String-for,kkk ; define-constant-string

   :" kkk" string-hash->index
   : Symbol-index:kkk ; define-constant
   : kkk (*  -- *)
     String-for,kkk
     Var-string,for-update-display
     save2
     Exit
   ; define-function

   :" aaa

   : help:tryREDL (*  --  *)
     (* D *)
     update-display
     (* R *)
     read-char  (* write-space write-dec-number cr *)
     (* E *)
     char->function-name-symbol
     executeSymbol
     (* L *)
     help:tryREDL
     Exit
   ; define-recursive-function
   "
   : String-for,aaa
   ; define-constant-string

   :" aaa" string-hash->index
   : Symbol-index:aaa ; define-constant
   : aaa (*  -- *)
     String-for,aaa
     Var-string,for-update-display
     save2
     Exit
   ; define-function



   (* in the future this funciton must see a lot of global variables *)
   : char->function-name-symbol
     (* char -- [index, <symbol>] *)
     dup 'k' == if
       drop Symbol-index:kkk <symbol> Exit
     then
     dup 'a' == if
       drop Symbol-index:aaa <symbol> Exit
     then
     Exit
   ; define-function


   :" executeSymbol said:
      ``My function-type is (* [index, <symbol>] -- unknown *)
        But I meet the following type
        I will not touch it and call debuger.''
      --> "
   : Message:executeSymbol,type-error ; define-constant-string
   : executeSymbol (* [index, <symbol>] -- unknown *)
     dup <symbol> =/= if
       Message:executeSymbol,type-error print-string
       dup print-type-tag cr
       debuger
       Exit
     then
     drop (* drop <symbol> *)
     index-hashback->string
     execute-word
     Exit
   ; define-function



   : help:tryREDL (*  --  *)
     (* D *)
     update-display
     (* R *)
     read-char
     (* E *)
     char->function-name-symbol
     executeSymbol
     (* L *)
     help:tryREDL
     Exit
   ; define-recursive-function

   : tryREDL (*  --  *)
     setTerminalToReadKey
     help:tryREDL
     Exit
   ; define-function

   : t tryREDL Exit ; define-function
   #+end_src
* misc
** >< memory allocation
*** note
    make good use of lambda
*** implementation (new lexicographers)
    #+begin_src cicada
    constants:
    (StackName),Size (* unit: Cell-width *)
    (StackName),Bottom
    (StackName),Top

    variables:
    (StackName),Pointer

    functions:
    push,(StackName)
    pop,(StackName)
    empty?(StackName)



    : defineStack (*  -- *)
    ; define-function

    : defineHeap (*  -- *)
    ; define-function

    : defineArray (*  -- *)
    ; define-function

    : defineBuffer (*  -- *)
    ; define-function
    #+end_src
** --------------------------------------
** ok
   for the REPL is actually a REL which does not print
   so I provide a word to check that the cicada is working properly
   #+begin_src cicada :tangle english-core.cicada
   :" yes"
   : Message:yes ; define-constant-string
   : ok (* -- *)
     Message:yes print-string
     write-space
     Exit
   ; define-function
   #+end_src
** --------------------------------------
** welcome
   #+begin_src cicada :tangle english-core.cicada
   :"    welcome to cicada ^_^"
   : Message:welcome ; define-constant-string
   : welcome (* -- *)
     Message:welcome print-string cr
     Exit
   ; define-function

   cr

   welcome

   cr

   (* report the User-data-area size *)
   ."  the size of User-data-area is: " cr
   write-space
   End-of-user-data-area  User-data-area  -  write-dec-number
   ."  bytes" cr

   write-space
   End-of-user-data-area  Here fetch  -  write-dec-number
   ."  bytes free" cr

   write-space
   Here fetch  User-data-area  -  write-dec-number
   ."  bytes used" cr

   cr

   ."  you are in symbol-REPL
    in this REPL some types of symbol will be processed specially" cr

   cr
   #+end_src
* ==================================================
