#+TITLE: cicada english core
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* note
** about note
   1. note serves as one part of documentations of cicada language
   2. if both version existed
      Chinese version will follows English version
** about key-word
   ----------------------------------
   1. 有两类 key-word
      一类是 if else then comment colon
      它们 的实现方式 类似于 scheme 中对语法的扩展
      只不过这里用的是最基本的对字符串的处理
      而 scheme 中使用的是 一种 模式匹配 语言
      蝉语中的方法虽然基本 更具灵活性
   2. 另一类是 literal branch false?branch address
      它们虽然也以其后的 string 为参数
      但是行为方式却有明显的不同
      它们 以指定的方式 把后面的 string 处理好
      并编译到函数体当中的同时
      还会 在这之前 编译一个
      定义在汇编中的函数的地址
      这个汇编中的函数以特定的方式解释 函数体中 在其后的值
      这些函数通常定义在汇编中的原因是
      它们需要改变 Return-stack 的栈顶的值
      而 我实现 栈虚拟机 的方式
      不允许我在 非汇编函数中随意地处理 Return-stack
   3. 第一类语法关键词 是真正意义上的语法关键词
      而 第二类语法关键词 存在的原因
      是去 改变 虚拟机对函数体内部的值的单一的解释方式
** about parsing string
   ----------------------------------
   1. parsing 的 意思是语法解析
      这里 简单的 对字符串的 语法解析的 例子如下 :
      1) 阅读 用字符串 表示的 各个进位制的数字
         然后 在函数体中编译一些适当的 Cell
         栈机 执行函数体时
         当执行到这些被编入其中的适当的 Cell 的时候
         将会把所表示的数值入栈
      2) 又比如 阅读表示 字符 和 字符串 的字符串
         当然还有 阅读表示 各种链表 的字符串
      3) 这些例子都是对某类数据类型的阅读
   2. 在 实现 蝉语 的过程中 我发现 我有两种简单的作语法解析的方式
      1) 第一种方式的例子是
         string-denote-integer 还有 string->integer,with-error
         这两个函数 对 表示 各个进位制的数字 的字符串的处理
         它们都是 以字符串为参数 以 数值为返回值的函数
         编译的工作 被 需要被另外的 函数进行
      2) 第二中方式在于
         设计各种前缀 key-word
         也就是说把 解析前缀的工作
         从一个大的 解析字符串的函数中分离出来
         然后 把这些前缀实现为 第二类语法关键词
         此时就需要加空格了
         比如 对字符 解析 可以被实现为 "char A"
      3) 其实 还有一种相对不重要的方式
         就是把 某些数据
         直接实现为 蝉语 中的名词
         并且 设计 具有所需要的形态的字符串 来命名它们
   3. 对比 一下 两种实现方式
      就会发现非常有趣的结果
      1) 首先不能说那种方式更灵活
         因为它们分别受 空格 的限制
         只不过 空格 限制它们的方式不同
      2) 但是 第二种方式 具有更好的可维护性
         因为它把一个大函数 拆开成了很多小函数
      3) 我可以
         1. 把第一种 处理方式 命名为 符号性的处理方式
            此时你要设计符号的形态
            比如 2#0001_1111 表示 二进制数
         2. 把第二种 处理方式 命名为 前缀性的处理方式
            此时你要选择合适的前缀
            比如 char A
      4) 我认为 前缀性的处理方式 更好
         因为 它节省了 我对表达 各种数据结构的 字符串 的形态上的设计
         还因为 它用更明显的视觉形态 降低了 代码的阅读者的 "认知上的负担"
         + 前提是有语法高亮的帮助
         并且 很适合中文 因为中文中原本就没有很多不表意
         而 单表 句之结构的 标点符号
         在我的中文代码中 表 句之结构的 标点符号 就只有空格而已
         其实也类似于标点符号 因为它们也有 表明句之结构的功能
         只不过它们 使用了 比异于文字的 标点符号 更 让人亲近的 文字本身 而已
* ==================================================
* *test*
  #+begin_src cicada
  : factorial (* n -- n! *)
    dup one? if
      Exit
    then
    dup sub1 factorial * Exit
  ; define-verb


  1 factorial .
  2 factorial .
  3 factorial .

  (* need to re-define "." to run the following *)
  4 factorial .
  5 factorial .
  6 factorial .
  7 factorial .
  8 factorial .
  9 factorial .
  10 factorial .
  11 factorial .
  12 factorial .
  13 factorial .
  14 factorial .
  15 factorial .
  16 factorial .
  17 factorial .
  18 factorial .
  19 factorial .
  20 factorial .
  #+end_src
* lexicographer
** define-key-word
   #+begin_src cicada :tangle english-core.cicada
   : define-key-word
     (* words-string[address, length] -- *)
     tail-and-head-of-word-string
     create-word-header
     dup push-lambda-stack
       add-new-word-to-dictionary
       Verb-explainer append-number-to-here
       append-word-description-to-here
     pop-lambda-stack
     dup set-size-of-word
     word,link->address-of-type
     1 swap save-byte
     Exit
   ; define-verb
   #+end_src
* char
** [key-word] char
   #+begin_src cicada :tangle english-core.cicada
   (* need UTF-8 support in the following function *)
   : string->char
     (* string[address, length] -- char *)
     drop fetch-byte
     Exit
   ; define-verb

   : char
     (* word-string[address, length] -- word-string[address, length] *)
     (* compile::
          _literal[address of explainer], char *)
     literal _literal append-number-to-here
     tail-and-head-of-word-string
     string->char append-number-to-here
     Exit
   ; define-key-word
   #+end_src
* *test*
  #+begin_src cicada
  : .12 (* 1 2 -- *)
    2 == if
      char 2 write-char
      1 == if
        char 1 write-char
      else
        char _ write-char
      then
    else
      char _ write-char
      1 == if
        char 1 write-char
      else
        char _ write-char
      then
    then
    Exit
  ; define-verb

  1 2 .12 cr
  6 2 .12 cr
  1 6 .12 cr
  6 6 .12 cr
  #+end_src
* >< string
** note
   1. I will NOT implement simple string as "aaa"
      I have tried
      and I found that
      it against the natural of a Forth-like language so much
** [key-word] string
   #+begin_src cicada
   : :" (* -- string[address of Basic-string-buffer, length] *)
     read-string-into-buffer
     Exit
   ; define-verb

   : ." (* -- string[address of Basic-string-buffer, length] *)
     read-string-into-buffer print-string
     Exit
   ; define-verb
   #+end_src
* number writer
** note
   1. due to the lack of the "semantic of substitution"
      to achieve the following functions
      I have to copy lots of code
      instead of just using lambda-abstraction
** implementation
*** write-dec-number
    #+begin_src cicada
    : write-dec-number-char (* byte -- *)
      '0' + write-char
      Exit
    ; define-verb

    : help:write-dec-number,push-chars
      (* ... , number of small DecNumbers, fixnum --
         ... , number of small DecNumbers *)
      10 moddiv
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help:write-dec-number,push-chars
      Exit
    ; define-verb

    : help:write-dec-number,write-chars
      (* ... , number of small DecNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-dec-number-char
      help:write-dec-number,write-chars
      Exit
    ; define-verb


    : write-dec-number,unsign (* fixnum -- *)
      0 swap
      help:write-dec-number,push-chars
      help:write-dec-number,write-chars
      Exit
    ; define-verb

    : write-dec-number,sign (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-dec-number,unsign
      Exit
    ; define-verb

    : write-dec-number
      write-dec-number,sign
      Exit
    ; define-verb
    #+end_src
*** write-bin-number
    #+begin_src cicada
    : write-bin-number-char (* byte -- *)
      '0' + write-char
      Exit
    ; define-verb

    : help:write-bin-number,push-chars
      (* ... , number of small BinNumbers, fixnum --
         ... , number of small BinNumbers *)
      2 moddiv
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help:write-bin-number,push-chars
      Exit
    ; define-verb

    : help:write-bin-number,write-chars
      (* ... , number of small BinNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-bin-number-char
      help:write-bin-number,write-chars
      Exit
    ; define-verb

    : write-bin-number,unsign (* fixnum -- *)
      0 swap
      help:write-bin-number,push-chars
      help:write-bin-number,write-chars
      Exit
    ; define-verb

    : write-bin-number,sign (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-bin-number,unsign
      Exit
    ; define-verb

    : write-bin-number
      write-bin-number,sign
      Exit
    ; define-verb
    #+end_src
*** write-oct-number
    #+begin_src cicada
    : write-oct-number-char (* byte -- *)
      '0' + write-char
      Exit
    ; define-verb

    : help:write-oct-number,push-chars
      (* ... , number of small OctNumbers, fixnum --
         ... , number of small OctNumbers *)
      8 moddiv
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help:write-oct-number,push-chars
      Exit
    ; define-verb

    : help:write-oct-number,write-chars
      (* ... , number of small OctNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-oct-number-char
      help:write-oct-number,write-chars
      Exit
    ; define-verb

    : write-oct-number,unsign (* fixnum -- *)
      0 swap
      help:write-oct-number,push-chars
      help:write-oct-number,write-chars
      Exit
    ; define-verb

    : write-oct-number,sign (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-oct-number,unsign
      Exit
    ; define-verb

    : write-oct-number
      write-oct-number,sign
      Exit
    ; define-verb
    #+end_src
*** write-hex-number
    #+begin_src cicada
    : write-hex-number-char (* byte -- *)
      dup 10 < if
        '0' + write-char Exit
      then
      10 -
      'a' + write-char
      Exit
    ; define-verb

    : write-hex-number-char,capital (* byte -- *)
      dup 10 < if
        '0' + write-char Exit
      then
      10 -
      'A' + write-char
      Exit
    ; define-verb

    : help:write-hex-number,push-chars
      (* ... , number of small HexNumbers, fixnum --
         ... , number of small HexNumbers *)
      16 moddiv
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help:write-hex-number,push-chars
      Exit
    ; define-verb

    : help:write-hex-number,write-chars
      (* ... , number of small HexNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-hex-number-char
      help:write-hex-number,write-chars
      Exit
    ; define-verb

    : help:write-hex-number,write-chars,capital
      (* ... , number of small HexNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-hex-number-char,capital
      help:write-hex-number,write-chars,capital
      Exit
    ; define-verb

    : write-hex-number,unsign (* fixnum -- *)
      0 swap
      help:write-hex-number,push-chars
      help:write-hex-number,write-chars
      Exit
    ; define-verb

    : write-hex-number,capital (* fixnum -- *)
      0 swap
      help:write-hex-number,push-chars
      help:write-hex-number,write-chars,capital
      Exit
    ; define-verb

    : write-hex-number,sign (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-hex-number,unsign
      Exit
    ; define-verb

    : write-hex-number,sign,capital (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-hex-number,capital
      Exit
    ; define-verb

    : write-hex-number
      write-hex-number,sign
      Exit
    ; define-verb
    #+end_src
*** write-aph-number
    #+begin_src cicada
    : write-aph-number-char (* byte -- *)
      dup 10 < if
        '0' + write-char Exit
      then
      10 -
      'a' + write-char
      Exit
    ; define-verb

    : write-aph-number-char,capital (* byte -- *)
      dup 10 < if
        '0' + write-char Exit
      then
      10 -
      'A' + write-char
      Exit
    ; define-verb

    : help:write-aph-number,push-chars
      (* ... , number of small AphNumbers, fixnum --
         ... , number of small AphNumbers *)
      36 moddiv
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help:write-aph-number,push-chars
      Exit
    ; define-verb

    : help:write-aph-number,write-chars
      (* ... , number of small AphNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-aph-number-char
      help:write-aph-number,write-chars
      Exit
    ; define-verb

    : help:write-aph-number,write-chars,capital
      (* ... , number of small AphNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap write-aph-number-char,capital
      help:write-aph-number,write-chars,capital
      Exit
    ; define-verb

    : write-aph-number,unsign (* fixnum -- *)
      0 swap
      help:write-aph-number,push-chars
      help:write-aph-number,write-chars
      Exit
    ; define-verb

    : write-aph-number,capital (* fixnum -- *)
      0 swap
      help:write-aph-number,push-chars
      help:write-aph-number,write-chars,capital
      Exit
    ; define-verb

    : write-aph-number,sign (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-aph-number,unsign
      Exit
    ; define-verb

    : write-aph-number,sign,capital (* fixnum -- *)
      dup 0 < if
        '-' write-char
        negate
      then
      write-aph-number,capital
      Exit
    ; define-verb

    : write-aph-number
      write-aph-number,sign
      Exit
    ; define-verb
    #+end_src
*** usage
    #+begin_src cicada
    : .unsign (* fixnum -- *)
      write-dec-number
      'space' write-char
      Exit
    ; define-verb

    : .sign (* fixnum -- *)
      write-dec-number,sign
      'space' write-char
      Exit
    ; define-verb


    : . .sign Exit ; define-verb


    : .bin (* fixnum -- *)
      write-bin-number
      'space' write-char
      Exit
    ; define-verb

    : .bin,sign (* fixnum -- *)
      write-bin-number,sign
      'space' write-char
      Exit
    ; define-verb

    : .oct (* fixnum -- *)
      write-oct-number
      'space' write-char
      Exit
    ; define-verb

    : .oct,sign (* fixnum -- *)
      write-oct-number,sign
      'space' write-char
      Exit
    ; define-verb

    : .hex (* fixnum -- *)
      write-hex-number
      'space' write-char
      Exit
    ; define-verb

    : .hex,sign (* fixnum -- *)
      write-hex-number,sign
      'space' write-char
      Exit
    ; define-verb

    : .hex,capital (* fixnum -- *)
      write-hex-number,capital
      'space' write-char
      Exit
    ; define-verb

    : .hex,sign,capital (* fixnum -- *)
      write-hex-number,sign,capital
      'space' write-char
      Exit
    ; define-verb


    : .aph (* fixnum -- *)
      write-aph-number
      'space' write-char
      Exit
    ; define-verb

    : .aph,sign (* fixnum -- *)
      write-aph-number,sign
      'space' write-char
      Exit
    ; define-verb

    : .aph,capital (* fixnum -- *)
      write-aph-number,capital
      'space' write-char
      Exit
    ; define-verb

    : .aph,sign,capital (* fixnum -- *)
      write-aph-number,sign,capital
      'space' write-char
      Exit
    ; define-verb

    : write-space (* -- *)
      'space' write-char Exit
    ; define-verb

    : write-some-space (* n -- *)
      dup zero? if
        drop Exit
      then
      sub1
      write-space
      write-some-space
      Exit
    ; define-verb
    #+end_src
** test
   #+begin_src cicada
   123 321 123321 . . .
   -123 321 -123321 . . .
   -123 321 -123321 .sign .sign .sign
   -123 321 -123321 .unsign .unsign .unsign

   123 321 123321 .bin .bin .bin
   -123 321 -123321 .bin,sign .bin,sign .bin,sign

   123 321 123321 .oct .oct .oct
   -123 321 -123321 .oct,sign .oct,sign .oct,sign

   123 321 123321 .hex .hex .hex
   123 321 123321 .hex,capital .hex,capital .hex,capital
   -123 321 -123321 .hex,sign .hex,sign .hex,sign
   -123 321 -123321 .hex,sign,capital .hex,sign,capital .hex,sign,capital

   123 321 123321 .aph .aph .aph
   123 321 123321 .aph,capital .aph,capital .aph,capital
   -123 321 -123321 .aph,sign .aph,sign .aph,sign
   -123 321 -123321 .aph,sign,capital .aph,sign,capital .aph,sign,capital
   #+end_src
* debuger
** debuger-REPL & trace-function
*** note
    1. "debuger" should be placed in Function-body
       when called, it pause the calculation of the function
       bring you into the debuger-REPL
    2. after type tag encoding
       we should handle type error as possible as we could
    3. the ``IdentificationOf#Word'' in ``def*'' macros is for ``debuger''
*** implementation
    #+begin_src cicada
    : count-return-stack (* -- the length of ReturnStack *)
      Return-stack-top fetch-return-stack-pointer -
      Cell-width /
      sub1 (* for we are in this function call *)
      Exit
    ; define-verb

    : count-argument-stack (* -- the length of ArgumentStack *)
      Argument-stack-top fetch-argument-stack-pointer -
      Cell-width /
      Exit
    ; define-verb


    0 : Return-stack-position   ; define-variable
    0 : Argument-stack-position ; define-variable

    (* the following two function are as interface *)
    : debuger,fetch-from-return-stack (* n -- *)
      sub1 Cell-width *
      Return-stack-position fetch +
      fetch
      Exit
    ; define-verb

    : debuger,fetch-from-argument-stack (* n -- *)
      sub1 Cell-width *
      Argument-stack-position fetch +
      fetch
      Exit
    ; define-verb


    :" bye"
    : Message:bye ; define-constant-string

    : execute-word (* string[address, length] -- unknown *)
      dup2
      string-denote-integer? if
        string->integer,with-error drop
        Exit
      then
      dup2 find dup zero? false? if
        xx|swap|x drop2
        word-link->word-explainer execute
        Exit
      then
      drop
      Message:undefined-word print-string
      print-string cr
      Exit
    ; define-verb

    : debuger-REPL (* unknown -- unknown *)
      read-word-for-runtime
      dup2
      Message:bye equal-string? if
        drop2
        Exit
      then
      execute-word
      debuger-REPL
      Exit
    ; define-verb

    :" debuger said: ``Welcome! Hope you find what's wrong.''"
    : Message:debuger,welcome ; define-constant-string

    :" the length of Return-stack is: "
    : Message:debuger,the-length-of-returnstack ; define-constant-string

    :" the length of Argument-stack is: "
    : Message:debuger,the-length-of-argument-stack ; define-constant-string

    :" debuger said: ``Good bye! The computation will go on!''"
    : Message:debuger,goodbye ; define-constant-string

    : debuger (* unknown -- unknown *)
      Message:debuger,welcome print-string cr
      3 write-some-space Message:debuger,the-length-of-returnstack print-string
        count-return-stack write-dec-number cr
      3 write-some-space Message:debuger,the-length-of-argument-stack print-string
        count-argument-stack write-dec-number cr
      fetch-return-stack-pointer Return-stack-position save
      fetch-argument-stack-pointer Argument-stack-position save
      Input-buffer Current-reading save
      Input-buffer Reading-boundary save
      debuger-REPL
      Message:debuger,goodbye print-string cr
      Exit
    ; define-verb

    (* ><><>< bug ><><>< *)
    (* ``1 fetch'' will cause core dump *)
    : identification-of-word? (* an address in a word -- *)
      dup fetch ==
      Exit
    ; define-verb

    (* ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     * || m(bytes) : name-string  ||
     * ||  1 : size of function body  ||
     * ||  1 : identification  ||
     * ||  1 : link  ||
     * ||  1 : type  ||
     * ||  1 : address-of-name-string-header  ||
     * ||  1 : address-of-explainer  ||
     * ||  n : body  ||
     *)

    : word,body->id
      (* [an address of a cell in a word] -- word[identification] *)
      dup
      identification-of-word? if
        Exit
      then
      Cell-width -
      word,body->id
      Exit
    ; define-verb

    : word,id->name
      (* word[identification] -- string[address, length] *)
      Cell-width 3 * +
      fetch dup
      add8 swap
      fetch
      Exit
    ; define-verb

    : word,id->explainer
      (* word[identification] -- explainer *)
      Cell-width 4 * +
      fetch
      Exit
    ; define-verb

    : word,id->body-size
      (* word[identification] -- body-size *)
      Cell-width -
      fetch
      Exit
    ; define-verb

    : word,id->body-list
      (* word[identification] -- body-list[address, length] *)
      dup
        Cell-width 5 * +
      swap
      word,id->body-size
      Exit
    ; define-verb

    : print-name-of-explainer (* explainer -- *)
      dup Verb-explainer == if
        literal Verb-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Variable-explainer == if
        literal Variable-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Constant-explainer == if
        literal Constant-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      dup Constant-string-explainer == if
        literal Constant-string-explainer
        word,body->id
        word,id->name
        print-string
        drop Exit
      then
      drop
      Exit
    ; define-verb

    : print-function-body-list (* body-list[address, length] -- *)
      dup zero? if
        drop2 Exit
      then
      6 write-some-space
      over fetch word,body->id word,id->name print-string cr
      sub1 swap
      Cell-width + swap
      print-function-body-list
      Exit
    ; define-verb

    :"  -->  "
    : Message:_-->__ ; define-constant-string

    (* the following function is the first function
       on which I must use ``if,else,then'' *)
    : with-pointer,print-function-body-list
      (* [an address of a cell in a word], body-list[address, length] -- *)
      dup zero? if
        drop2 drop Exit
      then
      x|over|xx x|over|xx == if
        Message:_-->__ print-string
      else
        6 write-some-space
      then
      over
      dup fetch special-key-word? if
        fetch word,body->id word,id->name print-string cr
        sub2 swap
        dup
        6 write-some-space
        Cell-width + fetch write-dec-number cr
        Cell-width 2 * + swap
        with-pointer,print-function-body-list
        Exit
      then
      fetch word,body->id word,id->name print-string cr
      sub1 swap
      Cell-width + swap
      with-pointer,print-function-body-list
      Exit
    ; define-verb


    :" trace-function said: ``Ya! Let's trace a function!''"
    : Message:trace-function,welcome ; define-constant-string

    :" The function we use to trace is:"
    : Message:trace-function,function-to-trace ; define-constant-string

    :" The function be traced to is:"
    : Message:trace-function,function-be-traced-to ; define-constant-string

    :" The size of the body of this function is:"
    : Message:trace-function,function-body-size ; define-constant-string

    :" The body of this function is:"
    : Message:trace-function,function-body ; define-constant-string

    :" trace-function said: ``The end of a tracing.''"
    : Message:trace-function,goodbye ; define-constant-string

    : trace-function
      (* [an address of a cell in a word] -- *)
      Message:trace-function,welcome print-string cr
      dup
        3 write-some-space Message:trace-function,function-to-trace print-string cr
        6 write-some-space fetch word,body->id word,id->name print-string cr
      dup (* with-pointer,print-function-body-list still uses original arg *)
      word,body->id
        dup
          3 write-some-space Message:trace-function,function-be-traced-to print-string cr
          6 write-some-space word,id->name print-string cr
        dup
          3 write-some-space Message:trace-function,function-body-size print-string cr
          6 write-some-space word,id->body-size write-dec-number cr
        3 write-some-space Message:trace-function,function-body print-string cr
        word,id->body-list with-pointer,print-function-body-list
      Message:trace-function,goodbye print-string cr
      Exit
    ; define-verb
    #+end_src
*** simple trace
    #+begin_src cicada
    : trace (* n -- *)
      debuger,fetch-from-return-stack
      trace-function
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    (* test: trace-function *)

    : xxx (* n, m -- *)
       debuger
       +
       666 .
       .
       Exit
    ; define-verb

    10 1 xxx
      1 debuger,fetch-from-return-stack  trace-function
      2 debuger,fetch-from-return-stack  trace-function
      bye
    (* 666 11 *)


    : factorial (* n -- n! *)
        dup one? if
          debuger
          Exit
        then
        dup sub1 factorial * Exit
    ; define-verb

    10 factorial
      1 debuger,fetch-from-return-stack
        trace-function
      9 debuger,fetch-from-return-stack
        trace-function
      10 debuger,fetch-from-return-stack
        trace-function
      bye
    . (* 3628800 *)



    (* about tail call *)
    : write-some-space (* n -- *)
        dup zero? if
          drop Exit
        then
        sub1
        'space' write-char
        debuger
        write-some-space
        Exit
    ; define-verb

    100 write-some-space
      1 debuger,fetch-from-return-stack
        trace-function
      2 debuger,fetch-from-return-stack
        trace-function
      bye
    (* Ya! you can never say ``bye'' to this call of ``debuger'' *)
    (* when ever you call ``debuger'' in front of a recursive call, this happens *)
    basic-REPL
    count-argument-stack . (* 0 *)
    count-return-stack . (* 0 *)
    #+end_src
** new lexicographers with debuger
*** note
    1. the following redefined ``append-word-description-to-here''
       will call debuger if it meets a undefined word
    2. there will be syntax-check after the implementation of ``list''
*** implementation
    #+begin_src cicada
    : print-word-list (* word-string[address, the number of words] -- *)
      dup2 string-full-of-blank? if
        drop2
        cr Exit
      then
      3 write-some-space
      tail-and-head-of-word-string print-string cr
      print-word-list
      Exit
    ; define-verb


    :" an error occurs!
    append-word-description-to-here said:
       ``I am a tail-recursive-function.
         My function-type is (* word-string[address, the number of words] -- *)
         `define-verb' and `define-verb' call me.
         The following word is undefined.
         I will print the rest of the Word-list and call debuger.''
       --> "
    : Message:append-word-description-to-here,meet-undefined-word
    ; define-constant-string

    :" The length of the rest of the Word-list is: "
    : Message:append-word-description-to-here,length-of-the-rest-of-the-word-list
    ; define-constant-string

    :" The rest of the Word-list is: "
    : Message:append-word-description-to-here,the-rest-of-the-word-list
    ; define-constant-string


    : append-word-description-to-here
      (* word-string[address, the number of words] -- *)
      dup2 string-full-of-blank? if
        drop2
        Exit
      then
      tail-and-head-of-word-string
      dup2 Bra:comment equal-string? if
        help:append-word-description-to-here,comment
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:if equal-string? if
        help:append-word-description-to-here,if
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:else equal-string? if
        help:append-word-description-to-here,else
        append-word-description-to-here
        Exit
      then
      dup2 Key-word:then equal-string? if
        help:append-word-description-to-here,then
        append-word-description-to-here
        Exit
      then
      dup2 string-denote-literal-or-branch? if
        help:append-word-description-to-here,literal&branch
        append-word-description-to-here
        Exit
      then
      dup2 string-denote-integer? if
        help:append-word-description-to-here,number
        append-word-description-to-here
        Exit
      then
      dup2 find dup zero? false? if
        word-link->word-explainer append-number-to-here
        drop2 (* drop the string[address, length], which is for debuger *)
        append-word-description-to-here
        Exit
      then
      drop (* drop the 0 *)
      Message:append-word-description-to-here,meet-undefined-word print-string
      print-string cr
      Message:append-word-description-to-here,length-of-the-rest-of-the-word-list
      print-string dup write-dec-number cr
      Message:append-word-description-to-here,the-rest-of-the-word-list print-string cr
      print-word-list
      debuger
      Exit
    ; define-verb

    : _define-verb
      define-verb
      Exit
    ; define-verb

    : define-verb
      (* word-string[address, the number of words] -- *)
      tail-and-head-of-word-string
      create-word-header
      set-size-of-word
      add-new-word-to-dictionary
      Verb-explainer append-number-to-here
      append-word-description-to-here
      Exit
    ; _define-verb
    #+end_src
* hash
** note
   1. ``string-hash->index index-hashback->string''
      is a identity function
      and if the argumt is a index returned by ``string-hash->index''
      ``index-hashback->string string-hash->index''
      also is a identity function
   2. you can set a 8 bytes value
      to every symbol in this hash-table
      by:
      [value, index] index->address save
      dynamic type system make use of it
      for I implement type-tag as a special symbol
      but you should NOT set a pair to a symbol
      for I can not afford to let gc scan the whole hash-table to mark it
   3. hash-function (string)
      ==> (sum-up [byte_n * 2^n]) mod Number-of-symbol-entrys
      + where:
        0 <= n < Symbol-max-length
        and the Number-of-symbol-entrys is a prime number
      after sum-up, the greatest number < 2^(Symbol-max-length + 8)
      so I let Symbol-max-length == 64 - 8 == 56
      only first Symbol-max-length of the string is used by the hash-function
** string-hash->index & index-hashback->string
   #+begin_src cicada
   (* a Symbol-entry [unit : byte]
    * ==========================
    *  ||   8 : Symbol-value   ||
    * --------------------------
    *  ||   1 : Symbol-length  ||
    * --------------------------
    *  || 56+ : Symbol-string  ||
    * ==========================
    * where Symbol-max-length = 56 *)

   :" an error occurs!
   index->address said:
      ``My function-type is (* index -- address *)
        The following unsign-number is not a index of the hash-table
        I will not touch it and call debuger.''
      --> "
   : Message:index->address,error ; define-constant-string

   : index->address (* index -- address *)
     dup Number-of-symbol-entrys >= if
       Message:index->address,error print-string
       dup write-dec-number cr
       debuger Exit
     then
     dup 0 < if
       Message:index->address,error print-string
       dup write-dec-number cr
       debuger Exit
     then
     Symbol-entry-bytes-size *
     First-symbol-entry +
     Exit
   ; define-verb

   : index-hashback->string
     (* index -- string[address, length] *)
     index->address Cell-width +
     dup add1 swap
     fetch-byte
     Exit
   ; define-verb


   : help:string-hash->index,sum-up
     (* sum-up , string[address, length] -- sum-up *)
     dup zero? if
       drop2 Exit
     then
     tail-and-head-of-string
     over shift-left
     x|swap|xxx  +  xx|swap|x
     help:string-hash->index,sum-up
     Exit
   ; define-verb

   : help:string-hash->index,find-old-or-creat-new
     (* string[address, length], index -- index *)
     xx|tuck|x
     index-hashback->string
     (* index, string[address, length], string-2[address, length] *)
     dup zero? if  (* creat-new *)
       drop
       (* index, string[address, length], destination-address *)
       over over
       (* index, string[address, length], destination-address, length, address *)
       sub1 save-byte
       swap
       (* index,, source-address, destination-address, length *)
       copy-byte-string
       Exit
     then
     (* index, string[address, length], string-2[address, length] *)
     xx|over|xx equal-string? if (* found old *)
       drop2 Exit
     then
     x|swap|xx (* to get next-index *)
     (* string[address, length], index *)
     dup index->address Last-symbol-entry == if
       drop
       0
       help:string-hash->index,find-old-or-creat-new
       Exit
     then
     add1
     help:string-hash->index,find-old-or-creat-new
     Exit
   ; define-verb

   : help:string-hash->index,sum-up->index
     (* sum-up -- index *)
     Number-of-symbol-entrys mod
     Exit
   ; define-verb

   : string-hash->index
     (* string[address, length] -- index *)
     dup2
       dup Symbol-max-length > if
         drop Symbol-max-length
         (* this means only first Symbol-max-length of the string is used by the hash-function *)
       then
       0 xx|swap|x
       help:string-hash->index,sum-up
       help:string-hash->index,sum-up->index
     help:string-hash->index,find-old-or-creat-new
     Exit
   ; define-verb
   #+end_src
** test
   #+begin_src cicada
   Number-of-symbol-entrys 1 -
   index->address Last-symbol-entry == . (* 1 *)

   -1 index->address
   basic-REPL
   1000000000 index->address
   basic-REPL

   :" a" string-hash->index . cr
   :" b" string-hash->index . cr
   :" c" string-hash->index . cr

   :" k" string-hash->index . cr
   :" kk" string-hash->index . cr
   :" xxx" string-hash->index . cr
   :" xxxk" string-hash->index . cr
   :" xxxkk" string-hash->index . cr
   :" xxxxxx" string-hash->index . cr
   :" xxxxxxk" string-hash->index . cr
   :" xxxxxxkk" string-hash->index . cr
   :" xxxxxxxxx" string-hash->index . cr
   :" xxxxxxxxxk" string-hash->index . cr
   :" xxxxxxxxxkk" string-hash->index . cr
   :" xxxxxxxxxxxx" string-hash->index . cr
   :" xxxxxxxxxxxxk" string-hash->index . cr
   :" xxxxxxxxxxxxkk" string-hash->index . cr
   :" xxxxxxxxxxxxxxx" string-hash->index . cr
   :" xxxxxxxxxxxxxxxk" string-hash->index . cr
   :" xxxxxxxxxxxxxxxkk" string-hash->index . cr


   (* Number-of-symbol-entrys : 10_0333 , 10_0003
      97      97
      98      98
      99      99
      107     107
      321     321
      749     749
      1605    1605
      3317    3317
      6741    6741
      13589   13589
      27285   27285
      54677   54677
      9128    9458
      18363   19023
      36833   38153
      73773   76413
      47320   52930
      94747   5964
      89268   12035
      78310   24177
    *)


   (* test: collision *)
   (*  'A'*2 + 'c' = 'B'*2 + 'a' *)
   :" Ac" string-hash->index . cr (* 229 *)
   :" Ba" string-hash->index . cr (* 230 *)

   :" A"
     string-hash->index index-hashback->string
   print-string

   :" Ac"
     string-hash->index index-hashback->string
   print-string

   :" Ba"
     string-hash->index index-hashback->string
   print-string

   (* test: rounding *)

   (* when: Number-of-symbol-entrys = 10_0003 *)
   10_0003 .bin (* 11000011010100011 *)

   (* when: Number-of-symbol-entrys = 10_0333 *)
   10_0333 .bin (* 11000011111101101 *)


   (* I do not want to solve two funny equations about ascii-chars,
    * just to test the two ``Number-of-symbol-entrys'' above !!!???
    * so, to test this, I reset ``Number-of-symbol-entrys'' to 230, in assembler,
    * then the greatest index == 229,
    * then to test collision is to test rounding
    *)


   :" Ac" string-hash->index . cr (* 229 *)
   :" Ba" string-hash->index . cr (* 0 *)

   :" Ac"
     string-hash->index index-hashback->string
   print-string

   :" Ba"
     string-hash->index index-hashback->string
   print-string
   #+end_src
* dynamic type system
** >< [OLD] note
   1. I make the following stipulations about creating cicada words:
      1 constants) and variables are nouns,
         the first letter of them should be capitalized.
         (just as in Deutsch)
      2) functions are verbs,
         the first letter of them should be NOT capitalized.
      3) I use compoundWordByCamelCase
         when the word is about non-typed value.
         examples:
         print-string print-type-tag define-verb
      4) I use compound-word-with-dashes
         when the word is about typed value.
         examples:
         cons car cdr set-car! set-cdr! list-copy
      5) I use <this-kind-of-word>
         when the word is about type.
         examples:
         <pair> <pair-like>? <graph> <lambda> <fixnum> <type>
      6) I do not use compound_word_with_underscores
   2. atom :
      TypedValue[valus, type tag]
   3. non-atom :
      TypedValue[address, type tag]
   4. this is really a flexible and dangerous way to use dynamic-type-value
   5. this is dangerous,
      for you can meet semantic overload sometimes
      for example,
      True-Bool == [1, <bool>]
      True == 1
      that means you have two syntaxes to denote one semantic
      then, how should you implement ``if,else,then'' ???
      this is really not acceptable !!!
   6. this is flexible,
      for you can easily define different kinds of <pair-like> values:
      1) <list>
      2) <alist> (associated-list)
      3) <dali> (double-linked-list)
      4) <wodili> (wodili)
      5) <graph>
      6) and more
   7. to implement gc
      one have to (and only have to)
      be able to distinguish <pair> and <non-pair>
   8. every new data type implemented by <pair>
      have to be handled by gc as <pair>
   9. I do not need type-inherit at all
      for I can easily convert one type to another
      say, I have <xxx-list>
      a function apply on <list> will not apply on <xxx-list>
      but if I use <xxx-list> as a list
      which every cdr is of type <list>
      only the first type is change from <list> to <xxx-list>
      then, when I want to treat this <xxx-list> as a <list>
      I just ``drop <list>''
** implementation
   #+begin_src cicada
   (* if 1 is setted to a symbol, this symbol is a fixnum like data type
      if 2 is setted to a symbol, this symbol is a pair like data type *)

   : define-data-type
     (* word-string[address, the number of words] -- *)
     dup2
       head-of-word-string
       string-hash->index
       dup
         index->address 1 swap save
       xx|swap|x
     define-constant
     Exit
   ; define-verb

   : define-pair-like-data-type
     (* word-string[address, the number of words] -- *)
     dup2
       head-of-word-string
       string-hash->index
       dup
         index->address 2 swap save
       xx|swap|x
     define-constant
     Exit
   ; define-verb


   (* every word can be used as a name of a data type
      the following are my convention *)

   : <fixnum>    ; define-data-type
   : <bool>      ; define-data-type
   : <type>      ; define-data-type
   : <char>      ; define-data-type
   : <symbol>    ; define-data-type
   : <substring> ; define-data-type
   : <null>      ; define-data-type


   : <fixnum-like>? (* type -- True or False *)
       index->address fetch 1 ==
       Exit
   ; define-verb


   0 : Null ; define-constant

   : null Null <null> Exit ; define-verb

   : null? (* [value, type] -- True or False *)
     <null> == if
       Null == if
         True Exit
       then
       False Exit
     then
     drop False Exit
   ; define-verb




   : True-Bool  True  <bool> Exit ; define-verb
   : False-Bool False <bool> Exit ; define-verb



   : <pair>    ; define-pair-like-data-type
   : <string>  ; define-pair-like-data-type
   : <list>    ; define-pair-like-data-type

   : <dali>   ; define-pair-like-data-type

   : <wodi>           ; define-pair-like-data-type
   : <bound-variable> ; define-pair-like-data-type
   : <wodili>         ; define-pair-like-data-type


   : <pair-like>? (* type -- True or False *)
       index->address fetch 2 ==
       Exit
   ; define-verb

   : <not-pair-like>? (* type -- True or False *)
       index->address fetch 2 =/=
       Exit
   ; define-verb


   : <dali-like>? (* type -- True or False *)
     dup <dali> == if
       drop True Exit
     then
     dup <wodili> == if
       drop True Exit
     then
     drop False Exit
   ; define-verb


   : <not-dali-like>? (* type -- True or False *)
     dup <dali> == if
       drop False Exit
     then
     dup <wodili> == if
       drop False Exit
     then
     drop True Exit
   ; define-verb




   :" an error occurs!
   print-type-tag said:
      ``My function-type is (* type-tag[index of hash-table] -- *)
        The following index is not a type-tag
        I will not touch it and call debuger.''
      --> "
   : Message:print-type-tag,error ; define-constant-string

   : print-type-tag
     (* type-tag[index of hash-table] -- *)
     dup
     index->address fetch 1 == if
       index-hashback->string print-string Exit
     then
     dup
     index->address fetch 2 == if
       index-hashback->string print-string Exit
     then
     Message:print-type-tag,error print-string
     write-dec-number cr
     debuger Exit
   ; define-verb


   : eq? (* [value, type], [value, type] -- True or False *)
     x|over|xx =/= if
       drop drop2 False Exit
     then
     x|over|xx =/= if
       drop2 False Exit
     then
     drop2 True Exit
   ; define-verb
   #+end_src
** dictionary operations
*** >< note
*** implementation
    #+begin_src cicada
    (*
     * a word in the dictionary [unit : Cell-width = 8 bytes]
     *   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     *   ||  m : name-string  ||
     *   ||  1 : SizeOfFunctionBody ||
     *   ||  1 : identification  ||
     *   ||  1 : link  ||
     *   ||  1 : type  ||
     *   ||  1 : address-of-name-string-header  ||
     *   ||  1 : address-of-explainer  ||
     *   ||  n : body  ||
     * where
     *   ||  1 : type  ||
     * ==
     *   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
     * type-bit-0 is for HiddenWord
     * type-bit-1 is for VariableOfTypedValue [DynamicVar]
     *)

    : last-word-in-dictionary? (* word[address of link] -- True or False *)
        zero? Exit
    ; define-verb

    : next-word-in-dictionary
      (* word[address of link] -- next-word[address of link] *)
        fetch Exit
    ; define-verb

    : fetch-word-type (* word[address of link] -- WordType *)
        add8 fetch
        Exit
    ; define-verb

    : save-word-type (* word[address of link], WordType -- *)
        swap add8 save
        Exit
    ; define-verb


    0 : Offset-for-hidden-word          ; define-constant
    1 : Offset-for-dynamic-variable-word ; define-constant

    : dynamic-variable-word? (* word[address of link] -- True or False *)
        fetch-word-type Offset-for-dynamic-variable-word fetch-bit one?
        Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    : ~ (* word[address of link] -- word[address of link] *)
        dup dynamic-variable-word? .
        (* dup last-word-in-dictionary? . *)
        next-word-in-dictionary
      Exit
    ; define-verb

    first-word-in-dictionary fetch

    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
    #+end_src
* incremental-gc of <pair> & <string>
** note
   1. this gc is a incremental-gc
      a marking-gc for pair
      a copy-gc for string
   2. if string-heap is used up
      before PairConstructionsArray is used up
      gc must be restart
      so string-heap should be large to avoid this
   3. there are two way to represent string now:
      1) [address, length]
      2) [address, <string>]
         in this one,
         there must be 4-bytes in address-4
         to save the length of the string
** dynamic-allocation of string
*** try,copy-substring,from->to
    #+begin_src cicada
    (* example of a substring stored in string-heap :
       || 4 : length of substring  ||
       || n : substring  ||
     *)

    String-heap-1 : Pointer:String-heap,from ; define-variable
    String-heap-2 : Pointer:string-heap,to   ; define-variable

    String-heap-1 : Current-free-string-address,from ; define-variable
    String-heap-2 : Current-free-string-address,to   ; define-variable



    (*
     * : fetch-four-bytes (\* address -- value *\)
     *   0 fetch-argument-stack-pointer
     *   x|over|xx swap
     *   4 copy-byte-string
     *   swap drop
     *   Exit
     * ; define-verb
     *
     * : save-four-bytes (\* value, address -- *\)
     *   swap fetch-argument-stack-pointer
     *   x|over|xx
     *   4 copy-byte-string
     *   drop2
     *   Exit
     * ; define-verb
     *)



    : get-length-of-string (* string[address] -- length *)
      sub4 fetch-four-bytes
      Exit
    ; define-verb

    : string-in?string-heap,from (* string[address] -- True or False *)
      Pointer:String-heap,from fetch
      over over
      Size-of-string-heap +  <
      xx|swap|x  >=
      bitwise-and
      Exit
    ; define-verb

    : string-in?string-heap,to (* string[address] -- True or False *)
      Pointer:string-heap,to fetch
      over over
      Size-of-string-heap +  <
      xx|swap|x  >=
      bitwise-and
      Exit
    ; define-verb

    : with-length,copy-byte-string
      (* source address, destination address, length -- *)
      dup x|over|xx save-four-bytes
      swap add4 swap
      copy-byte-string
      Exit
    ; define-verb

    : try,copy-substring,from->to
      (* [address, <substring>] -- [address, <substring>] *)
      (*
       * dup <substring> =/= if
       *   Exit
       * then
       *)
      over dup
      string-in?string-heap,to if
        drop Exit
      then
      Current-free-string-address,to fetch
      over get-length-of-string
      with-length,copy-byte-string
      (* set return value *)
      Current-free-string-address,to fetch add4
      |123->321|
      (* update Current-free-string-address,to *)
      get-length-of-string add4
      Current-free-string-address,to add-save
      Exit
    ; define-verb

    (* test: *)
    (*
     * Current-free-string-address,to fetch
     *   s" xxx " dup2 print-string (\* xxx *\)
     *   drop <substring>
     *   try,copy-substring,from->to
     *   drop2
     * add4 dup
     * get-length-of-string
     * print-string (\* xxx *\)
     *)


    : try,copy-substring,from->to,for-car
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      over fetch2 (* this line is as car *)
      dup <substring> =/= if
        drop2 (* drop car *)
        Exit
      then
      try,copy-substring,from->to
      x|over|xxx save2 (* this line is as set-car! *)
      Exit
    ; define-verb

    : try,copy-substring,from->to,for-cdr
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      over Car-bytes-size + fetch2 (* this line is as cdr *)
      dup <substring> =/= if
        drop2 (* drop cdr *)
        Exit
      then
      try,copy-substring,from->to
      x|over|xxx Car-bytes-size + save2 (* this line is as set-cdr! *)
      Exit
    ; define-verb


    (*
     * {* s" xxx" drop <substring>
     *    s" ppp" drop <substring> *}
     *
     * dup2
     *   car print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* xxx *\)
     * dup2
     *   cdr print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* ppp *\)
     *
     * dup2
     *   car drop .hex cr (\* >< *\)
     * dup2
     *   cdr drop .hex cr (\* >< *\)
     *
     * dup2
     *   try,copy-substring,from->to,for-car
     *   try,copy-substring,from->to,for-cdr
     *
     * dup2
     *   car print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* xxx *\)
     * dup2
     *   cdr print-type-tag cr (\* <substring> *\)
     *   dup get-length-of-string
     *   print-string cr (\* ppp *\)
     *
     * (\* the two hex numbers must be different *\)
     * dup2
     *   car drop .hex cr (\* >< *\)
     * dup2
     *   cdr drop .hex cr (\* >< *\)
     *
     * drop2
     *)
    #+end_src
*** read-string
    #+begin_src cicada
    : read-non-string-ending-char (* -- FirstNonBlankChar or 0 *)
      read-char
      dup '"' == if
        drop 0
      then Exit
    ; define-verb

    : help:read-string,loop (* begin-address -- end-address *)
      read-non-string-ending-char
      dup zero? if
        drop Exit
      then
      over save-byte
      add1
      help:read-string,loop
      Exit
    ; define-verb

    : read-string (* -- string[address, length] *)
      Current-free-string-address,from fetch add4
      dup (* leave begin-address *)
        help:read-string,loop
      dup (* leave end-address *)
        Current-free-string-address,from save
      over -
      dup (* return: length *)
      x|over|xx (* return: address *)
      sub4 save-four-bytes
      Exit
    ; define-verb

    : s" (* -- string[address, length] *)
      read-string Exit
    ; define-verb

    (* test: *)
    (* s" 123 xxx aaa !!! @@@ ###" print-string *)
    #+end_src
** gc & <pair> & <string>
*** notation
    Lisp was originally implemented on the IBM 704 computer, in the late 1950s.
    The 704 hardware had special support for
    splitting a 36-bit machine word into four parts:
    1. address part   : 15 bits
    2. decrement part : 15 bits
    3. prefix part    : 3 bits
    4. tag part       : 3 bits
    Precursors to Lisp included the following functions:
    (The term "register" in the following context refers to "memory location")
    1. car : Contents of the Address part of Register number
    2. cdr : Contents of the Decrement part of Register number
    3. cpr : Contents of the Prefix part of Register number
    4. ctr : Contents of the Tag part of Register number
    --------------------------------------------------------
    in my cicada, for my PairConstruction
    I introduce the following c*r functions:
    (maybe more in the future, if needed)
    1. clr : color byte
       for garbage-collection
    2. car : contents of the address part of a PairConstruction
       as the first typed-value of a pair
    3. cdr : contents of the decrement part of a PairConstruction
       as the second typed-value of a pair
*** the construction & clr, car, cdr
    #+begin_src cicada
    (* the construction of pair : [unit : byte]
     * clr:
     *     ||  1 : color     ||
     * car:
     *     ||  8 : type tag  ||
     *     ||  8 : value     ||
     * cdr:
     *     ||  8 : type tag  ||
     *     ||  8 : value     ||
     *)

    (* the following constants are defined in assembler:
     * Cons-bytes-size == 33
     * Clr-bytes-size  ==  1
     * Car-bytes-size  == 16
     * Cdr-bytes-size  == 16
     *)

    :" clr said:
       ``My function-type is (* [address, <pair-like>] -- color-byte *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:clr,type-error ; define-constant-string
    : clr (* [address, <pair-like>] -- color-byte *)
      dup <not-pair-like>? if
        Message:clr,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      sub1 fetch-byte Exit
    ; define-verb


    :" car said:
       ``My function-type is (* [address, <pair-like>] -- [value, type] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:car,type-error ; define-constant-string
    : car (* [address, <pair-like>] -- [value, type] *)
      dup <not-pair-like>? if
        Message:car,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      fetch2 Exit
    ; define-verb


    :" cdr said:
       ``My function-type is (* [address, <pair-like>] -- [value, type] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:cdr,type-error ; define-constant-string
    : cdr (* [address, <pair-like>] -- [value, type] *)
      dup <not-pair-like>? if
        Message:cdr,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      Car-bytes-size + fetch2 Exit
    ; define-verb
    #+end_src
*** color & set-clr!
    two colors is enough
    a black pair in GreyPairStackTop is as a ``grey'' pair
    a grey-pair denotes front of the spreading black sub-graph
    these nodes maybe at the junction of black and white (maybe not)
    #+begin_src cicada
    0 : White ; define-constant
    1 : Black ; define-constant


    (* set three offsets used by fetch-byte, set-bit, clear-bit *)
    0 : Mutative-color-offset-for-finding  ; define-variable
    1 : Mutative-color-offset-for-marking  ; define-variable
    2 : Mutative-color-offset-for-cleaning ; define-variable
    : Color-offset-for-finding  Mutative-color-offset-for-finding  fetch Exit ; define-verb
    : Color-offset-for-marking  Mutative-color-offset-for-marking  fetch Exit ; define-verb
    : Color-offset-for-cleaning Mutative-color-offset-for-cleaning fetch Exit ; define-verb

    :" set-clr! said:
       ``My function-type is (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-clr!,type-error ; define-constant-string
    : set-clr! (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
      over dup  <not-pair-like>? if
        Message:set-clr!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      x|over|xx sub1 save-byte Exit
    ; define-verb
    #+end_src
*** marking
    #+begin_src cicada
    : white-color-for-marking? (* color-byte -- True or False *)
      Color-offset-for-marking fetch-bit White == Exit
    ; define-verb

    : black-color-for-marking? (* color-byte -- True or False *)
      Color-offset-for-marking fetch-bit Black == Exit
    ; define-verb

    : black-<pair>? (* [address, <pair-like>] -- True or False *)
      clr black-color-for-marking? Exit
    ; define-verb


    (* the following function is the only function who push-grey-pair-stack
     * and this function is called by one,grey->black and so on *)
    :" try,white->grey said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:try,white->grey,type-error ; define-constant-string
    : try,white->grey (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
        Message:try,white->grey,type-error print-string
        dup print-type-tag cr
        debuger
        Exit
      then
      dup2 clr
      dup
      white-color-for-marking? if
        Color-offset-for-marking set-bit set-clr!

        try,copy-substring,from->to,for-car
        try,copy-substring,from->to,for-cdr
        over push-grey-pair-stack
        Exit
      then
      drop (* drop the color-byte *) Exit
    ; define-verb


    : one,try,grey->black (* -- *)
      empty-grey-pair-stack? if
        Exit
      then
      pop-grey-pair-stack dup
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
        Car-bytes-size +
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
      Exit
    ; define-verb


    (* the following is a help-function of all,grey->black
     * the GreyPairStack must not be empty when it is called *)

    : one,grey->black (* -- *)
      pop-grey-pair-stack dup
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
        Car-bytes-size +
        fetch2 dup <pair-like>? if
          try,white->grey
        then drop2
      Exit
    ; define-verb

    : all,grey->black (* -- *)
      empty-grey-pair-stack? if
        Exit
      then
      one,grey->black
      all,grey->black Exit
    ; define-verb
    #+end_src
*** set!, set-car!, set-cdr!
    in cicada, to make the gc to be incremental
    there are many strategies you can use
    the following shows one of them
    #+begin_src cicada
    : set!
      (* VarForTypedValue[address], [value, type] -- VarForTypedValue[address] *)
      dup <pair-like>? if
        all,grey->black (* to be incremental-gc is to call this function here *)
        try,white->grey
      then
      x|over|xx save2
      Exit
    ; define-verb


    : help:set-car!&set-cdr!,for-black-<pair>
      (* [valus, type] -- [valus, type] *)
      dup <pair-like>? if
        all,grey->black (* to be incremental-gc is to call this function here *)
        try,white->grey
      then
      Exit
    ; define-verb


    :" set-car! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car!,type-error ; define-constant-string

    : set-car!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:set-car!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx save2
      Exit
    ; define-verb


    :" set-cdr! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-cdr!,type-error ; define-constant-string

    : set-cdr!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:set-cdr!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx Car-bytes-size + save2
      Exit
    ; define-verb


    (* ------------------------------------------------- *)


    :" [cons,car]! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[cons,car]!,type-error ; define-constant-string

    : [cons,car]!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:[cons,car]!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx save2
      Exit
    ; define-verb


    :" [cons,cdr]! said:
       ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
         If I view the third argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[cons,cdr]!,type-error ; define-constant-string

    : [cons,cdr]!
      (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
      x|over|xx dup  <not-pair-like>? if
        Message:[cons,cdr]!,type-error print-string
        print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag overed *)
      xx|over|xx black-<pair>? if
        help:set-car!&set-cdr!,for-black-<pair>
      then
      x|over|xxx Car-bytes-size + save2
      Exit
    ; define-verb


    (* ------------------------------------------------- *)


    :" [car,cons]! said:
       ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
         If I view the first argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[car,cons]!,type-error ; define-constant-string

    : [car,cons]!
      (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
      (* you can read this as ``car-cons-set'' *)
      dup <not-pair-like>? if
        Message:[car,cons]!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 black-<pair>? if
        xx|swap|xx help:set-car!&set-cdr!,for-black-<pair> xx|swap|xx
      then
      xx|tuck|xx
      drop save2
      Exit
    ; define-verb


    :" [cdr,cons]! said:
       ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
         If I view the first argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[cdr,cons]!,type-error ; define-constant-string

    : [cdr,cons]!
      (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
      (* you can read this as ``cdr-cons-set'' *)
      dup <not-pair-like>? if
        Message:[cdr,cons]!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 black-<pair>? if
        xx|swap|xx help:set-car!&set-cdr!,for-black-<pair> xx|swap|xx
      then
      xx|tuck|xx
      drop Car-bytes-size + save2
      Exit
    ; define-verb
    #+end_src
*** marking & define
    define and set! are the interface of dynamic-typed-value
    #+begin_src cicada
    (* recall
     * a word in the dictionary [unit : Cell-width = 8 bytes]
     *   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
     *   ||  m : name-string  ||
     *   ||  1 : SizeOfFunctionBody  ||
     *   ||  1 : identification  ||
     *   ||  1 : link  ||
     *   ||  1 : type  ||
     *   ||  1 : address-of-name-string-header  ||
     *   ||  1 : address-of-explainer  ||
     *   ||  n : body  ||
     * where
     *   ||  1 : type  ||
     * ==
     *   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
     * type-bit-0 is for HiddenWord
     * type-bit-1 is for VariableOfTypedValue
     *)

    : create-word-header-for-typed-value
      (* string[address, length] -- word[address of link] *)
      Here fetch xx|swap|x (* address-of-name-string-header *)
      append-string-to-here
      Here fetch append-number-to-here (* identification *)
      Here fetch (* leave the word[link] *)
      0 append-number-to-here (* link *)
      2 append-number-to-here  (* type *)
      swap
      append-number-to-here (* address-of-name-string-header *)
      Exit
    ; define-verb

    : define,by-string
      (* [value, type], string[address, length] -- *)
      create-word-header-for-typed-value
      Variable-explainer append-number-to-here
      xx|swap|x  (* leave wordHeader *)
      dup <pair-like>? if
        try,white->grey
      then
      append-number-to-here append-number-to-here
      add-new-word-to-dictionary
      Exit
    ; define-verb

    : define
      (* [value, type], word-string[address, the number of words] -- *)
      head-of-word-string
      define,by-string
      Exit
    ; define-verb
    #+end_src
*** finding & cons : constructor of <pair>
    #+begin_src cicada
    (* the following functions are helping cons *)

    : clear-color-bit-of-pair-for-cleaning (* pair[address] -- pair[address] *)
      <pair>
      dup2 clr
      Color-offset-for-cleaning clear-bit
      set-clr!
      drop
      Exit
    ; define-verb

    : white-color-for-finding? (* color-byte -- True or False *)
      Color-offset-for-finding fetch-bit White ==
      Exit
    ; define-verb

    : find-next-free-pair-construction
      (* pair[address] -- 0 or NextFreePairConstruction[address] *)
      dup Last-pair-construction == if
        drop 0 Exit
      then
      Cons-bytes-size +
      clear-color-bit-of-pair-for-cleaning
      dup <pair> clr
      white-color-for-finding? if
        Exit
      then
      find-next-free-pair-construction
      Exit
    ; define-verb



    (* a cyclic permutation
     * of the two three period cyclic permutation
     * in the third-order permutation group
     Mutative-color-offset-for-finding  --> Mutative-color-offset-for-cleaning
     Mutative-color-offset-for-marking  --> Mutative-color-offset-for-finding
     Mutative-color-offset-for-cleaning --> Mutative-color-offset-for-marking
     *)
    : reset-color-offsets (* -- *)
      Mutative-color-offset-for-finding  fetch
      Mutative-color-offset-for-marking  fetch
      Mutative-color-offset-for-cleaning fetch
      Mutative-color-offset-for-marking  save
      Mutative-color-offset-for-finding  save
      Mutative-color-offset-for-cleaning save
      Exit
    ; define-verb


    : dynamic-variable-word-for-<pair-like>?
      (* word[address of link] -- True or False *)
      dup dynamic-variable-word? if
      word-link->word-explainer execute fetch2
      swap drop
      <pair-like>?
      Exit
      then
      drop False Exit
    ; define-verb

    : help:push-all-root-node-into-grey-pair-stack
      (* word[address of link] -- *)
      dup last-word-in-dictionary? if
        drop Exit
      then
      dup dynamic-variable-word-for-<pair-like>? if
      dup word-link->word-explainer execute fetch2
      try,white->grey drop2
      then
      next-word-in-dictionary
      help:push-all-root-node-into-grey-pair-stack
      Exit
    ; define-verb

    : push-all-root-node-into-grey-pair-stack (* -- *)
        first-word-in-dictionary fetch
        help:push-all-root-node-into-grey-pair-stack
        Exit
    ; define-verb



    (* the following function is not intrinsic
       but I have to use it this way *)

    (* a value meet the following three conditions is an AddressOfPair
     *  (the following is infix notations)
     * 1. Value >= First-pair-construction
     * 2. Value <= Last-pair-construction
     * 3. [Value - First-pair-construction] mod Cons-bytes-size == 0
     *)

    : addressOfPair? (* value -- True or False *)
        dup First-pair-construction < if
          drop False Exit
        then
        dup Last-pair-construction > if
          drop False Exit
        then
        First-pair-construction - Cons-bytes-size mod zero?
        Exit
    ; define-verb



    : help:all-pairs-in-argument-stack,try,white->grey
      (* address of a Cell in ArgumentStack -- *)
        dup Argument-stack-top > if
          drop Exit
        then
        dup fetch addressOfPair? if
          dup fetch
          <pair> try,white->grey
          drop2
        then
        Cell-width +
        help:all-pairs-in-argument-stack,try,white->grey
        Exit
    ; define-verb

    : all-pairs-in-argument-stack,try,white->grey (* -- *)
        fetch-argument-stack-pointer
        help:all-pairs-in-argument-stack,try,white->grey
        Exit
    ; define-verb


    : help:all-pairs-in-lambda-stack,try,white->grey
      (* address of a Cell in LambdaStack -- *)
      dup Lambda-stack-top > if
        drop Exit
      then
      dup fetch addressOfPair? if
        dup fetch
        <pair> try,white->grey
        drop2
      then
      Cell-width +
      help:all-pairs-in-lambda-stack,try,white->grey
      Exit
    ; define-verb

    : all-pairs-in-lambda-stack,try,white->grey (* -- *)
      Lambda-stack-pointer fetch
      help:all-pairs-in-lambda-stack,try,white->grey
      Exit
    ; define-verb



    : resetVariablesAboutString (* -- *)
      Current-free-string-address,to fetch Current-free-string-address,from save
      Pointer:String-heap,from       fetch Current-free-string-address,to   save
      Pointer:string-heap,to         fetch Pointer:String-heap,from         save
      Current-free-string-address,to fetch Pointer:string-heap,to           save
      Exit
    ; define-verb


    :"  :gc: "
    : Message:gc ; define-constant-string

    :" cons said: ``Memory for cons is used up! No value is returned!''"
    : Message:cons,memory-is-used-up ; define-constant-string

    : cons (* -- [address, <pair>] *)
        Current-free-pair-construction fetch <pair> (* leave the return <value> *)
        Current-free-pair-construction fetch find-next-free-pair-construction
        dup zero? false? (* 0 denotes fail to find *) if
          Current-free-pair-construction save
          Exit
        then drop (* drop the 0, which denotes fail to find, need gc *)
        all-pairs-in-argument-stack,try,white->grey
        all,grey->black
        reset-color-offsets resetVariablesAboutString (* note the timing to reset *)
        push-all-root-node-into-grey-pair-stack
        In-front-of-the-first-pair-construction find-next-free-pair-construction
        dup zero? false? if
          Current-free-pair-construction save
          Message:gc print-string
          Exit
        then drop
        (* if after gc still fail to find, we know the memory is used up *)
        drop2
        Message:cons,memory-is-used-up print-string cr
        debuger
        Exit
    ; define-verb
    #+end_src
*** substring & string : constructor of <substring> & <string>
    #+begin_src cicada
    : read-string (* -- [address, <string>] *)
      cons drop (* drop <pair> *) <string>
      s" drop (* drop length *) <substring>
      set-car!
      null set-cdr!
      Exit
    ; define-verb

    : ::" (* -- [address, <string>] *)
      read-string Exit
    ; define-verb


    :" write-string said:
       ``My function-type is ( [address, <string>] -- ).
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:write-string,type-error ; define-constant-string

    : write-string (* [address, <string>] -- *)
      dup <string> =/= if
        Message:write-string,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      car drop (* drop <substring> *)
      dup get-length-of-string print-string
      Exit
    ; define-verb

    : substring (* length -- address *)
      (* allocate a substring of the given length *)
      Current-free-string-address,from fetch add4 swap (* leave begin-address *)
      dup Current-free-string-address,from fetch save-four-bytes
      4 + Current-free-string-address,from add-save
      Exit
    ; define-verb

    : string (* length -- [address, <string>] *)
      (* allocate a string of the given length *)
      substring <substring>
      null
      cons drop <string>
      [cdr,cons]!
      [car,cons]!
      Exit
    ; define-verb
    #+end_src
*** about test
    #+begin_src cicada
    (* for test *)
    : print-type-of-it (* type -- *)
      print-type-tag ':' write-char write-space Exit
    ; define-verb

    (* test: gc *)
    : ask-for-lots-of-cons (* n -- *)
        dup zero? if drop Exit
        then
        sub1
        cons
          555 <fixnum> set-car!
          666 <fixnum> set-cdr!
        drop2
        ask-for-lots-of-cons
        Exit
    ; define-verb

    : ask-for-lots-of-cons,leave-them-on-the-argument-stack (* n -- *)
        dup zero? if drop Exit
        then
        sub1
        cons
          555 <fixnum> set-car!
          666 <fixnum> set-cdr!
        x|swap|xx
        ask-for-lots-of-cons,leave-them-on-the-argument-stack
        Exit
    ; define-verb
    #+end_src
** test
   #+begin_src cicada
   : {* cons Exit ; define-verb
   : *} xx|swap|xxxx [cdr,cons]! [car,cons]! Exit ; define-verb


   (* test: define *)
   6 <fixnum> : Liu-fixnum ; define
   Liu-fixnum fetch2 print-type-of-it . cr (* <fixnum>: 6 *)

   (* test: cons *)
   cons 9 <fixnum> set-car!
        8 <fixnum> set-cdr!
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2

   {* 9 <fixnum>  8 <fixnum> *}
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2

   (* test: cons *)
   9 <fixnum>  8 <fixnum>  cons
   [cdr,cons]! [car,cons]!
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2


   (* test: define a pair *)
   cons 9 <fixnum> set-car!
        8 <fixnum> set-cdr!
   : Simple-pair ; define
   Simple-pair fetch2
   dup2
     car print-type-of-it . cr (* <fixnum>: 9 *)
   dup2
     cdr print-type-of-it . cr (* <fixnum>: 8 *)
   drop2


   (* test: set-car! & set-cdr! *)
   Simple-pair fetch2
     {* 7 <fixnum>   6 <fixnum> *}
   set-car!
   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)
   drop2




   Simple-pair fetch2
     {* 5 <fixnum>
        {* 4 <fixnum>  3 <fixnum> *} *}
   set-cdr!

   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)
   dup2
     cdr car print-type-of-it . cr (* <fixnum>: 5 *)
   dup2
     cdr cdr car print-type-of-it . cr (* <fixnum>: 4 *)
   dup2
     cdr cdr cdr print-type-of-it . cr (* <fixnum>: 3 *)
   drop2




   (* test: all,grey->black *)
     empty-grey-pair-stack? . cr (* 0 *)
     all,grey->black
     empty-grey-pair-stack? . cr (* 1 *)


   (* test: marking *)
     Simple-pair fetch2
     cdr cdr clr Color-offset-for-marking fetch-bit . cr (* 1 *)




   all,grey->black


   (* test: reset set-cdr! *)
   Simple-pair fetch2
     {* 1 <fixnum>
        {* 2 <fixnum>  3 <fixnum> *} *}
   set-cdr!

   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)

   dup2
     cdr car print-type-of-it . cr (* <fixnum>: 1 *)
   dup2
     cdr cdr car print-type-of-it . cr (* <fixnum>: 2 *)
   dup2
     cdr cdr cdr print-type-of-it . cr (* <fixnum>: 3 *)
   drop2



   (* test: gc *)
   : ask-for-lots-of-cons (* n -- *)
       dup zero? if drop Exit
       then
       sub1
       {* 555 <fixnum>
          666 <fixnum> *}
       drop2
       ask-for-lots-of-cons
       Exit
   ; define-verb


   Number-of-pair-constructions ask-for-lots-of-cons

   Number-of-pair-constructions 30 * ask-for-lots-of-cons




   (* after gc the Simple-pair must still be ok *)
   Simple-pair fetch2

   dup2
     car car print-type-of-it . cr (* <fixnum>: 7 *)
   dup2
     car cdr print-type-of-it . cr (* <fixnum>: 6 *)
   dup2
     cdr car print-type-of-it . cr (* <fixnum>: 1 *)
   dup2
     cdr cdr car print-type-of-it . cr (* <fixnum>: 2 *)
   dup2
     cdr cdr cdr print-type-of-it . cr (* <fixnum>: 3 *)
   drop2



   (* ----------------------------------------------------------- *)
   (* after gc the values in the stack must still be ok *)

   {* {* 147 <fixnum>
         258 <fixnum> *}
      369 <fixnum> *}

   Number-of-pair-constructions 30 * ask-for-lots-of-cons

   dup2

   cr
   dup2
      car car print-type-of-it . cr (* <fixnum>: 147 *)
   dup2
      car cdr print-type-of-it . cr (* <fixnum>: 258 *)
   dup2
      cdr print-type-of-it . cr (* <fixnum>: 369 *)
   drop2
   ok

   Number-of-pair-constructions 30 * ask-for-lots-of-cons

   cr
   dup2
      car car print-type-of-it . cr (* <fixnum>: 147 *)
   dup2
      car cdr print-type-of-it . cr (* <fixnum>: 258 *)
   dup2
      cdr print-type-of-it . cr (* <fixnum>: 369 *)
   drop2
   ok





   (* ----------------------------------------------------------- *)
   (* about string *)
   (* after gc the values in the stack must still be ok *)


   ::" 111 "
   Number-of-pair-constructions  ask-for-lots-of-cons
   ::" 222 "
   Number-of-pair-constructions  ask-for-lots-of-cons
   ::" 333 "
   Number-of-pair-constructions  ask-for-lots-of-cons
   Number-of-pair-constructions  ask-for-lots-of-cons
   cr ok

   write-string write-string write-string (* 333 222 111 *)
   cr


   ::" aaa "
   : Simple-string ; define
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   Number-of-pair-constructions ask-for-lots-of-cons
   ::" AAA "
   ::" AAA "
   ::" AAA "
   Number-of-pair-constructions 20 * ask-for-lots-of-cons
   ok (* yse *)

   Simple-string fetch2 write-string (* aaa *)

   Number-of-pair-constructions  ask-for-lots-of-cons
   write-string write-string write-string (* AAA AAA AAA *)
   cr
   Number-of-pair-constructions  ask-for-lots-of-cons
   write-string write-string write-string (* AAA AAA AAA *)
   cr





   (* ----------------------------------------------------------- *)
   (* about using up memory *)


   (*
    ,* Number-of-pair-constructions
    ,* ask-for-lots-of-cons,leave-them-on-the-argument-stack
    ,*
    ,*
    ,* (\* in debuger-REPL: *\)
    ,*   1 debuger,fetch-from-return-stack trace-function
    ,*   2 debuger,fetch-from-return-stack trace-function
    ,*
    ,* basic-REPL count-argument-stack . cr (\* 0 *\)
    *)
   #+end_src
* list-processing
** about list-processing
*** note
    1. I mimic the naming conventions
       of the bra-ket notation in quantum mechanics
    2. I use ``bracket'' to denotes all kinds of brackets :
       - round  :: ()
       - square :: []
       - flower :: {}
       - angle  :: <>
       - note that, they all have lots of other names
         the above will be used by me
       - it feels so bad that only these brackets are available in ASCII
       - punctuations ":" and ";" as a pair
         are also used as ``brackets'' by me
         I call them ``cosemi''
       - more pairs of sequences of two or more characters
         will be used by me in the future
       - and "." is called a ``mid''
    3. but the value you put into a list or a dali
       should always be converted to dynamic-typed-value
       while they should always be read as simple as possible
    4. I found out that to parse post-lambda expression easily
       we have to always use dali
       so dali should be the default-list used in cicada
    5. so I have the following notations about list-processing :
       | { } | list   | single-linked-list |
       | [ ] | dali  | double-linked-list |
       | ( ) | wodili | wordy-list         |
    6. if I define ``['' and ``{'' as readers
       then, as functions the have to call each other
       due to the semantic of cicada
       this calls can not be compiled into the function-bodys of them
       unless I introduce new syntaxes
*** implementation
    #+begin_src cicada
    :" {" : Bra:flower ; define-constant-string
    :" }" : Ket:flower ; define-constant-string

    :" ." : Mid:dot ; define-constant-string

    :" (esc" : Bra:round-escape ; define-constant-string
    :" )"    : Ket:round-escape ; define-constant-string

    :" [" : Bra:square ; define-constant-string
    :" ]" : Ket:square ; define-constant-string

    :" (" : Bra:round ; define-constant-string
    :" )" : Ket:round ; define-constant-string
    #+end_src
** write
*** implementation
    #+begin_src cicada
    :" write-list"    : Message:write-list   ; define-constant-string
    :" write-*dali"  : Message:write-*dali ; define-constant-string
    :" write-wodili"  : Message:write-wodili ; define-constant-string
    :" write-wodi-or-bound-variable"
    : Message:write-wodi-or-bound-variable ; define-constant-string

    :" null"  : Message:null ; define-constant-string

    :" write said:
       ``I do not know how to write the following type of value,
         I will not touch it and call debuger.''
       --> "
    : Message:write,type-error ; define-constant-string

    : write (* [value, type] -- *)
      dup <fixnum> == if drop (* drop type-tag *)
        write-dec-number  write-space
        Exit
      then
      dup <symbol> == if drop (* drop type-tag *)
        index-hashback->string print-string  write-space
        Exit
      then
      dup <null> == if drop (* drop type-tag *)
        drop
        Message:null print-string write-space
        Exit
      then
      dup <list> == if
        Message:write-list find word-link->word-explainer execute
        Exit
      then
      dup <dali> == if
        Message:write-*dali find word-link->word-explainer execute
        Exit
      then
      dup <wodi> ==
      over <bound-variable> ==
      bitwise-or if
        Message:write-wodi-or-bound-variable find word-link->word-explainer execute
        Exit
      then
      dup <wodili> == if
        Message:write-wodili find word-link->word-explainer execute
        Exit
      then
      Message:write,type-error print-string
      dup print-type-tag cr
      debuger Exit
    ; define-verb
    #+end_src
** read-list & write-list
*** note
    1. this is the old good lisp-like single-linked-list
    2. like the language shen
       I do not use '() to quote a list (as in LISP)
       but use {} and []
       [ 1 (esc + 1 1 ) 3 ] or
       { 1 (esc + 1 1 ) 3 } as
       `(1 ,(+ 1 1) 3) in LISP
       because ``quote'' in LISP is just to provide you
       a convenient mechanism to read a list
    3. the good about LISP's way is that
       you can quote a symbol out side the list as 'a-symbol
       otherwise the symbol will be treated as a variable
    4. while in shen
       if one type ``a-symbol'' into the REPL
       it will be treated as a symbol
       you have to use a explicit way
       to treat it as a variable i.e. ``(value a-symbol)''
    5. in cicada things are very different
       no analogy should be drawed here
    6. the ``list-escape'' is very interesting
       it is to call a another reader in a list-reader
       and get back to the list-reader when finished
       it looks like the classic forth REPL
       which have two modes
       at first in the implementation of cicada
       I try to avoid many modes in REPL
       but now the list-leader brings me back to the classic forth
*** execute-word,for-list-reader
    #+begin_src cicada
    : string-denote-list-reader?
      (* string[address, length] -- True or False *)
      dup2 Bra:flower equal-string? if
        drop2 True Exit
      then
      dup2 Bra:round-escape equal-string? if
        drop2 True Exit
      then
      dup2 Bra:square equal-string? if
        drop2 True Exit
      then
      dup2 Bra:round equal-string? if
        drop2 True Exit
      then
      drop2 False Exit
    ; define-verb

    (* then we need mutually recursive call *)
    : execute-word,for-list-reader
      (* string[address, length] -- [value, type] *)
      dup2 string-denote-list-reader? if
        find word-link->word-explainer execute
        Exit
      then
      dup2 string-denote-integer? if
        string->integer,with-error drop <fixnum>
        Exit
      then
      dup2 Message:null equal-string? if
        drop2 null
        Exit
      then
      string-hash->index <symbol>
      Exit
    ; define-verb
    #+end_src
*** list-escape-REPL
    #+begin_src cicada
    : list-escape-REPL
      (* could  be: unknown -- unknown *)
      (* should be:  -- [value, type] *)
      read-word-for-runtime
      dup2
      string-denote-integer? if
        string->integer,with-error drop
        list-escape-REPL
        Exit
      then
      dup2
      Ket:round-escape equal-string? if
        drop2
        Exit
      then
      dup2 find dup zero? false? if
        xx|swap|x drop2
        word-link->word-explainer execute
        list-escape-REPL
        Exit
      then
      drop
      Message:undefined-word print-string
      print-string cr
      list-escape-REPL
      Exit
    ; define-verb

    : (esc list-escape-REPL Exit ; define-verb
    #+end_src
*** read-list
    #+begin_src cicada
    : read-list (* -- [address, <list>] *)
      read-word
      dup2 Ket:flower equal-string? if
        drop2
        null Exit
      then
      dup2 Mid:dot equal-string? if
        drop2
        read-list car
        (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
        Exit
      then
      execute-word,for-list-reader
      cons drop <list>
        xx|swap|xx  set-car!
        read-list   set-cdr!
      Exit
    ; define-verb

    : { read-list Exit ; define-verb
    #+end_src
*** write-list
    #+begin_src cicada
    : help:write-list (* [address, <list>] or [Null, <null>] -- *)
      dup <null> == if
        drop2 Exit
      then
      dup <pair-like>? if
        dup2
        car write
        cdr help:write-list
        Exit
      then
      Mid:dot print-string write-space
      write
      Exit
    ; define-verb


    :" write-list said:
       ``My function-type is (* [address, <list>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-list,type-error ; define-constant-string

    : write-list (* [address, <list>] -- *)
      dup <list> =/= if
        Message:write-list,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      Bra:flower print-string write-space
      help:write-list
      Ket:flower print-string write-space
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    { 1
      { 1 2 3 4 5   { 1 2 3 4 5  6 }  6  }
        xxx 3 4 5
      { 1 2 3 4 5  6 } 6 }
    write-list

    { 1 . 2 } write-list
    { 1 2 3 4 5 6 7 8 9 . 0 } write-list
    { 1 . { 1 . 2 } } write-list
    { 1 . { 1 . (esc 2 <fixnum> ) } } write-list
    { 1 . { 1 . (esc 2 <fixnum> ) } } write


    (* beware of the following,
       error will not occurs ! *)

    { 1 . 2 3 }
    write-list  (* { 1 . 2 } *)

    { 1 . 2 { 1 . 2 3 } }
    write-list  (* { 1 . 2 } *)


    (* test: mutually recursive call *)
    { 1 [ 1 2 3 ] { 1 . (esc 2 <fixnum> ) } } write
    { 1 [ 1 2 3 ] . { 1 . (esc 2 <fixnum> ) } } write
    #+end_src
** set-*!
*** >< note
    the name of the following functions should be changed
*** implementation
    #+begin_src cicada
    :" set-car-to-{car}! said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{car}!,type-error ; define-constant-string
    (* [car.cdr]->[[car].cdr] *)
    : set-car-to-{car}!
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
        Message:set-car-to-{car}!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2
      car cons
        xx|swap|xx set-car!
        null set-cdr!
      set-car!
      Exit
    ; define-verb


    :" set-car-to-{cdr}! said:
       ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{cdr}!,type-error ; define-constant-string
    (* [car.cdr]->[car.[cdr]] *)
    : set-cdr-to-{cdr}!
      (* [address, <pair-like>] -- [address, <pair-like>] *)
      dup <not-pair-like>? if
        Message:set-car-to-{cdr}!,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2
      cdr cons
        xx|swap|xx set-car!
        null set-cdr!
      set-cdr!
      Exit
    ; define-verb




    :" set-car-to-{car.x}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{car.x}!,type-error ; define-constant-string

    : set-car-to-{car.x}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{car.x}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      car cons
        xx|swap|xx set-car!
        xx|swap|xx set-cdr!
      set-car!
      Exit
    ; define-verb


    :" set-car-to-{cdr.x}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{cdr.x}!,type-error ; define-constant-string

    (* [car.cdr],x->[car.[cdr.x]]! *)
    : set-cdr-to-{cdr.x}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{cdr.x}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      cdr cons
        xx|swap|xx set-car!
        xx|swap|xx set-cdr!
      set-cdr!
      Exit
    ; define-verb


    :" set-car-to-{x.car}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{x.car}!,type-error ; define-constant-string

    : set-car-to-{x.car}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{x.car}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      car cons
        xx|swap|xx set-cdr!
        xx|swap|xx set-car!
      set-car!
      Exit
    ; define-verb


    :" set-car-to-{x.cdr}! said:
       ``My function-type is
        (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
         If I view the second argument as a type-tag,
         It will be the following,
         I will not touch it and call debuger.''
       --> "
    : Message:set-car-to-{x.cdr}!,type-error ; define-constant-string

    : set-cdr-to-{x.cdr}!
      (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
      x|over|xx <not-pair-like>? if
        Message:set-car-to-{x.cdr}!,type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|over|xx
      cdr cons
        xx|swap|xx set-cdr!
        xx|swap|xx set-car!
      set-cdr!
      Exit
    ; define-verb
    #+end_src
** dali processing
*** <- & ->
    #+begin_src cicada
    :" <- said:
       ``My function-type is (* [address, <dali-like>] -- [address, <dali>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:<-,type-error ; define-constant-string

    : <- (* [address, <dali-like>] -- [address, <dali>] *)
      dup <not-dali-like>? if
        Message:<-,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      cdr car Exit
    ; define-verb


    :" -> said:
       ``My function-type is (* [address, <dali-like>] -- [address, <dali>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:->,type-error ; define-constant-string

    : -> (* [address, <dali-like>] -- [address, <dali>] *)
      dup <not-dali-like>? if
        Message:->,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      cdr cdr Exit
    ; define-verb
    #+end_src
*** list->dali
    #+begin_src cicada
    (* note that:
       in the following, I am using side-effect to change a existed list
       but NOT to form a new dali from scratch *)

    : help:list->dali
      (* [address, <dali>], left[address, <dali>] -- [address, <dali>] *)
      (* or *)
      (* [address, <dali>], [value, <non-dali>] -- [address, <dali>] *)
      set-cdr-to-{x.cdr}! (* set the ``left'' *)
      dup2 cdr
        dup2 cdr <not-pair-like>? if
          drop (* drop the non-pair-value *)
          null set-cdr!
          (* this means the 3 in { 1 2 . 3 } will be droped *)
          drop2 Exit
        then
        (* change the type-tag of the cdr of the old list, from <list> to <dali> *)
        (* the pair-like-value is still here *) <dali> set-cdr!
        cdr
      (* [address, <dali>], [address, <pair-like>] *)
      xx|swap|xx
      help:list->dali
      Exit
    ; define-verb


    :" list->*dali* said:
       ``My function-type is
         (* [address, <list>] -- head[address, <dali>], tail[address, <dali>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:list->*dali*,type-error ; define-constant-string

    : list->*dali*
      (* [address, <list>] -- head[address, <dali>], tail[address, <dali>] *)
      dup <list> =/= if
        Message:list->*dali*,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dali>
      dup2 (* leave the return value *)
      null
      help:list->dali
      Exit
    ; define-verb


    :" list->dali* said:
       ``My function-type is (* [address, <list>] -- tail[address, <dali>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:list->dali*,type-error ; define-constant-string

    : list->dali*
      (* [address, <list>] -- tail[address, <dali>] *)
      dup <list> =/= if
        Message:list->dali*,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dali>
      null
      help:list->dali
      Exit
    ; define-verb


    :" list->*dali said:
       ``My function-type is (* [address, <list>] -- head[address, <dali>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:list->*dali,type-error ; define-constant-string

    : list->*dali
      (* [address, <list>] -- head[address, <dali>] *)
      dup <list> =/= if
        Message:list->*dali,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dali>
      dup2 (* leave the return value *)
      null
      help:list->dali
      drop2
      Exit
    ; define-verb
    #+end_src
*** *dali? & dali*?
    #+begin_src cicada
    : *dali? (* [address, <dali>] -- True or False *)
      <- null? if
        True Exit
      then
      False Exit
    ; define-verb

    : dali*? (* [address, <dali>] -- True or False *)
      -> null? if
        True Exit
      then
      False Exit
    ; define-verb
    #+end_src
*** nested-list->dali
    #+begin_src cicada
    : help:nested-list->dali
      (* [address, <dali>], left[address, <dali>] -- [address, <dali>] *)
      (* or *)
      (* [address, <dali>], [value, <non-dali>] -- [address, <dali>] *)
      set-cdr-to-{x.cdr}! (* set the ``left'' *)
      dup2 car dup <list> == if
        list->*dali set-car!
      else
        drop2
      then
      dup2 cdr
        dup2 cdr <not-pair-like>? if
          drop (* drop the non-pair-value *)
          null set-cdr!
          (* this means the 3 in { 1 2 . 3 } will be droped *)
          drop2 Exit
        then
        (* change the type-tag of the cdr of the old list, from <list> to <dali> *)
        (* the pair-like-value is still here *) <dali> set-cdr!
        cdr
      (* [address, <dali>], [address, <pair-like>] *)
      xx|swap|xx
      help:nested-list->dali
      Exit
    ; define-verb


    :" nested-list->*dali said:
       ``My function-type is (* [address, <list>] -- head[address, <dali>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:nested-list->*dali,type-error ; define-constant-string

    : nested-list->*dali
      (* [address, <list>] -- head[address, <dali>] *)
      dup <list> =/= if
        Message:nested-list->*dali,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop <dali>
      dup2 (* leave the return value *)
      null
      help:nested-list->dali
      drop2
      Exit
    ; define-verb
    #+end_src
*** dali->tail & head<-dali
    #+begin_src cicada
    :" dali->tail said:
       ``My function-type is
         (* [address, <dali-like>] -- tail[address, <dali-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:dali->tail,type-error ; define-constant-string

    : dali->tail
      (* [address, <dali-like>] -- tail[address, <dali-like>] *)
      dup <not-dali-like>? if
        Message:dali->tail,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 dali*? if
        Exit
      then
      ->  dali->tail
      Exit
    ; define-verb


    :" head<-dali said:
       ``My function-type is
         (* [address, <dali-like>] -- head[address, <dali-like>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:head<-dali,type-error ; define-constant-string

    : head<-dali
      (* [address, <dali-like>] -- head[address, <dali-like>] *)
      dup <not-dali-like>? if
        Message:head<-dali,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2 *dali? if
        Exit
      then
      <-  head<-dali
      Exit
    ; define-verb
    #+end_src
*** [value,dali]-associate & [value,dali]-member?
    #+begin_src cicada
    :" [value,dali]-associate said:
       ``My function-type is
         (* [value, type], head[address, <dali-like>] --
            associate-pair[address, <pair-like>] or [Null, <null>] *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:[value,dali]-associate,type-error,at-first
    ; define-constant-string

    :" [value,dali]-associate said:
       ``My function-type is
         (* [value, type], head[address, <dali-like>] --
            associate-pair[address, <pair-like>] or [Null, <null>] *)
         But in the middle of recursion
         I found the dali is not an associated-dali
         the following is what I found
         I will not touch it and call debuger''
       --> "
    : Message:[value,dali]-associate,type-error,in-the-middle
    ; define-constant-string

    : help:[value,dali]-associate
      (* [value, type], head[address, <dali-like>], or [Null, <null>] --
         associate-pair[address, <pair-like>] or [Null, <null>] *)
      dup <null> == if
        (* if associate fail, return null *)
        xx|swap|xx drop2 Exit
      then
      dup2
      car dup <not-pair-like>? if
        Message:[value,dali]-associate,type-error,in-the-middle print-string
        dup print-type-tag cr
        debuger Exit
      then
      car
      (* [value, type], head[address, <dali-like>], car-car[value, type] *)
      xx|over|xxxx eq? if
        xx|swap|xx drop2
        car Exit
      then
      ->  help:[value,dali]-associate
      Exit
    ; define-verb

    : [value,dali]-associate
      (* [value, type], head[address, <dali-like>] --
         associate-pair[address, <pair-like>] or [Null, <null>] *)
      dup <not-dali-like>? if
        Message:[value,dali]-associate,type-error,at-first print-string
        dup print-type-tag cr
        debuger Exit
      then
      help:[value,dali]-associate
      Exit
    ; define-verb



    : [value,dali]-member?
      (* [value, type], [address, <dali-like>] -- True or False *)
      dup <null> == if
        drop2 drop2 False Exit
      then
      dup2 car
      xx|over|xxxx eq? if
        drop2 drop2 True Exit
      then
      ->  [value,dali]-member?
      Exit
    ; define-verb
    #+end_src
*** ^_^
    the following function is very important
    it for dali is as the ``cons'' for list
    but also really different
    #+begin_src cicada
    :" ^_^ said:
       ``My function-type is
         (*  left[address, <dali-like>], rigth[address, <dali-like>] --
             rigth[address, <dali-like>] *)
         If I view the 1st argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:^_^,1st-type-error ; define-constant-string

    :" ^_^ said:
       ``My function-type is
         (*  left[address, <dali-like>], rigth[address, <dali-like>] --
             rigth[address, <dali-like>] *)
         If I view the 3rd argument as a type-tag,
         it will be as the following,
         I will not touch it and call debuger.''
       --> "
    : Message:^_^,3rd-type-error ; define-constant-string


    (* the following ``little-smile-face'' is ``link-dali'' *)
    : ^_^
      (*  left[address, <dali-like>], rigth[address, <dali-like>] --
         rigth[address, <dali-like>] *)
      (* where: left[address, <dali-like>] could be a null *)
      dup <not-dali-like>? if
        Message:^_^,1st-type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      x|over|xx <null> == if
        xx|tuck|xx (* leave the return value *)
        cdr xx|over|xx set-car! drop2
        drop2
        Exit
      then
      x|over|xx <not-dali-like>? if
        Message:^_^,3rd-type-error print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|tuck|xx (* leave the return value *)
      cdr xx|over|xx set-car! drop2
      cdr xx|over|xx set-cdr! drop2
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    cr

    { 1 2 3 } list->*dali*
    dup print-type-tag (* <dali> *) cr


    (* test: tail[address, <dali>] *) cr
    dup2
      *dali? . (* 0 *) cr
    dup2
      dali*? . (* 1 *) cr
    dup2
      car print-type-tag write-space . (* <fixnum> 3 *) cr
    dup2
      ->
      print-type-tag write-space . (* <null> 0 *) cr
    dup2
      <-
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    dup2
      <-
      <-
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    dup2
      <-
      <-
      ->
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    drop2


    (* test: head[address, <dali>] *) cr
    dup2
      *dali? . (* 1 *) cr
    dup2
      dali*? . (* 0 *) cr
    dup2
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    dup2
      <-
      print-type-tag write-space . (* <null> 0 *) cr
    dup2
      ->
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    dup2
      ->
      ->
      car print-type-tag write-space . (* <fixnum> 3 *) cr
    dup2
      ->
      ->
      <-
      car print-type-tag write-space . (* <fixnum> 2 *) cr
    dup2
      ->
      ->
      <-
      <-
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    drop2


    (* ----------------------------------------------------- *)

    (* test: nested-list *) cr
    { 1 { 2 3 } 4 } nested-list->*dali
    dup print-type-tag (* <dali> *) cr


    (* test: head[address, <dali>] *) cr
    dup2
      *dali? . (* 1 *) cr
    dup2
      dali*? . (* 0 *) cr
    dup2
      car print-type-tag write-space . (* <fixnum> 1 *) cr
    dup2
      <-
      print-type-tag write-space . (* <null> 0 *) cr

    dup2
      ->
      ->
      car print-type-tag write-space . (* <fixnum> 4 *) cr

    dup2
      ->
      ->
      <-
      <-
      car print-type-tag write-space . (* <fixnum> 1 *) cr

    dup2
      ->
      car
      dup print-type-tag (* <dali> *) cr
      dup2
        *dali? . (* 1 *) cr
      dup2
        car print-type-tag write-space . (* <fixnum> 2 *) cr
      dup2
        <-
        print-type-tag write-space . (* <null> 0 *) cr
      dup2
        ->
        car print-type-tag write-space . (* <fixnum> 3 *) cr
      dup2
        ->
        <-
        ->
        car print-type-tag write-space . (* <fixnum> 3 *) cr

    drop2



    (* ----------------------------------------------- *)
    (* the following test must be done after read-*dali *)
    (* test: [value,dali]-associate *)
    2 <fixnum>
    [ { 1 . a } { 2 . b } { 3 . b } ]
    [value,dali]-associate
      dup print-type-tag (* <list> *) cr
      car  print-type-tag (* <fixnum> *) cr
      write-dec-number (* 2 *) cr

    (* the following test must be done in symbol-REPL *)
    ::x
    [ { 1 . a } { ::x . xxx } { 3 . b } ]
    [value,dali]-associate
      cdr write (* xxx *)
    #+end_src
** read-dali & write-dali
*** read-*dali
    #+begin_src cicada
    : help:read-*dali
      (* tail[address, <dali>] -- head[address, <dali>] *)
      (* where:
           the <- of ``tail'' is setted,
           need to set the -> of ``tail'' *)
      read-word
      dup2 Ket:square equal-string? if
        drop2
        dup <null> == if
          Exit (* so [ ] null will be read as null *)
        then
        dup2
          cdr
            null  set-cdr!
          drop2
        head<-dali
        Exit
      then
      execute-word,for-list-reader
      cons drop <dali>
        xx|swap|xx  set-car!
        cons        set-cdr!
      ^_^
      help:read-*dali
      Exit
    ; define-verb


    : read-*dali (* -- head[address, <dali>] *)
      null
      help:read-*dali
      Exit
    ; define-verb

    : [ read-*dali Exit ; define-verb
    #+end_src
*** write-*dali
    #+begin_src cicada
    : help:write-*dali
      (* [address, <dali>] -- *)
      dup2 dali*? if
        car write Exit
      then
      dup2
        car write
      -> help:write-*dali Exit
    ; define-verb


    :" write-*dali said:
       ``My function-type is (* [address, <dali>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-*dali,type-error ; define-constant-string

    : write-*dali (* [address, <dali>] -- *)
      dup <dali> =/= if
        Message:write-*dali,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      Bra:square print-string write-space
      help:write-*dali
      Ket:square print-string write-space
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    [ ] print-type-tag (* <null> *) cr
    write-dec-number (* 0 *) cr

    [ 1 ] write-*dali

    [ 1 2 3 4 5 6 7 8 9 0 ] write-*dali

    [ 1
      [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
        xxx 3 4 5
      [ 1 2 3 4 5  6 ] 6 ]
    write-*dali

    [ 1
      [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
        xxx 3 4 5
      { a b c }
      [ 1 2 3 4 5  6 ] 6 ]
    write-*dali

    [ a [ a b c ]
      b [ a b c ]
      c [ a b c
            [ a [ a b c ] [ a b c ] lambda
              b [ a b c ]
              c [ a b c ] ] ] ]
    write-*dali

    [ [ a b c ] a b c ]
    write-*dali

    [ [ [ [ :x ] ] ] ]
    write-*dali

    [ [ [ :x ] ]
      [ [ :x ] ] ]
    write-*dali

    [ [ [ [ :x ] ] ]
      [ [ [ :x ] ] ] ]
    write-*dali

    [ [ [ [ :x :x @ ] :x :x @ ] lambda :y @ ]
      [ [ :x :x @ ] lambda :y @ ] ]
    write-*dali

    [ 1 { 2 . 3 } 4 ]
    dup2 write
    -> car
    dup print-type-tag (* <list> *) cr
    car print-type-tag (* <fixnum> *) cr
    write-dec-number (* 2 *) cr
    #+end_src
** stack & list & dali
*** note
    it is hard to convert a list of value in the ArgumentStack
    say, [1, 2, 3], to a real list { 3 2 1 }
    for during recursive calls
    there will be lots ``cons'' leaved in the ArgumentStack
    or:
    1. you convert [1, 2, 3] to { 1 2 3 }
    2. you use LambdaStack for help
    3. you use dali but not list
    ------------------------------------------
    I implement the following:
    1. FIAF denotes first in at first
    2. LIAF denotes last in at first
       LIAF version uses the LambdaStack
       which is very funny
*** stack->list
    #+begin_src cicada
    : help:stack-LIAF->list
      (* ..., number --  *)
      (* LambdaStack::
         [address, <list>] -- *)
      dup zero? if
        drop (* drop 0 *)
        get-back null set-cdr!
        drop2 Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      dup2
        get-back [cdr,cons]! drop2
      ready
      help:stack-LIAF->list
      Exit
    ; define-verb

    : stack-LIAF->list
      (* ..., number -- [address, <list>] *)
      dup zero? if
        drop null Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      dup2 ready (* leave the return *)
      ready
        help:stack-LIAF->list
      get-back Exit
    ; define-verb


    : help:stack-FIAF->list
      (* ..., number -- *)
      (* LambdaStack::
         [address, <list>] -- [address, <list>] *)
      dup zero? if
        drop (* drop 0 *)
        Exit
      then
      sub1
      swap <fixnum>  cons drop <list>  [car,cons]!
      get-back [cons,cdr]! ready
      help:stack-FIAF->list
      Exit
    ; define-verb

    : stack-FIAF->list
      (* ..., number -- [address, <list>] *)
      dup zero? if
        drop null Exit
      then
      null
      ready
        help:stack-FIAF->list
      get-back
      Exit
    ; define-verb
    #+end_src
*** stack->dali
    #+begin_src cicada
    : help:stack-LIAF->dali
      (* ..., number -- [address, <list>] *)
      (* LambdaStack::
         [address, <list>] -- *)
      dup zero? if
        drop (* drop 0 *)
        get-back
        dup2 cdr
        null set-cdr!
        drop2
        head<-dali
        Exit
      then
      sub1
      swap <fixnum>  cons drop <dali>  [car,cons]!
      cons  [cons,cdr]!
      get-back
        xx|swap|xx ^_^
      ready
      help:stack-LIAF->dali
      Exit
    ; define-verb

    : stack-LIAF->dali
      (* ..., number -- [address, <dali>] *)
      dup zero? if
        drop null Exit
      then
      null
      ready
      help:stack-LIAF->dali
      Exit
    ; define-verb


    : help:stack-FIAF->dali
      (* ..., number -- [address, <list>] *)
      (* LambdaStack::
         [address, <list>] -- *)
      dup zero? if
        drop (* drop 0 *)
        get-back
        dup2 cdr
        null set-car!
        drop2 Exit
      then
      sub1
      swap <fixnum>  cons drop <dali>  [car,cons]!
      cons  [cons,cdr]!
      get-back
        ^_^ <-
      ready
      help:stack-FIAF->dali
      Exit
    ; define-verb

    : stack-FIAF->dali
      (* ..., number -- [address, <dali>] *)
      (* ..., number -- [address, <dali>] *)
      dup zero? if
        drop null Exit
      then
      sub1
      swap <fixnum>  cons drop <dali>
      [car,cons]!
        null set-cdr-to-{cdr.x}!
      ready
      help:stack-FIAF->dali
      Exit
    ; define-verb
    #+end_src
*** list->stack
    #+begin_src cicada
    :" stack<-FIAF-list said:
       ``My function type is (* [address, <list>] -- ... *)
         the list should be a list of <not-pair-like> value
         But in the middle of recursion
         the following is what I found
         I will not touch it and call debuger''
       --> "
    : Message:stack<-FIAF-list,error ; define-constant-string

    :" stack<-FIAF-list said:
       ``My function type is (* [address, <list>] -- ... *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:stack<-FIAF-list,type-error ; define-constant-string

    : help:stack<-FIAF-list
      (* -- ... *)
      (* LambdaStack::
         [address, <list>] -- *)
      get-back
      dup <null> == if
        drop2 Exit
      then
      dup2
        cdr ready
      car
      dup <pair-like>? if
        Message:stack<-FIAF-list,error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop a <not-pair-like> type-tag *)
      (* leave the value of the [value, <not-pair-like>] *)
      help:stack<-FIAF-list
      Exit
    ; define-verb

    : stack<-FIAF-list
      (* [address, <list>] -- ... *)
      dup <list> =/= if
        Message:stack<-FIAF-list,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      ready
      help:stack<-FIAF-list
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    cr
    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-LIAF->list write (* { 0 9 8 7 6 5 4 3 2 1 } *) cr
    . (* 666 *) cr
    1  1 stack-LIAF->list write (* { 1 } *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-FIAF->list write (* { 1 2 3 4 5 6 7 8 9 0 } *) cr
    . (* 666 *) cr
    1  1 stack-FIAF->list write (* { 1 } *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-LIAF->dali write (* [ 0 9 8 7 6 5 4 3 2 1 ] *) cr
    . (* 666 *) cr
    1  1 stack-LIAF->dali write (* [ 1 ] *) cr
    cr

    666
      1 2 3 4 5 6 7 8 9 0
      10 stack-FIAF->dali write (* [ 1 2 3 4 5 6 7 8 9 0 ] *) cr
    . (* 666 *) cr
    1  1 stack-FIAF->dali write (* [ 1 ] *) cr
    cr

    666 { 1 } stack<-FIAF-list
     . (* 1 *) . (* 666 *) cr
    666 { 1 2 3 4 } stack<-FIAF-list
     . . . . (* 4 3 2 1 *) . (* 666 *) cr
    cr
    #+end_src
** symbol types
*** helper funciton
    #+begin_src cicada
    : char-denote-number,or-alphabet,or-out-of-ascii?
      (* char -- True of False *)
      dup  48 < if     drop False Exit
      then
      dup  57 <= if    drop True Exit
      then
      dup  65 < if     drop False Exit
      then
      dup  90 <= if    drop True Exit
      then
      dup  97 < if     drop False Exit
      then
      dup  122 <= if   drop True Exit
      then
      dup  128 < if    drop False Exit
      then
      drop True Exit
    ; define-verb
    #+end_src
*** Bound-variable
    #+begin_src cicada
    (* `:' followed by a number or alphabet is a symbolDenoteBoundVariable
       ascii: 48 -- 57, 65 -- 90, 97 -- 122, 128 -- ...
       this set maybe change in the future *)

    : string-denote-bound-variable,one?
      (* [address, length] -- True or False *)
      tail-and-head-of-string
      ':' =/= if
        drop2 False (* Exit *)
      else
        dup 0 == if
          drop2 False (* Exit *)
        else
          tail-and-head-of-string
          char-denote-number,or-alphabet,or-out-of-ascii? if
            drop2 True (* Exit *)
          else
            drop2 False (* Exit *)
          then
        then
      then
      Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-bound-variable,one? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,one?,type-error ; define-constant-string
    : symbol-denote-bound-variable,one?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,one?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,one?
      Exit
    ; define-verb



    : string-denote-bound-variable,two?
      (* [address, length] -- True or False *)
      dup 2 <= if
        drop2 False Exit
      then
      tail-and-head-of-string ':' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,one? Exit
      Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-bound-variable,two? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,two?,type-error ; define-constant-string
    : symbol-denote-bound-variable,two?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,two?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,two?
      Exit
    ; define-verb




    : string-denote-bound-variable,three?
      (* [address, length] -- True or False *)
      dup 3 <= if
        drop2 False Exit
      then
      tail-and-head-of-string ':' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,two? Exit
      Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-bound-variable,three? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,three?,type-error ; define-constant-string
    : symbol-denote-bound-variable,three?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,three?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,three?
      Exit
    ; define-verb



    : string-denote-bound-variable,four?
      (* [address, length] -- True or False *)
      dup 4 <= if
        drop2 False Exit
      then
      tail-and-head-of-string ':' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,three? Exit
      Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-bound-variable,four? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable,four?,type-error ; define-constant-string
    : symbol-denote-bound-variable,four?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable,four?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable,four?
      Exit
    ; define-verb




    : string-denote-bound-variable?
      (* [address, length] -- True or False *)
      dup2 string-denote-bound-variable,one? if
        drop2 True Exit
      then
      dup2 string-denote-bound-variable,two? if
        drop2 True Exit
      then
      dup2 string-denote-bound-variable,three? if
        drop2 True Exit
      then
      dup2 string-denote-bound-variable,four? if
        drop2 True Exit
      then
      drop2 False Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-bound-variable? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-bound-variable?,type-error ; define-constant-string
    : symbol-denote-bound-variable?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-bound-variable?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-bound-variable?
      Exit
    ; define-verb
    #+end_src
*** wodi
    #+begin_src cicada
    (* string begin with a number or alphabet
       and end with `:' following a number or alphabet
       is a symbolDenotewodi *)

    : string-denote-wodi?
      (* [address, length] -- True or False *)
      dup 2 < if
        drop2 False Exit
      then
      dup2 head-of-string
      char-denote-number,or-alphabet,or-out-of-ascii? false? if
        drop2 False Exit
      then
      dup2  sub1 +  fetch-byte ':' =/= if
        drop2 False Exit
      then
      dup2  sub2 +  fetch-byte
      char-denote-number,or-alphabet,or-out-of-ascii? false? if
        drop2 False Exit
      then
      drop2 True Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-wodi? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-wodi?,type-error ; define-constant-string
    : symbol-denote-wodi?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-wodi?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-wodi?
      Exit
    ; define-verb
    #+end_src
*** LambdaArgument
    #+begin_src cicada
    (* `<' plus a string-denote-bound-variable,one *)
    : string-denote-lambda-argument,one?
      (* [address, length] -- True or False *)
      dup 2 <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,one? Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-lambda-argument,one? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,one?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,one?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,one?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,one?
      Exit
    ; define-verb



    (* `<' plus a string-denote-bound-variable,two *)
    : string-denote-lambda-argument,two?
      (* [address, length] -- True or False *)
      dup 3 <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,two? Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-lambda-argument,two? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,two?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,two?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,two?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,two?
      Exit
    ; define-verb




    (* `<' plus a string-denote-bound-variable,three *)
    : string-denote-lambda-argument,three?
      (* [address, length] -- True or False *)
      dup 4 <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,three? Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-lambda-argument,three? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,three?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,three?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,three?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,three?
      Exit
    ; define-verb




    (* `<' plus a string-denote-bound-variable,four *)
    : string-denote-lambda-argument,four?
      (* [address, length] -- True or False *)
      dup 5 <= if
        drop2 False Exit
      then
      tail-and-head-of-string '<' =/= if
        drop2 False Exit
      then
      string-denote-bound-variable,four? Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-lambda-argument,four? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument,four?,type-error ; define-constant-string
    : symbol-denote-lambda-argument,four?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument,four?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument,four?
      Exit
    ; define-verb



    : string-denote-lambda-argument?
      (* [address, length] -- True or False *)
      dup2 string-denote-lambda-argument,one? if
        drop2 True Exit
      then
      dup2 string-denote-lambda-argument,two? if
        drop2 True Exit
      then
      dup2 string-denote-lambda-argument,three? if
        drop2 True Exit
      then
      dup2 string-denote-lambda-argument,four? if
        drop2 True Exit
      then
      drop2 False Exit
    ; define-verb

    :" an error occurs!
    symbol-denote-lambda-argument? said:
       ``My function-type is (* [index, <symbol>] -- True or False *)
         But the type I received is the following,
         I will not touch it and call debuger.''
       --> "
    : Message:symbol-denote-lambda-argument?,type-error ; define-constant-string
    : symbol-denote-lambda-argument?
      (* [index, <symbol>] -- True or False *)
      dup <symbol> =/= if
        Message:symbol-denote-lambda-argument?,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      drop (* drop the type-tag *)
      index-hashback->string
      string-denote-lambda-argument?
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    :" xxx"   string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 0 *) cr
    :" :xxx"  string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 1 *) cr
    :" ::"    string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 0 *) cr
    :" :"     string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 0 *) cr
    :" :1"    string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 1 *) cr
    :" :中文" string-hash->index <symbol> symbol-denote-bound-variable,one? . (* 1 *) cr
    cr
    :" :xxx"   string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 0 *) cr
    :" ::xxx"  string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 1 *) cr
    :" :::"    string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 0 *) cr
    :" ::"     string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 0 *) cr
    :" ::1"    string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 1 *) cr
    :" ::中文" string-hash->index <symbol> symbol-denote-bound-variable,two? . (* 1 *) cr
    cr
    :" xxx"   string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" :xxx"  string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" ::"    string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" :"     string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" :1"    string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" :中文" string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    cr
    :" xxx::" string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" xxx:"  string-hash->index <symbol> symbol-denote-wodi? . (* 1 *) cr
    :" 1:"    string-hash->index <symbol> symbol-denote-wodi? . (* 1 *) cr
    :" :1:"   string-hash->index <symbol> symbol-denote-wodi? . (* 0 *) cr
    :" 中文:" string-hash->index <symbol> symbol-denote-wodi? . (* 1 *) cr
    cr
    :" <:xxx::" string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    :" <:xxx:"  string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    :" <:1:"    string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    :" <::1:"   string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 0 *) cr
    :" <:中文:" string-hash->index <symbol> symbol-denote-lambda-argument,one? . (* 1 *) cr
    cr
    :" <:xxx::" string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    :" <:xxx:"  string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    :" <:1:"    string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    :" <::1:"   string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 1 *) cr
    :" <:中文:" string-hash->index <symbol> symbol-denote-lambda-argument,two? . (* 0 *) cr
    cr

    (* ----------------------------------------------------- *)
    cr
    :" xxx"    string-denote-bound-variable,one? . (* 0 *) cr
    :" :xxx"   string-denote-bound-variable,one? . (* 1 *) cr
    :" ::"     string-denote-bound-variable,one? . (* 0 *) cr
    :" :"      string-denote-bound-variable,one? . (* 0 *) cr
    :" :1"     string-denote-bound-variable,one? . (* 1 *) cr
    :" :中文"  string-denote-bound-variable,one? . (* 1 *) cr
    cr
    :" :xxx"    string-denote-bound-variable,two? . (* 0 *) cr
    :" ::xxx"   string-denote-bound-variable,two? . (* 1 *) cr
    :" :::"     string-denote-bound-variable,two? . (* 0 *) cr
    :" ::"      string-denote-bound-variable,two? . (* 0 *) cr
    :" ::1"     string-denote-bound-variable,two? . (* 1 *) cr
    :" ::中文"  string-denote-bound-variable,two? . (* 1 *) cr
    cr
    :" xxx"    string-denote-wodi? . (* 0 *) cr
    :" :xxx"   string-denote-wodi? . (* 0 *) cr
    :" ::"     string-denote-wodi? . (* 0 *) cr
    :" :"      string-denote-wodi? . (* 0 *) cr
    :" :1"     string-denote-wodi? . (* 0 *) cr
    :" :中文"  string-denote-wodi? . (* 0 *) cr
    cr
    :" xxx::"  string-denote-wodi? . (* 0 *) cr
    :" xxx:"   string-denote-wodi? . (* 1 *) cr
    :" 1:"     string-denote-wodi? . (* 1 *) cr
    :" :1:"    string-denote-wodi? . (* 0 *) cr
    :" 中文:"  string-denote-wodi? . (* 1 *) cr
    cr
    :" <:xxx::"  string-denote-lambda-argument,one? . (* 1 *) cr
    :" <:xxx:"   string-denote-lambda-argument,one? . (* 1 *) cr
    :" <:1:"     string-denote-lambda-argument,one? . (* 1 *) cr
    :" <::1:"    string-denote-lambda-argument,one? . (* 0 *) cr
    :" <:中文:"  string-denote-lambda-argument,one? . (* 1 *) cr
    cr
    :" <:xxx::"  string-denote-lambda-argument,two? . (* 0 *) cr
    :" <:xxx:"   string-denote-lambda-argument,two? . (* 0 *) cr
    :" <:1:"     string-denote-lambda-argument,two? . (* 0 *) cr
    :" <::1:"    string-denote-lambda-argument,two? . (* 1 *) cr
    :" <:中文:"  string-denote-lambda-argument,two? . (* 0 *) cr
    cr
    (* ----------------------------------------------------- *)

    (* test: type-error *)
    null symbol-denote-wodi?          basic-REPL
    null symbol-denote-bound-variable,one?  basic-REPL
    #+end_src
** read-wodili & write-wodili
*** note
    1. wodili denotes wordy-list
    2. wodili is a dali of list
    3. lambda will use ``bound-variable-wodili''
*** read-wodili
    #+begin_src cicada
    : help:with-word,read-wodi-or-bound-variable
      (* -- [address, <list>] *)
      (* LambdaStack::
         -- wodi[address, length] *)
      read-word
      dup2 string-denote-wodi? if
        ready
        null Exit
      then
      dup2 string-denote-bound-variable? if
        ready
        null Exit
      then
      dup2 Ket:round equal-string? if
        ready
        null Exit
      then
      dup2 Mid:dot equal-string? if
        drop2
        help:with-word,read-wodi-or-bound-variable car
        (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
        Exit
      then
      execute-word,for-list-reader
      cons drop <list>
        xx|swap|xx  set-car!
          help:with-word,read-wodi-or-bound-variable
        set-cdr!
      Exit
    ; define-verb


    : with-word,read-wodi-or-bound-variable
      (* word[address, length] -- [address, <wodi>], word[address, length] *)
      (* LambdaStack:: <wodi> -- *)
      (* or *)
      (* word[address, length] -- [address, <bound-variable>], word[address, length] *)
      (* LambdaStack:: <bound-variable> -- *)
      string-hash->index <symbol>
      cons drop pop-lambda-stack
        [car,cons]!
          help:with-word,read-wodi-or-bound-variable
        [cons,cdr]!
      get-back
      (* return the next ``wodi'' word
         it must be handled in help:read-wodili *)
      Exit
    ; define-verb



    :" help:read-wodili said:
       ``My function type is
         (* [address, <wodili>], word[address, length] -- head[address, <wodili>] *)
         the `word' must be `)' or denotes `wodi' or denotes `bound-variable'
         But the following is what I meet
         I will not touch it and call debuger''
       --> "
    : Message:help:read-wodili,error ; define-constant-string

    (* a ``with-word'' reader *)
    : help:read-wodili
      (* [address, <wodili>], word[address, length] -- head[address, <wodili>] *)
      (* where:
           the <- of [address, <wodili>] is setted,
           need to set the -> of [address, <wodili>] *)
      dup2 Ket:round equal-string? if
        drop2
        dup2
          cdr
            null  set-cdr!
          drop2
        head<-dali
        Exit
      then
      dup2 string-denote-wodi? if
        <wodi> push-lambda-stack
      else
        dup2 string-denote-bound-variable? if
          <bound-variable> push-lambda-stack
        else
          Message:help:read-wodili,error print-string
          print-string cr
          debuger Exit
        then
      then
      with-word,read-wodi-or-bound-variable
      (* [address, <wodili>], [address, <wodi>], word[address, length] *)
      (* or *)
      (* [address, <wodili>], [address, <bound-variable>], word[address, length] *)
      xxxx|swap|xx
      cons drop <wodili>
        xx|swap|xx  set-car!
        cons        set-cdr!
      ^_^
      xx|swap|xx
      help:read-wodili
      Exit
    ; define-verb



    : read-wodili (* -- head[address, <wodili>] *)
      null
      read-word
      dup2 Ket:round equal-string? if
        (* return ``null'' on ( ) *)
        drop2 Exit
      then
      help:read-wodili
      Exit
    ; define-verb

    : ( read-wodili Exit ; define-verb
    #+end_src
*** write-wodi & write-wodili
    #+begin_src cicada
    :" write-wodi-or-bound-variable said:
       ``My function-type is (* [address, <wodi> or <bound-variable>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-wodi-or-bound-variable,type-error ; define-constant-string

    : write-wodi-or-bound-variable
      (* [address, <wodi> or <bound-variable>] -- *)
      dup <wodi> =/=
      over <bound-variable> =/=
      bitwise-and if
        Message:write-wodi-or-bound-variable,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup2
        car write
      cdr help:write-list
      Exit
    ; define-verb



    : help:write-wodili
      (* [address, <wodili>] -- *)
      dup <null> == if
        drop2 Exit
      then
      dup2
        car write
      -> help:write-wodili Exit
    ; define-verb


    :" write-wodili said:
       ``My function-type is (* [address, <wodili>] -- *)
         But the 1st argument is the following
         I will not touch it and call debuger.''
       --> "
    : Message:write-wodili,type-error ; define-constant-string

    : write-wodili
      (* [address, <wodili>] -- *)
      dup <wodili> =/= if
        Message:write-wodili,type-error print-string
        dup print-type-tag cr
        debuger Exit
      then
      Bra:round print-string write-space
      help:write-wodili
      Ket:round print-string write-space
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    ( x: ( a: 1 2 3 b: 4 5 6 )
      a: 1 2 3
      b: 4 5 6 )
     write

    ( a: b: 6 ) write-wodili

    ( :a 1 :b 2 ) write-wodili
    #+end_src
** ><><>< wodili processing
** execute-word [redefine] & symbol-REPL & lambda-argument
*** note
    1. to read different types of symbols
    2. to handle <:x <::x <:::x <::::x
    3. print better ErrorInfo for ExecuteWord
*** implementation
    #+begin_src cicada
    : <lambda-argument-one>   ; define-pair-like-data-type
    : <lambda-argument-two>   ; define-pair-like-data-type
    : <lambda-argument-three> ; define-pair-like-data-type
    : <lambda-argument-four>  ; define-pair-like-data-type

    : <lambda-argument>?
      (* type-tag -- True or False *)
      dup <lambda-argument-one> == if
        drop True Exit
      then
      dup <lambda-argument-two> == if
        drop True Exit
      then
      dup <lambda-argument-three> == if
        drop True Exit
      then
      dup <lambda-argument-four> == if
        drop True Exit
      then
      drop False Exit
    ; define-verb

    (* ><><>< the following comment should be rewritten *)
    (* redefine execute-word to handle the following symbols
       <:x   ::    value       -- [{ :x  . { ... } }, <lambda-argument-one>]
       <::x  ::  [value, type] -- [{ ::x . { ... } }, <lambda-argument-two>]
       ...
       examples:
       [{ :x       . { 1 } },             <lambda-argument-one>]
       [{ ::null   . { Null <null> } },   <lambda-argument-two>]
       [{ ::number . { 666 <fixnum> } },  <lambda-argument-two>]
       note that:
         every value in list must have a type
         so in every list above, type of a car is setted to <fixnum>
     *)

    : execute-word (* string[address, length] -- unknown *)
      dup2
      string-denote-integer? if
        string->integer,with-error drop Exit
      then

      dup2 string-denote-bound-variable,one? if
        string-hash->index <symbol> Exit
      then
      dup2 string-denote-bound-variable,two? if
        string-hash->index <symbol> Exit
      then
      dup2 string-denote-bound-variable,three? if
        string-hash->index <symbol> Exit
      then
      dup2 string-denote-bound-variable,four? if
        string-hash->index <symbol> Exit
      then

      dup2 string-denote-lambda-argument,one? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-one>
          xx|swap|xx set-car!
          ready
            1 stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 string-denote-lambda-argument,two? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-two>
          xx|swap|xx set-car!
          ready
            2 stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 string-denote-lambda-argument,three? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-three>
          xx|swap|xx set-car!
          ready
            3 stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 string-denote-lambda-argument,four? if
        tail-of-string
        string-hash->index <symbol>
        cons drop <lambda-argument-four>
          xx|swap|xx set-car!
          ready
            4 stack-FIAF->list
          get-back
          xx|swap|xx set-cdr!
        Exit
      then
      dup2 find dup zero? false? if
        xx|swap|x drop2
        word-link->word-explainer execute Exit
      then
      drop (* drop the 0 that denotes finding-error *)
      Message:undefined-word print-string
      print-string (* print the word *) cr
      Exit
    ; define-verb

    (* if wished
     *   one needs to use help:symbol-REPL to do the recursive
     *   and reset the two pointers in symbol-REPL
     * Return-stack-top reset-return-stack-pointer
     * Argument-stack-top reset-argument-stack-pointer *)

    : symbol-REPL (* unknown -- unknown *)
      read-word-for-runtime
      execute-word
      symbol-REPL
      Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    symbol-REPL 1 2 + . (* 3 *) cr
    cr

    :xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* :xxx *) cr
    cr

    ::xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* ::xxx *) cr
    cr

    :::xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* :::xxx *) cr
    cr

    ::::xxx print-type-tag (* <symbol> *) cr
    index-hashback->string print-string (* ::::xxx *) cr
    cr
    #+end_src
** using the symbol-REPL now !
   #+begin_src cicada
   symbol-REPL
   #+end_src
* ><><>< lambda-calculus
** lambda
*** [OLD] english note
**** about lambda-calculus
     1. lambda is a function which uses one dali and one wodili
        to compose a anonymous function
        (not compile to the dictionary)
        apply is a function which
        explain (or eval) the anonymous function composed by lambda
     2. ``compose(撰写)'' is different from ``compile(编撰)''
     3. the essence is
        ``compose and explain''
        or ``compile and explain''
        1) what(syntax) to be composed ?
        2) compose to what ?
        3) how to explain(or eval) the result of the composition
     4. in cicada
        apply is linear
        lambda is almost linear
        ``linear'' means a loop walk through a dali
        but not a recursive function traverse a nested dali
        only the function that calculates the scope of a lambda is recursive
     5. a bound-variable of a lambda function
        is used to label the place in the lambda-body
        into where you want to substitute a argument
        when lambda-body is nested
        the scope of bound-variables need to be handled
        scheme use closure to handle this
        cicada use simple graph processing to handle this
     6. during lambda-application,
        one <lambda-argument-N> substitute into
        one <bound-variable>
     7. from lisp to cicada
        I am dispersing the works of parsing all the time
**** about lazy-eval
     1. lazy-eval has better theoretical feature in lambda-calculus
        but it makes computation unpredictable
**** about substitution
     note that you can only use bound-variable (such as ::x :n) in a lambda-body
     but NOT in a dali or list or wodili
*** Chinese note
**** 关于 lambda-calculus
     1. 在 cicada 中 lambda 被实现为一个函数
        它用 一个 代表函数体的 dali [ ]
        和 一个 代表约束变量列表的 wodili ( )
        来 撰写(compose) 一个匿名函数
        - 注意 不是 编撰(compile) 到字典里
     2. apply 是一个函数
        它 解释(explain) lambda 所编撰的匿名函数
     3. 在字典比喻下
        核心的一对概念就是
        "撰" 与 "释"
        目前你已经看到了 两种 对这一对概念的具体化
        1) define-verb & execute-word
        2) lambda & apply
        更一般地
        当再次需要 通过具体化这一对概念
        来设计新的语法和语义 的时候
        只需要再实现一对这样的函数就行了
        尽管 可能 使用 不同的 数据结构
        或 不同的 语法
        但是核心的概念是不变的
     4. 与 LISP 中的 apply 不同
        在 cicada 中 apply 是完全线性的
        lambda 也几乎是线性的
        这里 线性的意思是
        这些函数只是一些 遍历 dali 的循环
        而不是 遍历 嵌套的 dali 的递归函数
        而 "几乎线性" 的意思是
        只有 计算 lambda 的约束变元 的 "标记范围" 的函数才是递归的
        这种特性的产生原因
        与 "不做语法解析的解释器" 的产生原因类似
        这种过程可以看作是 栈处理机 对 表达式 的解构
        而形成 表面上的 后缀表达式
        后缀表达式 中的一个函数 包含了这个 后缀表达式 这种语法本身
        而不是 由一个 外在的解释器 去实现这种语法
     6. 一个 lambda 函数 的 约束变元(bound-variable)
        使用来 标记 这个 lambda 函数 的函数体中的某些位置的
        在这些位置上 你可以代入 参数
     7. 当 lambda 函数 的 函数体 形成嵌套的时候
        约束变元 的 "标记范围" 需要被计算
        scheme 用 闭包(closure) 来处理这种情况
        而 cicada 用简单的 有向图处理(direct-graph-processing)
        来解决这个问题
     8. 在 lambda-application 期间
        一个 <lambda-argument-N> 被代入 一个 <bound-variable>
**** 关于 lazy-eval
     1. 用 lazy-eval 所实现的 lambda-calculus 具有更好的数学性质
        但是 在实践中 由于 它们让局部的 计算 所消耗的时间 不可预测
        所以 是有问题的
**** >< 需要解决的问题
     1. 只能 在 lambda-body 中 使用 bound-variable (such as ::x :n)
        而 不能 在一般的 list dali wodili 中使用
*** data-types
    #+begin_src cicada
    : <lambda>               ; define-pair-like-data-type
    : <explainer-pair>       ; define-pair-like-data-type
    : <explainer>            ; define-data-type
    #+end_src
*** helper functions
    used to decide the type error of lambda
    and to decide when I need to calculate lambda-scope
    两个 辅助性的 谓词
    可以发现命名规则上还有待改进 并标准化
    #+begin_src cicada
    : bound-variable-wodili?
      (* head[address, <wodili>] -- True or False *)
      dup <wodili> =/= if
        drop2 False Exit
      then
      dup2 car  swap drop
      <bound-variable> =/= if
        drop2 False Exit
      then
      dup2 dali*? if
        drop2 True Exit
      then
      ->  bound-variable-wodili?
      Exit
    ; define-verb


    (*
     * the following function return `True'
     * on the following dali as a tail
     *   [ [address, <dali>]
     *     bound-variable-wodili[address, <wodili>]
     *    ]
     * and
     *   [ [address, <dali>]
     *     null
     *    ]
     *)

    : meet-lambda-abstraction-in-lambda-body-dali?
      (* tail[address, <dali>] -- True or False *)
      dup <dali> =/= if
        drop2 False Exit
      then
      dup2 car
      dup2       bound-variable-wodili?
      xx|swap|x  null?
      bitwise-or if
        <- dup <dali> =/= if
          drop2 False Exit
        then
          car <dali> =/= if
            drop False Exit
          then
            drop True Exit
      then
      drop2 False Exit
    ; define-verb

    (*
     * test:
     *
     * [ [ 1 ] ( :x ) ] dali->tail
     * meet-lambda-abstraction-in-lambda-body-dali? . (\* 1 *\) cr
     * [ [ 1 ] null ] dali->tail
     * meet-lambda-abstraction-in-lambda-body-dali? . (\* 1 *\) cr
     * [ [ 1 ] ( ) ] dali->tail
     * meet-lambda-abstraction-in-lambda-body-dali? . (\* 1 *\) cr
     * cr
     * [ [ 1 ] ( x: ) ] dali->tail
     * meet-lambda-abstraction-in-lambda-body-dali? . (\* 0 *\) cr
     *)
    #+end_src
*** bound-variable-wodili-subtraction (for calculating lambda-scope)
    #+begin_src cicada
    : help:bound-variable-wodili-subtraction
      (* LambdaStack::
         (a-b) [address, <wodili>] -- *)
      (* b [address, <wodili>], a [address, <wodili>] --
         (a-b) [address, <wodili>] *)
      dup <null> == if
        drop2 drop2
        get-back
        dup <null> == if
          Exit
        then
        dup2 cdr null [cons,cdr]! drop2
        head<-dali
        Exit
      then
      dup2
        car car   xx|over|xxxx
        [value,dali]-associate
        dup <null> =/= if
        (* if this bound-variable is ``blocked'',
           it should not be ``cons'' to the new bound-variable-wodili *)
        drop2 (* drop the associate-pair *)
        ->  help:bound-variable-wodili-subtraction Exit
      then
      drop2 (* drop the associate-pair *)
      (* b [address, <wodili>], a [address, <wodili>] *)
      dup2 car
      (* a wodi as a whole is ``cons''ed to the new bound-variable-wodili *)
      cons drop <wodili>
        [car,cons]!
        cons [cons,cdr]!
      get-back
        xx|swap|xx  ^_^
        (* so the order of bound-variable-wodili will be preserved *)
      ready
      ->  help:bound-variable-wodili-subtraction Exit
    ; define-verb


    (* the following function will creat a new wodili, maybe ``null'' *)
    : bound-variable-wodili-subtraction
      (* a [address, <wodili>], b [address, <wodili>] --
         (a-b) [address, <wodili>] *)
      x|over|xx <null> == if
        (* a == null, (a-b) == a == null *)
        drop2 Exit
      then
      dup <null> == if
        (* b == null, (a-b) == a *)
        drop2 Exit
      then
      null ready
      xx|swap|xx
      (* b [address, <wodili>], a [address, <wodili>] *)
      (* LambdaStack::  [Null, <null>] *)
      help:bound-variable-wodili-subtraction
      Exit
    ; define-verb


    (*
     *  test:
     *
     * 666
     * ( ::a ::b ::c )
     * ( ::a ::c ::x )
     * bound-variable-wodili-subtraction
     * write (\* ( ::b )  *\)
     *
     * . (\* 666 *\)
     *)
    #+end_src
*** lambda
    #+begin_src cicada
    :" lambda" string-hash->index
    : Symbol-index:lambda ; define-constant

    :" λ" string-hash->index
    : Symbol-index:λ ; define-constant


    (* the following two functions are side-effects through a dali
     ,* in the direction of ``<-''

     ,* some special-types of elements in the lambda-body
     ,* should be setted for ``apply''

     ,* note that: (currently)
     ,*   <fixnum> <list> <dali> <wodili> <symbol>
     ,*   are the only types of value
     ,*   that could be readed into a dali

     ,*   only all <symbol> in this dali
     ,*   and some <symbol> that denote-bound-variable nestedly existed in this dali
     ,*   will be handled by the following functions

     ,*   while
     ,*   in the ``apply''
     ,*   when meet [666, <fixnum>]
     ,*     666 ( ONLY ONE VALUE ) will be push to ArgumentStack
     ,*   when meet [address, <list>]
     ,*     [address, <list>] will be push to ArgumentStack
     ,*   when meet [address, <dali>]
     ,*     [address, <dali>] will be push to ArgumentStack
     ,*   when meet [address, <wodili>]
     ,*     [address, <wodili>] will be push to ArgumentStack
     ,*)

    (*
     ,* 下面的两个 函数是主要的辅助函数
     ,* 它们不是术语函数范式
     ,* 它们是 沿着 ``<-'' 方向 对 dali 做副作用
     ,*)


    : help:lambda,set-bound-variables (* calculating lambda-scope *)
      (* [address, <wodili>], [address, <dali>] -- *)
      dup <null> == if
        (* drop all the arguments here *)
        drop2 drop2 Exit
      then
      dup2 car

      (* [address, <wodili>], [address, <dali>], car[value, type] *)
      dup <symbol> =/= if
        (* types of value other then <symbol>
           will be leaved in the lambda-body as they are *)
        drop2
        <-  help:lambda,set-bound-variables Exit
      then

      (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
      dup2 symbol-denote-bound-variable? if
        xx|over|xxxx
        dup <null> == if
          (* when bound-variable-wodili is null
             symbol-denote-bound-variable can not be bound by this lambda
             just leave them in the lambda-body as they are *)
          drop2 (* drop [Null, <null>] *)
          drop2 (* drop [index, <symbol>] *)
          <-  help:lambda,set-bound-variables Exit
        then
        [value,dali]-associate
        dup <null> == if
          (* symbol-denote-bound-variable that can not be bound by this lambda
             will be leaved in the lambda-body as they are *)
          drop2
          <-  help:lambda,set-bound-variables Exit
        then
        (* [address, <wodili>], [address, <dali>], [address, <bound-variable>] *)
        [cons,car]!
        <-  help:lambda,set-bound-variables Exit
      then

      (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
      dup2 drop
        dup   Symbol-index:lambda ==
        swap  Symbol-index:λ ==
      bitwise-or if
        drop2
        <-
        (* make a special treatment only when
           ``meet-lambda-abstraction-in-lambda-body-dali'' *)
        dup2
        meet-lambda-abstraction-in-lambda-body-dali?
        false? if
          help:lambda,set-bound-variables Exit
        then
        (* [address, <wodili>], [address, <dali>] *)
          (* prepare the arguments for a non-tail-recursive call of help:lambda,set-bound-variables *)
          xx|over|xx xx|over|xx
            car bound-variable-wodili-subtraction
          xx|over|xx
            (* note that: the 2ed arg of help:lambda,set-bound-variables is a tail-dali *)
            <-  car  dali->tail
          help:lambda,set-bound-variables
          (* after then : *)
          <- <-  help:lambda,set-bound-variables Exit
      then

      (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
      (* here is general symbol *)
      drop2
      <-  help:lambda,set-bound-variables Exit
    ; define-verb


    : help:lambda,set-function-body
      (* [address, <wodili>], [address, <dali>] -- *)
      dup <null> == if
        (* drop all the arguments here *)
        drop2 drop2 Exit
      then
      dup2 car
      (* [address, <wodili>], [address, <dali>], car[value, type] *)
      dup <symbol> =/= if
        (* types of value other then <symbol>
           will be leaved in the lambda-body as they are *)
        drop2
        <-  help:lambda,set-function-body Exit
      then
      (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
      dup2 symbol-denote-lambda-argument? if
        (* i.e. symbols like ``<:x''
           will be leaved in the lambda-body as they are
           they will be handled by ``apply'' *)
        drop2
        <-  help:lambda,set-function-body Exit
      then
      (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
      dup2 symbol-denote-bound-variable? if
        (* i.e. symbols like ``:x''
           will be leaved in the lambda-body as they are
           ``help:lambda,set-bound-variables'' take care of them
           when ``apply'' is executed there should be none of them *)
        drop2
        <-  help:lambda,set-function-body Exit
      then
      (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
      (* here is general symbol *)
      over
        index-hashback->string
        find (* ><><>< error handling when not found *)
        word-link->word-explainer
        <explainer>
      cons drop <explainer-pair>
        [cdr,cons]!  [car,cons]!
      [cons,car]!
      <-  help:lambda,set-function-body Exit
    ; define-verb




    : help:lambda,make-lambda-function
      (* [address, <wodili>], [address, <dali>] --
         [address, <lambda>] *)
      cons drop <lambda>
        xx|swap|xx set-cdr!
        xx|swap|xx set-car!
      Exit
    ; define-verb




    :" lambda said:
       ``My function type is
         (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
         (* or *)
         (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
         But the 1st argument is the following
         I will not touch it and call debuger''
       --> "
    : Message:lambda,type-error,1st ; define-constant-string

    :" lambda said:
       ``My function type is
         (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
         (* or *)
         (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
         The 1st argument is a wodili but not a bound-variable-wodili
         I will not touch it and call debuger''"
    : Message:lambda,type-error,1st,not-bound-variable-wodili
    ; define-constant-string

    :" lambda said:
       ``My function type is
         (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
         (* or *)
         (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
         But the 3rd argument is the following
         I will not touch it and call debuger''
       --> "
    : Message:lambda,type-error,3rd ; define-constant-string

    : lambda
      (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
      (* or *)
      (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
      dup <wodili> =/=
      over <null> =/=
      bitwise-and if
        Message:lambda,type-error,1st print-string
        dup print-type-tag cr
        debuger Exit
      then
      dup <wodili> ==
      xx|over|x bound-variable-wodili? false?
      bitwise-and if
        Message:lambda,type-error,1st,not-bound-variable-wodili
        print-string cr
        debuger Exit
      then
      x|over|xx <dali> =/= if
        Message:lambda,type-error,3rd print-string
        x|over|xx print-type-tag cr
        debuger Exit
      then
      xx|tuck|xx  xx|over|xx
      dali->tail
      (* [address, <wodili>], [address, <dali>],
         [address, <wodili>], tail[address, <dali>] *)
      xx|over|xx  xx|over|xx
      help:lambda,set-bound-variables
      (* multi-pass *)
      help:lambda,set-function-body
      (* [address, <wodili>], [address, <dali>] *)
      help:lambda,make-lambda-function
      Exit
    ; define-verb

    : λ lambda Exit ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    [              :b negate
        4 :a :c * *
            :b :b *  -  ><><><sqrt  +
                        2 :a  *  / ] dup2 write cr
    ( :a :b :c ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ::x ) lambda ] dup2 write cr
    ( ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ) lambda ] dup2 write cr
    ( ) dup2 write cr
    lambda
    drop2


    [ ::y
      [ ::x ::x ::x ]
      ( ::x ) lambda ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ ::x ::x ::x ] ( ::x ) lambda ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda
       ::y
      [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda  ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2


    [ [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda ::y
      [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda @ ] dup2 write cr
    ( ::y ) dup2 write cr
    lambda
    drop2
    #+end_src
** apply
*** chinese note
    1. 此时 bound-variable 通过计算 标记范围 而对同名的 位置 的标记
       已经被 lambda 处理 成了一个 不依赖于 "名" 的
       用简单 "有向图" 做成的 对位置的标记
       在 apply 的开端 就是 约束变元 与 值 之间的绑定
       这个绑定是对 "有向图" 的副作用
       有向图的性质 使得 我可以做到 一次 绑定 多点使用
    2. 对 lambda-body 的正确求值
       是依赖于``绑定''对这个 lambda 所作的副作用的
       那么在作用的过程中就不能破坏(更改)对这些约束变元的绑定
       这就需要每次 lambda 的作用都去更新 <lambda> pair 中的约束变元 wodili
    3. ><><>< bug
       这样的话
       如果 在一个 lambda-body 嵌套出现了 这个 lambda 本身的作用
       那么在退出嵌套的时候 函数绑定就不对了
       所以 应该用栈(用某种链表实现的栈)来实现 约束变元对值的绑定
    4. 一个 lambda 就像是一个指示计算的 图纸 一样
       每次 为了使用 这个 图纸 来做计算
       有需要在 这个图纸上 做一些记录
       当使用完毕时 再 擦去 这些记录
       上面 所引入的 栈 的意思就是
       在这个 图纸用到一半的时候
       需要 这个计算本身 又要 用到这张图纸
       这时 就先把 之前的在图纸上的记录 放到栈里保存起来
       在这次 在图纸所指示的计算之内 使用玩图纸本身之后
       再利用栈中保存的 图纸上的旧记录 回到之前的计算
    5. 很容易发现
       这种 对栈的利用在 单核 的时候还 顺利进行
       当多核的时候就不行了
*** lambda-body-stack
    1. >< 这里对栈的需要 值得被分析一下
    #+begin_src cicada
    (* note that:
         when a explainer is been executed
         only the arguments of the word to be explained
         should be in the ArgumentStack or LambdaStack *)

    (* a stack as list
       list of dali
       in which a dali denotes a lambda-body *)
    null : lambda-body-stack ; define

    : push,lambda-body-stack
      (* [address, <wodili>] -- *)
      cons drop <list>  [car,cons]!
      lambda-body-stack fetch2
      [cons,cdr]!
      lambda-body-stack save2
      Exit
    ; define-verb

    : drop,lambda-body-stack
      (* -- *)
      lambda-body-stack fetch2
      cdr
      lambda-body-stack save2
      Exit
    ; define-verb
    #+end_src
*** help:apply,eval-lambda-body
    #+begin_src cicada
    (* the following function
       do side-effect to the car of the lambda-body-stack *)

    : <end-of-one-lambda-body> ; define-data-type
    : <end-of-all-lambda-body> ; define-data-type

    : lambda-forth
      (* -- [value, type] or <end-of-lambda-body> or <>] *)
      lambda-body-stack fetch2
      dup <null> == if
        drop2
        <end-of-all-lambda-body>
        Exit
      then
      dup2 car
        (* [address, <list>], [address, <dali>] or null *)
        dup <null> == if
        drop2 drop2
        <end-of-one-lambda-body>
        drop,lambda-body-stack
        Exit
      then
      (* [address, <list>], [address, <dali>] *)
      xx|tuck|xx
      (* [address, <dali>],
         [address, <list>], [address, <dali>] *)
      ->  (* up date the 1st lambda-body in lambda-body-stack *)
      [cons,car]! drop2
      car
      Exit
    ; define-verb


    :" help:apply,eval-lambda-body said:
       ``My function type is (* unknow -- unknow *)
         I call `lambda-forth' to do side-effect on lambda-body-stack
         The symbol I meet should always DenoteLambdaArgument
         But I meet the following symbol
         I will not touch it and call debuger''
       --> "
    : Message:help:apply,eval-lambda-body,error,symbol
    ; define-constant-string

    : help:apply,eval-lambda-body
      (* unknow -- unknow *)
      lambda-forth
      dup <end-of-one-lambda-body> == if
        drop Exit
      then

      (* examples:
           [{ :x  . { 100 } }, <bound-variable>]
           [{ ::x . { 666 <fixnum> } }, <bound-variable>] *)
      dup <bound-variable> == if
        cdr
        stack<-FIAF-list
        help:apply,eval-lambda-body
        Exit
      then

      (* example:
           [{ word-name . word-explainer }, <explainer-pair>] *)
      dup <explainer-pair> == if
        cdr
        drop (* drop type-tag: <explainer> *)
        execute
        help:apply,eval-lambda-body
        Exit
      then

      (* example:
           [index, <symbol>] *)
      dup <symbol> == if
        dup2 symbol-denote-lambda-argument? if
          drop (* drop <symbol> *)
          index-hashback->string
          execute-word
          help:apply,eval-lambda-body
          Exit
        then
        Message:help:apply,eval-lambda-body,error,symbol print-string
        dup2 write cr
        debuger
        Exit
      then

      (* example:
           [666, <fixnum>] *)
      dup <fixnum> == if
        drop (* drop type-tag: <fixnum> *)
        help:apply,eval-lambda-body
        Exit
      then

      (* examples:
           [address, <list>]
           [address, <dali>]
           [address, <wodili>]
         and all other types
         leave the value and the type in the stack *)
      help:apply,eval-lambda-body
      Exit
    ; define-verb
    #+end_src
*** apply
    #+begin_src cicada
    (* examples of <lambda-argument>:
         { :x       . { 1 } }
         { ::null   . { Null <null> } }
         { ::number . { 666 <fixnum> } }
       example of bound-variable-wodili
         ( :a ::b :::c )
         [ { :a    . ... }
           { ::b   . ... }
           { ::::c . ... } ]
     *)


    : help-to-rec,help:apply,set-variables
      (* ArgumentStack::
         ..., [address, <lambda-argument-N>] -- *)
      (* LambdaStack::
         [address, <wodili>] -- [address, <wodili>] *)
      dup <lambda-argument>? false? if
        Exit
      then
      dup2   car    get-back dup2 ready
      (* [address, <lambda-argument-N>], [index, <symbol>], [address, <wodili>] *)
      [value,dali]-associate
      dup <null> == if
        drop2 Exit
      then
      (* [address, <lambda-argument-N>], [..., <bound-variable>] *)
      xx|swap|xx   cdr
      [cons,cdr]!  drop2
      help-to-rec,help:apply,set-variables
      Exit
    ; define-verb


    : help:apply,set-variables
      (* ..., [address, <lambda-argument>], [address, <wodili>] -- *)
      ready
        help-to-rec,help:apply,set-variables
      get-back drop2 Exit
    ; define-verb



    :" apply said:
       ``My function type is
         (* LambdaStack::  [address, <lambda>] -- unknow *)
         (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
         But the value in the LambdaStack is of the following type
         I will not touch it and call debuger''
       --> "
    : Message:apply,type-error ; define-constant-string
    : apply
      (* LambdaStack::  [address, <lambda>] -- unknow *)
      (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
      get-back dup2 ready
      dup <lambda> == if
        car dup <null> == if
          drop2
        else
          help:apply,set-variables
        then
        get-back  cdr
        push,lambda-body-stack
        help:apply,eval-lambda-body
        Exit
      then
      Message:apply,type-error print-string
      print-type-tag cr
      drop (* drop the the value been getted back *)
      debuger Exit
    ; define-verb
    #+end_src
*** syntax sugar
    #+begin_src cicada
    : @
      (* ...,
         [address, <lambda-argument>],
         [address, <lambda>]
         ---------------------------
         unknow *)
      ready apply Exit
    ; define-verb
    #+end_src
*** test
    #+begin_src cicada
    [ :x 1 + ]  (* push a dali to ArgumentStack *)
    ( :x )      (* push a wodili of bound-variables to ArgumentStack *)
    λ           (* digests wodili as bound-variables
                   and a dali in the ArgumentStack as function-body in the Argument-stack
                   and return a lambda-function made by them *)
    ready (* pop ArgumentStack, push the lambda-function to LambdaStack *)

    3   (* push 3 into the ArgumentStack *)
    <:x (* make a typed value of type : <lambda-argument-one> *)

    apply (* apply a lambda-function in the LambdaStack function
             to the ArgumentStack,
             the arguments of the above lambda-function is labeled with a symbol `:x',
             so if there are many arguments, order will be not important *)

    write-dec-number (* 4 *) cr

    (* -------------------------------------------------------------- *)

    [ + + + ] ( :x ) λ ready
    1 2 3 4  apply
    write-dec-number (* 10 *) cr

    [ :x 1 2 3 * + + ] ( :x ) λ ready
    100 <:x
    apply
    write-dec-number (* 107 *) cr

    [ 1 :x 2 3 + + + ] ( :x ) λ ready
    100 <:x
    apply
    write-dec-number (* 106 *) cr

    [ 1 2 3 + :x + + ] ( :x ) λ ready
    100 <:x
    apply
    write-dec-number (* 106 *) cr

    [ :::x + + ] ( :::x ) λ ready
    1 2 3 <:::x
    apply
    write-dec-number (* 6 *) cr

    [ ::x + ] ( ::x ) λ ready
    1 2 <::x
    apply
    write-dec-number (* 3 *) cr

    [ :x * + + ] ( :x ) λ ready
    1 2 3
    100 <:x
    apply
    write-dec-number (* 303 *) cr

    [ :x + + + ] ( :x ) λ ready
    1 2 3
    100 <:x
    apply
    write-dec-number (* 106 *) cr


    (* ------------------------------------ *)
    (* the following tests are with scope *)

    [ [ :x + + + ] ( :x ) λ ready
      1 2 3
      100 <:x
      apply :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    write-dec-number (* 116 *) cr

    [ 1 2 3
      100 <:x [ :x + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    write-dec-number (* 116 *) cr

    [ 1 2 3
      100 <:x [ :x :x + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    write-dec-number (* 216 *) cr

    [ 1 2 3
      100 <:x [ :y + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    write-dec-number (* 26 *) cr

    [ 1 2 3
      100 <:x [ :y :x + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    write-dec-number (* 126 *) cr

    [ 1 2 3
      100 <:x [ :x :y + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply
    write-dec-number (* 126 *) cr

    [ 1 2 3
      100 <:x [ :y :y + + + + ] ( :x ) λ @
      :y + ]
    ( :y ) λ ready
    10 <:y
    apply write-dec-number (* 36 *) cr

    [ 1 2 3 [ :y :y + + + + . ] null λ @ ]
    ( :y ) λ ready
    1000 <:y
    apply  (* 2006 *) cr


    [ 1 2 3 [ :y :y + + + + ] null λ @ ]
    ( :y ) λ ready
    1000 <:y
    apply write-dec-number (* 2006 *) cr

    [ 1 2 3 [ :y :y + + + + ] ( ) λ @ ]
    ( :y ) λ ready
    1000 <:y
    apply write-dec-number (* 2006 *) cr


    (* ----------------------------------- *)
    (* explicit lazy-eval  *)
    666
    1 2 3 4
     [ + + + ] ( ) λ @
     . (* 10 *) cr
    . (* 666 *) cr

    666
    1 2 3 4
     [ + + + ] null λ @
     . (* 10 *) cr
    . (* 666 *) cr


    (* ============================================== *)


    (* ----------------------------------- *)
    (* the following tests need flow-point-number
       for we need to define ``sqrt'' *)

    (*
     ,* the following shows the problem that people argued at:
     ,* http://lambda-the-ultimate.org/node/900

     ,* -b  +/- sqrt(b^2 - 4 * a * c)
     ,* -----------------------------
     ,*            2 * a
     ,*)


    (*
     ,* [              :b negate
     ,*     4 :a :c * *
     ,*         :b :b *  -  sqrt  +
     ,*                     2 :a  *  / ] dup2 write
     ,* ( :a :b :c ) dup2 write
     ,* λ ready
     ,*
     ,* 1 <:a  2 <:b  1 <:c
     ,*
     ,* apply write-dec-number cr (\* -1 *\)
     *)
    #+end_src
** play with lambda
*** note
    1. it is very important to remember
       that lazy-eval must be explicit
    2. and again
       about substitution
       note that you can only use bound-variable (such as ::x :n) in a lambda-body
       bot NOT in a list or dali or wodili
*** play
    #+begin_src cicada
    [ ::x ]
    ( ::x 3 4 ) λ
    : Var,I ; define
    : I Var,I fetch2 Exit ; define-verb

    1 2 I @
    . . . . (* 4 3 2 1 *) cr
    cr

    1 2 <::x I @
    . . (* 2 1 *) cr
    cr

    1 2 I @
    . . . . (* 2 1 2 1 *) cr
    cr


    [ ::x ]
    ( ::x 3 4 ) λ
    : I ; define
    : I I fetch2 Exit ; define-verb

    1 2 I @
    . . . . (* 4 3 2 1 *) cr
    cr

    1 2 <::x I @
    . . (* 2 1 *) cr
    cr

    1 2 I @
    . . . . (* 2 1 2 1 *) cr
    cr



    [ [ ::T @ ]
      ( ::F ) λ ]
    ( ::T ) λ
    : Var,T ; define
    : T Var,T fetch2 Exit ; define-verb

    [ 1 2 3 . . . ] ( ) λ <::T
    T @ ready
    [ 7 8 9 . . . ] ( ) λ <::F
    apply (* 3 2 1 *) cr

    [ 1 2 3 . . . ] null λ <::T
    [ 7 8 9 . . . ] null λ <::F
    T @ @ (* 3 2 1 *) cr

    [ 7 8 9 . . . ] ( ) λ <::F
    [ 1 2 3 . . . ] ( ) λ <::T
    T @ @ (* 3 2 1 *) cr

    cr

    [ [ ::F @ ]
      ( ::F ) λ ]
    ( ::T ) λ
    : Var,F ; define
    : F Var,F fetch2 Exit ; define-verb

    [ 1 2 3 . . . ] null λ <::T
    F @ ready
    [ 7 8 9 . . . ] null λ <::F
    apply (* 9 8 7 *) cr

    cr


    : make-lambda-bool
      (* True or False -- T or F *)
      true? if
        T Exit
      then F Exit
    ; define-verb

    [ [ ::true <::T :if make-lambda-bool @ ready
        ::false <::F apply ]
      ( :if ) λ ]
    ( ::true ::false ) λ
    : Var,IF ; define
    : IF Var,IF fetch2 Exit ; define-verb

    True <:if
    [ 1 2 3 . . . ] null λ <::true
    [ 7 8 9 . . . ] null λ <::false
      IF @
    @ (* 3 2 1 *) cr

    [ 1 2 3 . . . ] null λ <::true
    [ 7 8 9 . . . ] null λ <::false
      IF @ ready
    True <:if apply (* 3 2 1 *) cr

    [ 7 8 9 . . . ] null λ <::false
    [ 1 2 3 . . . ] null λ <::true
      IF @ ready
    True <:if apply (* 3 2 1 *) cr

    [ 7 8 9 . . . ] null λ <::false
    [ 1 2 3 . . . ] null λ <::true
      IF @ ready
    False <:if apply (* 9 8 7 *) cr

    cr

    (* Y-combinator
       using explicit lazy-eval
       for cicada's semantic is eager-eval
       because lazy-eval is not natural to postfix-notation
     ,*)

    (*
     ,* in λ-cal:
     ,* Y = (λy.(λx.y(xx))(λx.y(xx)))
     ,*
     ,* in daedalus:
     ,* (def Y
     ,*   (λ (y)
     ,*     ((λ (x) (y (x x)))
     ,*      (λ (x) (y (x x))))))
     ,*)

    (* in cicada: *)


    [ [ [ ::x <::x ::x @ ] null λ <::rec ::y @ ]  ( ::x ) λ <::x
      [ [ ::x <::x ::x @ ] null λ <::rec ::y @ ]  ( ::x ) λ @ ]
    ( ::y ) λ
    : Var,Y ; define
    : Y Var,Y fetch2 Exit ; define-verb


    [ [ [ 1 ] null λ <::true
        [ :n :n sub1 <:n ::rec @ @ * ] null λ <::false
         IF @ ready
        :n one? <:if apply ]
      ( :n ) λ ]
    ( ::rec ) λ  <::y  Y @
    : Var,factorial ; define
    : factorial Var,factorial fetch2 Exit ; define-verb

    1 <:n factorial @ .
    2 <:n factorial @ .
    3 <:n factorial @ .
    4 <:n factorial @ .
    5 <:n factorial @ .
    6 <:n factorial @ .
    7 <:n factorial @ .
    8 <:n factorial @ .
    cr

    (* ================================================== *)
    (* TODO the heuristic about Y *)

    [ [ 1 ] null λ <::true
      [ :n :n sub1

          <:n
          [ [ 1 ] null λ <::true
            [ :n :n sub1

            <:n
            [ [ 1 ] null λ <::true
              [ :n :n sub1

                  ,* ]
            null λ <::false
               IF @ ready
              :n one? <:if apply ]
            ( :n ) λ @

                ,* ]
          null λ <::false
             IF @ ready
            :n one? <:if apply ]
          ( :n ) λ @

             ,* ]
       null λ <::false
       IF @ ready
      :n one? <:if apply ]
    ( :n ) λ

    dup2 ready
    1 <:n apply . (* 1 *) cr
    dup2 ready
    2 <:n apply . (* 2 *) cr
    dup2 ready
    3 <:n apply . (* 3 *) cr
    drop2
    cr
    #+end_src
** ><><>< interface for lambda
*** chinese note
    1. 这里 最重要的笔记 是关于如何使用 lambda-calculus
       其实 上面的笔记中 对 lambda-calculus 的实现方式 的解释 都是次要的
       因为只要你理解了 "有向图" 你就理解了一切
       但是
       使用 lambda-calculus 的方式
       即 语言中这个性状的语法
       或 这个程序的这个功能的用户接口
       要想把这一点设计好 才是困难的地方
    2.
*** implementation
    #+begin_src cicada
    [ ::x ]
    ( ::x 3 4 ) λ
    : I ; defineLambda


    : Var,I ; define
    : I Var,I fetch2 Exit ; define-verb


    : defineLambda,byString
      (* [value, type], string[address, length] -- *)

      Exit
    ; define-verb

    : defineLambda,byString
      (* [value, type], word-string[address, number of words] -- *)
      head-of-word-string
      defineLambda,byString
      Exit
    ; define-verb
    #+end_src
* >< editor
** x & k
   - x :: 被读入的text是被结构化地保存的
          显示的时候也可以根据结构高亮
   - x :: 每个命令都是一个 string-processing function
          有一个命令的缓冲区 也就是说并不是每个命令都会马上被执行
          这样在显示方面就要多费些功夫
          显示与命令的执行分离
          命令的执行也通过缓冲区与这些命令作为 string-processing function 的功能分离
          这样整个文本编辑器就是cicada的string-processing的应用了
          只是在cicada的string-processing上面添加了一个函数缓冲还有显示而已
          cicada的string-processing中的函数有两种类型
          一种是副作用类型的
          一种是利用原有的字符串构造新的字符串的(函数式编程范式)
          我将首先只实现函数式的那一种
          也就是说对于一个字符串 插入 删除 替换 等操作都会生成一个全新的字符串
          这也许非常耗费内存 但是其能行性值得被实验一下
          注意
          我必须利用缓冲下来的很多命令来形成一个字符处理函数
          ;-- 这样就需要设计一个"编辑命令"到"字符串处理数"的转换器
          ;-- 然而这样的在两个层次之间做转换的转换器的存在的前提是
          ;-- 必须对两个层次都作出特殊的设计
          因为每个字符处理函数都是要申请很多内存 来保存一行字符的
          这也要求我设计很多新的字符串处理的语法
          还要实现对这些语法的处理
          这是最难的部分
          注意
          另一个重要的 操作是 匹配
          它的函数类型与上面的不同
          注意
          这里可能需要加强cicada对字符串的实现方式
          尤其是需要考虑gc
   - k :: 太好了!
          你已经有一个大致的思路了
          我们可以先假装gc没有问题然后去实现这些想法试试
   - x :: 没错
          我之前说过
          字符串处理 模块系统 文档系统 文本编辑器 都应该被同时设计
          但是现在我明白了
          应该被同时设计的是
          字符串处理 和 文本编辑器
          而 模块系统 文档系统 其实应该与集成开发环境的用户接口一起设计
          模块系统涉及到对命名空间的控制
          当用hash-table来实现find的时候这并不难做到
          模块系统还涉及到 如何定义什么是一个模块
          非常简单 就是一个词的集合而已 其中可以有 任何类型的词
** x & k 2
   - x :: 还有一个重要的需要考虑的问题就是关于文本编辑的数据类型
          我想对于下手实现我还有些犹豫
          就是因为这个数据类型我还没有设计好
   - k :: 这里需要借鉴emacs
          尽管对字符串的处理将是函数式的
          但是对于文本编辑器而言数据类型将以dali和wodili为核心
   - x :: 没错
          现在很多wodili处理函数还没有写好
          在实现文本编辑器的过程中我会完善它们
          我的设计是这样的
          就文本编辑而言核心的数据结构将是被结构化的文本
          每个语言mode都必须实现自己的parser
          [mode] :: string =parser=> structured-string
          类比过去这里类似buffer的数据结构就是structured-string
          每个structured-string都会有附属于它的ScreenBuffer
          将会有附属于structured-string的editing-pointer
          对于每个mode必须还有一个专门用于显示的函数
          structured-string =structure-displayer=> ScreenBuffer
          这个函数还必须处理editing-pointer
          以让它与ScreenBuffer的Cursor对应
   - k :: 这样其实就形成了一个mode的模板
          也许我们应该重新命名这些概念
          不叫mode而叫做structure
          这里的structure其实就是sexp不是吗?
          只不过list被换成了dali
          以适应对文本的副作用
   - x :: 而且我有wodili
          它是专门用来补足sexp不适合用来自定义数据结构这一弱点的
** note
   1. the loop :
      1) read a key (a char)
      2) according to some global variables
         dispatch a key to a function and execute
         the execution of a function
         will edit the datastructure for text
         and  edit the datastructure for display
      3) update display
      4) loop
      so it is a ``REDL''
   2. two datastructures for cicada-editor
      one for text
      one for display
   3. key binding :
      every key can be bound to any function
** string->line-dali
   every mode has its parser
   string->line-dali is the parser of fundamental-mode
   #+begin_src cicada
   : find-char-address
     (* char, [address, length] -- address or -1 *)
     dup zero? if
       drop2 drop
       1 negate
       Exit
     then
     tail-and-head-of-string
     x|over|xxx == if
       drop swap drop
       sub1 Exit
     then
     find-char-address
     Exit
   ; define-verb

   : find-char-index
     (* char, [address, length] -- index or -1 *)
     (* index start from 0 *)
     over
     xxx|swap|x
     find-char-address
     dup 0 < if
       swap drop Exit
     then
     swap -
     Exit
   ; define-verb


   (* little test:
    * 'k' s" k" find-char-index . (\* 0 *\) cr
    * 'k' s" kkk" find-char-index . (\* 0 *\) cr
    * 'k' s" skkk" find-char-index . (\* 1 *\) cr
    * 'k' s"  kkk" find-char-index . (\* 1 *\) cr
    * 'k' s" 0123456789k" find-char-index . (\* 10 *\) cr
    * 'k' s" 0123456789" find-char-index . (\* -1 *\) cr
    *)



   : help:string->line-dali
     (* [address, length] -- head[address, <dali>] *)
     (* LambdaStack:: [address, <dali>] -- *)
     dup zero? if
       get-back
       dup2
         cdr null [cons,cdr]!
         drop2
       head<-dali
       Exit
     then
     dup2
     'linefeed' xx|over|x find-char-index
     dup 0 < if
       (* this means if a string is not end with 'linefeed'
          a 'linefeed' will be added at the end *)
       drop
       dup substring
       xx|tuck|x
       swap copy-byte-string
       <substring>
       cons drop <dali>
       [car,cons]!
         cons null [cons,cdr]!
       [cons,cdr]!
       get-back
       xx|swap|xx
       ^_^
       head<-dali
       Exit
     then
     (* [address, length], index-of-linefeed *)
     x|over|xx over + add1
     xxx|swap|x (* leave the new address *)
     swap over - sub1
     xx|swap|x (* leave the new length *)
     (* [new address, new length], address, index-of-linefeed *)
     dup zero? if
       (* 'linefeed' is the 1st char of the string
          so we meet an empty line, it will be stored as `null' in dali *)
       drop2
       null
     else
       (* index-of-linefeed is just the length of substring *)
       dup substring
       xx|tuck|x
       swap copy-byte-string
       <substring>
     then
     cons drop <dali>
     [car,cons]!
       cons null [cons,cdr]!
     [cons,cdr]!
     get-back
       xx|swap|xx
       ^_^
     ready
     help:string->line-dali
     Exit
   ; define-verb

   : string->line-dali
     (* [address, length] -- head[address, <dali>] *)
     (* which parses a string and return a dali of substring
        one substring denotes one line of text
        empty line is stored as `null' in dali *)
     null ready
     help:string->line-dali
     Exit
   ; define-verb
   #+end_src
** test: string->line-dali
   #+begin_src cicada
   s" kkk" string->line-dali
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr

   s" kkk
   " string->line-dali
   dup2 dali*? . (* 1 *) cr
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr

   s" kkk
   aaa" string->line-dali
   dup2 dali*? . (* 0 *) cr
   dup2
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr
   ->
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* aaa *) cr

   s" kkk
   aaa
   " string->line-dali
   dup2 dali*? . (* 0 *) cr
   dup2
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* kkk *) cr
   ->
   car print-type-tag (* <substring> *) cr
   dup get-length-of-string
   print-string (* aaa *) cr
   #+end_src
** >< reduce text-editing to line-editing
   #+begin_src cicada
   (* buffer: ==
        [address]
      line: ==
        buffer[address, length], cursors[address, <list>]
      where:
        cursor is a zero-based-index, from 0 to length *)


   0 : Var,LineBuffer ; define-variable

   Here fetch Var,LineBuffer save
   1000 Here add-save

   : LineBuffer (*  -- buffer[address] *)
     Var,LineBuffer fetch
     Exit
   ; define-verb


   0 : Var,Tmp,LineBuffer ; define-variable

   Here fetch Var,Tmp,LineBuffer save
   1000 Here add-save

   : Tmp,LineBuffer (*  -- buffer[address] *)
     Var,Tmp,LineBuffer fetch
     Exit
   ; define-verb


   : copyStringToBuffer
     (* string[address, length], buffer[address] --
        buffer[address, length] *)
     push-lambda-stack
     tuck
     pop-lambda-stack dup push-lambda-stack
     swap copy-byte-string
     pop-lambda-stack
     swap
     Exit
   ; define-verb

   : copyStringToLine
     (* string[address, length], buffer[address] --
        buffer[address, length], cursors[address, <list>] *)
     copyStringToBuffer
     cons drop <list>
     0 <fixnum>
     [cons,car]!
     Exit
   ; define-verb


   : line,move-cursor-right
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|over|x car drop (* drop <fixnum> *)
     +  <fixnum> [cons,car]!
     Exit
   ; define-verb

   : line,move-cursor-left
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|over|x car drop (* drop <fixnum> *)
     -  <fixnum> [cons,car]!
     Exit
   ; define-verb

   : line,move-cursor-to-col
     (* buffer[address, length], cursors[address, <list>], index --
        buffer[address, length], cursors[address, <list>] *)
     <fixnum> [cons,car]!
     Exit
   ; define-verb


   (* ><><><
      the following two functions need better factoring *)

   : insertString
     (* string[address, length],
        buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     dup2 ready
     xx|over|xx ready
     car drop (* drop <fixnum> *)
     tuck -
     xx|swap|x +
       dup push-lambda-stack (* address of middle buffer *)
     swap
     Tmp,LineBuffer copyStringToBuffer
     xx|swap|xx
     pop-lambda-stack copyStringToBuffer
       dup push-lambda-stack (* length of string *)
     + copyStringToBuffer
     drop2
     pop-lambda-stack
     get-back x|swap|xx dup push-lambda-stack
     +
     pop-lambda-stack
     get-back
     x|tuck|xx car drop (* <fixnum> *)
     + <fixnum> [cons,car]!
     Exit
   ; define-verb

   (*
    * test:
    * s"  xxx "
    * s"  kkk " LineBuffer copyStringToLine
    * 2 line,move-cursor-right
    * insertString
    * car write (\* 7 *\) cr
    * print-string (\*  k xxx kk  *\) cr
    *)

   : insertChar
     (* char,
        buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     dup2 ready
     xx|over|xx ready
     car drop (* drop <fixnum> *)
     tuck -
     xx|swap|x +
       dup push-lambda-stack (* address of middle buffer *)
     swap
     Tmp,LineBuffer copyStringToBuffer
     x|swap|xx
     pop-lambda-stack tuck save-byte
     add1
     copyStringToBuffer
     drop2
     get-back add1
     get-back dup2 car drop (* <fixnum> *)
     add1 <fixnum> [cons,car]!
     Exit
   ; define-verb


   (*
    * test:
    * 'x'
    * s"  kkk " LineBuffer copyStringToLine
    * 2 line,move-cursor-right
    * insertChar
    * car write (\* 3 *\) cr
    * print-string (\*  kxkk  *\) cr
    *)


   : deleteChars
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|tuck|x
     xx|swap|x dup2 ready
     car drop (* drop <fixnum> *)
     +
     (* buffer[address, length], number, number + cursors *)
     xx|swap|x  -
     (* buffer[address], number + cursors, length - number *)
     x|over|xx swap ready
     (* buffer[address], number + cursors *)
     +
     xx|swap|x

     Exit
   ; define-verb

   : line,kill-line (* erase-half-line-to-end *)
     (* buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     Exit
   ; define-verb







   (*
    * : text,move-cursor-up (\* number -- *\)
    * ; define-verb
    *
    * : text,move-cursor-down (\* number -- *\)
    * ; define-verb
    *
    * : text,move-cursor-down-&-to-the-begin-of-line (\* number -- *\)
    * ; define-verb
    *
    * : text,move-cursor-up-&-to-the-begin-of-line (\* number -- *\)
    * ; define-verb
    *)




   (*
    * : text,move-cursor-to-row (\* row-index -- *\)
    * ; define-verb
    *
    * : text,move-cursor-to-row-&-col (\* row-index, col-index -- *\)
    * ; define-verb
    *)


   (* the position of the cursor
    * is also as an argument of the following functions
    * but the cursor do not move when these functions are executed
    *)



   (*
    * : delete-lines (\* number -- *\)
    * ; define-verb
    *)



   (*
    * : erase-half-screen-to-end (\* -- *\)
    * ; define-verb
    *
    * : erase-half-screen-to-start (\* -- *\)
    * ; define-verb
    *
    * : erase-screen (\* -- *\)
    * ; define-verb
    *)
   #+end_src
** >< tryREDL
   just use the ``read-char''
   #+begin_src cicada
   :" 1234567890"
   : InitString,for-update-display ; define-constant-string

   InitString,for-update-display
   : Var-string,for-update-display ; define


   : update-display
     (*  --  *)
     terminal,clearScreen
     Var-string,for-update-display
     fetch2 print-string cr
     Exit
   ; define-verb


   :" kkk
   : tryREDL (*  --  *)
     setTerminalToReadKey
     help:tryREDL
     Exit
   ; define-verb
   "
   : String-for,kkk ; define-constant-string

   :" kkk" string-hash->index
   : Symbol-index:kkk ; define-constant
   : kkk (*  -- *)
     String-for,kkk
     Var-string,for-update-display
     save2
     Exit
   ; define-verb

   :" aaa

   : help:tryREDL (*  --  *)
     (* D *)
     update-display
     (* R *)
     read-char  (* write-space write-dec-number cr *)
     (* E *)
     char->function-name-symbol
     executeSymbol
     (* L *)
     help:tryREDL
     Exit
   ; define-verb
   "
   : String-for,aaa
   ; define-constant-string

   :" aaa" string-hash->index
   : Symbol-index:aaa ; define-constant
   : aaa (*  -- *)
     String-for,aaa
     Var-string,for-update-display
     save2
     Exit
   ; define-verb



   (* in the future this funciton must see a lot of global variables *)
   : char->function-name-symbol
     (* char -- [index, <symbol>] *)
     dup 'k' == if
       drop Symbol-index:kkk <symbol> Exit
     then
     dup 'a' == if
       drop Symbol-index:aaa <symbol> Exit
     then
     Exit
   ; define-verb


   :" executeSymbol said:
      ``My function-type is (* [index, <symbol>] -- unknown *)
        But I meet the following type
        I will not touch it and call debuger.''
      --> "
   : Message:executeSymbol,type-error ; define-constant-string
   : executeSymbol (* [index, <symbol>] -- unknown *)
     dup <symbol> =/= if
       Message:executeSymbol,type-error print-string
       dup print-type-tag cr
       debuger
       Exit
     then
     drop (* drop <symbol> *)
     index-hashback->string
     execute-word
     Exit
   ; define-verb



   : help:tryREDL (*  --  *)
     (* D *)
     update-display
     (* R *)
     read-char
     (* E *)
     char->function-name-symbol
     executeSymbol
     (* L *)
     help:tryREDL
     Exit
   ; define-verb

   : tryREDL (*  --  *)
     setTerminalToReadKey
     help:tryREDL
     Exit
   ; define-verb

   : t tryREDL Exit ; define-verb
   #+end_src
* misc
** >< memory allocation
*** note
    make good use of lambda
*** implementation (new lexicographers)
    #+begin_src cicada
    constants:
    (StackName),Size (* unit: Cell-width *)
    (StackName),Bottom
    (StackName),Top

    variables:
    (StackName),Pointer

    functions:
    push,(StackName)
    pop,(StackName)
    empty?(StackName)



    : defineStack (*  -- *)
    ; define-verb

    : defineHeap (*  -- *)
    ; define-verb

    : defineArray (*  -- *)
    ; define-verb

    : defineBuffer (*  -- *)
    ; define-verb
    #+end_src
** --------------------------------------
** ok
   for the REPL is actually a REL which does not print
   so I provide a word to check that the cicada is working properly
   #+begin_src cicada
   :" yes"
   : Message:yes ; define-constant-string
   : ok (* -- *)
     Message:yes print-string
     write-space
     Exit
   ; define-verb
   #+end_src
** --------------------------------------
** welcome
   #+begin_src cicada
   :"    welcome to cicada ^_^"
   : Message:welcome ; define-constant-string
   : welcome (* -- *)
     Message:welcome print-string cr
     Exit
   ; define-verb

   cr

   welcome

   cr

   (* report the User-data-area size *)
   ."  the size of User-data-area is: " cr
   write-space
   End-of-user-data-area  User-data-area  -  write-dec-number
   ."  bytes" cr

   write-space
   End-of-user-data-area  Here fetch  -  write-dec-number
   ."  bytes free" cr

   write-space
   Here fetch  User-data-area  -  write-dec-number
   ."  bytes used" cr

   cr

   ."  you are in symbol-REPL
    in this REPL some types of symbol will be processed specially" cr

   cr
   #+end_src
* ==================================================
