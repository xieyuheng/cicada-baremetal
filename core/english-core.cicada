: define-variable,by-string
  (* initial-value, String[address, length] -- *)
  create-word-header
  Variable-explainer append-number-to-here
  swap (* leave wordHeader *)
  append-number-to-here (* the initial-value of Var *)
  add-new-word-to-dictionary
  Exit
; define-function

: define-variable (* byWordList *)
  (* initial-value, WordList[address, the number of words] -- *)
  head-of-word-list
  define-variable,by-string
  Exit
; define-function

: define-constant,by-string
  (* initial-value, WordList[address, the number of words] -- *)
  create-word-header
  Constant-explainer append-number-to-here
  swap (* leave wordHeader *)
  append-number-to-here (* the initial-value of Const *)
  add-new-word-to-dictionary
  Exit
; define-function

: define-constant (* byWordList *)
  (* initial-value, WordList[address, the number of words] -- *)
  head-of-word-list
  define-constant,by-string
  Exit
; define-function
: /mod (* a, b -- quotient, a mod b *)
  mod/ swap
  Exit
; define-function

: / (* a, b -- quotient *)
  /mod drop
  Exit
; define-function

: mod (* a, b -- a mod b *)
  mod/ drop
  Exit
; define-function
9   : 'tab'      ; define-constant
10  : 'linefeed' ; define-constant
10  : 'newline'  ; define-constant
27  : 'esc'      ; define-constant
27  : 'escape'   ; define-constant
32  : 'space'    ; define-constant
127 : 'delete'   ; define-constant

33 : '!' ; define-constant
34 : '"' ; define-constant
35 : '#' ; define-constant
36 : '$' ; define-constant
37 : '%' ; define-constant
38 : '&' ; define-constant
39 : ''' ; define-constant
40 : '(' ; define-constant
41 : ')' ; define-constant
42 : '*' ; define-constant
43 : '+' ; define-constant
44 : ',' ; define-constant
45 : '-' ; define-constant
46 : '.' ; define-constant
47 : '/' ; define-constant

48 : '0' ; define-constant
49 : '1' ; define-constant
50 : '2' ; define-constant
51 : '3' ; define-constant
52 : '4' ; define-constant
53 : '5' ; define-constant
54 : '6' ; define-constant
55 : '7' ; define-constant
56 : '8' ; define-constant
57 : '9' ; define-constant

58 : ':' ; define-constant
59 : ';' ; define-constant
60 : '<' ; define-constant
61 : '=' ; define-constant
62 : '>' ; define-constant
63 : '?' ; define-constant
64 : '@' ; define-constant

65 : 'A' ; define-constant
66 : 'B' ; define-constant
67 : 'C' ; define-constant
68 : 'D' ; define-constant
69 : 'E' ; define-constant
70 : 'F' ; define-constant
71 : 'G' ; define-constant
72 : 'H' ; define-constant
73 : 'I' ; define-constant
74 : 'J' ; define-constant
75 : 'K' ; define-constant
76 : 'L' ; define-constant
77 : 'M' ; define-constant
78 : 'N' ; define-constant
79 : 'O' ; define-constant
80 : 'P' ; define-constant
81 : 'Q' ; define-constant
82 : 'R' ; define-constant
83 : 'S' ; define-constant
84 : 'T' ; define-constant
85 : 'U' ; define-constant
86 : 'V' ; define-constant
87 : 'W' ; define-constant
88 : 'X' ; define-constant
89 : 'Y' ; define-constant
90 : 'Z' ; define-constant

91 : '[' ; define-constant
92 : '\' ; define-constant
93 : ']' ; define-constant
94 : '^' ; define-constant
95 : '_' ; define-constant
96 : '`' ; define-constant

97  : 'a' ; define-constant
98  : 'b' ; define-constant
99  : 'c' ; define-constant
100 : 'd' ; define-constant
101 : 'e' ; define-constant
102 : 'f' ; define-constant
103 : 'g' ; define-constant
104 : 'h' ; define-constant
105 : 'i' ; define-constant
106 : 'j' ; define-constant
107 : 'k' ; define-constant
108 : 'l' ; define-constant
109 : 'm' ; define-constant
110 : 'n' ; define-constant
111 : 'o' ; define-constant
112 : 'p' ; define-constant
113 : 'q' ; define-constant
114 : 'r' ; define-constant
115 : 's' ; define-constant
116 : 't' ; define-constant
117 : 'u' ; define-constant
118 : 'v' ; define-constant
119 : 'w' ; define-constant
120 : 'x' ; define-constant
121 : 'y' ; define-constant
122 : 'z' ; define-constant

123 : '{' ; define-constant
124 : '|' ; define-constant
125 : '}' ; define-constant
126 : '~' ; define-constant
: :" (* -- string[address of Basic-string-buffer, length] *)
  read-string-into-buffer
  Exit
; define-function

: ." (* -- string[address of Basic-string-buffer, length] *)
  read-string-into-buffer print-string
  Exit
; define-function

: define-constant-string,by-string
  (* initial-string[address, length],
     string[address, length], the number of words] -- *)
  create-word-header
  Constant-string-explainer append-number-to-here
  xx|swap|x (* leave wordHeader *)
  append-string-to-here (* initial-string *)
  add-new-word-to-dictionary
  Exit
; define-function

: define-constant-string (* byWordList *)
  (* string[address, length],
     wordList[address, the number of words] -- *)
  head-of-word-list
  define-constant-string,by-string
  Exit
; define-function
(* the following is a basic function
   that allow you to define recursive function with tail call optimization *)
: define-recursive-function
  (* wordList[address, the number of words] -- *)
  tail-and-head-of-word-list
  create-word-header-for-function
  set-size-of-function-body
  add-new-word-to-dictionary
  Function-body-explainer append-number-to-here
  append-word-description-to-here
  Exit
; define-function

:" if"    : Key-word:if   ; define-constant-string
:" else"  : Key-word:else ; define-constant-string
:" then"  : Key-word:then ; define-constant-string

(* the following is an old function
   direct literal number is not handled
   it is no big deal, for this function is only used once *)

: append-word-description-to-here,with-if&then
  (* wordList[address, the number of words] -- *)
  dup zero? false?branch 3
    drop2 Exit

  tail-and-head-of-word-list

  dup2 Key-word:if equal-string? false?branch 12
    drop2
    literal false?branch append-number-to-here
    Here fetch xx|swap|x
    Zero append-number-to-here (* leave a place *)
    append-word-description-to-here,with-if&then Exit

  dup2 Key-word:then equal-string? false?branch 13
    drop2
    x|swap|xx
    Here fetch over -  Cell-width /
    swap save
    append-word-description-to-here,with-if&then Exit

  dup2 string-denote-integer? false?branch 6
    string->integer,with-error drop append-number-to-here
    append-word-description-to-here,with-if&then Exit

    find word-link->word-explainer append-number-to-here
    append-word-description-to-here,with-if&then Exit
; define-recursive-function

: define-recursive-function,with-if&then
  (* wordList[address, the number of words] -- *)
  tail-and-head-of-word-list
  create-word-header-for-function
  set-size-of-function-body
  add-new-word-to-dictionary
  Function-body-explainer append-number-to-here
  append-word-description-to-here,with-if&then
  Exit
; define-function


(* redefine append-word-description-to-here add "else"
   this also can be viewed as a basic test of new implemented "if&then"
   and this time, I use Lambda-stack *)

: help:append-word-description-to-here,if
  (* string if [address, length] -- *)
  drop2
  literal false?branch append-number-to-here
  Here fetch xx|swap|x
  Zero append-number-to-here (* leave a place *)
  Exit
; define-function

: help:append-word-description-to-here,else
  (* string else [address, length] -- *)
  drop2
  literal branch append-number-to-here
  Here fetch xxx|swap|x
  Zero append-number-to-here (* leave a place *)
  x|swap|xx
  Here fetch over -  Cell-width /
  swap save
  Exit
; define-function

: help:append-word-description-to-here,then
  (* string then [address, length] -- *)
  drop2
  x|swap|xx
  Here fetch over -  Cell-width /
  swap save
  Exit
; define-function

: append-word-description-to-here
  (* wordList[address, the number of words] -- *)
  dup zero? if
    drop2
    Exit
  then
  tail-and-head-of-word-list
  dup2 Key-word:if equal-string? if
    help:append-word-description-to-here,if
    append-word-description-to-here
    Exit
  then
  dup2 Key-word:else equal-string? if
    help:append-word-description-to-here,else
    append-word-description-to-here
    Exit
  then
  dup2 Key-word:then equal-string? if
    help:append-word-description-to-here,then
    append-word-description-to-here
    Exit
  then
  dup2 string-denote-literal-or-branch? if
    help:append-word-description-to-here,literal&branch
    append-word-description-to-here
    Exit
  then
  dup2 string-denote-integer? if
    help:append-word-description-to-here,number
    append-word-description-to-here
    Exit
  then
  help:append-word-description-to-here,word
  append-word-description-to-here
  Exit
; define-recursive-function,with-if&then


(* redefine define-recursive-function & define-function *)

: define-function
  (* wordList[address, the number of words] -- *)
  tail-and-head-of-word-list
  create-word-header-for-function
  set-size-of-function-body
  xx|swap|x
  Function-body-explainer append-number-to-here
  append-word-description-to-here
  add-new-word-to-dictionary
  Exit
; define-function

: define-recursive-function
  (* wordList[address, the number of words] -- *)
  tail-and-head-of-word-list
  create-word-header-for-function
  set-size-of-function-body
  add-new-word-to-dictionary
  Function-body-explainer append-number-to-here
  append-word-description-to-here
  Exit
; define-function
: special-key-word? (* word[explainer] -- True or False *)
  dup literal literal           == if drop True Exit then
  dup literal branch            == if drop True Exit then
  dup literal zero?branch       == if drop True Exit then
  dup literal false?branch      == if drop True Exit then
  drop False
  Exit
; define-function
: write-dec-number-char (* byte -- *)
  '0' + write-char
  Exit
; define-function

: help:write-dec-number,push-chars
  (* ... , number of small DecNumbers, fixnum --
     ... , number of small DecNumbers *)
  10 mod/
  dup zero? if
    drop swap add1 Exit
  then
  xx|swap|x xx|swap|x add1 swap
  help:write-dec-number,push-chars
  Exit
; define-recursive-function

: help:write-dec-number,write-chars
  (* ... , number of small DecNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-dec-number-char
  help:write-dec-number,write-chars
  Exit
; define-recursive-function


: write-dec-number,unsign (* fixnum -- *)
  Zero swap
  help:write-dec-number,push-chars
  help:write-dec-number,write-chars
  Exit
; define-function

: write-dec-number,sign (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-dec-number,unsign
  Exit
; define-function

: write-dec-number
  write-dec-number,sign
  Exit
; define-function
: write-bin-number-char (* byte -- *)
  '0' + write-char
  Exit
; define-function

: help:write-bin-number,push-chars
  (* ... , number of small BinNumbers, fixnum --
     ... , number of small BinNumbers *)
  2 mod/
  dup zero? if
    drop swap add1 Exit
  then
  xx|swap|x xx|swap|x add1 swap
  help:write-bin-number,push-chars
  Exit
; define-recursive-function

: help:write-bin-number,write-chars
  (* ... , number of small BinNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-bin-number-char
  help:write-bin-number,write-chars
  Exit
; define-recursive-function

: write-bin-number,unsign (* fixnum -- *)
  Zero swap
  help:write-bin-number,push-chars
  help:write-bin-number,write-chars
  Exit
; define-function

: write-bin-number,sign (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-bin-number,unsign
  Exit
; define-function

: write-bin-number
  write-bin-number,sign
  Exit
; define-function
: write-oct-number-char (* byte -- *)
  '0' + write-char
  Exit
; define-function

: help:write-oct-number,push-chars
  (* ... , number of small OctNumbers, fixnum --
     ... , number of small OctNumbers *)
  8 mod/
  dup zero? if
    drop swap add1 Exit
  then
  xx|swap|x xx|swap|x add1 swap
  help:write-oct-number,push-chars
  Exit
; define-recursive-function

: help:write-oct-number,write-chars
  (* ... , number of small OctNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-oct-number-char
  help:write-oct-number,write-chars
  Exit
; define-recursive-function

: write-oct-number,unsign (* fixnum -- *)
  Zero swap
  help:write-oct-number,push-chars
  help:write-oct-number,write-chars
  Exit
; define-function

: write-oct-number,sign (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-oct-number,unsign
  Exit
; define-function

: write-oct-number
  write-oct-number,sign
  Exit
; define-function
: write-hex-number-char (* byte -- *)
  dup Ten < if
    '0' + write-char Exit
  then
  Ten -
  'a' + write-char
  Exit
; define-function

: write-hex-number-char,capital (* byte -- *)
  dup Ten < if
    '0' + write-char Exit
  then
  Ten -
  'A' + write-char
  Exit
; define-function

: help:write-hex-number,push-chars
  (* ... , number of small HexNumbers, fixnum --
     ... , number of small HexNumbers *)
  16 mod/
  dup zero? if
    drop swap add1 Exit
  then
  xx|swap|x xx|swap|x add1 swap
  help:write-hex-number,push-chars
  Exit
; define-recursive-function

: help:write-hex-number,write-chars
  (* ... , number of small HexNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-hex-number-char
  help:write-hex-number,write-chars
  Exit
; define-recursive-function

: help:write-hex-number,write-chars,capital
  (* ... , number of small HexNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-hex-number-char,capital
  help:write-hex-number,write-chars,capital
  Exit
; define-recursive-function

: write-hex-number,unsign (* fixnum -- *)
  Zero swap
  help:write-hex-number,push-chars
  help:write-hex-number,write-chars
  Exit
; define-function

: write-hex-number,capital (* fixnum -- *)
  Zero swap
  help:write-hex-number,push-chars
  help:write-hex-number,write-chars,capital
  Exit
; define-function

: write-hex-number,sign (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-hex-number,unsign
  Exit
; define-function

: write-hex-number,sign,capital (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-hex-number,capital
  Exit
; define-function

: write-hex-number
  write-hex-number,sign
  Exit
; define-function
: write-aph-number-char (* byte -- *)
  dup Ten < if
    '0' + write-char Exit
  then
  Ten -
  'a' + write-char
  Exit
; define-function

: write-aph-number-char,capital (* byte -- *)
  dup Ten < if
    '0' + write-char Exit
  then
  Ten -
  'A' + write-char
  Exit
; define-function

: help:write-aph-number,push-chars
  (* ... , number of small AphNumbers, fixnum --
     ... , number of small AphNumbers *)
  36 mod/
  dup zero? if
    drop swap add1 Exit
  then
  xx|swap|x xx|swap|x add1 swap
  help:write-aph-number,push-chars
  Exit
; define-recursive-function

: help:write-aph-number,write-chars
  (* ... , number of small AphNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-aph-number-char
  help:write-aph-number,write-chars
  Exit
; define-recursive-function

: help:write-aph-number,write-chars,capital
  (* ... , number of small AphNumbers -- *)
  dup zero? if drop Exit
  then
  sub1 swap write-aph-number-char,capital
  help:write-aph-number,write-chars,capital
  Exit
; define-recursive-function

: write-aph-number,unsign (* fixnum -- *)
  Zero swap
  help:write-aph-number,push-chars
  help:write-aph-number,write-chars
  Exit
; define-function

: write-aph-number,capital (* fixnum -- *)
  Zero swap
  help:write-aph-number,push-chars
  help:write-aph-number,write-chars,capital
  Exit
; define-function

: write-aph-number,sign (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-aph-number,unsign
  Exit
; define-function

: write-aph-number,sign,capital (* fixnum -- *)
  dup Zero < if
    '-' write-char
    negate
  then
  write-aph-number,capital
  Exit
; define-function

: write-aph-number
  write-aph-number,sign
  Exit
; define-function
: .unsign (* fixnum -- *)
  write-dec-number
  'space' write-char
  Exit
; define-function

: .sign (* fixnum -- *)
  write-dec-number,sign
  'space' write-char
  Exit
; define-function


: . .sign Exit ; define-function


: .bin (* fixnum -- *)
  write-bin-number
  'space' write-char
  Exit
; define-function

: .bin,sign (* fixnum -- *)
  write-bin-number,sign
  'space' write-char
  Exit
; define-function

: .oct (* fixnum -- *)
  write-oct-number
  'space' write-char
  Exit
; define-function

: .oct,sign (* fixnum -- *)
  write-oct-number,sign
  'space' write-char
  Exit
; define-function

: .hex (* fixnum -- *)
  write-hex-number
  'space' write-char
  Exit
; define-function

: .hex,sign (* fixnum -- *)
  write-hex-number,sign
  'space' write-char
  Exit
; define-function

: .hex,capital (* fixnum -- *)
  write-hex-number,capital
  'space' write-char
  Exit
; define-function

: .hex,sign,capital (* fixnum -- *)
  write-hex-number,sign,capital
  'space' write-char
  Exit
; define-function


: .aph (* fixnum -- *)
  write-aph-number
  'space' write-char
  Exit
; define-function

: .aph,sign (* fixnum -- *)
  write-aph-number,sign
  'space' write-char
  Exit
; define-function

: .aph,capital (* fixnum -- *)
  write-aph-number,capital
  'space' write-char
  Exit
; define-function

: .aph,sign,capital (* fixnum -- *)
  write-aph-number,sign,capital
  'space' write-char
  Exit
; define-function

: cr (* -- *)
  'newline' write-char Exit
; define-function


: write-space (* -- *)
  'space' write-char Exit
; define-function

: write-some-space (* n -- *)
  dup zero? if
    drop Exit
  then
  sub1
  write-space
  write-some-space
  Exit
; define-recursive-function
: print-string,null-terminated
  (* null-terminated-string[address] -- *)
  dup fetch-byte zero? if
    drop
    Exit
  then
  dup fetch-byte write-char
  add1
  print-string,null-terminated
  Exit
; define-recursive-function
: count-return-stack (* -- the length of ReturnStack *)
  Return-stack-top fetch-return-stack-pointer -
  Eight /
  sub1 (* for we are in this function call *)
  Exit
; define-function

: count-argument-stack (* -- the length of ArgumentStack *)
  Argument-stack-top fetch-argument-stack-pointer -
  Eight /
  Exit
; define-function


0 : Return-stack-position   ; define-variable
0 : Argument-stack-position ; define-variable

(* the following two function are as interface *)
: debuger,fetch-from-return-stack (* n -- *)
  sub1 Eight *
  Return-stack-position fetch +
  fetch
  Exit
; define-function

: debuger,fetch-from-argument-stack (* n -- *)
  sub1 Eight *
  Argument-stack-position fetch +
  fetch
  Exit
; define-function


:" bye"
: Message:bye ; define-constant-string

: execute-word (* string[address, length] -- unknown *)
  dup2
  string-denote-integer? if
    string->integer,with-error drop
    Exit
  then
  dup2 find dup not-zero? if
    xx|swap|x drop2
    word-link->word-explainer execute
    Exit
  then
  drop
  Message:undefined-word print-string
  print-string cr
  Exit
; define-function

: debuger-REPL (* unknown -- unknown *)
  read-word-for-runtime
  dup2
  Message:bye equal-string? if
    drop2
    Exit
  then
  execute-word
  debuger-REPL
  Exit
; define-recursive-function

:" debuger said: ``Welcome! Hope you find what's wrong.''"
: Message:debuger,welcome ; define-constant-string

:" the length of Return-stack is: "
: Message:debuger,the-length-of-returnstack ; define-constant-string

:" the length of Argument-stack is: "
: Message:debuger,the-length-of-argument-stack ; define-constant-string

:" debuger said: ``Good bye! The computation will go on!''"
: Message:debuger,goodbye ; define-constant-string

: debuger (* unknown -- unknown *)
  Message:debuger,welcome print-string cr
  Three write-some-space Message:debuger,the-length-of-returnstack print-string
    count-return-stack write-dec-number cr
  Three write-some-space Message:debuger,the-length-of-argument-stack print-string
    count-argument-stack write-dec-number cr
  fetch-return-stack-pointer Return-stack-position save
  fetch-argument-stack-pointer Argument-stack-position save
  Input-buffer Current-reading save
  Input-buffer Reading-boundary save
  debuger-REPL
  Message:debuger,goodbye print-string cr
  Exit
; define-function

(* ><><>< bug ><><>< *)
(* ``1 fetch'' will cause core dump *)
: identification-of-word? (* an address in a word -- *)
  dup fetch ==
  Exit
; define-function

(* ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 * || m(bytes) : name-string  ||
 * ||  1 : size of function body  ||
 * ||  1 : identification  ||
 * ||  1 : link  ||
 * ||  1 : type  ||
 * ||  1 : address-of-name-string-header  ||
 * ||  1 : address-of-explainer  ||
 * ||  n : body  ||
 *)

: word,body->id
  (* [an address of a cell in a word] -- word[identification] *)
  dup
  identification-of-word? if
    Exit
  then
  Cell-width -
  word,body->id
  Exit
; define-recursive-function

: word,id->name
  (* word[identification] -- string[address, length] *)
  Cell-width Three * +
  fetch dup
  add8 swap
  fetch
  Exit
; define-function

: word,id->explainer
  (* word[identification] -- explainer *)
  Cell-width Four * +
  fetch
  Exit
; define-function

: word,id->body-size
  (* word[identification] -- body-size *)
  Cell-width -
  fetch
  Exit
; define-function

: word,id->body-list
  (* word[identification] -- body-list[address, length] *)
  dup
    Cell-width Five * +
  swap
  word,id->body-size
  Exit
; define-function

: print-name-of-explainer (* explainer -- *)
  dup Function-body-explainer == if
    literal Function-body-explainer
    word,body->id
    word,id->name
    print-string
    drop Exit
  then
  dup Variable-explainer == if
    literal Variable-explainer
    word,body->id
    word,id->name
    print-string
    drop Exit
  then
  dup Constant-explainer == if
    literal Constant-explainer
    word,body->id
    word,id->name
    print-string
    drop Exit
  then
  dup Constant-string-explainer == if
    literal Constant-string-explainer
    word,body->id
    word,id->name
    print-string
    drop Exit
  then
  drop
  Exit
; define-function

: print-function-body-list (* body-list[address, length] -- *)
  dup zero? if
    drop2 Exit
  then
  Six write-some-space
  over fetch word,body->id word,id->name print-string cr
  sub1 swap
  Cell-width + swap
  print-function-body-list
  Exit
; define-recursive-function

:"  -->  "
: Message:_-->__ ; define-constant-string

(* the following function is the first function
   on which I must use ``if,else,then'' *)
: with-pointer,print-function-body-list
  (* [an address of a cell in a word], body-list[address, length] -- *)
  dup zero? if
    drop2 drop Exit
  then
  x|over|xx x|over|xx == if
    Message:_-->__ print-string
  else
    Six write-some-space
  then
  over
  dup fetch special-key-word? if
    fetch word,body->id word,id->name print-string cr
    sub2 swap
    dup
    Six write-some-space
    Cell-width + fetch write-dec-number cr
    Cell-width Two * + swap
    with-pointer,print-function-body-list
    Exit
  then
  fetch word,body->id word,id->name print-string cr
  sub1 swap
  Cell-width + swap
  with-pointer,print-function-body-list
  Exit
; define-recursive-function


:" trace-function said: ``Ya! Let's trace a function!''"
: Message:trace-function,welcome ; define-constant-string

:" The function we use to trace is:"
: Message:trace-function,function-to-trace ; define-constant-string

:" The function be traced to is:"
: Message:trace-function,function-be-traced-to ; define-constant-string

:" The size of the body of this function is:"
: Message:trace-function,function-body-size ; define-constant-string

:" The body of this function is:"
: Message:trace-function,function-body ; define-constant-string

:" trace-function said: ``The end of a tracing.''"
: Message:trace-function,goodbye ; define-constant-string

: trace-function
  (* [an address of a cell in a word] -- *)
  Message:trace-function,welcome print-string cr
  dup
    Three write-some-space Message:trace-function,function-to-trace print-string cr
    Six write-some-space fetch word,body->id word,id->name print-string cr
  dup (* with-pointer,print-function-body-list still uses original arg *)
  word,body->id
    dup
      Three write-some-space Message:trace-function,function-be-traced-to print-string cr
      Six write-some-space word,id->name print-string cr
    dup
      Three write-some-space Message:trace-function,function-body-size print-string cr
      Six write-some-space word,id->body-size write-dec-number cr
    Three write-some-space Message:trace-function,function-body print-string cr
    word,id->body-list with-pointer,print-function-body-list
  Message:trace-function,goodbye print-string cr
  Exit
; define-function
: trace (* n -- *)
  debuger,fetch-from-return-stack
  trace-function
  Exit
; define-function
: print-word-list (* WordList[address, the number of words] -- *)
  dup zero? if
    drop2
    cr Exit
  then
  Three write-some-space
  tail-and-head-of-word-list print-string cr
  print-word-list
  Exit
; define-recursive-function


:" an error occurs!
append-word-description-to-here said:
   ``I am a tail-recursive-function.
     My function-type is (* WordList[address, the number of words] -- *)
     `define-recursive-function' and `define-function' call me.
     The following word is undefined.
     I will print the rest of the Word-list and call debuger.''
   --> "
: Message:append-word-description-to-here,meet-undefined-word
; define-constant-string

:" The length of the rest of the Word-list is: "
: Message:append-word-description-to-here,length-of-the-rest-of-the-word-list
; define-constant-string

:" The rest of the Word-list is: "
: Message:append-word-description-to-here,the-rest-of-the-word-list
; define-constant-string


: append-word-description-to-here
  (* WordList[address, the number of words] -- *)
  dup zero? if
    drop2
    Exit
  then
  tail-and-head-of-word-list
  dup2 Key-word:if equal-string? if
    help:append-word-description-to-here,if
    append-word-description-to-here
    Exit
  then
  dup2 Key-word:else equal-string? if
    help:append-word-description-to-here,else
    append-word-description-to-here
    Exit
  then
  dup2 Key-word:then equal-string? if
    help:append-word-description-to-here,then
    append-word-description-to-here
    Exit
  then
  dup2 string-denote-literal-or-branch? if
    help:append-word-description-to-here,literal&branch
    append-word-description-to-here
    Exit
  then
  dup2 string-denote-integer? if
    help:append-word-description-to-here,number
    append-word-description-to-here
    Exit
  then
  dup2 find dup not-zero? if
    word-link->word-explainer append-number-to-here
    drop2 (* drop the string[address, length], which is for debuger *)
    append-word-description-to-here
    Exit
  then
  drop (* drop the Zero *)
  Message:append-word-description-to-here,meet-undefined-word print-string
  print-string cr
  Message:append-word-description-to-here,length-of-the-rest-of-the-word-list
  print-string dup write-dec-number cr
  Message:append-word-description-to-here,the-rest-of-the-word-list print-string cr
  print-word-list
  debuger
  Exit
; define-recursive-function


: define-function
  (* wordList[address, the number of words] -- *)
  tail-and-head-of-word-list
  create-word-header-for-function
  set-size-of-function-body
  xx|swap|x
  Function-body-explainer append-number-to-here
  append-word-description-to-here
  add-new-word-to-dictionary
  Exit
; define-function

: define-recursive-function
  (* wordList[address, the number of words] -- *)
  tail-and-head-of-word-list
  create-word-header-for-function
  set-size-of-function-body
  add-new-word-to-dictionary
  Function-body-explainer append-number-to-here
  append-word-description-to-here
  Exit
; define-function

(*
 * (\* wordy version for testing *\)
 * : define-function
 *   (\* wordList[address, the number of words] -- *\)
 *   tail-and-head-of-word-list
 *     dup2 print-string
 *     'newline' write-char
 *   create-word-header-for-function
 *   set-size-of-function-body
 *   xx|swap|x
 *   Function-body-explainer append-number-to-here
 *   append-word-description-to-here
 *   add-new-word-to-dictionary
 *   Exit
 * ; define-function
 *
 * : define-recursive-function
 *   (\* wordList[address, the number of words] -- *\)
 *   tail-and-head-of-word-list
 *     dup2 print-string
 *     'newline' write-char
 *   create-word-header-for-function
 *   set-size-of-function-body
 *   add-new-word-to-dictionary
 *   Function-body-explainer append-number-to-here
 *   append-word-description-to-here
 *   Exit
 * ; define-function
 *)
(* a Symbol-entry [unit : byte]
 * ==========================
 *  ||   8 : Symbol-value   ||
 * --------------------------
 *  ||   1 : Symbol-length  ||
 * --------------------------
 *  || 56+ : Symbol-string  ||
 * ==========================
 * where Symbol-max-length = 56 *)

:" an error occurs!
index->address said:
   ``My function-type is (* index -- address *)
     The following unsign-number is not a index of the hash-table
     I will not touch it and call debuger.''
   --> "
: Message:index->address,error ; define-constant-string

: index->address (* index -- address *)
  dup Number-of-symbol-entrys >= if
    Message:index->address,error print-string
    dup write-dec-number cr
    debuger Exit
  then
  dup Zero < if
    Message:index->address,error print-string
    dup write-dec-number cr
    debuger Exit
  then
  Symbol-entry-bytes-size *
  First-symbol-entry +
  Exit
; define-function

: index-hashback->string
  (* index -- string[address, length] *)
  index->address Eight +
  dup add1 swap
  fetch-byte
  Exit
; define-function


: help:string-hash->index,sum-up
  (* sum-up , string[address, length] -- sum-up *)
  dup zero? if
    drop2 Exit
  then
  tail-and-head-of-string
  over shift-left
  x|swap|xxx  +  xx|swap|x
  help:string-hash->index,sum-up
  Exit
; define-recursive-function

: help:string-hash->index,find-old-or-creat-new
  (* string[address, length], index -- index *)
  xx|tuck|x
  index-hashback->string
  (* index, string[address, length], string-2[address, length] *)
  dup zero? if  (* creat-new *)
    drop
    (* index, string[address, length], destination-address *)
    over over
    (* index, string[address, length], destination-address, length, address *)
    sub1 save-byte
    swap
    (* index,, source-address, destination-address, length *)
    copy-byte-string
    Exit
  then
  (* index, string[address, length], string-2[address, length] *)
  xx|over|xx equal-string? if (* found old *)
    drop2 Exit
  then
  x|swap|xx (* to get next-index *)
  (* string[address, length], index *)
  dup index->address Last-symbol-entry == if
    drop
    Zero
    help:string-hash->index,find-old-or-creat-new
    Exit
  then
  add1
  help:string-hash->index,find-old-or-creat-new
  Exit
; define-recursive-function

: help:string-hash->index,sum-up->index
  (* sum-up -- index *)
  Number-of-symbol-entrys mod
  Exit
; define-function

: string-hash->index
  (* string[address, length] -- index *)
  dup2
    dup Symbol-max-length > if
      drop Symbol-max-length
      (* this means only first Symbol-max-length of the string is used by the hash-function *)
    then
    Zero xx|swap|x
    help:string-hash->index,sum-up
    help:string-hash->index,sum-up->index
  help:string-hash->index,find-old-or-creat-new
  Exit
; define-function
(* if 1 is setted to a symbol, this symbol is a fixnum like data type
   if 2 is setted to a symbol, this symbol is a pair like data type *)

: define-data-type
  (* wordList[address, the number of words] -- *)
  dup2
    head-of-word-list
    string-hash->index
    dup
      index->address One swap save
    xx|swap|x
  define-constant
  Exit
; define-function

: define-pair-like-data-type
  (* wordList[address, the number of words] -- *)
  dup2
    head-of-word-list
    string-hash->index
    dup
      index->address Two swap save
    xx|swap|x
  define-constant
  Exit
; define-function


(* every word can be used as a name of a data type
   the following are my convention *)

: <fixnum>    ; define-data-type
: <bool>      ; define-data-type
: <type>      ; define-data-type
: <char>      ; define-data-type
: <symbol>    ; define-data-type
: <substring> ; define-data-type
: <null>      ; define-data-type


: <fixnum-like>? (* type -- True or False *)
    index->address fetch One ==
    Exit
; define-function


0 : Null ; define-constant

: null Null <null> Exit ; define-function

: null? (* [value, type] -- True or False *)
  <null> == if
    Null == if
      True Exit
    then
    False Exit
  then
  drop False Exit
; define-function




: True-Bool  True  <bool> Exit ; define-function
: False-Bool False <bool> Exit ; define-function



: <pair>    ; define-pair-like-data-type
: <string>  ; define-pair-like-data-type
: <list>    ; define-pair-like-data-type

: <dali>   ; define-pair-like-data-type

: <wodi>           ; define-pair-like-data-type
: <bound-variable> ; define-pair-like-data-type
: <wodili>         ; define-pair-like-data-type


: <pair-like>? (* type -- True or False *)
    index->address fetch Two ==
    Exit
; define-function

: <not-pair-like>? (* type -- True or False *)
    index->address fetch Two =/=
    Exit
; define-function


: <dali-like>? (* type -- True or False *)
  dup <dali> == if
    drop True Exit
  then
  dup <wodili> == if
    drop True Exit
  then
  drop False Exit
; define-function


: <not-dali-like>? (* type -- True or False *)
  dup <dali> == if
    drop False Exit
  then
  dup <wodili> == if
    drop False Exit
  then
  drop True Exit
; define-function




:" an error occurs!
print-type-tag said:
   ``My function-type is (* type-tag[index of hash-table] -- *)
     The following index is not a type-tag
     I will not touch it and call debuger.''
   --> "
: Message:print-type-tag,error ; define-constant-string

: print-type-tag
  (* type-tag[index of hash-table] -- *)
  dup
  index->address fetch One == if
    index-hashback->string print-string Exit
  then
  dup
  index->address fetch Two == if
    index-hashback->string print-string Exit
  then
  Message:print-type-tag,error print-string
  write-dec-number cr
  debuger Exit
; define-function


: eq? (* [value, type], [value, type] -- True or False *)
  x|over|xx =/= if
    drop drop2 False Exit
  then
  x|over|xx =/= if
    drop2 False Exit
  then
  drop2 True Exit
; define-function
(*
 * a word in the dictionary [unit : Cell-width = 8 bytes]
 *   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 *   ||  m : name-string  ||
 *   ||  1 : SizeOfFunctionBody ||
 *   ||  1 : identification  ||
 *   ||  1 : link  ||
 *   ||  1 : type  ||
 *   ||  1 : address-of-name-string-header  ||
 *   ||  1 : address-of-explainer  ||
 *   ||  n : body  ||
 * where
 *   ||  1 : type  ||
 * ==
 *   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
 * type-bit-0 is for HiddenWord
 * type-bit-1 is for VariableOfTypedValue [DynamicVar]
 *)

: last-word-in-dictionary? (* word[address of link] -- True or False *)
    zero? Exit
; define-function

: next-word-in-dictionary
  (* word[address of link] -- next-word[address of link] *)
    fetch Exit
; define-function

: fetch-word-type (* word[address of link] -- WordType *)
    add8 fetch
    Exit
; define-function

: save-word-type (* word[address of link], WordType -- *)
    swap add8 save
    Exit
; define-function


0 : Offset-for-hidden-word          ; define-constant
1 : Offset-for-dynamic-variable-word ; define-constant

: dynamic-variable-word? (* word[address of link] -- True or False *)
    fetch-word-type Offset-for-dynamic-variable-word fetch-bit one?
    Exit
; define-function
(* example of a substring stored in string-heap :
   || 4 : length of substring  ||
   || n : substring  ||
 *)

String-heap-1 : Pointer:String-heap,from ; define-variable
String-heap-2 : Pointer:string-heap,to   ; define-variable

String-heap-1 : Current-free-string-address,from ; define-variable
String-heap-2 : Current-free-string-address,to   ; define-variable



(*
 * : fetch-four-bytes (\* address -- value *\)
 *   Zero fetch-argument-stack-pointer
 *   x|over|xx swap
 *   Four copy-byte-string
 *   swap drop
 *   Exit
 * ; define-function
 *
 * : save-four-bytes (\* value, address -- *\)
 *   swap fetch-argument-stack-pointer
 *   x|over|xx
 *   Four copy-byte-string
 *   drop2
 *   Exit
 * ; define-function
 *)



: get-length-of-string (* string[address] -- length *)
  sub4 fetch-four-bytes
  Exit
; define-function

: string-in?string-heap,from (* string[address] -- True or False *)
  Pointer:String-heap,from fetch
  over over
  Size-of-string-heap +  <
  xx|swap|x  >=
  bitwise-and
  Exit
; define-function

: string-in?string-heap,to (* string[address] -- True or False *)
  Pointer:string-heap,to fetch
  over over
  Size-of-string-heap +  <
  xx|swap|x  >=
  bitwise-and
  Exit
; define-function

: with-length,copy-byte-string
  (* source address, destination address, length -- *)
  dup x|over|xx save-four-bytes
  swap add4 swap
  copy-byte-string
  Exit
; define-function

: try,copy-substring,from->to
  (* [address, <substring>] -- [address, <substring>] *)
  (*
   * dup <substring> =/= if
   *   Exit
   * then
   *)
  over dup
  string-in?string-heap,to if
    drop Exit
  then
  Current-free-string-address,to fetch
  over get-length-of-string
  with-length,copy-byte-string
  (* set return value *)
  Current-free-string-address,to fetch add4
  |123->321|
  (* update Current-free-string-address,to *)
  get-length-of-string add4
  Current-free-string-address,to add-save
  Exit
; define-function

(* test: *)
(*
 * Current-free-string-address,to fetch
 *   s" xxx " dup2 print-string (\* xxx *\)
 *   drop <substring>
 *   try,copy-substring,from->to
 *   drop2
 * add4 dup
 * get-length-of-string
 * print-string (\* xxx *\)
 *)


: try,copy-substring,from->to,for-car
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  over fetch2 (* this line is as car *)
  dup <substring> =/= if
    drop2 (* drop car *)
    Exit
  then
  try,copy-substring,from->to
  x|over|xxx save2 (* this line is as set-car! *)
  Exit
; define-function

: try,copy-substring,from->to,for-cdr
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  over Car-bytes-size + fetch2 (* this line is as cdr *)
  dup <substring> =/= if
    drop2 (* drop cdr *)
    Exit
  then
  try,copy-substring,from->to
  x|over|xxx Car-bytes-size + save2 (* this line is as set-cdr! *)
  Exit
; define-function


(*
 * {* s" xxx" drop <substring>
 *    s" ppp" drop <substring> *}
 *
 * dup2
 *   car print-type-tag cr (\* <substring> *\)
 *   dup get-length-of-string
 *   print-string cr (\* xxx *\)
 * dup2
 *   cdr print-type-tag cr (\* <substring> *\)
 *   dup get-length-of-string
 *   print-string cr (\* ppp *\)
 *
 * dup2
 *   car drop .hex cr (\* >< *\)
 * dup2
 *   cdr drop .hex cr (\* >< *\)
 *
 * dup2
 *   try,copy-substring,from->to,for-car
 *   try,copy-substring,from->to,for-cdr
 *
 * dup2
 *   car print-type-tag cr (\* <substring> *\)
 *   dup get-length-of-string
 *   print-string cr (\* xxx *\)
 * dup2
 *   cdr print-type-tag cr (\* <substring> *\)
 *   dup get-length-of-string
 *   print-string cr (\* ppp *\)
 *
 * (\* the two hex numbers must be different *\)
 * dup2
 *   car drop .hex cr (\* >< *\)
 * dup2
 *   cdr drop .hex cr (\* >< *\)
 *
 * drop2
 *)
: read-non-string-ending-char (* -- FirstNonBlankChar or Zero *)
  read-char
  dup '"' == if
    drop Zero
  then Exit
; define-function

: help:read-string,loop (* begin-address -- end-address *)
  read-non-string-ending-char
  dup zero? if
    drop Exit
  then
  over save-byte
  add1
  help:read-string,loop
  Exit
; define-recursive-function

: read-string (* -- string[address, length] *)
  Current-free-string-address,from fetch add4
  dup (* leave begin-address *)
    help:read-string,loop
  dup (* leave end-address *)
    Current-free-string-address,from save
  over -
  dup (* return: length *)
  x|over|xx (* return: address *)
  sub4 save-four-bytes
  Exit
; define-function

: s" (* -- string[address, length] *)
  read-string Exit
; define-function

(* test: *)
(* s" 123 xxx aaa !!! @@@ ###" print-string *)
(* the construction of pair : [unit : byte]
 * clr:
 *     ||  1 : color     ||
 * car:
 *     ||  8 : type tag  ||
 *     ||  8 : value     ||
 * cdr:
 *     ||  8 : type tag  ||
 *     ||  8 : value     ||
 *)

(* the following constants are defined in assembler:
 * Cons-bytes-size == 33
 * Clr-bytes-size  ==  1
 * Car-bytes-size  == 16
 * Cdr-bytes-size  == 16
 *)

:" clr said:
   ``My function-type is (* [address, <pair-like>] -- color-byte *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:clr,type-error ; define-constant-string
: clr (* [address, <pair-like>] -- color-byte *)
  dup <not-pair-like>? if
    Message:clr,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  sub1 fetch-byte Exit
; define-function


:" car said:
   ``My function-type is (* [address, <pair-like>] -- [value, type] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:car,type-error ; define-constant-string
: car (* [address, <pair-like>] -- [value, type] *)
  dup <not-pair-like>? if
    Message:car,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  fetch2 Exit
; define-function


:" cdr said:
   ``My function-type is (* [address, <pair-like>] -- [value, type] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:cdr,type-error ; define-constant-string
: cdr (* [address, <pair-like>] -- [value, type] *)
  dup <not-pair-like>? if
    Message:cdr,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  Car-bytes-size + fetch2 Exit
; define-function
0 : White ; define-constant
1 : Black ; define-constant


(* set three offsets used by fetch-byte, set-bit, clear-bit *)
0 : Mutative-color-offset-for-finding  ; define-variable
1 : Mutative-color-offset-for-marking  ; define-variable
2 : Mutative-color-offset-for-cleaning ; define-variable
: Color-offset-for-finding  Mutative-color-offset-for-finding  fetch Exit ; define-function
: Color-offset-for-marking  Mutative-color-offset-for-marking  fetch Exit ; define-function
: Color-offset-for-cleaning Mutative-color-offset-for-cleaning fetch Exit ; define-function

:" set-clr! said:
   ``My function-type is (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-clr!,type-error ; define-constant-string
: set-clr! (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
  over dup  <not-pair-like>? if
    Message:set-clr!,type-error print-string
    print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  x|over|xx sub1 save-byte Exit
; define-function
: white-color-for-marking? (* color-byte -- True or False *)
  Color-offset-for-marking fetch-bit White == Exit
; define-function

: black-color-for-marking? (* color-byte -- True or False *)
  Color-offset-for-marking fetch-bit Black == Exit
; define-function

: black-<pair>? (* [address, <pair-like>] -- True or False *)
  clr black-color-for-marking? Exit
; define-function


(* the following function is the only function who push-grey-pair-stack
 * and this function is called by one,grey->black and so on *)
:" try,white->grey said:
   ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:try,white->grey,type-error ; define-constant-string
: try,white->grey (* [address, <pair-like>] -- [address, <pair-like>] *)
  dup <not-pair-like>? if
    Message:try,white->grey,type-error print-string
    dup print-type-tag cr
    debuger
    Exit
  then
  dup2 clr
  dup
  white-color-for-marking? if
    Color-offset-for-marking set-bit set-clr!

    try,copy-substring,from->to,for-car
    try,copy-substring,from->to,for-cdr
    over push-grey-pair-stack
    Exit
  then
  drop (* drop the color-byte *) Exit
; define-function


: one,try,grey->black (* -- *)
  empty-grey-pair-stack? if
    Exit
  then
  pop-grey-pair-stack dup
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
    Car-bytes-size +
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
  Exit
; define-function


(* the following is a help-function of all,grey->black
 * the GreyPairStack must not be empty when it is called *)

: one,grey->black (* -- *)
  pop-grey-pair-stack dup
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
    Car-bytes-size +
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
  Exit
; define-function

: all,grey->black (* -- *)
  empty-grey-pair-stack? if
    Exit
  then
  one,grey->black
  all,grey->black Exit
; define-recursive-function
: set!
  (* VarForTypedValue[address], [value, type] -- VarForTypedValue[address] *)
  dup <pair-like>? if
    all,grey->black (* to be incremental-gc is to call this function here *)
    try,white->grey
  then
  x|over|xx save2
  Exit
; define-function


: help:set-car!&set-cdr!,for-black-<pair>
  (* [valus, type] -- [valus, type] *)
  dup <pair-like>? if
    all,grey->black (* to be incremental-gc is to call this function here *)
    try,white->grey
  then
  Exit
; define-function


:" set-car! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car!,type-error ; define-constant-string

: set-car!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    Message:set-car!,type-error print-string
    print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help:set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx save2
  Exit
; define-function


:" set-cdr! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-cdr!,type-error ; define-constant-string

: set-cdr!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    Message:set-cdr!,type-error print-string
    print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help:set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx Car-bytes-size + save2
  Exit
; define-function


(* ------------------------------------------------- *)


:" [cons,car]! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:[cons,car]!,type-error ; define-constant-string

: [cons,car]!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    Message:[cons,car]!,type-error print-string
    print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help:set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx save2
  Exit
; define-function


:" [cons,cdr]! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:[cons,cdr]!,type-error ; define-constant-string

: [cons,cdr]!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    Message:[cons,cdr]!,type-error print-string
    print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help:set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx Car-bytes-size + save2
  Exit
; define-function


(* ------------------------------------------------- *)


:" [car,cons]! said:
   ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
     If I view the first argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:[car,cons]!,type-error ; define-constant-string

: [car,cons]!
  (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
  (* you can read this as ``car-cons-set'' *)
  dup <not-pair-like>? if
    Message:[car,cons]!,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2 black-<pair>? if
    xx|swap|xx help:set-car!&set-cdr!,for-black-<pair> xx|swap|xx
  then
  xx|tuck|xx
  drop save2
  Exit
; define-function


:" [cdr,cons]! said:
   ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
     If I view the first argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:[cdr,cons]!,type-error ; define-constant-string

: [cdr,cons]!
  (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
  (* you can read this as ``cdr-cons-set'' *)
  dup <not-pair-like>? if
    Message:[cdr,cons]!,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2 black-<pair>? if
    xx|swap|xx help:set-car!&set-cdr!,for-black-<pair> xx|swap|xx
  then
  xx|tuck|xx
  drop Car-bytes-size + save2
  Exit
; define-function
(* recall
 * a word in the dictionary [unit : Cell-width = 8 bytes]
 *   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 *   ||  m : name-string  ||
 *   ||  1 : SizeOfFunctionBody  ||
 *   ||  1 : identification  ||
 *   ||  1 : link  ||
 *   ||  1 : type  ||
 *   ||  1 : address-of-name-string-header  ||
 *   ||  1 : address-of-explainer  ||
 *   ||  n : body  ||
 * where
 *   ||  1 : type  ||
 * ==
 *   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
 * type-bit-0 is for HiddenWord
 * type-bit-1 is for VariableOfTypedValue
 *)

: create-word-header-for-typed-value
  (* string[address, length] -- word[address of link] *)
  Here fetch xx|swap|x (* address-of-name-string-header *)
  append-string-to-here
  Here fetch append-number-to-here (* identification *)
  Here fetch (* leave the word[link] *)
  Zero append-number-to-here (* link *)
  Two append-number-to-here  (* type *)
  swap
  append-number-to-here (* address-of-name-string-header *)
  Exit
; define-function

: define,by-string
  (* [value, type], string[address, length] -- *)
  create-word-header-for-typed-value
  Variable-explainer append-number-to-here
  xx|swap|x  (* leave wordHeader *)
  dup <pair-like>? if
    try,white->grey
  then
  append-number-to-here append-number-to-here
  add-new-word-to-dictionary
  Exit
; define-function

: define
  (* [value, type], wordList[address, the number of words] -- *)
  head-of-word-list
  define,by-string
  Exit
; define-function
(* the following functions are helping cons *)

: clear-color-bit-of-pair-for-cleaning (* pair[address] -- pair[address] *)
  <pair>
  dup2 clr
  Color-offset-for-cleaning clear-bit
  set-clr!
  drop
  Exit
; define-function

: white-color-for-finding? (* color-byte -- True or False *)
  Color-offset-for-finding fetch-bit White ==
  Exit
; define-function

: find-next-free-pair-construction
  (* pair[address] -- Zero or NextFreePairConstruction[address] *)
  dup Last-pair-construction == if
    drop Zero Exit
  then
  Cons-bytes-size +
  clear-color-bit-of-pair-for-cleaning
  dup <pair> clr
  white-color-for-finding? if
    Exit
  then
  find-next-free-pair-construction
  Exit
; define-recursive-function



(* a cyclic permutation
 * of the two three period cyclic permutation
 * in the third-order permutation group
 Mutative-color-offset-for-finding  --> Mutative-color-offset-for-cleaning
 Mutative-color-offset-for-marking  --> Mutative-color-offset-for-finding
 Mutative-color-offset-for-cleaning --> Mutative-color-offset-for-marking
 *)
: reset-color-offsets (* -- *)
  Mutative-color-offset-for-finding  fetch
  Mutative-color-offset-for-marking  fetch
  Mutative-color-offset-for-cleaning fetch
  Mutative-color-offset-for-marking  save
  Mutative-color-offset-for-finding  save
  Mutative-color-offset-for-cleaning save
  Exit
; define-function


: dynamic-variable-word-for-<pair-like>?
  (* word[address of link] -- True or False *)
  dup dynamic-variable-word? if
  word-link->word-explainer execute fetch2
  swap drop
  <pair-like>?
  Exit
  then
  drop False Exit
; define-function

: help:push-all-root-node-into-grey-pair-stack
  (* word[address of link] -- *)
  dup last-word-in-dictionary? if
    drop Exit
  then
  dup dynamic-variable-word-for-<pair-like>? if
  dup word-link->word-explainer execute fetch2
  try,white->grey drop2
  then
  next-word-in-dictionary
  help:push-all-root-node-into-grey-pair-stack
  Exit
; define-recursive-function

: push-all-root-node-into-grey-pair-stack (* -- *)
    first-word-in-dictionary fetch
    help:push-all-root-node-into-grey-pair-stack
    Exit
; define-function



(* the following function is not intrinsic
   but I have to use it this way *)

(* a value meet the following three conditions is an AddressOfPair
 *  (the following is infix notations)
 * 1. Value >= First-pair-construction
 * 2. Value <= Last-pair-construction
 * 3. [Value - First-pair-construction] mod Cons-bytes-size == 0
 *)

: addressOfPair? (* value -- True or False *)
    dup First-pair-construction < if
      drop False Exit
    then
    dup Last-pair-construction > if
      drop False Exit
    then
    First-pair-construction - Cons-bytes-size mod zero?
    Exit
; define-function



: help:all-pairs-in-argument-stack,try,white->grey
  (* address of a Cell in ArgumentStack -- *)
    dup Argument-stack-top > if
      drop Exit
    then
    dup fetch addressOfPair? if
      dup fetch
      <pair> try,white->grey
      drop2
    then
    Cell-width +
    help:all-pairs-in-argument-stack,try,white->grey
    Exit
; define-recursive-function

: all-pairs-in-argument-stack,try,white->grey (* -- *)
    fetch-argument-stack-pointer
    help:all-pairs-in-argument-stack,try,white->grey
    Exit
; define-function


: help:all-pairs-in-lambda-stack,try,white->grey
  (* address of a Cell in LambdaStack -- *)
  dup Lambda-stack-top > if
    drop Exit
  then
  dup fetch addressOfPair? if
    dup fetch
    <pair> try,white->grey
    drop2
  then
  Cell-width +
  help:all-pairs-in-lambda-stack,try,white->grey
  Exit
; define-recursive-function

: all-pairs-in-lambda-stack,try,white->grey (* -- *)
  Lambda-stack-pointer fetch
  help:all-pairs-in-lambda-stack,try,white->grey
  Exit
; define-function



: resetVariablesAboutString (* -- *)
  Current-free-string-address,to fetch Current-free-string-address,from save
  Pointer:String-heap,from       fetch Current-free-string-address,to   save
  Pointer:string-heap,to         fetch Pointer:String-heap,from         save
  Current-free-string-address,to fetch Pointer:string-heap,to           save
  Exit
; define-function


:"  :gc: "
: Message:gc ; define-constant-string

:" cons said: ``Memory for cons is used up! No value is returned!''"
: Message:cons,memory-is-used-up ; define-constant-string

: cons (* -- [address, <pair>] *)
    Current-free-pair-construction fetch <pair> (* leave the return <value> *)
    Current-free-pair-construction fetch find-next-free-pair-construction
    dup not-zero? (* Zero denotes fail to find *) if
      Current-free-pair-construction save
      Exit
    then drop (* drop the Zero, which denotes fail to find, need gc *)
    all-pairs-in-argument-stack,try,white->grey
    all,grey->black
    reset-color-offsets resetVariablesAboutString (* note the timing to reset *)
    push-all-root-node-into-grey-pair-stack
    In-front-of-the-first-pair-construction find-next-free-pair-construction
    dup not-zero? if
      Current-free-pair-construction save
      Message:gc print-string
      Exit
    then drop
    (* if after gc still fail to find, we know the memory is used up *)
    drop2
    Message:cons,memory-is-used-up print-string cr
    debuger
    Exit
; define-function
: read-string (* -- [address, <string>] *)
  cons drop (* drop <pair> *) <string>
  s" drop (* drop length *) <substring>
  set-car!
  null set-cdr!
  Exit
; define-function

: ::" (* -- [address, <string>] *)
  read-string Exit
; define-function


:" write-string said:
   ``My function-type is ( [address, <string>] -- ).
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:write-string,type-error ; define-constant-string

: write-string (* [address, <string>] -- *)
  dup <string> =/= if
    Message:write-string,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  car drop (* drop <substring> *)
  dup get-length-of-string print-string
  Exit
; define-function

: substring (* length -- address *)
  (* allocate a substring of the given length *)
  Current-free-string-address,from fetch add4 swap (* leave begin-address *)
  dup Current-free-string-address,from fetch save-four-bytes
  Four + Current-free-string-address,from add-save
  Exit
; define-function

: string (* length -- [address, <string>] *)
  (* allocate a string of the given length *)
  substring <substring>
  null
  cons drop <string>
  [cdr,cons]!
  [car,cons]!
  Exit
; define-function
(* for test *)
: print-type-of-it (* type -- *)
  print-type-tag ':' write-char write-space Exit
; define-function

(* test: gc *)
: ask-for-lots-of-cons (* n -- *)
    dup zero? if drop Exit
    then
    sub1
    cons
      555 <fixnum> set-car!
      666 <fixnum> set-cdr!
    drop2
    ask-for-lots-of-cons
    Exit
; define-recursive-function

: ask-for-lots-of-cons,leave-them-on-the-argument-stack (* n -- *)
    dup zero? if drop Exit
    then
    sub1
    cons
      555 <fixnum> set-car!
      666 <fixnum> set-cdr!
    x|swap|xx
    ask-for-lots-of-cons,leave-them-on-the-argument-stack
    Exit
; define-recursive-function
:" {" : Bra:flower ; define-constant-string
:" }" : Ket:flower ; define-constant-string

:" ." : Mid:dot ; define-constant-string

:" (esc" : Bra:round-escape ; define-constant-string
:" )"    : Ket:round-escape ; define-constant-string

:" [" : Bra:square ; define-constant-string
:" ]" : Ket:square ; define-constant-string

:" (" : Bra:round ; define-constant-string
:" )" : Ket:round ; define-constant-string
:" write-list"    : Message:write-list   ; define-constant-string
:" write-*dali"  : Message:write-*dali ; define-constant-string
:" write-wodili"  : Message:write-wodili ; define-constant-string
:" write-wodi-or-bound-variable"
: Message:write-wodi-or-bound-variable ; define-constant-string

:" null"  : Message:null ; define-constant-string

:" write said:
   ``I do not know how to write the following type of value,
     I will not touch it and call debuger.''
   --> "
: Message:write,type-error ; define-constant-string

: write (* [value, type] -- *)
  dup <fixnum> == if drop (* drop type-tag *)
    write-dec-number  write-space
    Exit
  then
  dup <symbol> == if drop (* drop type-tag *)
    index-hashback->string print-string  write-space
    Exit
  then
  dup <null> == if drop (* drop type-tag *)
    drop
    Message:null print-string write-space
    Exit
  then
  dup <list> == if
    Message:write-list find word-link->word-explainer execute
    Exit
  then
  dup <dali> == if
    Message:write-*dali find word-link->word-explainer execute
    Exit
  then
  dup <wodi> ==
  over <bound-variable> ==
  bitwise-or if
    Message:write-wodi-or-bound-variable find word-link->word-explainer execute
    Exit
  then
  dup <wodili> == if
    Message:write-wodili find word-link->word-explainer execute
    Exit
  then
  Message:write,type-error print-string
  dup print-type-tag cr
  debuger Exit
; define-function
: string-denote-list-reader?
  (* string[address, length] -- True or False *)
  dup2 Bra:flower equal-string? if
    drop2 True Exit
  then
  dup2 Bra:round-escape equal-string? if
    drop2 True Exit
  then
  dup2 Bra:square equal-string? if
    drop2 True Exit
  then
  dup2 Bra:round equal-string? if
    drop2 True Exit
  then
  drop2 False Exit
; define-function

(* then we need mutually recursive call *)
: execute-word,for-list-reader
  (* string[address, length] -- [value, type] *)
  dup2 string-denote-list-reader? if
    find word-link->word-explainer execute
    Exit
  then
  dup2 string-denote-integer? if
    string->integer,with-error drop <fixnum>
    Exit
  then
  dup2 Message:null equal-string? if
    drop2 null
    Exit
  then
  string-hash->index <symbol>
  Exit
; define-function
: list-escape-REPL
  (* could  be: unknown -- unknown *)
  (* should be:  -- [value, type] *)
  read-word-for-runtime
  dup2
  string-denote-integer? if
    string->integer,with-error drop
    list-escape-REPL
    Exit
  then
  dup2
  Ket:round-escape equal-string? if
    drop2
    Exit
  then
  dup2 find dup not-zero? if
    xx|swap|x drop2
    word-link->word-explainer execute
    list-escape-REPL
    Exit
  then
  drop
  Message:undefined-word print-string
  print-string cr
  list-escape-REPL
  Exit
; define-recursive-function

: (esc list-escape-REPL Exit ; define-function
: read-list (* -- [address, <list>] *)
  read-word
  dup2 Ket:flower equal-string? if
    drop2
    null Exit
  then
  dup2 Mid:dot equal-string? if
    drop2
    read-list car
    (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
    Exit
  then
  execute-word,for-list-reader
  cons drop <list>
    xx|swap|xx  set-car!
    read-list   set-cdr!
  Exit
; define-recursive-function

: { read-list Exit ; define-function
: help:write-list (* [address, <list>] or [Null, <null>] -- *)
  dup <null> == if
    drop2 Exit
  then
  dup <pair-like>? if
    dup2
    car write
    cdr help:write-list
    Exit
  then
  Mid:dot print-string write-space
  write
  Exit
; define-recursive-function


:" write-list said:
   ``My function-type is (* [address, <list>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: Message:write-list,type-error ; define-constant-string

: write-list (* [address, <list>] -- *)
  dup <list> =/= if
    Message:write-list,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  Bra:flower print-string write-space
  help:write-list
  Ket:flower print-string write-space
  Exit
; define-function
:" set-car-to-{car}! said:
   ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car-to-{car}!,type-error ; define-constant-string
(* [car.cdr]->[[car].cdr] *)
: set-car-to-{car}!
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  dup <not-pair-like>? if
    Message:set-car-to-{car}!,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2
  car cons
    xx|swap|xx set-car!
    null set-cdr!
  set-car!
  Exit
; define-function


:" set-car-to-{cdr}! said:
   ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car-to-{cdr}!,type-error ; define-constant-string
(* [car.cdr]->[car.[cdr]] *)
: set-cdr-to-{cdr}!
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  dup <not-pair-like>? if
    Message:set-car-to-{cdr}!,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2
  cdr cons
    xx|swap|xx set-car!
    null set-cdr!
  set-cdr!
  Exit
; define-function




:" set-car-to-{car.x}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car-to-{car.x}!,type-error ; define-constant-string

: set-car-to-{car.x}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    Message:set-car-to-{car.x}!,type-error print-string
    x|over|xx print-type-tag cr
    debuger Exit
  then
  xx|over|xx
  car cons
    xx|swap|xx set-car!
    xx|swap|xx set-cdr!
  set-car!
  Exit
; define-function


:" set-car-to-{cdr.x}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car-to-{cdr.x}!,type-error ; define-constant-string

(* [car.cdr],x->[car.[cdr.x]]! *)
: set-cdr-to-{cdr.x}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    Message:set-car-to-{cdr.x}!,type-error print-string
    x|over|xx print-type-tag cr
    debuger Exit
  then
  xx|over|xx
  cdr cons
    xx|swap|xx set-car!
    xx|swap|xx set-cdr!
  set-cdr!
  Exit
; define-function


:" set-car-to-{x.car}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car-to-{x.car}!,type-error ; define-constant-string

: set-car-to-{x.car}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    Message:set-car-to-{x.car}!,type-error print-string
    x|over|xx print-type-tag cr
    debuger Exit
  then
  xx|over|xx
  car cons
    xx|swap|xx set-cdr!
    xx|swap|xx set-car!
  set-car!
  Exit
; define-function


:" set-car-to-{x.cdr}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: Message:set-car-to-{x.cdr}!,type-error ; define-constant-string

: set-cdr-to-{x.cdr}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    Message:set-car-to-{x.cdr}!,type-error print-string
    x|over|xx print-type-tag cr
    debuger Exit
  then
  xx|over|xx
  cdr cons
    xx|swap|xx set-cdr!
    xx|swap|xx set-car!
  set-cdr!
  Exit
; define-function
:" <- said:
   ``My function-type is (* [address, <dali-like>] -- [address, <dali>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:<-,type-error ; define-constant-string

: <- (* [address, <dali-like>] -- [address, <dali>] *)
  dup <not-dali-like>? if
    Message:<-,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  cdr car Exit
; define-function


:" -> said:
   ``My function-type is (* [address, <dali-like>] -- [address, <dali>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:->,type-error ; define-constant-string

: -> (* [address, <dali-like>] -- [address, <dali>] *)
  dup <not-dali-like>? if
    Message:->,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  cdr cdr Exit
; define-function
(* note that:
   in the following, I am using side-effect to change a existed list
   but NOT to form a new dali from scratch *)

: help:list->dali
  (* [address, <dali>], left[address, <dali>] -- [address, <dali>] *)
  (* or *)
  (* [address, <dali>], [value, <non-dali>] -- [address, <dali>] *)
  set-cdr-to-{x.cdr}! (* set the ``left'' *)
  dup2 cdr
    dup2 cdr <not-pair-like>? if
      drop (* drop the non-pair-value *)
      null set-cdr!
      (* this means the 3 in { 1 2 . 3 } will be droped *)
      drop2 Exit
    then
    (* change the type-tag of the cdr of the old list, from <list> to <dali> *)
    (* the pair-like-value is still here *) <dali> set-cdr!
    cdr
  (* [address, <dali>], [address, <pair-like>] *)
  xx|swap|xx
  help:list->dali
  Exit
; define-recursive-function


:" list->*dali* said:
   ``My function-type is
     (* [address, <list>] -- head[address, <dali>], tail[address, <dali>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:list->*dali*,type-error ; define-constant-string

: list->*dali*
  (* [address, <list>] -- head[address, <dali>], tail[address, <dali>] *)
  dup <list> =/= if
    Message:list->*dali*,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop <dali>
  dup2 (* leave the return value *)
  null
  help:list->dali
  Exit
; define-function


:" list->dali* said:
   ``My function-type is (* [address, <list>] -- tail[address, <dali>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:list->dali*,type-error ; define-constant-string

: list->dali*
  (* [address, <list>] -- tail[address, <dali>] *)
  dup <list> =/= if
    Message:list->dali*,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop <dali>
  null
  help:list->dali
  Exit
; define-function


:" list->*dali said:
   ``My function-type is (* [address, <list>] -- head[address, <dali>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:list->*dali,type-error ; define-constant-string

: list->*dali
  (* [address, <list>] -- head[address, <dali>] *)
  dup <list> =/= if
    Message:list->*dali,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop <dali>
  dup2 (* leave the return value *)
  null
  help:list->dali
  drop2
  Exit
; define-function
: *dali? (* [address, <dali>] -- True or False *)
  <- null? if
    True Exit
  then
  False Exit
; define-function

: dali*? (* [address, <dali>] -- True or False *)
  -> null? if
    True Exit
  then
  False Exit
; define-function
: help:nested-list->dali
  (* [address, <dali>], left[address, <dali>] -- [address, <dali>] *)
  (* or *)
  (* [address, <dali>], [value, <non-dali>] -- [address, <dali>] *)
  set-cdr-to-{x.cdr}! (* set the ``left'' *)
  dup2 car dup <list> == if
    list->*dali set-car!
  else
    drop2
  then
  dup2 cdr
    dup2 cdr <not-pair-like>? if
      drop (* drop the non-pair-value *)
      null set-cdr!
      (* this means the 3 in { 1 2 . 3 } will be droped *)
      drop2 Exit
    then
    (* change the type-tag of the cdr of the old list, from <list> to <dali> *)
    (* the pair-like-value is still here *) <dali> set-cdr!
    cdr
  (* [address, <dali>], [address, <pair-like>] *)
  xx|swap|xx
  help:nested-list->dali
  Exit
; define-recursive-function


:" nested-list->*dali said:
   ``My function-type is (* [address, <list>] -- head[address, <dali>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:nested-list->*dali,type-error ; define-constant-string

: nested-list->*dali
  (* [address, <list>] -- head[address, <dali>] *)
  dup <list> =/= if
    Message:nested-list->*dali,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop <dali>
  dup2 (* leave the return value *)
  null
  help:nested-list->dali
  drop2
  Exit
; define-function
:" dali->tail said:
   ``My function-type is
     (* [address, <dali-like>] -- tail[address, <dali-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:dali->tail,type-error ; define-constant-string

: dali->tail
  (* [address, <dali-like>] -- tail[address, <dali-like>] *)
  dup <not-dali-like>? if
    Message:dali->tail,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2 dali*? if
    Exit
  then
  ->  dali->tail
  Exit
; define-recursive-function


:" head<-dali said:
   ``My function-type is
     (* [address, <dali-like>] -- head[address, <dali-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:head<-dali,type-error ; define-constant-string

: head<-dali
  (* [address, <dali-like>] -- head[address, <dali-like>] *)
  dup <not-dali-like>? if
    Message:head<-dali,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2 *dali? if
    Exit
  then
  <-  head<-dali
  Exit
; define-recursive-function
:" [value,dali]-associate said:
   ``My function-type is
     (* [value, type], head[address, <dali-like>] --
        associate-pair[address, <pair-like>] or [Null, <null>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:[value,dali]-associate,type-error,at-first
; define-constant-string

:" [value,dali]-associate said:
   ``My function-type is
     (* [value, type], head[address, <dali-like>] --
        associate-pair[address, <pair-like>] or [Null, <null>] *)
     But in the middle of recursion
     I found the dali is not an associated-dali
     the following is what I found
     I will not touch it and call debuger''
   --> "
: Message:[value,dali]-associate,type-error,in-the-middle
; define-constant-string

: help:[value,dali]-associate
  (* [value, type], head[address, <dali-like>], or [Null, <null>] --
     associate-pair[address, <pair-like>] or [Null, <null>] *)
  dup <null> == if
    (* if associate fail, return null *)
    xx|swap|xx drop2 Exit
  then
  dup2
  car dup <not-pair-like>? if
    Message:[value,dali]-associate,type-error,in-the-middle print-string
    dup print-type-tag cr
    debuger Exit
  then
  car
  (* [value, type], head[address, <dali-like>], car-car[value, type] *)
  xx|over|xxxx eq? if
    xx|swap|xx drop2
    car Exit
  then
  ->  help:[value,dali]-associate
  Exit
; define-recursive-function

: [value,dali]-associate
  (* [value, type], head[address, <dali-like>] --
     associate-pair[address, <pair-like>] or [Null, <null>] *)
  dup <not-dali-like>? if
    Message:[value,dali]-associate,type-error,at-first print-string
    dup print-type-tag cr
    debuger Exit
  then
  help:[value,dali]-associate
  Exit
; define-function



: [value,dali]-member?
  (* [value, type], [address, <dali-like>] -- True or False *)
  dup <null> == if
    drop2 drop2 False Exit
  then
  dup2 car
  xx|over|xxxx eq? if
    drop2 drop2 True Exit
  then
  ->  [value,dali]-member?
  Exit
; define-recursive-function
:" ^_^ said:
   ``My function-type is
     (*  left[address, <dali-like>], rigth[address, <dali-like>] --
         rigth[address, <dali-like>] *)
     If I view the 1st argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:^_^,1st-type-error ; define-constant-string

:" ^_^ said:
   ``My function-type is
     (*  left[address, <dali-like>], rigth[address, <dali-like>] --
         rigth[address, <dali-like>] *)
     If I view the 3rd argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: Message:^_^,3rd-type-error ; define-constant-string


(* the following ``little-smile-face'' is ``link-dali'' *)
: ^_^
  (*  left[address, <dali-like>], rigth[address, <dali-like>] --
     rigth[address, <dali-like>] *)
  (* where: left[address, <dali-like>] could be a null *)
  dup <not-dali-like>? if
    Message:^_^,1st-type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  x|over|xx <null> == if
    xx|tuck|xx (* leave the return value *)
    cdr xx|over|xx set-car! drop2
    drop2
    Exit
  then
  x|over|xx <not-dali-like>? if
    Message:^_^,3rd-type-error print-string
    x|over|xx print-type-tag cr
    debuger Exit
  then
  xx|tuck|xx (* leave the return value *)
  cdr xx|over|xx set-car! drop2
  cdr xx|over|xx set-cdr! drop2
  Exit
; define-function
: help:read-*dali
  (* tail[address, <dali>] -- head[address, <dali>] *)
  (* where:
       the <- of ``tail'' is setted,
       need to set the -> of ``tail'' *)
  read-word
  dup2 Ket:square equal-string? if
    drop2
    dup <null> == if
      Exit (* so [ ] null will be read as null *)
    then
    dup2
      cdr
        null  set-cdr!
      drop2
    head<-dali
    Exit
  then
  execute-word,for-list-reader
  cons drop <dali>
    xx|swap|xx  set-car!
    cons        set-cdr!
  ^_^
  help:read-*dali
  Exit
; define-recursive-function


: read-*dali (* -- head[address, <dali>] *)
  null
  help:read-*dali
  Exit
; define-function

: [ read-*dali Exit ; define-function
: help:write-*dali
  (* [address, <dali>] -- *)
  dup2 dali*? if
    car write Exit
  then
  dup2
    car write
  -> help:write-*dali Exit
; define-recursive-function


:" write-*dali said:
   ``My function-type is (* [address, <dali>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: Message:write-*dali,type-error ; define-constant-string

: write-*dali (* [address, <dali>] -- *)
  dup <dali> =/= if
    Message:write-*dali,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  Bra:square print-string write-space
  help:write-*dali
  Ket:square print-string write-space
  Exit
; define-function
: help:stack-LIAF->list
  (* ..., number --  *)
  (* LambdaStack::
     [address, <list>] -- *)
  dup zero? if
    drop (* drop Zero *)
    get-back null set-cdr!
    drop2 Exit
  then
  sub1
  swap <fixnum>  cons drop <list>  [car,cons]!
  dup2
    get-back [cdr,cons]! drop2
  ready
  help:stack-LIAF->list
  Exit
; define-recursive-function

: stack-LIAF->list
  (* ..., number -- [address, <list>] *)
  dup zero? if
    drop null Exit
  then
  sub1
  swap <fixnum>  cons drop <list>  [car,cons]!
  dup2 ready (* leave the return *)
  ready
    help:stack-LIAF->list
  get-back Exit
; define-function


: help:stack-FIAF->list
  (* ..., number -- *)
  (* LambdaStack::
     [address, <list>] -- [address, <list>] *)
  dup zero? if
    drop (* drop Zero *)
    Exit
  then
  sub1
  swap <fixnum>  cons drop <list>  [car,cons]!
  get-back [cons,cdr]! ready
  help:stack-FIAF->list
  Exit
; define-recursive-function

: stack-FIAF->list
  (* ..., number -- [address, <list>] *)
  dup zero? if
    drop null Exit
  then
  null
  ready
    help:stack-FIAF->list
  get-back
  Exit
; define-function
: help:stack-LIAF->dali
  (* ..., number -- [address, <list>] *)
  (* LambdaStack::
     [address, <list>] -- *)
  dup zero? if
    drop (* drop Zero *)
    get-back
    dup2 cdr
    null set-cdr!
    drop2
    head<-dali
    Exit
  then
  sub1
  swap <fixnum>  cons drop <dali>  [car,cons]!
  cons  [cons,cdr]!
  get-back
    xx|swap|xx ^_^
  ready
  help:stack-LIAF->dali
  Exit
; define-recursive-function

: stack-LIAF->dali
  (* ..., number -- [address, <dali>] *)
  dup zero? if
    drop null Exit
  then
  null
  ready
  help:stack-LIAF->dali
  Exit
; define-function


: help:stack-FIAF->dali
  (* ..., number -- [address, <list>] *)
  (* LambdaStack::
     [address, <list>] -- *)
  dup zero? if
    drop (* drop Zero *)
    get-back
    dup2 cdr
    null set-car!
    drop2 Exit
  then
  sub1
  swap <fixnum>  cons drop <dali>  [car,cons]!
  cons  [cons,cdr]!
  get-back
    ^_^ <-
  ready
  help:stack-FIAF->dali
  Exit
; define-recursive-function

: stack-FIAF->dali
  (* ..., number -- [address, <dali>] *)
  (* ..., number -- [address, <dali>] *)
  dup zero? if
    drop null Exit
  then
  sub1
  swap <fixnum>  cons drop <dali>
  [car,cons]!
    null set-cdr-to-{cdr.x}!
  ready
  help:stack-FIAF->dali
  Exit
; define-function
:" stack<-FIAF-list said:
   ``My function type is (* [address, <list>] -- ... *)
     the list should be a list of <not-pair-like> value
     But in the middle of recursion
     the following is what I found
     I will not touch it and call debuger''
   --> "
: Message:stack<-FIAF-list,error ; define-constant-string

:" stack<-FIAF-list said:
   ``My function type is (* [address, <list>] -- ... *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:stack<-FIAF-list,type-error ; define-constant-string

: help:stack<-FIAF-list
  (* -- ... *)
  (* LambdaStack::
     [address, <list>] -- *)
  get-back
  dup <null> == if
    drop2 Exit
  then
  dup2
    cdr ready
  car
  dup <pair-like>? if
    Message:stack<-FIAF-list,error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop a <not-pair-like> type-tag *)
  (* leave the value of the [value, <not-pair-like>] *)
  help:stack<-FIAF-list
  Exit
; define-recursive-function

: stack<-FIAF-list
  (* [address, <list>] -- ... *)
  dup <list> =/= if
    Message:stack<-FIAF-list,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  ready
  help:stack<-FIAF-list
  Exit
; define-function
: char-denote-number,or-alphabet,or-out-of-ascii?
  (* char -- True of False *)
  dup  48 < if     drop False Exit
  then
  dup  57 <= if    drop True Exit
  then
  dup  65 < if     drop False Exit
  then
  dup  90 <= if    drop True Exit
  then
  dup  97 < if     drop False Exit
  then
  dup  122 <= if   drop True Exit
  then
  dup  128 < if    drop False Exit
  then
  drop True Exit
; define-function
(* `:' followed by a number or alphabet is a symbolDenoteBoundVariable
   ascii: 48 -- 57, 65 -- 90, 97 -- 122, 128 -- ...
   this set maybe change in the future *)

: string-denote-bound-variable,one?
  (* [address, length] -- True or False *)
  tail-and-head-of-string
  ':' =/= if
    drop2 False (* Exit *)
  else
    dup Zero == if
      drop2 False (* Exit *)
    else
      tail-and-head-of-string
      char-denote-number,or-alphabet,or-out-of-ascii? if
        drop2 True (* Exit *)
      else
        drop2 False (* Exit *)
      then
    then
  then
  Exit
; define-function

:" an error occurs!
symbol-denote-bound-variable,one? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-bound-variable,one?,type-error ; define-constant-string
: symbol-denote-bound-variable,one?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-bound-variable,one?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-bound-variable,one?
  Exit
; define-function



: string-denote-bound-variable,two?
  (* [address, length] -- True or False *)
  dup Two <= if
    drop2 False Exit
  then
  tail-and-head-of-string ':' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,one? Exit
  Exit
; define-function

:" an error occurs!
symbol-denote-bound-variable,two? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-bound-variable,two?,type-error ; define-constant-string
: symbol-denote-bound-variable,two?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-bound-variable,two?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-bound-variable,two?
  Exit
; define-function




: string-denote-bound-variable,three?
  (* [address, length] -- True or False *)
  dup Three <= if
    drop2 False Exit
  then
  tail-and-head-of-string ':' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,two? Exit
  Exit
; define-function

:" an error occurs!
symbol-denote-bound-variable,three? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-bound-variable,three?,type-error ; define-constant-string
: symbol-denote-bound-variable,three?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-bound-variable,three?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-bound-variable,three?
  Exit
; define-function



: string-denote-bound-variable,four?
  (* [address, length] -- True or False *)
  dup Four <= if
    drop2 False Exit
  then
  tail-and-head-of-string ':' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,three? Exit
  Exit
; define-function

:" an error occurs!
symbol-denote-bound-variable,four? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-bound-variable,four?,type-error ; define-constant-string
: symbol-denote-bound-variable,four?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-bound-variable,four?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-bound-variable,four?
  Exit
; define-function




: string-denote-bound-variable?
  (* [address, length] -- True or False *)
  dup2 string-denote-bound-variable,one? if
    drop2 True Exit
  then
  dup2 string-denote-bound-variable,two? if
    drop2 True Exit
  then
  dup2 string-denote-bound-variable,three? if
    drop2 True Exit
  then
  dup2 string-denote-bound-variable,four? if
    drop2 True Exit
  then
  drop2 False Exit
; define-function

:" an error occurs!
symbol-denote-bound-variable? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-bound-variable?,type-error ; define-constant-string
: symbol-denote-bound-variable?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-bound-variable?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-bound-variable?
  Exit
; define-function
(* string begin with a number or alphabet
   and end with `:' following a number or alphabet
   is a symbolDenotewodi *)

: string-denote-wodi?
  (* [address, length] -- True or False *)
  dup Two < if
    drop2 False Exit
  then
  dup2 head-of-string
  char-denote-number,or-alphabet,or-out-of-ascii? false? if
    drop2 False Exit
  then
  dup2  sub1 +  fetch-byte ':' =/= if
    drop2 False Exit
  then
  dup2  sub2 +  fetch-byte
  char-denote-number,or-alphabet,or-out-of-ascii? false? if
    drop2 False Exit
  then
  drop2 True Exit
; define-function

:" an error occurs!
symbol-denote-wodi? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-wodi?,type-error ; define-constant-string
: symbol-denote-wodi?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-wodi?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-wodi?
  Exit
; define-function
(* `<' plus a string-denote-bound-variable,one *)
: string-denote-lambda-argument,one?
  (* [address, length] -- True or False *)
  dup Two <= if
    drop2 False Exit
  then
  tail-and-head-of-string '<' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,one? Exit
; define-function

:" an error occurs!
symbol-denote-lambda-argument,one? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-lambda-argument,one?,type-error ; define-constant-string
: symbol-denote-lambda-argument,one?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-lambda-argument,one?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-lambda-argument,one?
  Exit
; define-function



(* `<' plus a string-denote-bound-variable,two *)
: string-denote-lambda-argument,two?
  (* [address, length] -- True or False *)
  dup Three <= if
    drop2 False Exit
  then
  tail-and-head-of-string '<' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,two? Exit
; define-function

:" an error occurs!
symbol-denote-lambda-argument,two? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-lambda-argument,two?,type-error ; define-constant-string
: symbol-denote-lambda-argument,two?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-lambda-argument,two?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-lambda-argument,two?
  Exit
; define-function




(* `<' plus a string-denote-bound-variable,three *)
: string-denote-lambda-argument,three?
  (* [address, length] -- True or False *)
  dup Four <= if
    drop2 False Exit
  then
  tail-and-head-of-string '<' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,three? Exit
; define-function

:" an error occurs!
symbol-denote-lambda-argument,three? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-lambda-argument,three?,type-error ; define-constant-string
: symbol-denote-lambda-argument,three?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-lambda-argument,three?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-lambda-argument,three?
  Exit
; define-function




(* `<' plus a string-denote-bound-variable,four *)
: string-denote-lambda-argument,four?
  (* [address, length] -- True or False *)
  dup Five <= if
    drop2 False Exit
  then
  tail-and-head-of-string '<' =/= if
    drop2 False Exit
  then
  string-denote-bound-variable,four? Exit
; define-function

:" an error occurs!
symbol-denote-lambda-argument,four? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-lambda-argument,four?,type-error ; define-constant-string
: symbol-denote-lambda-argument,four?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-lambda-argument,four?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-lambda-argument,four?
  Exit
; define-function



: string-denote-lambda-argument?
  (* [address, length] -- True or False *)
  dup2 string-denote-lambda-argument,one? if
    drop2 True Exit
  then
  dup2 string-denote-lambda-argument,two? if
    drop2 True Exit
  then
  dup2 string-denote-lambda-argument,three? if
    drop2 True Exit
  then
  dup2 string-denote-lambda-argument,four? if
    drop2 True Exit
  then
  drop2 False Exit
; define-function

:" an error occurs!
symbol-denote-lambda-argument? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: Message:symbol-denote-lambda-argument?,type-error ; define-constant-string
: symbol-denote-lambda-argument?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    Message:symbol-denote-lambda-argument?,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  string-denote-lambda-argument?
  Exit
; define-function
: help:with-word,read-wodi-or-bound-variable
  (* -- [address, <list>] *)
  (* LambdaStack::
     -- wodi[address, length] *)
  read-word
  dup2 string-denote-wodi? if
    ready
    null Exit
  then
  dup2 string-denote-bound-variable? if
    ready
    null Exit
  then
  dup2 Ket:round equal-string? if
    ready
    null Exit
  then
  dup2 Mid:dot equal-string? if
    drop2
    help:with-word,read-wodi-or-bound-variable car
    (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
    Exit
  then
  execute-word,for-list-reader
  cons drop <list>
    xx|swap|xx  set-car!
      help:with-word,read-wodi-or-bound-variable
    set-cdr!
  Exit
; define-recursive-function


: with-word,read-wodi-or-bound-variable
  (* word[address, length] -- [address, <wodi>], word[address, length] *)
  (* LambdaStack:: <wodi> -- *)
  (* or *)
  (* word[address, length] -- [address, <bound-variable>], word[address, length] *)
  (* LambdaStack:: <bound-variable> -- *)
  string-hash->index <symbol>
  cons drop pop-lambda-stack
    [car,cons]!
      help:with-word,read-wodi-or-bound-variable
    [cons,cdr]!
  get-back
  (* return the next ``wodi'' word
     it must be handled in help:read-wodili *)
  Exit
; define-function



:" help:read-wodili said:
   ``My function type is
     (* [address, <wodili>], word[address, length] -- head[address, <wodili>] *)
     the `word' must be `)' or denotes `wodi' or denotes `bound-variable'
     But the following is what I meet
     I will not touch it and call debuger''
   --> "
: Message:help:read-wodili,error ; define-constant-string

(* a ``with-word'' reader *)
: help:read-wodili
  (* [address, <wodili>], word[address, length] -- head[address, <wodili>] *)
  (* where:
       the <- of [address, <wodili>] is setted,
       need to set the -> of [address, <wodili>] *)
  dup2 Ket:round equal-string? if
    drop2
    dup2
      cdr
        null  set-cdr!
      drop2
    head<-dali
    Exit
  then
  dup2 string-denote-wodi? if
    <wodi> push-lambda-stack
  else
    dup2 string-denote-bound-variable? if
      <bound-variable> push-lambda-stack
    else
      Message:help:read-wodili,error print-string
      print-string cr
      debuger Exit
    then
  then
  with-word,read-wodi-or-bound-variable
  (* [address, <wodili>], [address, <wodi>], word[address, length] *)
  (* or *)
  (* [address, <wodili>], [address, <bound-variable>], word[address, length] *)
  xxxx|swap|xx
  cons drop <wodili>
    xx|swap|xx  set-car!
    cons        set-cdr!
  ^_^
  xx|swap|xx
  help:read-wodili
  Exit
; define-recursive-function



: read-wodili (* -- head[address, <wodili>] *)
  null
  read-word
  dup2 Ket:round equal-string? if
    (* return ``null'' on ( ) *)
    drop2 Exit
  then
  help:read-wodili
  Exit
; define-function

: ( read-wodili Exit ; define-function
:" write-wodi-or-bound-variable said:
   ``My function-type is (* [address, <wodi> or <bound-variable>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: Message:write-wodi-or-bound-variable,type-error ; define-constant-string

: write-wodi-or-bound-variable
  (* [address, <wodi> or <bound-variable>] -- *)
  dup <wodi> =/=
  over <bound-variable> =/=
  bitwise-and if
    Message:write-wodi-or-bound-variable,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup2
    car write
  cdr help:write-list
  Exit
; define-function



: help:write-wodili
  (* [address, <wodili>] -- *)
  dup <null> == if
    drop2 Exit
  then
  dup2
    car write
  -> help:write-wodili Exit
; define-recursive-function


:" write-wodili said:
   ``My function-type is (* [address, <wodili>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: Message:write-wodili,type-error ; define-constant-string

: write-wodili
  (* [address, <wodili>] -- *)
  dup <wodili> =/= if
    Message:write-wodili,type-error print-string
    dup print-type-tag cr
    debuger Exit
  then
  Bra:round print-string write-space
  help:write-wodili
  Ket:round print-string write-space
  Exit
; define-function
: <lambda-argument-one>   ; define-pair-like-data-type
: <lambda-argument-two>   ; define-pair-like-data-type
: <lambda-argument-three> ; define-pair-like-data-type
: <lambda-argument-four>  ; define-pair-like-data-type

: <lambda-argument>?
  (* type-tag -- True or False *)
  dup <lambda-argument-one> == if
    drop True Exit
  then
  dup <lambda-argument-two> == if
    drop True Exit
  then
  dup <lambda-argument-three> == if
    drop True Exit
  then
  dup <lambda-argument-four> == if
    drop True Exit
  then
  drop False Exit
; define-function

(* ><><>< the following comment should be rewritten *)
(* redefine execute-word to handle the following symbols
   <:x   ::    value       -- [{ :x  . { ... } }, <lambda-argument-one>]
   <::x  ::  [value, type] -- [{ ::x . { ... } }, <lambda-argument-two>]
   ...
   examples:
   [{ :x       . { 1 } },             <lambda-argument-one>]
   [{ ::null   . { Null <null> } },   <lambda-argument-two>]
   [{ ::number . { 666 <fixnum> } },  <lambda-argument-two>]
   note that:
     every value in list must have a type
     so in every list above, type of a car is setted to <fixnum>
 *)

: execute-word (* string[address, length] -- unknown *)
  dup2
  string-denote-integer? if
    string->integer,with-error drop Exit
  then

  dup2 string-denote-bound-variable,one? if
    string-hash->index <symbol> Exit
  then
  dup2 string-denote-bound-variable,two? if
    string-hash->index <symbol> Exit
  then
  dup2 string-denote-bound-variable,three? if
    string-hash->index <symbol> Exit
  then
  dup2 string-denote-bound-variable,four? if
    string-hash->index <symbol> Exit
  then

  dup2 string-denote-lambda-argument,one? if
    tail-of-string
    string-hash->index <symbol>
    cons drop <lambda-argument-one>
      xx|swap|xx set-car!
      ready
        One stack-FIAF->list
      get-back
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 string-denote-lambda-argument,two? if
    tail-of-string
    string-hash->index <symbol>
    cons drop <lambda-argument-two>
      xx|swap|xx set-car!
      ready
        Two stack-FIAF->list
      get-back
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 string-denote-lambda-argument,three? if
    tail-of-string
    string-hash->index <symbol>
    cons drop <lambda-argument-three>
      xx|swap|xx set-car!
      ready
        Three stack-FIAF->list
      get-back
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 string-denote-lambda-argument,four? if
    tail-of-string
    string-hash->index <symbol>
    cons drop <lambda-argument-four>
      xx|swap|xx set-car!
      ready
        Four stack-FIAF->list
      get-back
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 find dup not-zero? if
    xx|swap|x drop2
    word-link->word-explainer execute Exit
  then
  drop (* drop the Zero that denotes finding-error *)
  Message:undefined-word print-string
  print-string (* print the word *) cr
  Exit
; define-function

(* if wished
 *   one needs to use help:symbol-REPL to do the recursive
 *   and reset the two pointers in symbol-REPL
 * Return-stack-top reset-return-stack-pointer
 * Argument-stack-top reset-argument-stack-pointer *)

: symbol-REPL (* unknown -- unknown *)
  read-word-for-runtime
  execute-word
  symbol-REPL
  Exit
; define-recursive-function
symbol-REPL
: <lambda>               ; define-pair-like-data-type
: <explainer-pair>       ; define-pair-like-data-type
: <explainer>            ; define-data-type
: bound-variable-wodili?
  (* head[address, <wodili>] -- True or False *)
  dup <wodili> =/= if
    drop2 False Exit
  then
  dup2 car  swap drop
  <bound-variable> =/= if
    drop2 False Exit
  then
  dup2 dali*? if
    drop2 True Exit
  then
  ->  bound-variable-wodili?
  Exit
; define-recursive-function


(*
 * the following function return `True'
 * on the following dali as a tail
 *   [ [address, <dali>]
 *     bound-variable-wodili[address, <wodili>]
 *    ]
 * and
 *   [ [address, <dali>]
 *     null
 *    ]
 *)

: meet-lambda-abstraction-in-lambda-body-dali?
  (* tail[address, <dali>] -- True or False *)
  dup <dali> =/= if
    drop2 False Exit
  then
  dup2 car
  dup2       bound-variable-wodili?
  xx|swap|x  null?
  bitwise-or if
    <- dup <dali> =/= if
      drop2 False Exit
    then
      car <dali> =/= if
        drop False Exit
      then
        drop True Exit
  then
  drop2 False Exit
; define-function

(*
 * test:
 *
 * [ [ 1 ] ( :x ) ] dali->tail
 * meet-lambda-abstraction-in-lambda-body-dali? . (\* 1 *\) cr
 * [ [ 1 ] null ] dali->tail
 * meet-lambda-abstraction-in-lambda-body-dali? . (\* 1 *\) cr
 * [ [ 1 ] ( ) ] dali->tail
 * meet-lambda-abstraction-in-lambda-body-dali? . (\* 1 *\) cr
 * cr
 * [ [ 1 ] ( x: ) ] dali->tail
 * meet-lambda-abstraction-in-lambda-body-dali? . (\* 0 *\) cr
 *)
: help:bound-variable-wodili-subtraction
  (* LambdaStack::
     (a-b) [address, <wodili>] -- *)
  (* b [address, <wodili>], a [address, <wodili>] --
     (a-b) [address, <wodili>] *)
  dup <null> == if
    drop2 drop2
    get-back
    dup <null> == if
      Exit
    then
    dup2 cdr null [cons,cdr]! drop2
    head<-dali
    Exit
  then
  dup2
    car car   xx|over|xxxx
    [value,dali]-associate
    dup <null> =/= if
    (* if this bound-variable is ``blocked'',
       it should not be ``cons'' to the new bound-variable-wodili *)
    drop2 (* drop the associate-pair *)
    ->  help:bound-variable-wodili-subtraction Exit
  then
  drop2 (* drop the associate-pair *)
  (* b [address, <wodili>], a [address, <wodili>] *)
  dup2 car
  (* a wodi as a whole is ``cons''ed to the new bound-variable-wodili *)
  cons drop <wodili>
    [car,cons]!
    cons [cons,cdr]!
  get-back
    xx|swap|xx  ^_^
    (* so the order of bound-variable-wodili will be preserved *)
  ready
  ->  help:bound-variable-wodili-subtraction Exit
; define-recursive-function


(* the following function will creat a new wodili, maybe ``null'' *)
: bound-variable-wodili-subtraction
  (* a [address, <wodili>], b [address, <wodili>] --
     (a-b) [address, <wodili>] *)
  x|over|xx <null> == if
    (* a == null, (a-b) == a == null *)
    drop2 Exit
  then
  dup <null> == if
    (* b == null, (a-b) == a *)
    drop2 Exit
  then
  null ready
  xx|swap|xx
  (* b [address, <wodili>], a [address, <wodili>] *)
  (* LambdaStack::  [Null, <null>] *)
  help:bound-variable-wodili-subtraction
  Exit
; define-function


(*
 *  test:
 *
 * 666
 * ( ::a ::b ::c )
 * ( ::a ::c ::x )
 * bound-variable-wodili-subtraction
 * write (\* ( ::b )  *\)
 *
 * . (\* 666 *\)
 *)
:" lambda" string-hash->index
: Symbol-index:lambda ; define-constant

:" λ" string-hash->index
: Symbol-index:λ ; define-constant


(* the following two functions are side-effects through a dali
 * in the direction of ``<-''

 * some special-types of elements in the lambda-body
 * should be setted for ``apply''

 * note that: (currently)
 *   <fixnum> <list> <dali> <wodili> <symbol>
 *   are the only types of value
 *   that could be readed into a dali

 *   only all <symbol> in this dali
 *   and some <symbol> that denote-bound-variable nestedly existed in this dali
 *   will be handled by the following functions

 *   while
 *   in the ``apply''
 *   when meet [666, <fixnum>]
 *     666 ( ONLY ONE VALUE ) will be push to ArgumentStack
 *   when meet [address, <list>]
 *     [address, <list>] will be push to ArgumentStack
 *   when meet [address, <dali>]
 *     [address, <dali>] will be push to ArgumentStack
 *   when meet [address, <wodili>]
 *     [address, <wodili>] will be push to ArgumentStack
 *)

(*
 * 下面的两个 函数是主要的辅助函数
 * 它们不是术语函数范式
 * 它们是 沿着 ``<-'' 方向 对 dali 做副作用
 *)


: help:lambda,set-bound-variables (* calculating lambda-scope *)
  (* [address, <wodili>], [address, <dali>] -- *)
  dup <null> == if
    (* drop all the arguments here *)
    drop2 drop2 Exit
  then
  dup2 car

  (* [address, <wodili>], [address, <dali>], car[value, type] *)
  dup <symbol> =/= if
    (* types of value other then <symbol>
       will be leaved in the lambda-body as they are *)
    drop2
    <-  help:lambda,set-bound-variables Exit
  then

  (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
  dup2 symbol-denote-bound-variable? if
    xx|over|xxxx
    dup <null> == if
      (* when bound-variable-wodili is null
         symbol-denote-bound-variable can not be bound by this lambda
         just leave them in the lambda-body as they are *)
      drop2 (* drop [Null, <null>] *)
      drop2 (* drop [index, <symbol>] *)
      <-  help:lambda,set-bound-variables Exit
    then
    [value,dali]-associate
    dup <null> == if
      (* symbol-denote-bound-variable that can not be bound by this lambda
         will be leaved in the lambda-body as they are *)
      drop2
      <-  help:lambda,set-bound-variables Exit
    then
    (* [address, <wodili>], [address, <dali>], [address, <bound-variable>] *)
    [cons,car]!
    <-  help:lambda,set-bound-variables Exit
  then

  (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
  dup2 drop
    dup   Symbol-index:lambda ==
    swap  Symbol-index:λ ==
  bitwise-or if
    drop2
    <-
    (* make a special treatment only when
       ``meet-lambda-abstraction-in-lambda-body-dali'' *)
    dup2
    meet-lambda-abstraction-in-lambda-body-dali?
    false? if
      help:lambda,set-bound-variables Exit
    then
    (* [address, <wodili>], [address, <dali>] *)
      (* prepare the arguments for a non-tail-recursive call of help:lambda,set-bound-variables *)
      xx|over|xx xx|over|xx
        car bound-variable-wodili-subtraction
      xx|over|xx
        (* note that: the 2ed arg of help:lambda,set-bound-variables is a tail-dali *)
        <-  car  dali->tail
      help:lambda,set-bound-variables
      (* after then : *)
      <- <-  help:lambda,set-bound-variables Exit
  then

  (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
  (* here is general symbol *)
  drop2
  <-  help:lambda,set-bound-variables Exit
; define-recursive-function


: help:lambda,set-function-body
  (* [address, <wodili>], [address, <dali>] -- *)
  dup <null> == if
    (* drop all the arguments here *)
    drop2 drop2 Exit
  then
  dup2 car
  (* [address, <wodili>], [address, <dali>], car[value, type] *)
  dup <symbol> =/= if
    (* types of value other then <symbol>
       will be leaved in the lambda-body as they are *)
    drop2
    <-  help:lambda,set-function-body Exit
  then
  (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
  dup2 symbol-denote-lambda-argument? if
    (* i.e. symbols like ``<:x''
       will be leaved in the lambda-body as they are
       they will be handled by ``apply'' *)
    drop2
    <-  help:lambda,set-function-body Exit
  then
  (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
  dup2 symbol-denote-bound-variable? if
    (* i.e. symbols like ``:x''
       will be leaved in the lambda-body as they are
       ``help:lambda,set-bound-variables'' take care of them
       when ``apply'' is executed there should be none of them *)
    drop2
    <-  help:lambda,set-function-body Exit
  then
  (* [address, <wodili>], [address, <dali>], [index, <symbol>] *)
  (* here is general symbol *)
  over
    index-hashback->string
    find (* ><><>< error handling when not found *)
    word-link->word-explainer
    <explainer>
  cons drop <explainer-pair>
    [cdr,cons]!  [car,cons]!
  [cons,car]!
  <-  help:lambda,set-function-body Exit
; define-recursive-function




: help:lambda,make-lambda-function
  (* [address, <wodili>], [address, <dali>] --
     [address, <lambda>] *)
  cons drop <lambda>
    xx|swap|xx set-cdr!
    xx|swap|xx set-car!
  Exit
; define-function




:" lambda said:
   ``My function type is
     (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
     (* or *)
     (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
     But the 1st argument is the following
     I will not touch it and call debuger''
   --> "
: Message:lambda,type-error,1st ; define-constant-string

:" lambda said:
   ``My function type is
     (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
     (* or *)
     (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
     The 1st argument is a wodili but not a bound-variable-wodili
     I will not touch it and call debuger''"
: Message:lambda,type-error,1st,not-bound-variable-wodili
; define-constant-string

:" lambda said:
   ``My function type is
     (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
     (* or *)
     (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
     But the 3rd argument is the following
     I will not touch it and call debuger''
   --> "
: Message:lambda,type-error,3rd ; define-constant-string

: lambda
  (* [address, <dali>], [address, <wodili>] -- [address, <lambda>] *)
  (* or *)
  (* [address, <dali>], [Null, <null>] -- [address, <lambda>] *)
  dup <wodili> =/=
  over <null> =/=
  bitwise-and if
    Message:lambda,type-error,1st print-string
    dup print-type-tag cr
    debuger Exit
  then
  dup <wodili> ==
  xx|over|x bound-variable-wodili? false?
  bitwise-and if
    Message:lambda,type-error,1st,not-bound-variable-wodili
    print-string cr
    debuger Exit
  then
  x|over|xx <dali> =/= if
    Message:lambda,type-error,3rd print-string
    x|over|xx print-type-tag cr
    debuger Exit
  then
  xx|tuck|xx  xx|over|xx
  dali->tail
  (* [address, <wodili>], [address, <dali>],
     [address, <wodili>], tail[address, <dali>] *)
  xx|over|xx  xx|over|xx
  help:lambda,set-bound-variables
  (* multi-pass *)
  help:lambda,set-function-body
  (* [address, <wodili>], [address, <dali>] *)
  help:lambda,make-lambda-function
  Exit
; define-function

: λ lambda Exit ; define-function
(* note that:
     when a explainer is been executed
     only the arguments of the word to be explained
     should be in the ArgumentStack or LambdaStack *)

(* a stack as list
   list of dali
   in which a dali denotes a lambda-body *)
null : lambda-body-stack ; define

: push,lambda-body-stack
  (* [address, <wodili>] -- *)
  cons drop <list>  [car,cons]!
  lambda-body-stack fetch2
  [cons,cdr]!
  lambda-body-stack save2
  Exit
; define-function

: drop,lambda-body-stack
  (* -- *)
  lambda-body-stack fetch2
  cdr
  lambda-body-stack save2
  Exit
; define-function
(* the following function
   do side-effect to the car of the lambda-body-stack *)

: <end-of-one-lambda-body> ; define-data-type
: <end-of-all-lambda-body> ; define-data-type

: lambda-forth
  (* -- [value, type] or <end-of-lambda-body> or <>] *)
  lambda-body-stack fetch2
  dup <null> == if
    drop2
    <end-of-all-lambda-body>
    Exit
  then
  dup2 car
    (* [address, <list>], [address, <dali>] or null *)
    dup <null> == if
    drop2 drop2
    <end-of-one-lambda-body>
    drop,lambda-body-stack
    Exit
  then
  (* [address, <list>], [address, <dali>] *)
  xx|tuck|xx
  (* [address, <dali>],
     [address, <list>], [address, <dali>] *)
  ->  (* up date the 1st lambda-body in lambda-body-stack *)
  [cons,car]! drop2
  car
  Exit
; define-function


:" help:apply,eval-lambda-body said:
   ``My function type is (* unknow -- unknow *)
     I call `lambda-forth' to do side-effect on lambda-body-stack
     The symbol I meet should always DenoteLambdaArgument
     But I meet the following symbol
     I will not touch it and call debuger''
   --> "
: Message:help:apply,eval-lambda-body,error,symbol
; define-constant-string

: help:apply,eval-lambda-body
  (* unknow -- unknow *)
  lambda-forth
  dup <end-of-one-lambda-body> == if
    drop Exit
  then

  (* examples:
       [{ :x  . { 100 } }, <bound-variable>]
       [{ ::x . { 666 <fixnum> } }, <bound-variable>] *)
  dup <bound-variable> == if
    cdr
    stack<-FIAF-list
    help:apply,eval-lambda-body
    Exit
  then

  (* example:
       [{ word-name . word-explainer }, <explainer-pair>] *)
  dup <explainer-pair> == if
    cdr
    drop (* drop type-tag: <explainer> *)
    execute
    help:apply,eval-lambda-body
    Exit
  then

  (* example:
       [index, <symbol>] *)
  dup <symbol> == if
    dup2 symbol-denote-lambda-argument? if
      drop (* drop <symbol> *)
      index-hashback->string
      execute-word
      help:apply,eval-lambda-body
      Exit
    then
    Message:help:apply,eval-lambda-body,error,symbol print-string
    dup2 write cr
    debuger
    Exit
  then

  (* example:
       [666, <fixnum>] *)
  dup <fixnum> == if
    drop (* drop type-tag: <fixnum> *)
    help:apply,eval-lambda-body
    Exit
  then

  (* examples:
       [address, <list>]
       [address, <dali>]
       [address, <wodili>]
     and all other types
     leave the value and the type in the stack *)
  help:apply,eval-lambda-body
  Exit
; define-recursive-function
(* examples of <lambda-argument>:
     { :x       . { 1 } }
     { ::null   . { Null <null> } }
     { ::number . { 666 <fixnum> } }
   example of bound-variable-wodili
     ( :a ::b :::c )
     [ { :a    . ... }
       { ::b   . ... }
       { ::::c . ... } ]
 *)


: help-to-rec,help:apply,set-variables
  (* ArgumentStack::
     ..., [address, <lambda-argument-N>] -- *)
  (* LambdaStack::
     [address, <wodili>] -- [address, <wodili>] *)
  dup <lambda-argument>? false? if
    Exit
  then
  dup2   car    get-back dup2 ready
  (* [address, <lambda-argument-N>], [index, <symbol>], [address, <wodili>] *)
  [value,dali]-associate
  dup <null> == if
    drop2 Exit
  then
  (* [address, <lambda-argument-N>], [..., <bound-variable>] *)
  xx|swap|xx   cdr
  [cons,cdr]!  drop2
  help-to-rec,help:apply,set-variables
  Exit
; define-recursive-function


: help:apply,set-variables
  (* ..., [address, <lambda-argument>], [address, <wodili>] -- *)
  ready
    help-to-rec,help:apply,set-variables
  get-back drop2 Exit
; define-function



:" apply said:
   ``My function type is
     (* LambdaStack::  [address, <lambda>] -- unknow *)
     (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
     But the value in the LambdaStack is of the following type
     I will not touch it and call debuger''
   --> "
: Message:apply,type-error ; define-constant-string
: apply
  (* LambdaStack::  [address, <lambda>] -- unknow *)
  (* ArgumentStack::  ..., [address, <lambda-argument>] -- unknow *)
  get-back dup2 ready
  dup <lambda> == if
    car dup <null> == if
      drop2
    else
      help:apply,set-variables
    then
    get-back  cdr
    push,lambda-body-stack
    help:apply,eval-lambda-body
    Exit
  then
  Message:apply,type-error print-string
  print-type-tag cr
  drop (* drop the the value been getted back *)
  debuger Exit
; define-function
: @
  (* ...,
     [address, <lambda-argument>],
     [address, <lambda>]
     ---------------------------
     unknow *)
  ready apply Exit
; define-function
:" yes"
: Message:yes ; define-constant-string
: ok (* -- *)
  Message:yes print-string
  write-space
  Exit
; define-function
:"    welcome to cicada ^_^"
: Message:welcome ; define-constant-string
: welcome (* -- *)
  Message:welcome print-string cr
  Exit
; define-function

cr

welcome

cr

(* report the User-data-area size *)
."  the size of User-data-area is: " cr
write-space
End-of-user-data-area  User-data-area  -  write-dec-number
."  bytes" cr

write-space
End-of-user-data-area  Here fetch  -  write-dec-number
."  bytes free" cr

write-space
Here fetch  User-data-area  -  write-dec-number
."  bytes used" cr

cr

."  you are in symbol-REPL
 in this REPL some types of symbol will be processed specially" cr

cr
