(* Here 这个名词 还是必须使用英文版本的 *)
夫 单元大小 Cell-width 者 也
夫 假 False 者 也
夫 真 True  者 也
夫 动词诠释者 Verb-explainer 者 也
夫 名词诠释者 Noun-explainer 者 也
夫 加       add      已矣 者 动词也
夫 减       sub      已矣 者 动词也
夫 乘       mul      已矣 者 动词也
夫 除       div      已矣 者 动词也
夫 模       mod      已矣 者 动词也
夫 除模     divmod   已矣 者 动词也
夫 模除     moddiv   已矣 者 动词也
夫 负       negate   已矣 者 动词也
夫 幂       power    已矣 者 动词也
(* 一般的 存取 所作用于 的是 一单元 大小 的存储空间
 * 小的 存取 所作用于 的是 一比特 大小 的存储空间
 *)

(* 多个值 而 存取 的作用 如下
 *   在存储空间中 :
 *     ||  1 : 值-1  ||
 *     ||  1 : 值-2  ||
 *     ||  1 : 值-3  ||
 *     ...
 *   在栈中 :
 *     (* 值-1, 值-2, 值-3, ... *)
 * 即 从上到下 对应 从左到右
 * 这样就和 名词 的结构保持了一致
 * 此时 取 很简单 但是 存 需要特殊处理
 *)

夫 存         save              已矣 者 动词也
夫 小存       save-byte         已矣 者 动词也
夫 而存       n-save            已矣 者 动词也
夫 而小存     n-save-byte       已矣 者 动词也


夫 取         fetch             已矣 者 动词也
夫 小取       fetch-byte        已矣 者 动词也
夫 而取       n-fetch           已矣 者 动词也
夫 而小取     n-fetch-byte      已矣 者 动词也


夫 加存       add-save          已矣 者 动词也
夫 减存       sub-save          已矣 者 动词也

夫 复制比特串 copy-byte-string  已矣 者 动词也
夫 做自引用值于参数栈
   make-self-reference-value,in-argument-stack
   已矣
者 动词也

夫 取参数栈指针
   fetch-argument-stack-pointer
   已矣
者 动词也

夫 重置参数栈指针
   reset-argument-stack-pointer
   已矣
者 动词也
夫 弃     drop      已矣 者 动词也
夫 而弃   n-drop    已矣 者 动词也
夫 复     dup       已矣 者 动词也
夫 而复   n-dup     已矣 者 动词也
夫 跃       over       已矣 者 动词也
夫 而跃     x-y-over   已矣 者 动词也
夫 藏       tuck       已矣 者 动词也
夫 而藏     x-y-tuck   已矣 者 动词也
夫 换       swap       已矣 者 动词也
夫 而换     x-y-swap   已矣 者 动词也
(* 入栈时 栈的指针 向低地址移动 *)
夫 入木答栈
   (* 参数栈:: 值 --> 木答栈:: 值 *)
   单元大小 址 Lambda-stack-pointer 减存
   Lambda-stack-pointer 存
   已矣
者 动词也

夫 出木答栈
   (* 木答栈:: 值 --> 参数栈:: 值 *)
   Lambda-stack-pointer 取
   单元大小 址 Lambda-stack-pointer 加存
   已矣
者 动词也


夫 准备
   (* 参数栈:: a, b --> 木答栈:: a, b *)
   (* 注意 参数的顺序 *)
   换 入木答栈 入木答栈
   已矣
者 动词也

夫 召回
   (* 木答栈:: a, b --> 参数栈:: a, b *)
   (* 注意 参数的顺序 *)
   出木答栈 出木答栈 换
   已矣
者 动词也
夫 真乎       true?   已矣 者 动词也
夫 假乎       false?  已矣 者 动词也
夫 相等       ==       已矣 者 动词也
夫 不等       =/=      已矣 者 动词也

夫 小于       <        已矣 者 动词也
夫 不大于     <=       已矣 者 动词也

夫 大于       >        已矣 者 动词也
夫 不小于     >=       已矣 者 动词也

夫 零乎       zero?    已矣 者 动词也
夫 一乎       one?     已矣 者 动词也
(* 默认 位 指 二进制数的一位 *)
夫 位与    bitwise-and       已矣 者 动词也
夫 位或    bitwise-or        已矣 者 动词也
夫 位异或  bitwise-xor       已矣 者 动词也
夫 位反    bitwise-invert    已矣 者 动词也
夫 左移    shift-left        已矣 者 动词也
夫 右移    shift-right       已矣 者 动词也

夫 右移并保持符号
   shift-right-preserve-sign
   已矣
者 动词也
夫 读比特 read-byte  已矣 者 动词也
夫 写比特 write-byte 已矣 者 动词也
夫 比特串相等      equal-string?            已矣 者 动词也
夫 比特串之首      head-of-string           已矣 者 动词也
夫 比特串之尾      tail-of-string           已矣 者 动词也
夫 比特串之尾与首  tail-and-head-of-string  已矣 者 动词也


夫 比特串全为空白乎
   (* 比特串[地址, 长度] -- 真 或 假 *)
   复 零乎 则
      2 而弃 真 已矣
   再 比特串之尾与首
   32 (* ASCII-space *)
   <= 则
      比特串全为空白乎 已矣
   再 2 而弃  假 已矣
者 动词也

夫 写比特串
   (* 比特串[地址, 长度] -- *)
   复 零乎 则
      2 而弃 已矣
   再
   1 减 换
   复 小取 写比特
   1 加 换
   写比特串
   已矣
者 动词也



夫 换行
   (* -- *)
   10 (* ASCII-space *)
   写比特
   已矣
者 动词也
夫 首位编码->编码长度
   (* UTF-8 char -- length or 0 *)
   char-header->char-length
   已矣
者 动词也
夫 缓冲区,字串之尾与首 0 者 也


(* >< 下面的函数没有做错误处理 *)
夫 字串之尾与首
   (* 比特串[地址, 长度] --
      比特串[地址, 长度], UTF-8 字符 *)

   (* 清空 字之缓冲区 *)
   0 址 缓冲区,字串之尾与首 存

   跃 小取 首位编码->编码长度
   复 入木答栈
   1 2 而跃  址 缓冲区,字串之尾与首
   1 2 而换  复制比特串

   缓冲区,字串之尾与首
   出木答栈 换 入木答栈
     藏 减
     2 1 而换  加
     换
   出木答栈
   已矣
者 动词也
夫 缓冲区,写字 0 者 也

夫 写字
   (* UTF-8 字符 -- *)
   复 址 缓冲区,写字 存
   首位编码->编码长度
   址 缓冲区,写字
   换 写比特串
   已矣
者 动词也
夫 比特串代表整数乎
   (* 比特串[地址, 长度] -- 真 或 假 *)
   string-denote-integer?
   已矣
者 动词也
夫 比特串->整数,与误
   (* 比特串[地址, 长度] -- 整数, 真 *)
   (* 或 *)
   (* 比特串[地址, 长度] -- 0, 假 *)
   string->integer,with-error
   已矣
者 动词也
夫 符号项之个数           Number-of-symbol-entrys    者 也
夫 符号项值域之大小       Symbol-value-bytes-size    者 也
夫 符号项比特串域之大小   Symbol-string-bytes-size   者 也
夫 符号项长度域之大小     Symbol-length-bytes-size   者 也
夫 符号项之大小           Symbol-entry-bytes-size    者 也
夫 符号项比特串域之最大值 Symbol-max-length          者 也

夫 首个符号项         First-symbol-entry         者 也
夫 末个符号项         Last-symbol-entry          者 也
(*
 * 符号项 :
 * | 值域     |
 * | 比特串域 |
 * | 长度域   |
 *)

夫 索引->地址
   (* 索引 -- 地址 *)
   符号项之大小 乘
   首个符号项 加
   已矣
者 动词也

夫 索引-逆散->比特串
   (* 索引 -- 比特串[地址, 长度] *)
   索引->地址 单元大小 加
   复  1 加  换
   小取
   已矣
者 动词也


夫 助,比特串-散->索引,求和
   (* 和 , 比特串[地址, 长度] -- 和 *)
   复 零乎 则
      2 而弃  已矣
   再 比特串之尾与首
   跃 左移
   1 3 而换  加  2 1 而换
   助,比特串-散->索引,求和
   已矣
者 动词也


夫 助,比特串-散->索引,找旧或作新
   (* 比特串[地址, 长度], 索引 -- 索引 *)
   2 1 而藏
   索引-逆散->比特串
   (* 索引, 比特串[地址, 长度], 比特串-2[地址, 长度] *)
   复 零乎 则
      (* 作新 *)
      弃 跃 跃
      1 减  小存
      换
      复制比特串
      已矣
   再
   (* 索引, 比特串[地址, 长度], 比特串-2[地址, 长度] *)
   2 2 而跃 比特串相等 则 (* 找旧 *)
     2 而弃 已矣
   再
   1 2 而换  (* 以得 下一个 索引 *)
   (* 比特串[地址, 长度], 索引 *)
   复 索引->地址 末个符号项 相等 则
      弃
      0
      助,比特串-散->索引,找旧或作新
      已矣
   再
   1 加
   助,比特串-散->索引,找旧或作新
   已矣
者 动词也


夫 助,比特串-散->索引,和->索引
   (* 和 -- 索引 *)
   符号项之个数 模
   已矣
者 动词也


夫 比特串-散->索引
   (* 比特串[地址, 长度] -- 索引 *)
   2 而复
     复 符号项比特串域之最大值 > 则
        弃 符号项比特串域之最大值
        (*
         * 这意味着
         * 只有 前面的 符号项比特串域之最大值 个比特
         * 被 散列函数使用到了
         *)
     再  0  2 1 而换
     助,比特串-散->索引,求和
     助,比特串-散->索引,和->索引
   助,比特串-散->索引,找旧或作新
   已矣
者 动词也
夫 编撰数于数据段
   (* 数 -- *)
   (* 编撰 于 数据段 ::
        数 *)
   Current-data-section
   存
   Current-data-section
   单元大小 加
   址 Current-data-section 存
   已矣
者 动词也

夫 编撰比特于数据段
   (* 比特 -- *)
   (* 编撰 于 数据段 ::
        数 *)
   Current-data-section
   小存
   1 址 Current-data-section 加存
   已矣
者 动词也

(*
 * 注意
 * 比特串在 内存中的样子是:
 * | 1 单元 | 长度   |
 * | n 比特 | 比特串 |
 * | 1 比特 | 0      |
 *)

夫 编撰比特串于数据段
   (* 比特串[地址, 长度] -- *)
   (* 编撰 于 数据段 ::
    * | 1 单元 | 长度   |
    * | n 比特 | 比特串 |
    * | 1 比特 | 0      |
    *)
   复 入木答栈 (* 为更新 Current-data-section *)
     复 编撰数于数据段
     Current-data-section
     换 复制比特串
   (* 更新 Current-data-section *)
   出木答栈
   Current-data-section 加
   0 跃 小存
   1 加
   址 Current-data-section 存
   已矣
者 动词也
夫 执行       execute     已矣 者 动词也
夫 词->大小
   (* 词的链接[地址] -- 大小 *)
   单元大小 -2 乘 加 取
   已矣
者 动词也

夫 词->大小之地址
   (* 词的链接[地址] -- 大小之地址 *)
   单元大小 -2 乘 加
   已矣
者 动词也

夫 词->标识
   (* 词的链接[地址] -- 既是值又是地址 *)
   单元大小 -1 乘 加
   已矣
者 动词也

夫 词->类型
   (* 词的链接[地址] -- 类型 *)
   单元大小 加 取
   已矣
者 动词也

夫 词->类型之地址
   (* 词的链接[地址] -- 类型之地址 *)
   单元大小 加
   已矣
者 动词也

夫 词->名字
   (* 词的链接[地址] -- 比特串[地址, 长度] *)
   单元大小 2 乘 加
   取 复
   单元大小 加 (* 地址 *)
   换 取 (* 长度 *)
   已矣
者 动词也

夫 词->诠释者
   (* 词的链接[地址] -- 诠释者[地址] *)
   单元大小 3 乘 加
   已矣
者 动词也

夫 词->定义
   (* 词的链接[地址] -- 定义[地址] *)
   单元大小 4 乘 加
   已矣
者 动词也
夫 查词典
   (* 词串[地址, 长度] -- 词之链接[地址] 或 0 *)
   比特串-散->索引
   索引->地址
   取
   已矣
者 动词也
夫 比特串代表虚词乎
   (* 比特串[地址, 长度] -- 真 或 假 *)
   查词典
   复 0 == 则 已矣
   再 词->类型
   2#111 位与  1 == 则
     真 已矣
   再 假 已矣
者 动词也
夫 找词界之地址,首
   (* [地址, 长度] -- 地址 或 -1 *)
   复 零乎 则
      2 而复
      -1
      已矣
   再
   比特串之尾与首
   32 (* ASCII space *)
   大于 则
     弃 1 减
     已矣
   再
   找词界之地址,首
   已矣
者 动词也


(*
 * 下面的函数 对于 长度为 0 的词串的处理方式 与上面不同
 * 这使得对 尾 之寻找 总会成功
 * 所以 当 使用寻找到的结果 来做副作用时 要小心
 *)

夫 助,找词界之地址,尾
   (* [地址, 长度] -- 地址 或 -1 *)
   复 零乎 则
      弃
      已矣
   再
   比特串之尾与首
   32 (* ASCII space *)
   <= 则
      弃 1 减
      已矣
   再
   助,找词界之地址,尾
   已矣
者 动词也


夫 找词界之地址,尾
   (* [地址, 长度] -- 地址 或 -1 *)
   (*
    * 对第一个做特殊处理 以保证 不在词内部时 也能有效
    * 所以 要 使用 "助,找词界之地址,尾" 这个帮助函数
    *)
   复 零乎 则
      弃
      已矣
   再
   比特串之尾与首
   32 (* ASCII space *)
   <= 则
      (* 不在词内部时 先进入词的内部 *)
      2 而复  找词界之地址,首
      复 -1 == 则
         3 而弃
         -1
         已矣
      再
      (* [地址, 长度], 首部词界之地址 *)
      (* 利用所找到的地址 计算一个词的内部的地址 *)
      2 1 而藏
      1 2 而换
      减 减
   再
   (*
    * 第一个非 空白的 比特 已经被 弃了
    * 现在 要么 已经在 词之内了
    * 要么 就已经在 尾部词界 了
    *)
   助,找词界之地址,尾
   已矣
者 动词也


(* 索引起始于 0 *)

夫 找词界之索引,首
   (* [地址, 长度] -- 索引 或 -1 *)
   跃 换
   找词界之地址,首
   复 -1 == 则
      换 弃 (* 把 -1 留下 *)
      已矣
   再
   换 减
   已矣
者 动词也

夫 找词界之索引,尾
   (* [地址, 长度] -- 索引 或 -1 *)
   跃 换
   找词界之地址,尾
   复 -1 == 则
      换 弃 (* 把 -1 留下 *)
      已矣
   再
   换 减
   已矣
者 动词也
(* 下面的三个函数 不能作用于 全为空白 的 比特串
 * 在使用这些函数之前应该保证参数不是 全为空白 的 比特串
 *)

夫 词串之首
   (* 词串[地址, 长度] -- 名[地址, 长度] *)
   2 而复  找词界之地址,首
   (* 先不做错误处理 而假设上面的函数能够返回正确的地址 *)
   2 1 而换
   找词界之地址,尾
   跃 减
   已矣
者 动词也

夫 词串之尾
   (* 词串[地址, 长度] -- 词串[地址, 长度] *)
   2 而复  找词界之索引,尾
   (* 先不做错误处理 而假设上面的函数能够返回正确的地址 *)
   藏 减
   2 1 而换
   加 换
   已矣
者 动词也


夫 词串之尾与首
   (* 词串[地址, 长度] -- 词串[地址, 长度], 名[地址, 长度] *)
   2 而复
   词串之尾
   2 2 而换
   词串之首
   已矣
者 动词也
夫 编撰数于词典
   (* 数 -- *)
   (* 编撰 :: 数 *)
   Here 存
   Here 单元大小 加
   址 Here 存
   已矣
者 动词也


(*
 * 注意:
 * 比特串在栈中是: [地址, 长度]
 * 而在内存中是:
 *   | 1 (单元) : 长度 |
 *   | n (比特) : 比特串 |
 *   | 1 (比特) : 0 |
 *)

夫 编撰比特串于词典
   (* 比特串[地址, 长度] -- *)
   复 入木答栈
      复 编撰数于词典
      Here 换 复制比特串
   (* 更新 Here 全局变量 *)
   出木答栈
   Here 加
   0 跃 小存
   1 加
   址 Here 存
   已矣
者 动词也


夫 助,编撰词之定义于词典,数
   (* 比特串[地址, 长度] -- *)
   (* >< 这里 没有就 string-to-integer,with-error 的返回值
    * 做错误处理 *)
   即 _即 编撰数于词典
   比特串->整数,与误 弃
   编撰数于词典
   已矣
者 动词也

夫 助,编撰词之定义于词典,虚词
   (* 词串[地址, 长度], 比特串[地址, 长度] -- 词串[地址, 长度] *)
   (* >< 这里 没有就 "查词典" 的返回值
    * 做错误处理 *)
   查词典 词->诠释者 执行
   已矣
者 动词也

夫 助,编撰词之定义于词典,词
   (* 词[地址] -- *)
   词->诠释者 编撰数于词典
   已矣
者 动词也


夫 编撰词之定义于词典
   (* 词串[地址, 长度] -- *)
   2 而复  比特串全为空白乎 则
     2 而弃
     已矣
   再

   词串之尾与首

   (* 下面这句是 找错误的时候用的 *)
   (* 2 而复 写比特串 换行 *)

   2 而复  比特串代表整数乎 则
     助,编撰词之定义于词典,数
     编撰词之定义于词典 已矣
   再

   2 而复  比特串代表虚词乎 则
     助,编撰词之定义于词典,虚词
     编撰词之定义于词典 已矣
   再

   2 而复  查词典
   复 0 == 假乎 则
      2 1 而换  2 而弃
      助,编撰词之定义于词典,词
      编撰词之定义于词典 已矣
   再

   (* 下面的错误处理是不好的 今后将予以改进 *)
   弃
   比特串-散->索引
   添加符号于等待列表
   编撰词之定义于词典
   已矣
者 动词也
夫 作词头
   (* 比特串[地址, 长度] -- 词[地址] *)
   Here 入木答栈 (* 为了 名字头的地址 *)
     编撰比特串于词典
     0    编撰数于词典 (* 词之大小 *)
     Here 编撰数于词典 (* 词之标识 *)
     Here (* 留下 词之链接 作为 返回值 *)
     0    编撰数于词典 (* 词之链接 *)
     0    编撰数于词典 (* 词之类型 *)
   出木答栈 编撰数于词典 (* 词之名字头的地址 *)
   已矣
者 动词也
夫 添加新词入词典
   (* 词[地址] -- *)
   复

   (* 为新的 符号散列表 *)
   复
   词->名字 比特串-散->索引 索引->地址
   存

   (* 为旧的 单向连接的链表 *)
   (* 需要更新 First-word-in-dictionary 使它指向新加入词典的词 *)
   复 First-word-in-dictionary
   换 存 址 First-word-in-dictionary 存
   已矣
者 动词也
(*
 * 下面的函数必须 在定义词的函数的末尾被调用
 * 即 在 编撰词之定义于词典 之后
 * 因为 它把 Here 作为一个 隐含的参数
 *)

夫 设置词之大小
   (* 词[地址] -- *)
   复 词->定义
   Here 换 减
   单元大小 除
   换 词->大小之地址
   存
   已矣
者 动词也
夫 添加符号于等待列表
   add-symbol-to-waiting-symbol-list
   已矣
者 动词也

夫 消去符号于等待列表
   sub-symbol-from-waiting-symbol-list
   已矣
者 动词也
(* 下面利用 两个同名的函数来互相重新定义对方 *)

夫 函数也
   (* 词串[地址, 长度] -- *)
   词串之尾与首
   作词头
   复 入木答栈
      添加新词入词典
      动词诠释者 编撰数于词典
      编撰词之定义于词典
   出木答栈
   复 设置词之大小
   词->名字 比特串-散->索引
   消去符号于等待列表
   已矣
者 动词也


夫 动词也
   (* 词串[地址, 长度] -- *)
   词串之尾与首
   作词头
   复 入木答栈
      添加新词入词典
      动词诠释者 编撰数于词典
      编撰词之定义于词典
   出木答栈
   复 设置词之大小
   词->名字 比特串-散->索引
   消去符号于等待列表
   已矣
者 函数也
夫 虚词也
   (* 词串[地址, 长度] -- *)
   词串之尾与首
   作词头
   复 入木答栈
      添加新词入词典
      动词诠释者 编撰数于词典
      编撰词之定义于词典
   出木答栈
   复 设置词之大小
   词->类型之地址
   1 换 小存
   已矣
者 动词也
(*
 * 用 UTF-8 编码来处理汉字
 * 当 发现比特串所包含的不是单一的 UTF-8 字时
 * 需要 特殊处理或报错
 * 这里 先不做这些处理 而只取第一个 UTF-8 字
 *)

(* 字者 于机器而言 即 字之编码 *)
夫 比特串->字
   (* 比特串[地址, 长度] -- 字之编码 *)
   字串之尾与首
   2 1 而换
   2 而弃
   已矣
者 动词也


夫 字
   (* 词串[地址, 长度] -- 词串[地址, 长度] *)
   (* 编撰 ::
        _即[诠释者之地址], 字之编码 *)
   即 _即 编撰数于词典
   词串之尾与首
   比特串->字 编撰数于词典
   已矣
者 虚词也
ok
(*
 * 其名为 比特串
 * 这在于 我提供简单的 方式
 * 来 阅读那些不能打印的 比特
 *)
ok
