#+TITLE: old kernelloader


* ==================================================
* [fasm] old pure64
** about the size of kernelloader and kernel
   #+begin_src fasm :tangle no
   checkMagicNumberOfKernel equ yes
   checkMagicNumberOfEnglishCore equ yes

   SizeOfKernelloader = 6 ;; unit :: k
   LocationOfKernelloader = 32*1024
   MagicNumberOfKernelloader = 26766h

   SizeOfKernel = 512 ;; unit :: k
   LocationOfKernel = 2*1024*1024
   MagicNumberOfKernel = 26881h

   SizeOfEnglishCore = 512 ;; unit :: k
   LocationOfEnglishCore = 4*1024*1024
   MagicNumberOfEnglishCore = "(* m"

   ;; ;; for old-kernel
   ;; LocationOfKernel = 1*1024*1024
   ;; english.ccd equ not_using

   ;; ;; for other kernels that use kernelloader
   ;; LocationOfKernel = 1*1024*1024
   ;; checkMagicNumberOfKernel equ no
   ;; checkMagicNumberOfEnglishCore equ no
   #+end_src
** value & memory addresses
   #+begin_src fasm :tangle no
   ; GDT selector
   ;; SYS64_NULL_SEL =               ; Null Segment
   SYS64_CODE_SEL = 1*8            ; Code segment, read/execute, nonconforming
   ;; SYS64_DATA_SEL =               ; Data segment, read/write, expand down

   ; Memory locations
   E820Map                = 0x0000000000004000
   InfoMap                = 0x0000000000005000
   SystemVariables        = 0x0000000000005A00
   VBEModeInfoBlock       = 0x0000000000005C00  ; 256 bytes
   ahci_cmdlist           = 0x0000000000070000  ; 4096 bytes    0x070000 -> 0x071FFF
   ahci_cmdtable          = 0x0000000000072000  ; 57344 bytes   0x072000 -> 0x07FFFF
   
   ; DQ - Starting at offset 0, increments by 0x8
   os_ACPITableAddress    = SystemVariables + 0x00
   screen_cursor_offset   = SystemVariables + 0x08
   os_LocalX2APICAddress  = SystemVariables + 0x10
   os_Counter_Timer       = SystemVariables + 0x18
   os_Counter_RTC         = SystemVariables + 0x20
   os_LocalAPICAddress    = SystemVariables + 0x28
   os_IOAPICAddress       = SystemVariables + 0x30
   os_HPETAddress         = SystemVariables + 0x38
   
   ; DD - Starting at offset 128, increments by 4
   os_BSP                 = SystemVariables + 128
   mem_amount             = SystemVariables + 132
   os_VideoBase           = SystemVariables + 136
   
   ; DW - Starting at offset 256, increments by 2
   cpu_speed              = SystemVariables + 256
   cpu_activated          = SystemVariables + 258
   cpu_detected           = SystemVariables + 260
   
   ; DB - Starting at offset 384, increments by 1
   screen_cursor_x        = SystemVariables + 386
   screen_cursor_y        = SystemVariables + 387
   memtempstring          = SystemVariables + 390
   speedtempstring        = SystemVariables + 400
   cpu_amount_string      = SystemVariables + 410
   os_key                 = SystemVariables + 421
   os_IOAPICCount         = SystemVariables + 424   
   
   
   ; VESA
   ; Mandatory information for all VBE revisions
   VBEModeInfoBlock.ModeAttributes         = VBEModeInfoBlock + 0        ; DW - mode attributes
   VBEModeInfoBlock.WinAAttributes         = VBEModeInfoBlock + 2        ; DB - window A attributes
   VBEModeInfoBlock.WinBAttributes         = VBEModeInfoBlock + 3        ; DB - window B attributes
   VBEModeInfoBlock.WinGranularity         = VBEModeInfoBlock + 4        ; DW - window granularity in KB
   VBEModeInfoBlock.WinSize                = VBEModeInfoBlock + 6        ; DW - window size in KB
   VBEModeInfoBlock.WinASegment            = VBEModeInfoBlock + 8        ; DW - window A start segment
   VBEModeInfoBlock.WinBSegment            = VBEModeInfoBlock + 10       ; DW - window B start segment
   VBEModeInfoBlock.WinFuncPtr             = VBEModeInfoBlock + 12       ; DD - real mode pointer to window function
   VBEModeInfoBlock.BytesPerScanLine       = VBEModeInfoBlock + 16       ; DW - bytes per scan line
   ; Mandatory information for VBE 1.2 and above
   VBEModeInfoBlock.XResolution            = VBEModeInfoBlock + 18       ; DW - horizontal resolution in pixels or characters
   VBEModeInfoBlock.YResolution            = VBEModeInfoBlock + 20       ; DW - vertical resolution in pixels or characters
   VBEModeInfoBlock.XCharSize              = VBEModeInfoBlock + 22       ; DB - character cell width in pixels
   VBEModeInfoBlock.YCharSize              = VBEModeInfoBlock + 23       ; DB - character cell height in pixels
   VBEModeInfoBlock.NumberOfPlanes         = VBEModeInfoBlock + 24       ; DB - number of memory planes
   VBEModeInfoBlock.BitsPerPixel           = VBEModeInfoBlock + 25       ; DB - bits per pixel
   VBEModeInfoBlock.NumberOfBanks          = VBEModeInfoBlock + 26       ; DB - number of banks
   VBEModeInfoBlock.MemoryModel            = VBEModeInfoBlock + 27       ; DB - memory model type
   VBEModeInfoBlock.BankSize               = VBEModeInfoBlock + 28       ; DB - bank size in KB
   VBEModeInfoBlock.NumberOfImagePages     = VBEModeInfoBlock + 29       ; DB - number of image pages
   VBEModeInfoBlock.Reserved               = VBEModeInfoBlock + 30       ; DB - reserved (0x00 for VBE 1.0-2.0, 0x01 for VBE 3.0)
   ; Direct Color fields (r=ired for direct/6 and YUV/7 memory models)
   VBEModeInfoBlock.RedMaskSize            = VBEModeInfoBlock + 31       ; DB - size of direct color red mask in bits
   VBEModeInfoBlock.RedFieldPosition       = VBEModeInfoBlock + 32       ; DB - bit position of lsb of red mask
   VBEModeInfoBlock.GreenMaskSize          = VBEModeInfoBlock + 33       ; DB - size of direct color green mask in bits
   VBEModeInfoBlock.GreenFieldPosition     = VBEModeInfoBlock + 34       ; DB - bit position of lsb of green mask
   VBEModeInfoBlock.BlueMaskSize           = VBEModeInfoBlock + 35       ; DB - size of direct color blue mask in bits
   VBEModeInfoBlock.BlueFieldPosition      = VBEModeInfoBlock + 36       ; DB - bit position of lsb of blue mask
   VBEModeInfoBlock.RsvdMaskSize           = VBEModeInfoBlock + 37       ; DB - size of direct color reserved mask in bits
   VBEModeInfoBlock.RsvdFieldPosition      = VBEModeInfoBlock + 38       ; DB - bit position of lsb of reserved mask
   VBEModeInfoBlock.DirectColorModeInfo    = VBEModeInfoBlock + 39       ; DB - direct color mode attributes
   ; Mandatory information for VBE 2.0 and above
   VBEModeInfoBlock.PhysBasePtr            = VBEModeInfoBlock + 40       ; DD - physical address for flat memory frame buffer
   VBEModeInfoBlock.Reserved1              = VBEModeInfoBlock + 44       ; DD - Reserved - always set to 0
   VBEModeInfoBlock.Reserved2              = VBEModeInfoBlock + 48       ; DD - Reserved - always set to 0   
   #+end_src
** start and init_smp_ap
   #+begin_src fasm :tangle no
   use16
   org LocationOfKernelloader
   start:
	   cli                             ; Disable all interrupts
	   xor eax, eax
	   xor ebx, ebx
	   xor ecx, ecx
	   xor edx, edx
	   xor esi, esi
	   xor edi, edi
	   xor ebp, ebp
	   mov ds, ax
	   mov es, ax
	   mov ss, ax
	   mov fs, ax
	   mov gs, ax
	   mov esp, LocationOfKernelloader ; Set a known free location for the stack

   ap_modify:
	   jmp start16                     ; This command will be overwritten with 'NOP's before the AP's are started
	   nop                             ; The 'jmp' is only 3 bytes

   ; AP's will start execution at 0x8000 and fall through to this code
   init_smp_ap:
	   jmp 0x0000:clearcs_ap

   clearcs_ap:

   ; Enable the A20 gate
   set_A20_ap:
	   in al, 0x64
	   test al, 0x02
	   jnz set_A20_ap
	   mov al, 0xD1
	   out 0x64, al
   check_A20_ap:
	   in al, 0x64
	   test al, 0x02
	   jnz check_A20_ap
	   mov al, 0xDF
	   out 0x60, al

   ; At this point we are done with real mode and BIOS interrupts. Jump to 32-bit mode.
	   lgdt [cs:GDTR32]                ; load GDT register

	   mov eax, cr0                    ; switch to 32-bit protected mode
	   or al, 1
	   mov cr0, eax

	   jmp 8:startap32


   ;; =============================================================================
   ;; 32-bit mode
   align 16
   use32

   startap32:
	   mov eax, 16                     ; load 4 GB data descriptor
	   mov ds, ax                      ; to all data segment registers
	   mov es, ax
	   mov fs, ax
	   mov gs, ax
	   mov ss, ax
	   xor eax, eax
	   xor ebx, ebx
	   xor ecx, ecx
	   xor edx, edx
	   xor esi, esi
	   xor edi, edi
	   xor ebp, ebp
	   mov esp, 0x8000                 ; Set a known free location for the stack

   ; Load the GDT
	   lgdt [GDTR64]

   ; Enable extended properties
	   mov eax, cr4
	   or eax, 0x0000000B0             ; PGE (Bit 7), PAE (Bit 5), and PSE (Bit 4)
	   mov cr4, eax

   ; Point cr3 at PML4
	   mov eax, 0x00002008             ; Write-thru (Bit 3)
	   mov cr3, eax

   ; Enable long mode and SYSCALL/SYSRET
	   mov ecx, 0xC0000080             ; EFER MSR number
	   rdmsr                           ; Read EFER
	   or eax, 0x00000101              ; LME (Bit 8)
	   wrmsr                           ; Write EFER

   ; Enable paging to activate long mode
	   mov eax, cr0
	   bts eax, 31
	   ;or eax, 0x80000000              ; PG (Bit 31)
	   mov cr0, eax

   ; Make the jump directly from 16-bit real mode to 64-bit long mode
	   jmp SYS64_CODE_SEL:startap64


   ;; =============================================================================
   ;; 64-bit mode
   align 16
   use64

   startap64:
	   xor rax, rax                    ; aka r0
	   xor rbx, rbx                    ; aka r3
	   xor rcx, rcx                    ; aka r1
	   xor rdx, rdx                    ; aka r2
	   xor rsi, rsi                    ; aka r6
	   xor rdi, rdi                    ; aka r7
	   xor rbp, rbp                    ; aka r5
	   xor rsp, rsp                    ; aka r4
	   xor r8, r8
	   xor r9, r9
	   xor r10, r10
	   xor r11, r11
	   xor r12, r12
	   xor r13, r13
	   xor r14, r14
	   xor r15, r15

	   mov ds, ax                      ; Clear the legacy segment registers
	   mov es, ax
	   mov ss, ax
	   mov fs, ax
	   mov gs, ax

	   mov rax, clearcs64_ap
	   jmp rax
	   nop
   clearcs64_ap:
	   xor rax, rax

	   ; Reset the stack. Each CPU gets a 1024-byte unique stack location
	   mov rsi, [os_LocalAPICAddress]  ; We would call os_smp_get_id here but the stack is not ...
	   add rsi, 0x20                   ; ... yet defined. It is safer to find the value directly.
	   lodsd                           ; Load a 32-bit value. We only want the high 8 bits
	   shr rax, 24                     ; Shift to the right and AL now holds the CPU's APIC ID
	   shl rax, 10                     ; shift left 10 bits for a 1024byte stack
	   add rax, 0x0000000000050400     ; stacks decrement when you "push", start at 1024 bytes in
	   mov rsp, rax                    ; Pure64 leaves 0x50000-0x9FFFF free so we use that

	   lgdt [GDTR64]                   ; Load the GDT
	   lidt [IDTR64]                   ; load IDT register

   ; Enable Local APIC on AP
	   mov rsi, [os_LocalAPICAddress]
	   add rsi, 0x00f0                 ; Offset to Spurious Interrupt Register
	   mov rdi, rsi
	   lodsd
	   or eax, 0000000100000000b
	   stosd

	   call init_cpu                   ; Setup CPU

   ; Make sure exceptions are working.
   ;       xor rax, rax
   ;       xor rbx, rbx
   ;       xor rcx, rcx
   ;       xor rdx, rdx
   ;       div rax

	   lock inc word [cpu_activated]
	   xor eax, eax
	   mov rsi, [os_LocalAPICAddress]
	   add rsi, 0x20                   ; Add the offset for the APIC ID location
	   lodsd                           ; APIC ID is stored in bits 31:24
	   shr rax, 24                     ; AL now holds the CPU's APIC ID (0 - 255)
	   mov rdi, 0x00005700             ; The location where the cpu values are stored
	   add rdi, rax                    ; RDI points to infomap CPU area + APIC ID. ex F701 would be APIC ID 1
	   mov al, 1
	   stosb
	   sti                             ; Activate interrupts for SMP
	   jmp ap_sleep


   align 16

   ap_sleep:
	   hlt                             ; Suspend CPU until an interrupt is received. opcode for hlt is 0xF4
	   jmp ap_sleep                    ; just-in-case of an NMI
   #+end_src
** data
*** configuration
    #+begin_src fasm :tangle no   
    cfg_smpinit:            db 1    ; By default SMP is enabled. Set to 0 to disable.
    cfg_default:            db 0    ; By default we don't need a config file so set to 0. If a config file is found set to 1.
    cfg_e820:               db 1    ; By default E820 should be present. kernelloader will set this to 0 if not found/usable.
    cfg_mbr:                db 0    ; Did we boot off of a disk with a proper MBR
    cfg_hdd:                db 0    ; Was a bootable drive detected
    #+end_src
*** misc
    #+begin_src fasm :tangle no    
    screen_cols:            db 80
    screen_rows:            db 25
    hextable:               db '0123456789ABCDEF'
    #+end_src
*** strings
    #+begin_src fasm :tangle no    
    ;msg_announce_rmode:     db '* kernelloader in 16 bits mode', 13, 10, 0
    ;msg_announce_pmode:     db '* kernelloader in 32 bits mode', 13, 10, 0
    ;msg_announce_lmode:     db '* kernelloader in 64 bits mode', 13, 10, 0

    msg_announce_rmode:     db '* kernelloader in 16 bits mode', 10, 0
    msg_announce_pmode:     db '* kernelloader in 32 bits mode', 10, 0
    msg_announce_lmode:     db '* kernelloader in 64 bits mode', 10, 0

    msg_done:               db ' Done', 0
    msg_CPU:                db '[CPU: ', 0
    msg_mhz:                db 'MHz x', 0
    msg_MEM:                db ']  [MEM: ', 0
    msg_mb:                 db ' MiB]', 0
    msg_startingkernel:     db '* kernel loaded, trying to run it ...', 13, 13, 0
    msg_no_lmode:           db '* [ERROR] this computer does not support 64 bits mode', 13, 10, 0
    #+end_src
*** GDTR32
    #+begin_src fasm :tangle no
    align 16
    GDTR32:                                 ; Global Descriptors Table Register
    dw gdt32_end - gdt32 - 1                ; limit of GDT (size minus one)
    dq gdt32                                ; linear address of GDT
    
    align 16
    gdt32:
    dw 0x0000, 0x0000, 0x0000, 0x0000       ; Null desciptor
    dw 0xFFFF, 0x0000, 0x9A00, 0x00CF       ; 32-bit code descriptor
    dw 0xFFFF, 0x0000, 0x9200, 0x00CF       ; 32-bit data descriptor
    gdt32_end:    
    #+end_src
*** GDTR64
    #+begin_src fasm :tangle no
    align 16
    GDTR64:                                 ; Global Descriptors Table Register
            dw gdt64_end - gdt64 - 1        ; limit of GDT (size minus one)
            dq 0x0000000000001000           ; linear address of GDT
    
    align 16
    gdt64:                                  ; This structure is copied to 0x0000000000001000
            dq 0x0000000000000000
            ;dq 0x0020980000000000           ; 0x00209A0000000000
            ;db 0, 0, 0, 0, 0, 10011000b, 00100000b, 0
            db 0, 0, 0, 0, 0, 10011000b, 10100000b, 0
            dq 0x0000900000000000           ; 0x0020920000000000
    gdt64_end:
    
    align 16
    IDTR64:                                 ; Interrupt Descriptor Table Register
            dw 256*16-1                     ; limit of IDT (size minus one) (4096 bytes - 1)
            dq 0x0000000000000000           ; linear address of IDT
    #+end_src
** start16
*** >< note
*** implementation
    #+begin_src fasm :tangle no
    align 16
    use16
    
    start16:
            jmp 0x0000:clearcs_16
    clearcs_16:
    
    ; Make sure the screen is set to 80x25 color text mode
            mov ax, 3
            int 0x10
    
    ; Print message
            mov si, msg_announce_rmode
            call print_string_16
    
    ; Disable blinking
         mov ax, 0x1003
         mov bx, 0x0000
         int 0x10
    
    ;; ; Configure serial port
    ;;      xor dx, dx                      ; First serial port
    ;;      mov ax, 0000000011100011b       ; 9600 baud, no parity, 1 stop bit, 8 data bits
    ;;      int 0x14
    
    ; Check to make sure the CPU supports 64-bit mode... If not then bail out
            mov eax, 0x80000000             ; Extended-function 8000000h.
            cpuid                           ; Is largest extended function
            cmp eax, 0x80000000             ; any function > 80000000h?
            jbe no_lmode                ; If not, no long mode.
            mov eax, 0x80000001             ; Extended-function 8000001h.
            cpuid                           ; Now EDX = extended-features flags.
            bt edx, 29                      ; Test if long mode is supported.
            jnc no_lmode                ; Exit if not supported.
    
    ; Setup legacy hardware
            call init_ISA
    
    ; Hide the hardware cursor (interferes with print_string_16 if called earlier)
            mov ax, 0x0200                  ; VIDEO - SET CURSOR POSITION
            mov bx, 0x0000                  ; Page number
            mov dx, 0x2000                  ; Row / Column
            int 0x10
    
    ; Print message
            mov si, msg_announce_pmode
            call print_string_16
    
    ; At this point we are done with real mode and BIOS interrupts. Jump to 32-bit mode.
            lgdt [cs:GDTR32]                ; Load GDT register
    
            mov eax, cr0
            or al, 0x01                     ; Set protected mode bit
            mov cr0, eax
    
            ;; ;; for test
            ;; cli
            ;; hlt
    
            jmp 8:start32                   ; Jump to 32-bit protected mode
    #+end_src
*** helper functions
**** print_string_16
     #+begin_src fasm :tangle no        
     ; 16-bit function to print a sting to the screen
     align 16
     print_string_16:                        ; Output string in SI to screen
             pusha
             mov ah, 0x0E                    ; http://www.ctyme.com/intr/rb-0106.htm
     print_string_16_repeat:
             lodsb                           ; Get char from string
             cmp al, 0
             je print_string_16_done         ; If char is zero, end of string
             int 0x10                        ; Otherwise, print it
             jmp print_string_16_repeat
     print_string_16_done:
             popa
             ret
     #+end_src
**** no_lmode
     #+begin_src fasm :tangle no
     ; Display an error message that the CPU does not support 64-bit mode
     align 16
     no_lmode:
             mov si, msg_no_lmode
             call print_string_16
             cli
             hlt
     #+end_src
**** init_ISA
     #+begin_src fasm :tangle no
     align 16
     init_ISA:
	     mov edi, 0x00004000             ; Clear out memory for the E820 map
	     xor eax, eax
	     mov ecx, 2048
	     rep stosd

     ; Get the BIOS E820 Memory Map
     ; use the INT 0x15, eax= 0xE820 BIOS function to get a memory map
     ; inputs: es:di -> destination buffer for 24 byte entries
     ; outputs: bp = entry count, trashes all registers except esi
     do_e820:
	     mov edi, 0x00004000             ; location that memory map will be stored to
	     xor ebx, ebx                    ; ebx must be 0 to start
	     xor bp, bp                      ; keep an entry count in bp
	     mov edx, 0x0534D4150            ; Place "SMAP" into edx
	     mov eax, 0xe820
	     mov [es:di + 20], dword 1       ; force a valid ACPI 3.X entry
	     mov ecx, 24                     ; ask for 24 bytes
	     int 0x15
	     jc nomemmap                     ; carry set on first call means "unsupported function"
	     mov edx, 0x0534D4150            ; Some BIOSes apparently trash this register?
	     cmp eax, edx                    ; on success, eax must have been reset to "SMAP"
	     jne nomemmap
	     test ebx, ebx                   ; ebx = 0 implies list is only 1 entry long (worthless)
	     je nomemmap
	     jmp jmpin
     e820lp:
	     mov eax, 0xe820                 ; eax, ecx get trashed on every int 0x15 call
	     mov [es:di + 20], dword 1       ; force a valid ACPI 3.X entry
	     mov ecx, 24                     ; ask for 24 bytes again
	     int 0x15
	     jc memmapend                    ; carry set means "end of list already reached"
	     mov edx, 0x0534D4150            ; repair potentially trashed register
     jmpin:
	     jcxz skipent                    ; skip any 0 length entries
	     cmp cl, 20                      ; got a 24 byte ACPI 3.X response?
	     jbe notext
	     test byte [es:di + 20], 1       ; if so: is the "ignore this data" bit clear?
	     je skipent
     notext:
	     mov ecx, [es:di + 8]            ; get lower dword of memory region length
	     test ecx, ecx                   ; is the qword == 0?
	     jne goodent
	     mov ecx, [es:di + 12]           ; get upper dword of memory region length
	     jecxz skipent                   ; if length qword is 0, skip entry
     goodent:
	     inc bp                          ; got a good entry: ++count, move to next storage spot
	     add di, 32
     skipent:
	     test ebx, ebx                   ; if ebx resets to 0, list is complete
	     jne e820lp
     nomemmap:
	     mov byte [cfg_e820], 0          ; No memory map function
     memmapend:
	     xor eax, eax                    ; Create a blank record for termination (32 bytes)
	     mov ecx, 8
	     rep stosd

     ; Enable the A20 gate
     set_A20:
	     in al, 0x64
	     test al, 0x02
	     jnz set_A20
	     mov al, 0xD1
	     out 0x64, al
     check_A20:
	     in al, 0x64
	     test al, 0x02
	     jnz check_A20
	     mov al, 0xDF
	     out 0x60, al

     ; Set up RTC
     ; Port 0x70 is RTC Address, and 0x71 is RTC Data
     ; http://www.nondot.org/sabre/os/files/MiscHW/RealtimeClockFAQ.txt
     rtc_poll:
	     mov al, 0x0A                    ; Status Register A
	     out 0x70, al                    ; Select the address
	     in al, 0x71                     ; Read the data
	     test al, 0x80                   ; Is there an update in process?
	     jne rtc_poll                    ; If so then keep polling
	     mov al, 0x0A                    ; Status Register A
	     out 0x70, al                    ; Select the address
	     mov al, 00100110b               ; UIP (0), RTC@32.768KHz (010), Rate@1024Hz (0110)
	     out 0x71, al                    ; Write the data

	     ; Remap PIC IRQ's
	     mov al, 00010001b               ; begin PIC 1 initialization
	     out 0x20, al
	     mov al, 00010001b               ; begin PIC 2 initialization
	     out 0xA0, al
	     mov al, 0x20                    ; IRQ 0-7: interrupts 20h-27h
	     out 0x21, al
	     mov al, 0x28                    ; IRQ 8-15: interrupts 28h-2Fh
	     out 0xA1, al
	     mov al, 4
	     out 0x21, al
	     mov al, 2
	     out 0xA1, al
	     mov al, 1
	     out 0x21, al
	     out 0xA1, al

	     ; Mask all PIC interrupts
	     mov al, 0xFF
	     out 0x21, al
	     out 0xA1, al


       	ret
     #+end_src
** start32
*** >< note
*** implementation
    #+begin_src fasm :tangle no 
    align 16
    use32
    
    start32:
            mov eax, 16                     ; load 4 GB data descriptor
            mov ds, ax                      ; to all data segment registers
            mov es, ax
            mov fs, ax
            mov gs, ax
            mov ss, ax
            xor eax, eax
            xor ebx, ebx
            xor ecx, ecx
            xor edx, edx
            xor esi, esi
            xor edi, edi
            xor ebp, ebp
            mov esp, 0x8000                 ; Set a known free location for the stack
    
            ;; mov al, '2'                     ; Now in 32-bit protected mode (0x20 = 32)
            ;; mov [0x000B809C], al
            ;; mov al, '0'
            ;; mov [0x000B809E], al
    
    ; Clear out the first 4096 bytes of memory. This will store the 64-bit IDT, GDT, PML4, and PDP
            mov ecx, 1024
            xor eax, eax
            mov edi, eax
            rep stosd
    
    ; Clear memory for the Page Descriptor Entries (0x10000 - 0x4FFFF)
            mov edi, 0x00010000
            mov ecx, 65536
            rep stosd
    
    ; Copy the GDT to its final location in memory
            mov esi, gdt64
            mov edi, 0x00001000             ; GDT address
            mov ecx, (gdt64_end - gdt64)
            rep movsb                       ; Move it to final pos.
    
    ; Create the Level 4 Page Map. (Maps 4GBs of 2MB pages)
    ; First create a PML4 entry.
    ; PML4 is stored at 0x0000000000002000, create the first entry there
    ; A single PML4 entry can map 512GB with 2MB pages.
            cld
            mov edi, 0x00002000             ; Create a PML4 entry for the first 4GB of RAM
            mov eax, 0x00003007
            stosd
            xor eax, eax
            stosd
    
            mov edi, 0x00002800             ; Create a PML4 entry for higher half (starting at 0xFFFF800000000000)
            mov eax, 0x00003007             ; The higher half is identity mapped to the lower half
            stosd
            xor eax, eax
            stosd
    
    ; Create the PDP entries.
    ; The first PDP is stored at 0x0000000000003000, create the first entries there
    ; A single PDP entry can map 1GB with 2MB pages
            mov ecx, 64                     ; number of PDPE's to make.. each PDPE maps 1GB of physical memory
            mov edi, 0x00003000
            mov eax, 0x00010007             ; location of first PD
    create_pdpe:
            stosd
            push eax
            xor eax, eax
            stosd
            pop eax
            add eax, 0x00001000             ; 4K later (512 records x 8 bytes)
            dec ecx
            cmp ecx, 0
            jne create_pdpe
    
    ; Create the PD entries.
    ; PD entries are stored starting at 0x0000000000010000 and ending at 0x000000000004FFFF (256 KiB)
    ; This gives us room to map 64 GiB with 2 MiB pages
            mov edi, 0x00010000
            mov eax, 0x0000008F             ; Bit 7 must be set to 1 as we have 2 MiB pages
            xor ecx, ecx
    pd_again:                               ; Create a 2 MiB page
            stosd
            push eax
            xor eax, eax
            stosd
            pop eax
            add eax, 0x00200000
            inc ecx
            cmp ecx, 2048
            jne pd_again                    ; Create 2048 2 MiB page maps.
    
    ; Load the GDT
            lgdt [GDTR64]
    
    ; Enable extended properties
            mov eax, cr4
            or eax, 0x0000000B0             ; PGE (Bit 7), PAE (Bit 5), and PSE (Bit 4)
            mov cr4, eax
    
    ; Point cr3 at PML4
            mov eax, 0x00002008             ; Write-thru (Bit 3)
            mov cr3, eax
    
    ; Enable long mode and SYSCALL/SYSRET
            mov ecx, 0xC0000080             ; EFER MSR number
            rdmsr                           ; Read EFER
            or eax, 0x00000101              ; LME (Bit 8)
            wrmsr                           ; Write EFER
    
    ;; ; Debug
    ;;         mov al, '1'                     ; About to make the jump into 64-bit mode
    ;;         mov [0x000B809C], al
    ;;         mov al, 'E'
    ;;         mov [0x000B809E], al
    
    ; Enable paging to activate long mode
            mov eax, cr0
            bts eax, 31            ; PG (Bit 31)
            mov cr0, eax
    
            jmp SYS64_CODE_SEL:start64      ; Jump to 64-bit mode
    #+end_src
** start64
*** >< note
*** implementation
    #+begin_src fasm :tangle no
    align 16
    use64
    
    start64:
    ; Debug
            ;; mov al, '4'                     ; Now in 64-bit mode (0x40 = 64)
            ;; mov [0x000B809C], al
            ;; mov al, '0'
            ;; mov [0x000B809E], al
    
            mov al, 2
            mov ah, 22
            call os_move_cursor
    
            ;; mov al, 5
            ;; mov ah, 0
            ;; call os_move_cursor
    
            xor rax, rax                    ; aka r0
            xor rbx, rbx                    ; aka r3
            xor rcx, rcx                    ; aka r1
            xor rdx, rdx                    ; aka r2
            xor rsi, rsi                    ; aka r6
            xor rdi, rdi                    ; aka r7
            xor rbp, rbp                    ; aka r5
            mov rsp, 0x8000                 ; aka r4
            xor r8, r8
            xor r9, r9
            xor r10, r10
            xor r11, r11
            xor r12, r12
            xor r13, r13
            xor r14, r14
            xor r15, r15
    
            mov ds, ax                      ; Clear the legacy segment registers
            mov es, ax
            mov ss, ax
            mov fs, ax
            mov gs, ax
    
            mov rax, clearcs64              ; Do a proper 64-bit jump. Should not be needed as the ...
            jmp rax                         ; jmp SYS64_CODE_SEL:start64 would have sent us ...
            nop                             ; out of compatibility mode and into 64-bit mode
    clearcs64:
            xor rax, rax
    
            lgdt [GDTR64]                   ; Reload the GDT
    
    ; Debug
            mov al, '2'
            mov [0x000B809E], al
    
    ; Patch kernelloader AP code            ; The AP's will be told to start execution at 0x8000
            mov edi, ap_modify              ; We need to remove the BSP Jump call to get the AP's
            mov eax, 0x90909090             ; to fall through to the AP Init code
            stosd
    
    ; Build the rest of the page tables (4GiB+)
            mov rcx, 0x0000000000000000
            mov rax, 0x000000010000008F
            mov rdi, 0x0000000000014000
    buildem:
            stosq
            add rax, 0x0000000000200000
            add rcx, 1
            cmp rcx, 30720                  ; Another 60 GiB (We already mapped 4 GiB)
            jne buildem
            ; We have 64 GiB mapped now
    
    ; Build a temporary IDT
            xor rdi, rdi                    ; create the 64-bit IDT (at linear address 0x0000000000000000)
    
            mov rcx, 32
    make_exception_gates:                   ; make gates for exception handlers
            mov rax, exception_gate
            push rax                        ; save the exception gate to the stack for later use
            stosw                           ; store the low word (15..0) of the address
            mov ax, SYS64_CODE_SEL
            stosw                           ; store the segment selector
            mov ax, 0x8E00
            stosw                           ; store exception gate marker
            pop rax                         ; get the exception gate back
            shr rax, 16
            stosw                           ; store the high word (31..16) of the address
            shr rax, 16
            stosd                           ; store the extra high dword (63..32) of the address.
            xor rax, rax
            stosd                           ; reserved
            dec rcx
            jnz make_exception_gates
    
            mov rcx, 256-32
    make_interrupt_gates:                   ; make gates for the other interrupts
            mov rax, interrupt_gate
            push rax                        ; save the interrupt gate to the stack for later use
            stosw                           ; store the low word (15..0) of the address
            mov ax, SYS64_CODE_SEL
            stosw                           ; store the segment selector
            mov ax, 0x8F00
            stosw                           ; store interrupt gate marker
            pop rax                         ; get the interrupt gate back
            shr rax, 16
            stosw                           ; store the high word (31..16) of the address
            shr rax, 16
            stosd                           ; store the extra high dword (63..32) of the address.
            xor rax, rax
            stosd                           ; reserved
            dec rcx
            jnz make_interrupt_gates
    
            ; Set up the exception gates for all of the CPU exceptions
            ; The following code will be seriously busted if the exception gates are moved above 16MB
            mov word [0x00*16], exception_gate_00
            mov word [0x01*16], exception_gate_01
            mov word [0x02*16], exception_gate_02
            mov word [0x03*16], exception_gate_03
            mov word [0x04*16], exception_gate_04
            mov word [0x05*16], exception_gate_05
            mov word [0x06*16], exception_gate_06
            mov word [0x07*16], exception_gate_07
            mov word [0x08*16], exception_gate_08
            mov word [0x09*16], exception_gate_09
            mov word [0x0A*16], exception_gate_10
            mov word [0x0B*16], exception_gate_11
            mov word [0x0C*16], exception_gate_12
            mov word [0x0D*16], exception_gate_13
            mov word [0x0E*16], exception_gate_14
            mov word [0x0F*16], exception_gate_15
            mov word [0x10*16], exception_gate_16
            mov word [0x11*16], exception_gate_17
            mov word [0x12*16], exception_gate_18
            mov word [0x13*16], exception_gate_19
    
            mov rdi, 0x21                   ; Set up Keyboard handler
            mov rax, keyboard
            call create_gate
            mov rdi, 0x22                   ; Set up Cascade handler
            mov rax, cascade
            call create_gate
            mov rdi, 0x28                   ; Set up RTC handler
            mov rax, rtc
            call create_gate
    
            lidt [IDTR64]                   ; load IDT register
    
    ; Debug
            mov al, '4'
            mov [0x000B809E], al
    
    ; Clear memory 0xf000 - 0xf7ff for the infomap (2048 bytes)
            xor rax, rax
            mov rcx, 256
            mov rdi, 0x000000000000F000
    clearmapnext:
            stosq
            dec rcx
            cmp rcx, 0
            jne clearmapnext
    
            call init_acpi                  ; Find and process the ACPI tables
    
            call init_cpu                   ; Configure the BSP CPU
    
            call init_pic                   ; Configure the PIC(s), also activate interrupts
    
    ; Debug
            mov al, '6'                     ; CPU Init complete
            mov [0x000B809E], al
    
    ; Make sure exceptions are working.
    ;       xor rax, rax
    ;       xor rbx, rbx
    ;       xor rcx, rcx
    ;       xor rdx, rdx
    ;       div rax
    
    ; Reset the stack to the proper location (was set to 0x8000 previously)
            mov rsi, [os_LocalAPICAddress]  ; We would call os_smp_get_id here but the stack is not ...
            add rsi, 0x20                   ; ... yet defined. It is safer to find the value directly.
            lodsd                           ; Load a 32-bit value. We only want the high 8 bits
            shr rax, 24                     ; Shift to the right and AL now holds the CPU's APIC ID
            shl rax, 10                     ; shift left 10 bits for a 1024byte stack
            add rax, 0x0000000000050400     ; stacks decrement when you "push", start at 1024 bytes in
            mov rsp, rax                    ; kernelloader leaves 0x50000-0x9FFFF free so we use that
    
    ; Debug
            mov al, '6'                     ; SMP Init complete
            mov [0x000B809C], al
            mov al, '0'
            mov [0x000B809E], al
    
    ; Calculate amount of usable RAM from Memory Map
            xor rcx, rcx
            mov rsi, 0x0000000000004000     ; E820 Map location
    readnextrecord:
            lodsq
            lodsq
            lodsd
            cmp eax, 0                      ; Are we at the end?
            je endmemcalc
            cmp eax, 1                      ; Useable RAM
            je goodmem
            cmp eax, 3                      ; ACPI Reclaimable
            je goodmem
            cmp eax, 6                      ; BIOS Reclaimable
            je goodmem
            lodsd
            lodsq
            jmp readnextrecord
    goodmem:
            sub rsi, 12
            lodsq
            add rcx, rax
            lodsq
            lodsq
            jmp readnextrecord
    
    endmemcalc:
            shr rcx, 20                     ; Value is in bytes so do a quick divide by 1048576 to get MiB's
            add ecx, 1                      ; The BIOS will usually report actual memory minus 1
            and ecx, 0xFFFFFFFE             ; Make sure it is an even number (in case we added 1 to an even number)
            mov dword [mem_amount], ecx
    
    ; Debug
            mov al, '2'
            mov [0x000B809E], al
    
    ; Convert CPU speed value to string
            xor rax, rax
            mov ax, [cpu_speed]
            mov rdi, speedtempstring
            call os_int_to_string
    
    ; Convert CPU amount value to string
            xor rax, rax
            mov ax, [cpu_activated]
            mov rdi, cpu_amount_string
            call os_int_to_string
    
    ; Convert RAM amount value to string
            xor rax, rax
            mov eax, [mem_amount]
            mov rdi, memtempstring
            call os_int_to_string
    
    ; Build the infomap
            xor rdi, rdi
            mov di, 0x5000
            mov rax, [os_ACPITableAddress]
            stosq
            mov eax, [os_BSP]
            stosd
    
            mov di, 0x5010
            mov ax, [cpu_speed]
            stosw
            mov ax, [cpu_activated]
            stosw
            mov ax, [cpu_detected]
            stosw
    
            mov di, 0x5020
            mov ax, [mem_amount]
            stosd
    
            mov di, 0x5030
            mov al, [os_IOAPICCount]
            stosb
    
            mov di, 0x5040
            mov rax, [os_HPETAddress]
            stosq
    
            mov di, 0x5060
            mov rax, [os_LocalAPICAddress]
            stosq
            xor ecx, ecx
            mov cl, [os_IOAPICCount]
            mov rsi, os_IOAPICAddress
    nextIOAPIC:
            lodsq
            stosq
            sub cl, 1
            cmp cl, 0
            jne nextIOAPIC
    
            mov di, 0x5080
            mov eax, [VBEModeInfoBlock.PhysBasePtr]         ; Base address of video memory (if graphics mode is set)
            stosd
            mov eax, [VBEModeInfoBlock.XResolution]         ; X and Y resolution (16-bits each)
            stosd
            mov al, [VBEModeInfoBlock.BitsPerPixel]         ; Color depth
            stosb
    
    ; Initialization is now complete... write a message to the screen
            mov rsi, msg_done
            call os_print_string
    
    ; Debug
            mov al, '4'
            mov [0x000B809E], al
    
    ; Print info on CPU and MEM
            mov ax, 0x0004
            call os_move_cursor
            mov rsi, msg_CPU
            call os_print_string
            mov rsi, speedtempstring
            call os_print_string
            mov rsi, msg_mhz
            call os_print_string
            mov rsi, cpu_amount_string
            call os_print_string
            mov rsi, msg_MEM
            call os_print_string
            mov rsi, memtempstring
            call os_print_string
            mov rsi, msg_mb
            call os_print_string
    
    
    if checkMagicNumberOfKernelloader eq yes
            mov eax, dword[LocationOfKernel + SizeOfKernel*1024 - 4]
            cmp eax, MagicNumberOfKernel
            jne magic_fail
    end if
    
    if checkMagicNumberOfEnglishCore eq yes
            mov eax, dword[LocationOfEnglishCore]
            cmp eax, MagicNumberOfEnglishCore
            jne magic_fail
    end if
    
    ; Print a message that the kernel is being started
            mov ax, 0x0006
            call os_move_cursor
            mov rsi, msg_startingkernel
            call os_print_string
    
    ; Debug
            mov rdi, 0x000B8092             ; Clear the debug messages
            mov ax, 0x0720
            mov cx, 7
    clearnext:
            stosw
            sub cx, 1
            cmp cx, 0
            jne clearnext
    
    ; Clear all registers (skip the stack pointer)
            xor rax, rax
            xor rbx, rbx
            xor rcx, rcx
            xor rdx, rdx
            xor rsi, rsi
            xor rdi, rdi
            xor rbp, rbp
            xor r8, r8
            xor r9, r9
            xor r10, r10
            xor r11, r11
            xor r12, r12
            xor r13, r13
            xor r14, r14
            xor r15, r15
    
            mov rsp, 10*1024*1024
    
            ;; ;; for test
            ;; cli
            ;; hlt
    
    
            jmp LocationOfKernel
    
    
    magic_fail:
            mov rsi, msg_MagicFail
            call os_print_string
            hlt
    
    msg_MagicFail:  db "kernelloader magic fail", 13, 10, 0
    #+end_src
*** helper functions
**** init ACPI
     #+begin_src fasm :tangle no
     init_acpi:
	     mov rsi, 0x00000000000E0000     ; Start looking for the Root System Description Pointer Structure
	     mov rbx, 'RSD PTR '             ; This in the Signature for the ACPI Structure Table (0x2052545020445352)
     searchingforACPI:
	     lodsq                           ; Load a quad word from RSI and store in RAX, then increment RSI by 8
	     cmp rax, rbx
	     je foundACPI
	     cmp rsi, 0x00000000000FFFFF     ; Keep looking until we get here
	     jge noACPI                      ; ACPI tables couldn't be found, Fail.
	     jmp searchingforACPI

     foundACPI:                              ; Found a Pointer Structure, verify the checksum
	     push rsi
	     xor ebx, ebx
	     mov ecx, 20                     ; As per the spec only the first 20 bytes matter
	     sub rsi, 8                      ; Bytes 0 thru 19 must sum to zero
     nextchecksum:
	     lodsb                           ; Get a byte
	     add bl, al                      ; Add it to the running total
	     sub cl, 1
	     cmp cl, 0
	     jne nextchecksum
	     pop rsi
	     cmp bl, 0
	     jne searchingforACPI            ; Checksum didn't check out? Then keep looking.

	     lodsb                           ; Checksum
	     lodsd                           ; OEMID (First 4 bytes)
	     lodsw                           ; OEMID (Last 2 bytes)
	     lodsb                           ; Grab the Revision value (0 is v1.0, 1 is v2.0, 2 is v3.0, etc)
	     add al, 49
	     mov [0x000B8098], al            ; Print the ACPI version number
	     sub al, 49
	     cmp al, 0
	     je foundACPIv1                  ; If AL is 0 then the system is using ACPI v1.0
	     jmp foundACPIv2                 ; Otherwise it is v2.0 or higher

     foundACPIv1:
	     xor eax, eax
	     lodsd                           ; Grab the 32 bit physical address of the RSDT (Offset 16).
	     mov rsi, rax                    ; RSI now points to the RSDT
	     lodsd                           ; Grab the Signiture
	     cmp eax, 'RSDT'                 ; Make sure the signiture is valid
	     jne novalidacpi                 ; Not the same? Bail out
	     sub rsi, 4
	     mov [os_ACPITableAddress], rsi  ; Save the RSDT Table Address
	     add rsi, 4
	     xor eax, eax
	     lodsd                           ; Length
	     add rsi, 28                     ; Skip to the Entry offset
	     sub eax, 36                     ; EAX holds the table size. Subtract the preamble
	     shr eax, 2                      ; Divide by 4
	     mov rdx, rax                    ; RDX is the entry count
	     xor ecx, ecx
     foundACPIv1_nextentry:
	     lodsd
	     push rax
	     add ecx, 1
	     cmp ecx, edx
	     je findACPITables
	     jmp foundACPIv1_nextentry

     foundACPIv2:
	     lodsd                           ; RSDT Address
	     lodsd                           ; Length
	     lodsq                           ; Grab the 64 bit physical address of the XSDT (Offset 24).
	     mov rsi, rax                    ; RSI now points to the XSDT
	     lodsd                           ; Grab the Signiture
	     cmp eax, 'XSDT'                 ; Make sure the signiture is valid
	     jne novalidacpi                 ; Not the same? Bail out
	     sub rsi, 4
	     mov [os_ACPITableAddress], rsi  ; Save the XSDT Table Address
	     add rsi, 4
	     xor eax, eax
	     lodsd                           ; Length
	     add rsi, 28                     ; Skip to the start of the Entries (offset 36)
	     sub eax, 36                     ; EAX holds the table size. Subtract the preamble
	     shr eax, 3                      ; Divide by 8
	     mov rdx, rax                    ; RDX is the entry count
	     xor ecx, ecx
     foundACPIv2_nextentry:
	     lodsq
	     push rax
	     add ecx, 1
	     cmp ecx, edx
	     jne foundACPIv2_nextentry

     findACPITables:
	     mov al, '3'                     ; Search through the ACPI tables
	     mov [0x000B809C], al
	     mov al, '4'
	     mov [0x000B809E], al
	     xor ecx, ecx
     nextACPITable:
	     pop rsi
	     lodsd
	     add ecx, 1
	     mov ebx, 'APIC'                 ; Signature for the Multiple APIC Description Table
	     cmp eax, ebx
	     je foundAPICTable
	     mov ebx, 'HPET'                 ; Signiture for the HPET Description Table
	     cmp eax, ebx
	     je foundHPETTable
	     cmp ecx, edx
	     jne nextACPITable
	     jmp init_smp_acpi_done          ;noACPIAPIC

     foundAPICTable:
	     call parseAPICTable
	     jmp nextACPITable

     foundHPETTable:
	     call parseHPETTable
	     jmp nextACPITable

     init_smp_acpi_done:
	     ret

     noACPI:
     novalidacpi:
	     mov al, 'X'
	     mov [0x000B809A], al
	     jmp $


     ; -----------------------------------------------------------------------------
     parseAPICTable:
	     push rcx
	     push rdx

	     lodsd                           ; Length of MADT in bytes
	     mov ecx, eax                    ; Store the length in ECX
	     xor ebx, ebx                    ; EBX is the counter
	     lodsb                           ; Revision
	     lodsb                           ; Checksum
	     lodsd                           ; OEMID (First 4 bytes)
	     lodsw                           ; OEMID (Last 2 bytes)
	     lodsq                           ; OEM Table ID
	     lodsd                           ; OEM Revision
	     lodsd                           ; Creator ID
	     lodsd                           ; Creator Revision
	     xor eax, eax
	     lodsd                           ; Local APIC Address
	     mov [os_LocalAPICAddress], rax  ; Save the Address of the Local APIC
	     lodsd                           ; Flags
	     add ebx, 44
	     mov rdi, 0x0000000000005100     ; Valid CPU IDs

     readAPICstructures:
	     cmp ebx, ecx
	     jge parseAPICTable_done
     ;       call os_print_newline
	     lodsb                           ; APIC Structure Type
     ;       call os_debug_dump_al
     ;       push rax
     ;       mov al, ' '
     ;       call os_print_char
     ;       pop rax
	     cmp al, 0x00                    ; Processor Local APIC
	     je APICapic
	     cmp al, 0x01                    ; I/O APIC
	     je APICioapic
	     cmp al, 0x02                    ; Interrupt Source Override
	     je APICinterruptsourceoverride
     ;       cmp al, 0x03                    ; Non-maskable Interrupt Source (NMI)
     ;       je APICnmi
     ;       cmp al, 0x04                    ; Local APIC NMI
     ;       je APIClocalapicnmi
     ;       cmp al, 0x05                    ; Local APIC Address Override
     ;       je APICaddressoverride
	     cmp al, 0x09                    ; Processor Local x2APIC
	     je APICx2apic
     ;       cmp al, 0x0A                    ; Local x2APIC NMI
     ;       je APICx2nmi

	     jmp APICignore

     APICapic:
	     xor eax, eax
	     xor edx, edx
	     lodsb                           ; Length (will be set to 8)
	     add ebx, eax
	     lodsb                           ; ACPI Processor ID
	     lodsb                           ; APIC ID
	     xchg eax, edx                   ; Save the APIC ID to EDX
	     lodsd                           ; Flags (Bit 0 set if enabled/usable)
	     bt eax, 0                       ; Test to see if usable
	     jnc readAPICstructures          ; Read the next structure if CPU not usable
	     inc word [cpu_detected]
	     xchg eax, edx                   ; Restore the APIC ID back to EAX
	     stosb
	     jmp readAPICstructures          ; Read the next structure

     APICioapic:
	     xor eax, eax
	     lodsb                           ; Length (will be set to 12)
	     add ebx, eax
	     lodsb                           ; IO APIC ID
	     lodsb                           ; Reserved
	     xor eax, eax
	     lodsd                           ; IO APIC Address
	     push rdi
	     push rcx
	     mov rdi, os_IOAPICAddress
	     xor ecx, ecx
	     mov cl, [os_IOAPICCount]
	     shl cx, 3                       ; Quick multiply by 8
	     add rdi, rcx
	     pop rcx
	     stosd                           ; Store the IO APIC Address
	     lodsd                           ; System Vector Base
	     stosd                           ; Store the IO APIC Vector Base
	     pop rdi
	     inc byte [os_IOAPICCount]
	     jmp readAPICstructures          ; Read the next structure

     APICinterruptsourceoverride:
	     xor eax, eax
	     lodsb                           ; Length (will be set to 10)
	     add ebx, eax
	     lodsb                           ; Bus
	     lodsb                           ; Source
     ;       call os_print_newline
     ;       call os_debug_dump_al
     ;       mov al, ' '
     ;       call os_print_char
	     lodsd                           ; Global System Interrupt
     ;       call os_debug_dump_eax
	     lodsw                           ; Flags
	     jmp readAPICstructures          ; Read the next structure

     APICx2apic:
	     xor eax, eax
	     xor edx, edx
	     lodsb                           ; Length (will be set to 16)
	     add ebx, eax
	     lodsw                           ; Reserved; Must be Zero
	     lodsd
	     xchg eax, edx                   ; Save the x2APIC ID to EDX
	     lodsd                           ; Flags (Bit 0 set if enabled/usable)
	     bt eax, 0                       ; Test to see if usable
	     jnc APICx2apicEnd               ; Read the next structure if CPU not usable
	     xchg eax, edx                   ; Restore the x2APIC ID back to EAX
	     call os_debug_dump_eax
	     call os_print_newline
	     ; Save the ID's somewhere
     APICx2apicEnd:
	     lodsd                           ; ACPI Processor UID
	     jmp readAPICstructures          ; Read the next structure

     APICignore:
	     xor eax, eax
	     lodsb                           ; We have a type that we ignore, read the next byte
	     add ebx, eax
	     add rsi, rax
	     sub rsi, 2                      ; For the two bytes just read
	     jmp readAPICstructures          ; Read the next structure

     parseAPICTable_done:
	     pop rdx
	     pop rcx
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     parseHPETTable:
	     lodsd                           ; Length of HPET in bytes
	     lodsb                           ; Revision
	     lodsb                           ; Checksum
	     lodsd                           ; OEMID (First 4 bytes)
	     lodsw                           ; OEMID (Last 2 bytes)
	     lodsq                           ; OEM Table ID
	     lodsd                           ; OEM Revision
	     lodsd                           ; Creator ID
	     lodsd                           ; Creator Revision
	     lodsd                           ; Event Timer Block ID
	     lodsd                           ; Base Address Settings
	     lodsq                           ; Base Address Value
	     mov [os_HPETAddress], rax       ; Save the Address of the HPET
	     lodsb                           ; HPET Number
	     lodsw                           ; Main Counter Minimum
	     lodsw                           ; Page Protection And OEM Attribute
	     ret
     ; -----------------------------------------------------------------------------
     #+end_src
**** init CPU
     #+begin_src fasm :tangle no
     init_cpu:
     
     ;; ; Disable Cache
     ;;         mov rax, cr0
     ;;         btr rax, 29                     ; Clear No Write Thru (Bit 29)
     ;;         bts rax, 30                     ; Set Cache Disable (Bit 30)
     ;;         mov cr0, rax
     ;;
     ;; ; Flush Cache
     ;;         wbinvd
     
     ; Disable Paging Global Extensions
             mov rax, cr4
             btr rax, 7                      ; Clear Paging Global Extensions (Bit 7)
             mov cr4, rax
             mov rax, cr3
             mov cr3, rax
     
     ; Disable MTRRs and Configure default memory type to UC
             mov ecx, 0x000002FF
             rdmsr
             and eax, 0xFFFFF300             ; Clear MTRR Enable (Bit 11), Fixed Range MTRR Enable (Bit 10), and Default Memory Type (Bits 7:0) to UC (0x00)
             wrmsr
     
     ; Setup variable-size address ranges
     ; Cache 0-64 MiB as type 6 (WB) cache
     ; See example in Intel Volume 3A. Example Base and Mask Calculations
     ;       mov ecx, 0x00000200             ; MTRR_Phys_Base_MSR(0)
     ;       mov edx, 0x00000000             ; Base is EDX:EAX, 0x0000000000000006
     ;       mov eax, 0x00000006             ; Type 6 (write-back cache)
     ;       wrmsr
     ;       mov ecx, 0x00000201             ; MTRR_Phys_Mask_MSR(0)
     ;;      mov edx, 0x00000000             ; Mask is EDX:EAX, 0x0000000001000800 (Because bochs sucks)
     ;;      mov eax, 0x01000800             ; Bit 11 set for Valid
     ;       mov edx, 0x0000000F             ; Mask is EDX:EAX, 0x0000000F80000800 (2 GiB)
     ;       mov eax, 0x80000800             ; Bit 11 set for Valid
     ;       wrmsr
     
     ; MTRR notes:
     ; Base 0x0000000000000000 = 0 MiB
     ; Base 0x0000000080000000 = 2048 MiB, 2048 is 0x800
     ; Base 0x0000000100000000 = 4096 MiB, 4096 is 0x1000
     ; Mask 0x0000000F80000000 = 2048 MiB, 0xFFFFFFFFF - F80000000 = 7FFFFFFF = 2147483647 (~2 GiB)
     ; Mask 0x0000000FC0000000 = 1024 MiB, 0xFFFFFFFFF - FC0000000 = 3FFFFFFF = 1073741823 (~1 GiB)
     ; Mask 0x0000000FFC000000 = 64 MiB,   0xFFFFFFFFF - FFC000000 =  3FFFFFF =   67108863 (~64 MiB)
     
     ;; Disable Cache
     ;        mov rax, cr0
     ;        btr rax, 29                     ; Clear No Write Thru (Bit 29)
     ;        bts rax, 30                     ; Set Cache Disable (Bit 30)
     ;        mov cr0, rax
     
     ; Flush Cache
     ;        wbinvd
     
     
     ; Enable MTRRs
             mov ecx, 0x000002FF
             rdmsr
             bts eax, 11                     ; Set MTRR Enable (Bit 11), Only enables Variable Range MTRR's
             wrmsr
     
     ; Enable Paging Global Extensions
           mov rax, cr4
           bts rax, 7                      ; Set Paging Global Extensions (Bit 7)
           mov cr4, rax
     
     ; Enable Floating Point
             mov rax, cr0
             bts rax, 1                      ; Set Monitor co-processor (Bit 1)
             btr rax, 2                      ; Clear Emulation (Bit 2)
             mov cr0, rax
     
     ; Enable SSE
             mov rax, cr4
             bts rax, 9                      ; Set Operating System Support for FXSAVE and FXSTOR instructions (Bit 9)
             bts rax, 10                     ; Set Operating System Support for Unmasked SIMD Floating-Point Exceptions (Bit 10)
             mov cr4, rax
     
     ; Enable Math Co-processor
             finit
     
     ; Enable and Configure Local APIC
             mov rsi, [os_LocalAPICAddress]
             cmp rsi, 0x00000000
             je noMP                         ; Skip MP init if we didn't get a valid LAPIC address
     
             xor eax, eax                    ; Clear Task Priority (bits 7:4) and Priority Sub-Class (bits 3:0)
             mov dword [rsi+0x80], eax       ; Task Priority Register (TPR)
     
             mov eax, 0x01000000             ; Set bits 31-24 for all cores to be in Group 1
             mov dword [rsi+0xD0], eax       ; Logical Destination Register
     
             xor eax, eax
             sub eax, 1                      ; Set EAX to 0xFFFFFFFF; Bits 31-28 set for Flat Mode
             mov dword [rsi+0xE0], eax       ; Destination Format Register
     
             mov eax, dword [rsi+0xF0]       ; Spurious Interrupt Vector Register
             mov al, 0xF8
             bts eax, 8                      ; Enable APIC (Set bit 8)
             mov dword [rsi+0xF0], eax
     
             mov eax, dword [rsi+0x320]      ; LVT Timer Register
             bts eax, 16                     ; Set bit 16 for mask interrupts
             mov dword [rsi+0x320], eax
     
           ; mov eax, dword [rsi+0x350]      ; LVT LINT0 Register
           ; mov al, 0                       ;Set interrupt vector (bits 7:0)
           ; bts eax, 8                      ;Delivery Mode (111b==ExtlNT] (bits 10:8)
           ; bts eax, 9
           ; bts eax, 10
           ; bts eax, 15                     ;bit15:Set trigger mode to Level (0== Edge, 1== Level)
           ; btr eax, 16                     ;bit16:unmask interrupts (0==Unmasked, 1== Masked)
           ; mov dword [rsi+0x350], eax
     
           ; mov eax, dword [rsi+0x360]      ; LVT LINT1 Register
           ; mov al, 0                       ;Set interrupt vector (bits 7:0)
           ; bts eax, 8                      ;Delivery Mode (111b==ExtlNT] (bits 10:8)
           ; bts eax, 9
           ; bts eax, 10
           ; bts eax, 15                     ;bit15:Set trigger mode to Edge (0== Edge, 1== Level)
           ; btr eax, 16                     ;bit16:unmask interrupts (0==Unmasked, 1== Masked)
           ; mov dword [rsi+0x360], eax
     
           ; mov eax, dword [rsi+0x370]      ; LVT Error Register
           ; mov al, 0                       ;Set interrupt vector (bits 7:0)
           ; bts eax, 16                     ;bit16:Mask interrupts (0==Unmasked, 1== Masked)
           ; mov dword [rsi+0x370], eax
     
        ; Flush Cache
                wbinvd
     
        ; Enable Cache
                mov rax, cr0
                btr rax, 29                     ; Clear No Write Thru (Bit 29)
                btr rax, 30                     ; Clear CD (Bit 30)
                mov cr0, rax
     
     ret
     #+end_src
**** init PIC
     #+begin_src fasm :tangle no
     init_pic:
             ; Enable specific interrupts
             in al, 0x21
             mov al, 11111001b               ; Enable Cascade, Keyboard
             out 0x21, al
             in al, 0xA1
             mov al, 11111110b               ; Enable RTC
             out 0xA1, al
     
             ; Set the periodic flag in the RTC
             mov al, 0x0B                    ; Status Register B
             out 0x70, al                    ; Select the address
             in al, 0x71                     ; Read the current settings
             push rax
             mov al, 0x0B                    ; Status Register B
             out 0x70, al                    ; Select the address
             pop rax
             bts ax, 6                       ; Set Periodic(6)
             out 0x71, al                    ; Write the new settings
     
             sti                             ; Enable interrupts
     
             ; Acknowledge the RTC
             mov al, 0x0C                    ; Status Register C
             out 0x70, al                    ; Select the address
             in al, 0x71                     ; Read the current settings
     
             ret
     #+end_src
**** init SMP
   #+begin_src fasm :tangle no
   init_smp:
	   mov al, '5'                     ; Start of MP init
	   mov [0x000B809C], al
	   mov al, '0'
	   mov [0x000B809E], al

   ; Check if we want the AP's to be enabled.. if not then skip to end
	 cmp byte [cfg_smpinit], 1       ; Check if SMP should be enabled
	 jne noMP                        ; If not then skip SMP init

   ; Start the AP's one by one
	   xor eax, eax
	   xor edx, edx
	   mov rsi, [os_LocalAPICAddress]
	   add rsi, 0x20                   ; Add the offset for the APIC ID location
	   lodsd                           ; APIC ID is stored in bits 31:24
	   shr rax, 24                     ; AL now holds the BSP CPU's APIC ID
	   mov dl, al                      ; Store BSP APIC ID in DL

	   mov al, '8'                     ; Start the AP's
	   mov [0x000B809E], al

	   mov rsi, 0x0000000000005100
	   xor eax, eax
	   xor ecx, ecx
	   mov cx, [cpu_detected]
   smp_send_INIT:
	   cmp cx, 0
	   je smp_send_INIT_done
	   lodsb

	   cmp al, dl                      ; Is it the BSP?
	   je smp_send_INIT_skipcore

	   ; Broadcast 'INIT' IPI to APIC ID in AL
	   mov rdi, [os_LocalAPICAddress]
	   shl eax, 24
	   mov dword [rdi+0x310], eax      ; Interrupt Command Register (ICR); bits 63-32
	   mov eax, 0x00004500
	   mov dword [rdi+0x300], eax      ; Interrupt Command Register (ICR); bits 31-0
   smp_send_INIT_verify:
	   mov eax, [rdi+0x300]            ; Interrupt Command Register (ICR); bits 31-0
	   bt eax, 12                      ; Verify that the command completed
	   jc smp_send_INIT_verify

   smp_send_INIT_skipcore:
	   dec cl
	   jmp smp_send_INIT

   smp_send_INIT_done:

	   mov rax, [os_Counter_RTC]
	   add rax, 10
   wait1:
	   mov rbx, [os_Counter_RTC]
	   cmp rax, rbx
	   jg wait1

	   mov rsi, 0x0000000000005100
	   xor ecx, ecx
	   mov cx, [cpu_detected]
   smp_send_SIPI:
	   cmp cx, 0
	   je smp_send_SIPI_done
	   lodsb

	   cmp al, dl                      ; Is it the BSP?
	   je smp_send_SIPI_skipcore

	   ; Broadcast 'Startup' IPI to destination using vector 0x08 to specify entry-point is at the memory-address 0x00008000
	   mov rdi, [os_LocalAPICAddress]
	   shl eax, 24
	   mov dword [rdi+0x310], eax      ; Interrupt Command Register (ICR); bits 63-32
	   mov eax, 0x00004608             ; Vector 0x08
	   mov dword [rdi+0x300], eax      ; Interrupt Command Register (ICR); bits 31-0
   smp_send_SIPI_verify:
	   mov eax, [rdi+0x300]            ; Interrupt Command Register (ICR); bits 31-0
	   bt eax, 12                      ; Verify that the command completed
	   jc smp_send_SIPI_verify

   smp_send_SIPI_skipcore:
	   dec cl
	   jmp smp_send_SIPI

   smp_send_SIPI_done:

	   mov al, 'A'
	   mov [0x000B809E], al

   ; Let things settle (Give the AP's some time to finish)
	   mov rax, [os_Counter_RTC]
	   add rax, 20
   wait3:
	   mov rbx, [os_Counter_RTC]
	   cmp rax, rbx
	   jg wait3

   ; Finish up
   noMP:
	   lock inc word [cpu_activated]   ; BSP adds one here

	   xor eax, eax
	   mov rsi, [os_LocalAPICAddress]
	   add rsi, 0x20                   ; Add the offset for the APIC ID location
	   lodsd                           ; APIC ID is stored in bits 31:24
	   shr rax, 24                     ; AL now holds the CPU's APIC ID (0 - 255)
	   mov [os_BSP], eax               ; Store the BSP APIC ID

	   mov al, 'C'
	   mov [0x000B809E], al

   ; Calculate speed of CPU (At this point the RTC is firing at 1024Hz)
	   cpuid
	   xor edx, edx
	   xor eax, eax
	   mov rcx, [os_Counter_RTC]
	   add rcx, 10
	   rdtsc
	   push rax
   speedtest:
	   mov rbx, [os_Counter_RTC]
	   cmp rbx, rcx
	   jl speedtest
	   rdtsc
	   pop rdx
	   sub rax, rdx
	   xor edx, edx
	   mov rcx, 10240
	   div rcx
	   mov [cpu_speed], ax

   ; Clear the periodic flag in the RTC
	   mov al, 0x0B                    ; Status Register B
	   out 0x70, al                    ; Select the address
	   in al, 0x71                     ; Read the current settings
	   push rax
	   mov al, 0x0B                    ; Status Register B
	   out 0x70, al                    ; Select the address
	   pop rax
	   btc ax, 6                       ; Set Periodic(6)
	   out 0x71, al                    ; Write the new settings

	   mov al, 'E'
	   mov [0x000B809E], al

	   cli                             ; Disable Interrupts

	   ret
#+end_src
**** syscalls
     #+begin_src fasm :tangle no
     ; -----------------------------------------------------------------------------
     ; os_move_cursor -- Moves the virtual cursor in text mode
     ;  IN:  AH, AL = column, row
     ; OUT:  Nothing. All registers preserved
     os_move_cursor:
	     push rcx
	     push rbx
	     push rax

	     xor ebx, ebx
	     mov [screen_cursor_x], ah
	     mov [screen_cursor_y], al
	     mov bl, ah

	     ; Calculate the new offset
	     and rax, 0x00000000000000FF     ; only keep the low 8 bits
	     mov cl, 80
	     mul cl                          ; AX = AL * CL
	     add ax, bx
	     shl ax, 1                       ; multiply by 2

	     add rax, 0x00000000000B8000
	     mov [screen_cursor_offset], rax

	     pop rax
	     pop rbx
	     pop rcx
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_print_newline -- Reset cursor to start of next line and scroll if needed
     ;  IN:  Nothing
     ; OUT:  Nothing, all registers perserved
     os_print_newline:
	     push rax

	     mov ah, 0                       ; Set the cursor x value to 0
	     mov al, [screen_cursor_y]       ; Grab the cursor y value
	     cmp al, 24                      ; Compare to see if we are on the last line
	     je os_print_newline_scroll      ; If so then we need to scroll the sreen

	     inc al                          ; If not then we can go ahead an increment the y value
	     jmp os_print_newline_done

     os_print_newline_scroll:
	     mov ax, 0x0000                  ; If we have reached the end then wrap back to the front

     os_print_newline_done:
	     call os_move_cursor             ; update the cursor

	     pop rax
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_print_string -- Displays text
     ;  IN:  RSI = message location (zero-terminated string)
     ; OUT:  Nothing, all registers perserved
     os_print_string:
	     push rsi
	     push rax

	     cld                             ; Clear the direction flag.. we want to increment through the string

     os_print_string_nextchar:
	     lodsb                           ; Get char from string and store in AL
	     cmp al, 0                       ; Strings are Zero terminated.
	     je os_print_string_done         ; If char is Zero then it is the end of the string

	     cmp al, 13                      ; Check if there was a newline character in the string
	     je os_print_string_newline      ; If so then we print a new line

	     call os_print_char

	     jmp os_print_string_nextchar

     os_print_string_newline:
	     call os_print_newline
	     jmp os_print_string_nextchar

     os_print_string_done:
	     pop rax
	     pop rsi
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_print_char -- Displays a char
     ;  IN:  AL = char to display
     ; OUT:  Nothing. All registers preserved
     os_print_char:
	     push rdi

	     mov rdi, [screen_cursor_offset]
	     stosb
	     add qword [screen_cursor_offset], 2     ; Add 2 (1 byte for char and 1 byte for attribute)

	     pop rdi
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_print_char_hex -- Displays a char in hex mode
     ;  IN:  AL = char to display
     ; OUT:  Nothing. All registers preserved
     os_print_char_hex:
	     push rbx
	     push rax

	     mov rbx, hextable

	     push rax                        ; save rax for the next part
	     shr al, 4                       ; we want to work on the high part so shift right by 4 bits
	     xlatb
	     call os_print_char

	     pop rax
	     and al, 0x0f                    ; we want to work on the low part so clear the high part
	     xlatb
	     call os_print_char

	     pop rax
	     pop rbx
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_debug_dump_(rax|eax|ax|al) -- Dump content of RAX, EAX, AX, or AL to the screen in hex format
     ;  IN:  RAX = content to dump
     ; OUT:  Nothing, all registers preserved
     os_debug_dump_rax:
	     ror rax, 56
	     call os_print_char_hex
	     rol rax, 8
	     call os_print_char_hex
	     rol rax, 8
	     call os_print_char_hex
	     rol rax, 8
	     call os_print_char_hex
	     rol rax, 32
     os_debug_dump_eax:
	     ror rax, 24
	     call os_print_char_hex
	     rol rax, 8
	     call os_print_char_hex
	     rol rax, 16
     os_debug_dump_ax:
	     ror rax, 8
	     call os_print_char_hex
	     rol rax, 8
     os_debug_dump_al:
	     call os_print_char_hex
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_dump_regs -- Dump the values on the registers to the screen (For debug purposes)
     ; IN/OUT: Nothing
     os_dump_regs:
	     push r15
	     push r14
	     push r13
	     push r12
	     push r11
	     push r10
	     push r9
	     push r8
	     push rsp
	     push rbp
	     push rdi
	     push rsi
	     push rdx
	     push rcx
	     push rbx
	     push rax

	     mov byte [os_dump_reg_stage], 0x00      ; Reset the stage to 0 since we are starting
	     mov rcx, rsp
	     call os_print_newline

     os_dump_regs_again:
	     mov rsi, os_dump_reg_string00
	     xor rax, rax
	     xor rbx, rbx
	     mov al, [os_dump_reg_stage]
	     mov bl, 5                               ; each string is 5 bytes
	     mul bl                                  ; ax = bl x al
	     add rsi, rax
	     call os_print_string                    ; Print the register name

	     mov rax, [rcx]
	     add rcx, 8
	     call os_debug_dump_rax

	     add byte [os_dump_reg_stage], 1
	     cmp byte [os_dump_reg_stage], 0x10
	     jne os_dump_regs_again

	     pop rax
	     pop rbx
	     pop rcx
	     pop rdx
	     pop rsi
	     pop rdi
	     pop rbp
	     pop rsp
	     pop r8
	     pop r9
	     pop r10
	     pop r11
	     pop r12
	     pop r13
	     pop r14
	     pop r15

	     ret

     os_dump_reg_string00: db '  A:', 0
     os_dump_reg_string01: db '  B:', 0
     os_dump_reg_string02: db '  C:', 0
     os_dump_reg_string03: db '  D:', 0
     os_dump_reg_string04: db ' SI:', 0
     os_dump_reg_string05: db ' DI:', 0
     os_dump_reg_string06: db ' BP:', 0
     os_dump_reg_string07: db ' SP:', 0
     os_dump_reg_string08: db '  8:', 0
     os_dump_reg_string09: db '  9:', 0
     os_dump_reg_string0A: db ' 10:', 0
     os_dump_reg_string0B: db ' 11:', 0
     os_dump_reg_string0C: db ' 12:', 0
     os_dump_reg_string0D: db ' 13:', 0
     os_dump_reg_string0E: db ' 14:', 0
     os_dump_reg_string0F: db ' 15:', 0
     os_dump_reg_stage: db 0x00
     ; -----------------------------------------------------------------------------



     ; -----------------------------------------------------------------------------
     ; os_dump_mem -- Dump some memory content to the screen (For debug purposes)
     ; IN: RSI = memory to dump (512bytes)
     ;OUT:
     os_dump_mem:
	     push rdx
	     push rcx
	     push rbx
	     push rax

	     push rsi

	     mov rcx, 512
     dumpit:
	     lodsb
	     call os_print_char_hex
	     dec rcx
	     cmp rcx, 0
	     jne dumpit

	     pop rsi

     ;       call os_print_newline

	     pop rax
	     pop rbx
	     pop rcx
	     pop rdx

	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_int_to_string -- Convert a binary interger into an string string
     ;  IN:  RAX = binary integer
     ;       RDI = location to store string
     ; OUT:  RDI = pointer to end of string
     ;       All other registers preserved
     ; Min return value is 0 and max return value is 18446744073709551615 so your
     ; string needs to be able to store at least 21 characters (20 for the number
     ; and 1 for the string terminator).
     ; Adapted from http://www.cs.usfca.edu/~cruse/cs210s09/rax2uint.s
     os_int_to_string:
	     push rdx
	     push rcx
	     push rbx
	     push rax

	     mov rbx, 10                             ; base of the decimal system
	     xor rcx, rcx                            ; number of digits generated
     os_int_to_string_next_divide:
	     xor rdx, rdx                            ; RAX extended to (RDX,RAX)
	     div rbx                                 ; divide by the number-base
	     push rdx                                ; save remainder on the stack
	     inc rcx                                 ; and count this remainder
	     cmp rax, 0x0                            ; was the quotient zero?
	     jne os_int_to_string_next_divide        ; no, do another division
     os_int_to_string_next_digit:
	     pop rdx                                 ; else pop recent remainder
	     add dl, '0'                             ; and convert to a numeral
	     mov [rdi], dl                           ; store to memory-buffer
	     inc rdi
	     loop os_int_to_string_next_digit        ; again for other remainders
	     mov al, 0x00
	     stosb                                   ; Store the null terminator at the end of the string

	     pop rax
	     pop rbx
	     pop rcx
	     pop rdx
	     ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; create_gate
     ; rax = address of handler
     ; rdi = gate # to configure
     create_gate:
	     push rdi
	     push rax

	     shl rdi, 4                      ; quickly multiply rdi by 16
	     stosw                           ; store the low word (15..0)
	     shr rax, 16
	     add rdi, 4                      ; skip the gate marker
	     stosw                           ; store the high word (31..16)
	     shr rax, 16
	     stosd                           ; store the high dword (63..32)

	     pop rax
	     pop rdi

	     ret
     ; -----------------------------------------------------------------------------
     #+end_src
** interrupt
   #+begin_src fasm :tangle no
   ; -----------------------------------------------------------------------------
   ; Default exception handler
   exception_gate:
           mov rsi, int_string
           call os_print_string
           mov rsi, exc_string
           call os_print_string
   exception_gate_halt:
           cli                             ; Disable interrupts
           hlt                             ; Halt the system
           jmp exception_gate_halt
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Default interrupt handler
   interrupt_gate:                         ; handler for all other interrupts
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Keyboard interrupt. IRQ 0x01, INT 0x21
   ; This IRQ runs whenever there is input on the keyboard
   align 16
   keyboard:
           push rdi
           push rax
   
           xor eax, eax
   
           in al, 0x60                     ; Get the scancode from the keyboard
           test al, 0x80
           jnz keyboard_done
   
           mov [0x000B8088], al            ; Dump the scancode to the screen
   
           mov rax, [os_Counter_RTC]
           add rax, 10
           mov [os_Counter_RTC], rax
   
   keyboard_done:
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0x20, al
   
           pop rax
           pop rdi
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Cascade interrupt. IRQ 0x02, INT 0x22
   cascade:
           push rax
   
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0x20, al
   
           pop rax
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Real-time clock interrupt. IRQ 0x08, INT 0x28
   align 16
   rtc:
           push rdi
           push rax
   
           add qword [os_Counter_RTC], 1   ; 64-bit counter started at bootup
   
           mov al, 'R'
           mov [0x000B8092], al
           mov rax, [os_Counter_RTC]
           and al, 1                       ; Clear all but lowest bit (Can only be 0 or 1)
           add al, 48
           mov [0x000B8094], al
           mov al, 0x0C                    ; Select RTC register C
           out 0x70, al                    ; Port 0x70 is the RTC index, and 0x71 is the RTC data
           in al, 0x71                     ; Read the value in register C
   
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0xA0, al
           out 0x20, al
   
           pop rax
           pop rdi
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Spurious interrupt. INT 0xFF
   align 16
   spurious:                               ; handler for spurious interrupts
           mov al, 'S'
           mov [0x000B8080], al
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; CPU Exception Gates
   exception_gate_00:
           mov al, 0x00
           jmp exception_gate_main
   
   exception_gate_01:
           mov al, 0x01
           jmp exception_gate_main
   
   exception_gate_02:
           mov al, 0x02
           jmp exception_gate_main
   
   exception_gate_03:
           mov al, 0x03
           jmp exception_gate_main
   
   exception_gate_04:
           mov al, 0x04
           jmp exception_gate_main
   
   exception_gate_05:
           mov al, 0x05
           jmp exception_gate_main
   
   exception_gate_06:
           mov al, 0x06
           jmp exception_gate_main
   
   exception_gate_07:
           mov al, 0x07
           jmp exception_gate_main
   
   exception_gate_08:
           mov al, 0x08
           jmp exception_gate_main
   
   exception_gate_09:
           mov al, 0x09
           jmp exception_gate_main
   
   exception_gate_10:
           mov al, 0x0A
           jmp exception_gate_main
   
   exception_gate_11:
           mov al, 0x0B
           jmp exception_gate_main
   
   exception_gate_12:
           mov al, 0x0C
           jmp exception_gate_main
   
   exception_gate_13:
           mov al, 0x0D
           jmp exception_gate_main
   
   exception_gate_14:
           mov al, 0x0E
           jmp exception_gate_main
   
   exception_gate_15:
           mov al, 0x0F
           jmp exception_gate_main
   
   exception_gate_16:
           mov al, 0x10
           jmp exception_gate_main
   
   exception_gate_17:
           mov al, 0x11
           jmp exception_gate_main
   
   exception_gate_18:
           mov al, 0x12
           jmp exception_gate_main
   
   exception_gate_19:
           mov al, 0x13
           jmp exception_gate_main
   
   exception_gate_main:
           call os_print_newline
           mov rsi, int_string
           call os_print_string
           mov rsi, exc_string00
           and rax, 0xFF                   ; Clear out everything in RAX except for AL
           shl eax, 3                              ; Quick multiply by 3
           add rsi, rax                            ; Use the value in RAX as an offset to get to the right message
           call os_print_string
           mov rsi, adr_string
           call os_print_string
           mov rax, [rsp]
           call os_debug_dump_rax
           call os_print_newline
           call os_dump_regs
   
   exception_gate_main_hang:
           nop
           jmp exception_gate_main_hang    ; Hang. User must reset machine at this point
   
   ; Strings for the error messages
   int_string db 'kernelloader - Exception ', 0
   adr_string db ' @ 0x', 0
   exc_string db '?? - Unknown', 0
   align 16
   exc_string00 db '00 - DE', 0
   exc_string01 db '01 - DB', 0
   exc_string02 db '02     ', 0
   exc_string03 db '03 - BP', 0
   exc_string04 db '04 - OF', 0
   exc_string05 db '05 - BR', 0
   exc_string06 db '06 - UD', 0
   exc_string07 db '07 - NM', 0
   exc_string08 db '08 - DF', 0
   exc_string09 db '09     ', 0            ; No longer generated on new CPU's
   exc_string10 db '10 - TS', 0
   exc_string11 db '11 - NP', 0
   exc_string12 db '12 - SS', 0
   exc_string13 db '13 - GP', 0
   exc_string14 db '14 - PF', 0
   exc_string15 db '15     ', 0
   exc_string16 db '16 - MF', 0
   exc_string17 db '17 - AC', 0
   exc_string18 db '18 - MC', 0
   exc_string19 db '19 - XM', 0
   #+end_src
** set the size & the magic number
   #+begin_src fasm :tangle no 
   times (SizeOfKernelloader * 1024) - ($-$$) - 4 db 0
   dd MagicNumberOfKernelloader   ;; 4 bytes
   #+end_src
* [nasm] old pure64
** note
   Loaded from the first stage.
   Gather information about the system while in 16-bit mode
   (BIOS is still accessible),
   setup a minimal 64-bit environment,
   copy the 64-bit kernel
   from the end of the Pure64 binary
   to the 1MiB memory mark and jump to it!

   Pure64 requires a payload for execution!
   The stand-alone pure64.sys file is not sufficient.
   You must append your kernel or software to the end of the Pure64 binary.
   The maximum size of the kernel of software is 26KiB.
** about the size of kernelloader and kernel
   #+begin_src nasm :tangle no
   %define checkMagicNumberOfKernel 
   %define checkMagicNumberOfEnglishCore 
      
   %define  SizeOfKernelloader  6 ;; unit :: k
   %define  LocationOfKernelloader  8000h
   %define  MagicNumberOfKernelloader  26766h
   
   %define  SizeOfKernel  512 ;; unit :: k
   %define  LocationOfKernel  2*1024*1024
   %define  MagicNumberOfKernel  26881h
   
   %define SizeOfEnglishCore 512 ;; unit :: k
   %define LocationOfEnglishCore  4*1024*1024
   %define MagicNumberOfEnglishCore  "(* m"

   ;; ;; for old-kernel
   ;; %define  LocationOfKernel  1*1024*1024
   ;; %undef checkMagicNumberOfEnglishCore

   ;; ;; for other kernels that use pure64
   ;; %define  LocationOfKernel  1*1024*1024
   ;; %undef checkMagicNumberOfKernel
   ;; %undef checkMagicNumberOfEnglishCore
   #+end_src
** start
   #+begin_src nasm :tangle no
   use16
   org 32*1024
   start:
           cli                             ; Disable all interrupts
           xor eax, eax
           xor ebx, ebx
           xor ecx, ecx
           xor edx, edx
           xor esi, esi
           xor edi, edi
           xor ebp, ebp
           mov ds, ax
           mov es, ax
           mov ss, ax
           mov fs, ax
           mov gs, ax
           mov esp, 0x8000                 ; Set a known free location for the stack

   ap_modify:
           jmp start16                     ; This command will be overwritten with 'NOP's before the AP's are started
           nop                             ; The 'jmp' is only 3 bytes
   #+end_src
** init SMP AP
   #+begin_src nasm :tangle no
   ; AP's will start execution at 0x8000 and fall through to this code
   
   use16
   
   init_smp_ap:
           jmp 0x0000:clearcs_ap
   
   clearcs_ap:
   
   ; Enable the A20 gate
   set_A20_ap:
           in al, 0x64
           test al, 0x02
           jnz set_A20_ap
           mov al, 0xD1
           out 0x64, al
   check_A20_ap:
           in al, 0x64
           test al, 0x02
           jnz check_A20_ap
           mov al, 0xDF
           out 0x60, al
   
   ; At this point we are done with real mode and BIOS interrupts. Jump to 32-bit mode.
           lgdt [cs:GDTR32]                ; load GDT register
   
           mov eax, cr0                    ; switch to 32-bit protected mode
           or al, 1
           mov cr0, eax
   
           jmp 8:startap32
   
   align 16
   
   
   ; =============================================================================
   ; 32-bit mode
   use32
   
   startap32:
           mov eax, 16                     ; load 4 GB data descriptor
           mov ds, ax                      ; to all data segment registers
           mov es, ax
           mov fs, ax
           mov gs, ax
           mov ss, ax
           xor eax, eax
           xor ebx, ebx
           xor ecx, ecx
           xor edx, edx
           xor esi, esi
           xor edi, edi
           xor ebp, ebp
           mov esp, 0x8000                 ; Set a known free location for the stack
   
   ; Load the GDT
           lgdt [GDTR64]
   
   ; Enable extended properties
           mov eax, cr4
           or eax, 0x0000000B0             ; PGE (Bit 7), PAE (Bit 5), and PSE (Bit 4)
           mov cr4, eax
   
   ; Point cr3 at PML4
           mov eax, 0x00002008             ; Write-thru (Bit 3)
           mov cr3, eax
   
   ; Enable long mode and SYSCALL/SYSRET
           mov ecx, 0xC0000080             ; EFER MSR number
           rdmsr                           ; Read EFER
           or eax, 0x00000101              ; LME (Bit 8)
           wrmsr                           ; Write EFER
   
   ; Enable paging to activate long mode
           mov eax, cr0
           bts eax, 31
           ;or eax, 0x80000000              ; PG (Bit 31)
           mov cr0, eax
   
   ; Make the jump directly from 16-bit real mode to 64-bit long mode
           jmp SYS64_CODE_SEL:startap64
   
   align 16
   
   
   ; =============================================================================
   ; 64-bit mode
   use64
   
   startap64:
           xor rax, rax                    ; aka r0
           xor rbx, rbx                    ; aka r3
           xor rcx, rcx                    ; aka r1
           xor rdx, rdx                    ; aka r2
           xor rsi, rsi                    ; aka r6
           xor rdi, rdi                    ; aka r7
           xor rbp, rbp                    ; aka r5
           xor rsp, rsp                    ; aka r4
           xor r8, r8
           xor r9, r9
           xor r10, r10
           xor r11, r11
           xor r12, r12
           xor r13, r13
           xor r14, r14
           xor r15, r15
   
           mov ds, ax                      ; Clear the legacy segment registers
           mov es, ax
           mov ss, ax
           mov fs, ax
           mov gs, ax
   
           mov rax, clearcs64_ap
           jmp rax
           nop
   clearcs64_ap:
           xor rax, rax
   
           ; Reset the stack. Each CPU gets a 1024-byte unique stack location
           mov rsi, [os_LocalAPICAddress]  ; We would call os_smp_get_id here but the stack is not ...
           add rsi, 0x20                   ; ... yet defined. It is safer to find the value directly.
           lodsd                           ; Load a 32-bit value. We only want the high 8 bits
           shr rax, 24                     ; Shift to the right and AL now holds the CPU's APIC ID
           shl rax, 10                     ; shift left 10 bits for a 1024byte stack
           add rax, 0x0000000000050400     ; stacks decrement when you "push", start at 1024 bytes in
           mov rsp, rax                    ; Pure64 leaves 0x50000-0x9FFFF free so we use that
   
           lgdt [GDTR64]                   ; Load the GDT
           lidt [IDTR64]                   ; load IDT register
   
   ; Enable Local APIC on AP
           mov rsi, [os_LocalAPICAddress]
           add rsi, 0x00f0                 ; Offset to Spurious Interrupt Register
           mov rdi, rsi
           lodsd
           or eax, 0000000100000000b
           stosd
   
           call init_cpu                   ; Setup CPU
   
   ; Make sure exceptions are working.
   ;       xor rax, rax
   ;       xor rbx, rbx
   ;       xor rcx, rcx
   ;       xor rdx, rdx
   ;       div rax
   
           lock inc word [cpu_activated]
           xor eax, eax
           mov rsi, [os_LocalAPICAddress]
           add rsi, 0x20                   ; Add the offset for the APIC ID location
           lodsd                           ; APIC ID is stored in bits 31:24
           shr rax, 24                     ; AL now holds the CPU's APIC ID (0 - 255)
           mov rdi, 0x00005700             ; The location where the cpu values are stored
           add rdi, rax                    ; RDI points to infomap CPU area + APIC ID. ex F701 would be APIC ID 1
           mov al, 1
           stosb
           sti                             ; Activate interrupts for SMP
           jmp ap_sleep
   
   
   align 16
   
   ap_sleep:
           hlt                             ; Suspend CPU until an interrupt is received. opcode for hlt is 0xF4
           jmp ap_sleep                    ; just-in-case of an NMI
   #+end_src
** start16
   #+begin_src nasm :tangle no
   ;db '_16_'                              ; Debug
   align 16

   use16
   start16:
           jmp 0x0000:clearcs

   clearcs:

   ; Configure serial port
           xor dx, dx                      ; First serial port
           mov ax, 0000000011100011b       ; 9600 baud, no parity, 1 stop bit, 8 data bits
           int 0x14

   ; Make sure the screen is set to 80x25 color text mode
           mov ax, 0x0003                  ; Set to normal (80x25 text) video mode
           int 0x10

   ; Disable blinking
           mov ax, 0x1003
           mov bx, 0x0000
           int 0x10

   ; Print message
           mov si, msg_initializing
           call print_string_16

   ; Check to make sure the CPU supports 64-bit mode... If not then bail out
           mov eax, 0x80000000             ; Extended-function 8000000h.
           cpuid                           ; Is largest extended function
           cmp eax, 0x80000000             ; any function > 80000000h?
           jbe no_long_mode                ; If not, no long mode.
           mov eax, 0x80000001             ; Extended-function 8000001h.
           cpuid                           ; Now EDX = extended-features flags.
           bt edx, 29                      ; Test if long mode is supported.
           jnc no_long_mode                ; Exit if not supported.

           call init_isa                   ; Setup legacy hardware

   ; Hide the hardware cursor (interferes with print_string_16 if called earlier)
           mov ax, 0x0200                  ; VIDEO - SET CURSOR POSITION
           mov bx, 0x0000                  ; Page number
           mov dx, 0x2000                  ; Row / Column
           int 0x10

   ; At this point we are done with real mode and BIOS interrupts. Jump to 32-bit mode.
           lgdt [cs:GDTR32]                ; Load GDT register

           mov eax, cr0
           or al, 0x01                     ; Set protected mode bit
           mov cr0, eax

           jmp 8:start32                   ; Jump to 32-bit protected mode

   ; 16-bit function to print a sting to the screen
   print_string_16:                        ; Output string in SI to screen
           pusha
           mov ah, 0x0E                    ; http://www.ctyme.com/intr/rb-0106.htm
   print_string_16_repeat:
           lodsb                           ; Get char from string
           cmp al, 0
           je print_string_16_done         ; If char is zero, end of string
           int 0x10                        ; Otherwise, print it
           jmp print_string_16_repeat
   print_string_16_done:
           popa
           ret

   ; Display an error message that the CPU does not support 64-bit mode
   no_long_mode:
           mov si, msg_no64
           call print_string_16
           jmp $
   #+end_src
** init ISA
   #+begin_src nasm :tangle no 
   init_isa:
           mov edi, 0x00004000             ; Clear out memory for the E820 map
           xor eax, eax
           mov ecx, 2048
           rep stosd
   
   ; Get the BIOS E820 Memory Map
   ; use the INT 0x15, eax= 0xE820 BIOS function to get a memory map
   ; inputs: es:di -> destination buffer for 24 byte entries
   ; outputs: bp = entry count, trashes all registers except esi
   do_e820:
           mov edi, 0x00004000             ; location that memory map will be stored to
           xor ebx, ebx                    ; ebx must be 0 to start
           xor bp, bp                      ; keep an entry count in bp
           mov edx, 0x0534D4150            ; Place "SMAP" into edx
           mov eax, 0xe820
           mov [es:di + 20], dword 1       ; force a valid ACPI 3.X entry
           mov ecx, 24                     ; ask for 24 bytes
           int 0x15
           jc nomemmap                     ; carry set on first call means "unsupported function"
           mov edx, 0x0534D4150            ; Some BIOSes apparently trash this register?
           cmp eax, edx                    ; on success, eax must have been reset to "SMAP"
           jne nomemmap
           test ebx, ebx                   ; ebx = 0 implies list is only 1 entry long (worthless)
           je nomemmap
           jmp jmpin
   e820lp:
           mov eax, 0xe820                 ; eax, ecx get trashed on every int 0x15 call
           mov [es:di + 20], dword 1       ; force a valid ACPI 3.X entry
           mov ecx, 24                     ; ask for 24 bytes again
           int 0x15
           jc memmapend                    ; carry set means "end of list already reached"
           mov edx, 0x0534D4150            ; repair potentially trashed register
   jmpin:
           jcxz skipent                    ; skip any 0 length entries
           cmp cl, 20                      ; got a 24 byte ACPI 3.X response?
           jbe notext
           test byte [es:di + 20], 1       ; if so: is the "ignore this data" bit clear?
           je skipent
   notext:
           mov ecx, [es:di + 8]            ; get lower dword of memory region length
           test ecx, ecx                   ; is the qword == 0?
           jne goodent
           mov ecx, [es:di + 12]           ; get upper dword of memory region length
           jecxz skipent                   ; if length qword is 0, skip entry
   goodent:
           inc bp                          ; got a good entry: ++count, move to next storage spot
           add di, 32
   skipent:
           test ebx, ebx                   ; if ebx resets to 0, list is complete
           jne e820lp
   nomemmap:
           mov byte [cfg_e820], 0          ; No memory map function
   memmapend:
           xor eax, eax                    ; Create a blank record for termination (32 bytes)
           mov ecx, 8
           rep stosd
   
   ; Enable the A20 gate
   set_A20:
           in al, 0x64
           test al, 0x02
           jnz set_A20
           mov al, 0xD1
           out 0x64, al
   check_A20:
           in al, 0x64
           test al, 0x02
           jnz check_A20
           mov al, 0xDF
           out 0x60, al
   
   ; Set up RTC
   ; Port 0x70 is RTC Address, and 0x71 is RTC Data
   ; http://www.nondot.org/sabre/os/files/MiscHW/RealtimeClockFAQ.txt
   rtc_poll:
           mov al, 0x0A                    ; Status Register A
           out 0x70, al                    ; Select the address
           in al, 0x71                     ; Read the data
           test al, 0x80                   ; Is there an update in process?
           jne rtc_poll                    ; If so then keep polling
           mov al, 0x0A                    ; Status Register A
           out 0x70, al                    ; Select the address
           mov al, 00100110b               ; UIP (0), RTC@32.768KHz (010), Rate@1024Hz (0110)
           out 0x71, al                    ; Write the data
   
           ; Remap PIC IRQ's
           mov al, 00010001b               ; begin PIC 1 initialization
           out 0x20, al
           mov al, 00010001b               ; begin PIC 2 initialization
           out 0xA0, al
           mov al, 0x20                    ; IRQ 0-7: interrupts 20h-27h
           out 0x21, al
           mov al, 0x28                    ; IRQ 8-15: interrupts 28h-2Fh
           out 0xA1, al
           mov al, 4
           out 0x21, al
           mov al, 2
           out 0xA1, al
           mov al, 1
           out 0x21, al
           out 0xA1, al
   
           ; Mask all PIC interrupts
           mov al, 0xFF
           out 0x21, al
           out 0xA1, al
   
   ;; Configure graphics if requested
           cmp byte [cfg_vesa], 1          ; Check if VESA should be enabled
           jne VBEdone                     ; If not then skip VESA init
   
           mov edi, VBEModeInfoBlock       ; VBE data will be stored at this address
           mov ax, 0x4F01                  ; GET SuperVGA MODE INFORMATION - http://www.ctyme.com/intr/rb-0274.htm
           ; CX queries the mode, it should be in the form 0x41XX as bit 14 is set for LFB and bit 8 is set for VESA mode
           ; 0x4112 is 640x480x24bit, 0x4129 should be 32bit
           ; 0x4115 is 800x600x24bit, 0x412E should be 32bit
           ; 0x4118 is 1024x768x24bit, 0x4138 should be 32bit
           ; 0x411B is 1280x1024x24bit, 0x413D should be 32bit
           ; 0x0103 (800x600x256) VBE 1.2+
           mov cx, 0x0103                  ; Put your desired mode here
           mov bx, cx                      ; Mode is saved to BX for the set command later
           int 0x10
   
           cmp ax, 0x004F                  ; Return value in AX should equal 0x004F if command supported and successful
           jne VBEfail
   
           cmp byte [VBEModeInfoBlock.BitsPerPixel], 24    ; Make sure this matches the number of bits for the mode!
           ;cmp byte [VBEModeInfoBlock.BitsPerPixel], 32    ; Make sure this matches the number of bits for the mode!
   
           jne VBEfail                     ; If set bit mode was unsuccessful then bail out
   
           or bx, 0x4000                   ; Use linear/flat frame buffer model (set bit 14)
           mov ax, 0x4F02                  ; SET SuperVGA VIDEO MODE - http://www.ctyme.com/intr/rb-0275.htm
           int 0x10
   
           cmp ax, 0x004F                  ; Return value in AX should equal 0x004F if supported and successful
           jne VBEfail
           jmp VBEdone
   
   VBEfail:
           mov si, msg_novesa
           call print_string_16
           xor ax, ax
           mov byte [cfg_vesa], al         ; Clear the VESA config as it was not successful
   
   VBEdone:
           ret
   #+end_src
** start32
   #+begin_src nasm :tangle no
   align 16
   GDTR32:                                 ; Global Descriptors Table Register
   dw gdt32_end - gdt32 - 1                ; limit of GDT (size minus one)
   dq gdt32                                ; linear address of GDT
   
   align 16
   gdt32:
   dw 0x0000, 0x0000, 0x0000, 0x0000       ; Null desciptor
   dw 0xFFFF, 0x0000, 0x9A00, 0x00CF       ; 32-bit code descriptor
   dw 0xFFFF, 0x0000, 0x9200, 0x00CF       ; 32-bit data descriptor
   gdt32_end:
   
   align 16
   
   
   ; =============================================================================
   ; 32-bit mode
   use32
   
   start32:
           mov eax, 16                     ; load 4 GB data descriptor
           mov ds, ax                      ; to all data segment registers
           mov es, ax
           mov fs, ax
           mov gs, ax
           mov ss, ax
           xor eax, eax
           xor ebx, ebx
           xor ecx, ecx
           xor edx, edx
           xor esi, esi
           xor edi, edi
           xor ebp, ebp
           mov esp, 0x8000                 ; Set a known free location for the stack
   
           mov al, '2'                     ; Now in 32-bit protected mode (0x20 = 32)
           mov [0x000B809C], al
           mov al, '0'
           mov [0x000B809E], al
   
   ; Clear out the first 4096 bytes of memory. This will store the 64-bit IDT, GDT, PML4, and PDP
           mov ecx, 1024
           xor eax, eax
           mov edi, eax
           rep stosd
   
   ; Clear memory for the Page Descriptor Entries (0x10000 - 0x4FFFF)
           mov edi, 0x00010000
           mov ecx, 65536
           rep stosd
   
   ; Copy the GDT to its final location in memory
           mov esi, gdt64
           mov edi, 0x00001000             ; GDT address
           mov ecx, (gdt64_end - gdt64)
           rep movsb                       ; Move it to final pos.
   
   ; Create the Level 4 Page Map. (Maps 4GBs of 2MB pages)
   ; First create a PML4 entry.
   ; PML4 is stored at 0x0000000000002000, create the first entry there
   ; A single PML4 entry can map 512GB with 2MB pages.
           cld
           mov edi, 0x00002000             ; Create a PML4 entry for the first 4GB of RAM
           mov eax, 0x00003007
           stosd
           xor eax, eax
           stosd
   
           mov edi, 0x00002800             ; Create a PML4 entry for higher half (starting at 0xFFFF800000000000)
           mov eax, 0x00003007             ; The higher half is identity mapped to the lower half
           stosd
           xor eax, eax
           stosd
   
   ; Create the PDP entries.
   ; The first PDP is stored at 0x0000000000003000, create the first entries there
   ; A single PDP entry can map 1GB with 2MB pages
           mov ecx, 64                     ; number of PDPE's to make.. each PDPE maps 1GB of physical memory
           mov edi, 0x00003000
           mov eax, 0x00010007             ; location of first PD
   create_pdpe:
           stosd
           push eax
           xor eax, eax
           stosd
           pop eax
           add eax, 0x00001000             ; 4K later (512 records x 8 bytes)
           dec ecx
           cmp ecx, 0
           jne create_pdpe
   
   ; Create the PD entries.
   ; PD entries are stored starting at 0x0000000000010000 and ending at 0x000000000004FFFF (256 KiB)
   ; This gives us room to map 64 GiB with 2 MiB pages
           mov edi, 0x00010000
           mov eax, 0x0000008F             ; Bit 7 must be set to 1 as we have 2 MiB pages
           xor ecx, ecx
   pd_again:                               ; Create a 2 MiB page
           stosd
           push eax
           xor eax, eax
           stosd
           pop eax
           add eax, 0x00200000
           inc ecx
           cmp ecx, 2048
           jne pd_again                    ; Create 2048 2 MiB page maps.
   
   ; Load the GDT
           lgdt [GDTR64]
   
   ; Enable extended properties
           mov eax, cr4
           or eax, 0x0000000B0             ; PGE (Bit 7), PAE (Bit 5), and PSE (Bit 4)
           mov cr4, eax
   
   ; Point cr3 at PML4
           mov eax, 0x00002008             ; Write-thru (Bit 3)
           mov cr3, eax
   
   ; Enable long mode and SYSCALL/SYSRET
           mov ecx, 0xC0000080             ; EFER MSR number
           rdmsr                           ; Read EFER
           or eax, 0x00000101              ; LME (Bit 8)
           wrmsr                           ; Write EFER
   
   ; Debug
           mov al, '1'                     ; About to make the jump into 64-bit mode
           mov [0x000B809C], al
           mov al, 'E'
           mov [0x000B809E], al
   
   ; Enable paging to activate long mode
           mov eax, cr0
           bts eax, 31 
           ;or eax, 0x80000000              ; PG (Bit 31)
           mov cr0, eax
   
           jmp SYS64_CODE_SEL:start64      ; Jump to 64-bit mode
   #+end_src
** start64
   #+begin_src nasm :tangle no
   align 16
   use64
   
   start64:
   ; Debug
           mov al, '4'                     ; Now in 64-bit mode (0x40 = 64)
           mov [0x000B809C], al
           mov al, '0'
           mov [0x000B809E], al
   
           mov al, 2
           mov ah, 22
           call os_move_cursor
   
           xor rax, rax                    ; aka r0
           xor rbx, rbx                    ; aka r3
           xor rcx, rcx                    ; aka r1
           xor rdx, rdx                    ; aka r2
           xor rsi, rsi                    ; aka r6
           xor rdi, rdi                    ; aka r7
           xor rbp, rbp                    ; aka r5
           mov rsp, 0x8000                 ; aka r4
           xor r8, r8
           xor r9, r9
           xor r10, r10
           xor r11, r11
           xor r12, r12
           xor r13, r13
           xor r14, r14
           xor r15, r15
   
           mov ds, ax                      ; Clear the legacy segment registers
           mov es, ax
           mov ss, ax
           mov fs, ax
           mov gs, ax
   
           mov rax, clearcs64              ; Do a proper 64-bit jump. Should not be needed as the ...
           jmp rax                         ; jmp SYS64_CODE_SEL:start64 would have sent us ...
           nop                             ; out of compatibility mode and into 64-bit mode
   clearcs64:
           xor rax, rax
   
           lgdt [GDTR64]                   ; Reload the GDT
   
   ; Debug
           mov al, '2'
           mov [0x000B809E], al
   
   ; Patch Pure64 AP code                  ; The AP's will be told to start execution at 0x8000
           mov edi, ap_modify              ; We need to remove the BSP Jump call to get the AP's
           mov eax, 0x90909090             ; to fall through to the AP Init code
           stosd
   
   ; Build the rest of the page tables (4GiB+)
           mov rcx, 0x0000000000000000
           mov rax, 0x000000010000008F
           mov rdi, 0x0000000000014000
   buildem:
           stosq
           add rax, 0x0000000000200000
           add rcx, 1
           cmp rcx, 30720                  ; Another 60 GiB (We already mapped 4 GiB)
           jne buildem
           ; We have 64 GiB mapped now
   
   ; Build a temporary IDT
           xor rdi, rdi                    ; create the 64-bit IDT (at linear address 0x0000000000000000)
   
           mov rcx, 32
   make_exception_gates:                   ; make gates for exception handlers
           mov rax, exception_gate
           push rax                        ; save the exception gate to the stack for later use
           stosw                           ; store the low word (15..0) of the address
           mov ax, SYS64_CODE_SEL
           stosw                           ; store the segment selector
           mov ax, 0x8E00
           stosw                           ; store exception gate marker
           pop rax                         ; get the exception gate back
           shr rax, 16
           stosw                           ; store the high word (31..16) of the address
           shr rax, 16
           stosd                           ; store the extra high dword (63..32) of the address.
           xor rax, rax
           stosd                           ; reserved
           dec rcx
           jnz make_exception_gates
   
           mov rcx, 256-32
   make_interrupt_gates:                   ; make gates for the other interrupts
           mov rax, interrupt_gate
           push rax                        ; save the interrupt gate to the stack for later use
           stosw                           ; store the low word (15..0) of the address
           mov ax, SYS64_CODE_SEL
           stosw                           ; store the segment selector
           mov ax, 0x8F00
           stosw                           ; store interrupt gate marker
           pop rax                         ; get the interrupt gate back
           shr rax, 16
           stosw                           ; store the high word (31..16) of the address
           shr rax, 16
           stosd                           ; store the extra high dword (63..32) of the address.
           xor rax, rax
           stosd                           ; reserved
           dec rcx
           jnz make_interrupt_gates
   
           ; Set up the exception gates for all of the CPU exceptions
           ; The following code will be seriously busted if the exception gates are moved above 16MB
           mov word [0x00*16], exception_gate_00
           mov word [0x01*16], exception_gate_01
           mov word [0x02*16], exception_gate_02
           mov word [0x03*16], exception_gate_03
           mov word [0x04*16], exception_gate_04
           mov word [0x05*16], exception_gate_05
           mov word [0x06*16], exception_gate_06
           mov word [0x07*16], exception_gate_07
           mov word [0x08*16], exception_gate_08
           mov word [0x09*16], exception_gate_09
           mov word [0x0A*16], exception_gate_10
           mov word [0x0B*16], exception_gate_11
           mov word [0x0C*16], exception_gate_12
           mov word [0x0D*16], exception_gate_13
           mov word [0x0E*16], exception_gate_14
           mov word [0x0F*16], exception_gate_15
           mov word [0x10*16], exception_gate_16
           mov word [0x11*16], exception_gate_17
           mov word [0x12*16], exception_gate_18
           mov word [0x13*16], exception_gate_19
   
           mov rdi, 0x21                   ; Set up Keyboard handler
           mov rax, keyboard
           call create_gate
           mov rdi, 0x22                   ; Set up Cascade handler
           mov rax, cascade
           call create_gate
           mov rdi, 0x28                   ; Set up RTC handler
           mov rax, rtc
           call create_gate
   
           lidt [IDTR64]                   ; load IDT register
   
   ; Debug
           mov al, '4'
           mov [0x000B809E], al
   
   ; Clear memory 0xf000 - 0xf7ff for the infomap (2048 bytes)
           xor rax, rax
           mov rcx, 256
           mov rdi, 0x000000000000F000
   clearmapnext:
           stosq
           dec rcx
           cmp rcx, 0
           jne clearmapnext
   
           call init_acpi                  ; Find and process the ACPI tables
   
           call init_cpu                   ; Configure the BSP CPU
   
           call init_pic                   ; Configure the PIC(s), also activate interrupts
   
   ; Debug
           mov al, '6'                     ; CPU Init complete
           mov [0x000B809E], al
   
   ; Make sure exceptions are working.
   ;       xor rax, rax
   ;       xor rbx, rbx
   ;       xor rcx, rcx
   ;       xor rdx, rdx
   ;       div rax
   
   ; Init of SMP
           call init_smp
   
   ; Reset the stack to the proper location (was set to 0x8000 previously)
           mov rsi, [os_LocalAPICAddress]  ; We would call os_smp_get_id here but the stack is not ...
           add rsi, 0x20                   ; ... yet defined. It is safer to find the value directly.
           lodsd                           ; Load a 32-bit value. We only want the high 8 bits
           shr rax, 24                     ; Shift to the right and AL now holds the CPU's APIC ID
           shl rax, 10                     ; shift left 10 bits for a 1024byte stack
           add rax, 0x0000000000050400     ; stacks decrement when you "push", start at 1024 bytes in
           mov rsp, rax                    ; Pure64 leaves 0x50000-0x9FFFF free so we use that
   
   ; Debug
           mov al, '6'                     ; SMP Init complete
           mov [0x000B809C], al
           mov al, '0'
           mov [0x000B809E], al
   
   ; Calculate amount of usable RAM from Memory Map
           xor rcx, rcx
           mov rsi, 0x0000000000004000     ; E820 Map location
   readnextrecord:
           lodsq
           lodsq
           lodsd
           cmp eax, 0                      ; Are we at the end?
           je endmemcalc
           cmp eax, 1                      ; Useable RAM
           je goodmem
           cmp eax, 3                      ; ACPI Reclaimable
           je goodmem
           cmp eax, 6                      ; BIOS Reclaimable
           je goodmem
           lodsd
           lodsq
           jmp readnextrecord
   goodmem:
           sub rsi, 12
           lodsq
           add rcx, rax
           lodsq
           lodsq
           jmp readnextrecord
   
   endmemcalc:
           shr rcx, 20                     ; Value is in bytes so do a quick divide by 1048576 to get MiB's
           add ecx, 1                      ; The BIOS will usually report actual memory minus 1
           and ecx, 0xFFFFFFFE             ; Make sure it is an even number (in case we added 1 to an even number)
           mov dword [mem_amount], ecx
   
   ; Debug
           mov al, '2'
           mov [0x000B809E], al
   
   ; Convert CPU speed value to string
           xor rax, rax
           mov ax, [cpu_speed]
           mov rdi, speedtempstring
           call os_int_to_string
   
   ; Convert CPU amount value to string
           xor rax, rax
           mov ax, [cpu_activated]
           mov rdi, cpu_amount_string
           call os_int_to_string
   
   ; Convert RAM amount value to string
           xor rax, rax
           mov eax, [mem_amount]
           mov rdi, memtempstring
           call os_int_to_string
   
   ; Build the infomap
           xor rdi, rdi
           mov di, 0x5000
           mov rax, [os_ACPITableAddress]
           stosq
           mov eax, [os_BSP]
           stosd
   
           mov di, 0x5010
           mov ax, [cpu_speed]
           stosw
           mov ax, [cpu_activated]
           stosw
           mov ax, [cpu_detected]
           stosw
   
           mov di, 0x5020
           mov ax, [mem_amount]
           stosd
   
           mov di, 0x5030
           mov al, [os_IOAPICCount]
           stosb
   
           mov di, 0x5040
           mov rax, [os_HPETAddress]
           stosq
   
           mov di, 0x5060
           mov rax, [os_LocalAPICAddress]
           stosq
           xor ecx, ecx
           mov cl, [os_IOAPICCount]
           mov rsi, os_IOAPICAddress
   nextIOAPIC:
           lodsq
           stosq
           sub cl, 1
           cmp cl, 0
           jne nextIOAPIC
   
           mov di, 0x5080
           mov eax, [VBEModeInfoBlock.PhysBasePtr]         ; Base address of video memory (if graphics mode is set)
           stosd
           mov eax, [VBEModeInfoBlock.XResolution]         ; X and Y resolution (16-bits each)
           stosd
           mov al, [VBEModeInfoBlock.BitsPerPixel]         ; Color depth
           stosb
   
   ; Initialization is now complete... write a message to the screen
           mov rsi, msg_done
           call os_print_string
   
   ; Debug
           mov al, '4'
           mov [0x000B809E], al
   
   ; Print info on CPU and MEM
           mov ax, 0x0004
           call os_move_cursor
           mov rsi, msg_CPU
           call os_print_string
           mov rsi, speedtempstring
           call os_print_string
           mov rsi, msg_mhz
           call os_print_string
           mov rsi, cpu_amount_string
           call os_print_string
           mov rsi, msg_MEM
           call os_print_string
           mov rsi, memtempstring
           call os_print_string
           mov rsi, msg_mb
           call os_print_string
     
   
   %ifdef checkMagicNumberOfKernel
           mov eax, dword[LocationOfKernel + SizeOfKernel*1024 - 4]
           cmp eax, MagicNumberOfKernel
           jne magic_fail
   %endif
   
   %ifdef checkMagicNumberOfEnglishCore
           mov eax, dword[LocationOfEnglishCore]
           cmp eax, MagicNumberOfEnglishCore
           jne magic_fail
   %endif
   
   ; Print a message that the kernel is being started
           mov ax, 0x0006
           call os_move_cursor
           mov rsi, msg_startingkernel
           call os_print_string
   
   ; Debug
           mov rdi, 0x000B8092             ; Clear the debug messages
           mov ax, 0x0720
           mov cx, 7
   clearnext:
           stosw
           sub cx, 1
           cmp cx, 0
           jne clearnext
   
   ; Clear all registers (skip the stack pointer)
           xor rax, rax
           xor rbx, rbx
           xor rcx, rcx
           xor rdx, rdx
           xor rsi, rsi
           xor rdi, rdi
           xor rbp, rbp
           xor r8, r8
           xor r9, r9
           xor r10, r10
           xor r11, r11
           xor r12, r12
           xor r13, r13
           xor r14, r14
           xor r15, r15
   
           mov rsp, 10*1024*1024
   
           jmp LocationOfKernel
   
   
   magic_fail:
           mov rsi, msg_MagicFail
           call os_print_string
           hlt
   
   msg_MagicFail:  db "pure64 magic fail", 13, 10, 0
   #+end_src
** init ACPI
   #+begin_src nasm :tangle no
   init_acpi:
           mov rsi, 0x00000000000E0000     ; Start looking for the Root System Description Pointer Structure
           mov rbx, 'RSD PTR '             ; This in the Signature for the ACPI Structure Table (0x2052545020445352)
   searchingforACPI:
           lodsq                           ; Load a quad word from RSI and store in RAX, then increment RSI by 8
           cmp rax, rbx
           je foundACPI
           cmp rsi, 0x00000000000FFFFF     ; Keep looking until we get here
           jge noACPI                      ; ACPI tables couldn't be found, Fail.
           jmp searchingforACPI
   
   foundACPI:                              ; Found a Pointer Structure, verify the checksum
           push rsi
           xor ebx, ebx
           mov ecx, 20                     ; As per the spec only the first 20 bytes matter
           sub rsi, 8                      ; Bytes 0 thru 19 must sum to zero
   nextchecksum:
           lodsb                           ; Get a byte
           add bl, al                      ; Add it to the running total
           sub cl, 1
           cmp cl, 0
           jne nextchecksum
           pop rsi
           cmp bl, 0
           jne searchingforACPI            ; Checksum didn't check out? Then keep looking.
   
           lodsb                           ; Checksum
           lodsd                           ; OEMID (First 4 bytes)
           lodsw                           ; OEMID (Last 2 bytes)
           lodsb                           ; Grab the Revision value (0 is v1.0, 1 is v2.0, 2 is v3.0, etc)
           add al, 49
           mov [0x000B8098], al            ; Print the ACPI version number
           sub al, 49
           cmp al, 0
           je foundACPIv1                  ; If AL is 0 then the system is using ACPI v1.0
           jmp foundACPIv2                 ; Otherwise it is v2.0 or higher
   
   foundACPIv1:
           xor eax, eax
           lodsd                           ; Grab the 32 bit physical address of the RSDT (Offset 16).
           mov rsi, rax                    ; RSI now points to the RSDT
           lodsd                           ; Grab the Signiture
           cmp eax, 'RSDT'                 ; Make sure the signiture is valid
           jne novalidacpi                 ; Not the same? Bail out
           sub rsi, 4
           mov [os_ACPITableAddress], rsi  ; Save the RSDT Table Address
           add rsi, 4
           xor eax, eax
           lodsd                           ; Length
           add rsi, 28                     ; Skip to the Entry offset
           sub eax, 36                     ; EAX holds the table size. Subtract the preamble
           shr eax, 2                      ; Divide by 4
           mov rdx, rax                    ; RDX is the entry count
           xor ecx, ecx
   foundACPIv1_nextentry:
           lodsd
           push rax
           add ecx, 1
           cmp ecx, edx
           je findACPITables
           jmp foundACPIv1_nextentry
   
   foundACPIv2:
           lodsd                           ; RSDT Address
           lodsd                           ; Length
           lodsq                           ; Grab the 64 bit physical address of the XSDT (Offset 24).
           mov rsi, rax                    ; RSI now points to the XSDT
           lodsd                           ; Grab the Signiture
           cmp eax, 'XSDT'                 ; Make sure the signiture is valid
           jne novalidacpi                 ; Not the same? Bail out
           sub rsi, 4
           mov [os_ACPITableAddress], rsi  ; Save the XSDT Table Address
           add rsi, 4
           xor eax, eax
           lodsd                           ; Length
           add rsi, 28                     ; Skip to the start of the Entries (offset 36)
           sub eax, 36                     ; EAX holds the table size. Subtract the preamble
           shr eax, 3                      ; Divide by 8
           mov rdx, rax                    ; RDX is the entry count
           xor ecx, ecx
   foundACPIv2_nextentry:
           lodsq
           push rax
           add ecx, 1
           cmp ecx, edx
           jne foundACPIv2_nextentry
   
   findACPITables:
           mov al, '3'                     ; Search through the ACPI tables
           mov [0x000B809C], al
           mov al, '4'
           mov [0x000B809E], al
           xor ecx, ecx
   nextACPITable:
           pop rsi
           lodsd
           add ecx, 1
           mov ebx, 'APIC'                 ; Signature for the Multiple APIC Description Table
           cmp eax, ebx
           je foundAPICTable
           mov ebx, 'HPET'                 ; Signiture for the HPET Description Table
           cmp eax, ebx
           je foundHPETTable
           cmp ecx, edx
           jne nextACPITable
           jmp init_smp_acpi_done          ;noACPIAPIC
   
   foundAPICTable:
           call parseAPICTable
           jmp nextACPITable
   
   foundHPETTable:
           call parseHPETTable
           jmp nextACPITable
   
   init_smp_acpi_done:
           ret
   
   noACPI:
   novalidacpi:
           mov al, 'X'
           mov [0x000B809A], al
           jmp $
   
   
   ; -----------------------------------------------------------------------------
   parseAPICTable:
           push rcx
           push rdx
   
           lodsd                           ; Length of MADT in bytes
           mov ecx, eax                    ; Store the length in ECX
           xor ebx, ebx                    ; EBX is the counter
           lodsb                           ; Revision
           lodsb                           ; Checksum
           lodsd                           ; OEMID (First 4 bytes)
           lodsw                           ; OEMID (Last 2 bytes)
           lodsq                           ; OEM Table ID
           lodsd                           ; OEM Revision
           lodsd                           ; Creator ID
           lodsd                           ; Creator Revision
           xor eax, eax
           lodsd                           ; Local APIC Address
           mov [os_LocalAPICAddress], rax  ; Save the Address of the Local APIC
           lodsd                           ; Flags
           add ebx, 44
           mov rdi, 0x0000000000005100     ; Valid CPU IDs
   
   readAPICstructures:
           cmp ebx, ecx
           jge parseAPICTable_done
   ;       call os_print_newline
           lodsb                           ; APIC Structure Type
   ;       call os_debug_dump_al
   ;       push rax
   ;       mov al, ' '
   ;       call os_print_char
   ;       pop rax
           cmp al, 0x00                    ; Processor Local APIC
           je APICapic
           cmp al, 0x01                    ; I/O APIC
           je APICioapic
           cmp al, 0x02                    ; Interrupt Source Override
           je APICinterruptsourceoverride
   ;       cmp al, 0x03                    ; Non-maskable Interrupt Source (NMI)
   ;       je APICnmi
   ;       cmp al, 0x04                    ; Local APIC NMI
   ;       je APIClocalapicnmi
   ;       cmp al, 0x05                    ; Local APIC Address Override
   ;       je APICaddressoverride
           cmp al, 0x09                    ; Processor Local x2APIC
           je APICx2apic
   ;       cmp al, 0x0A                    ; Local x2APIC NMI
   ;       je APICx2nmi
   
           jmp APICignore
   
   APICapic:
           xor eax, eax
           xor edx, edx
           lodsb                           ; Length (will be set to 8)
           add ebx, eax
           lodsb                           ; ACPI Processor ID
           lodsb                           ; APIC ID
           xchg eax, edx                   ; Save the APIC ID to EDX
           lodsd                           ; Flags (Bit 0 set if enabled/usable)
           bt eax, 0                       ; Test to see if usable
           jnc readAPICstructures          ; Read the next structure if CPU not usable
           inc word [cpu_detected]
           xchg eax, edx                   ; Restore the APIC ID back to EAX
           stosb
           jmp readAPICstructures          ; Read the next structure
   
   APICioapic:
           xor eax, eax
           lodsb                           ; Length (will be set to 12)
           add ebx, eax
           lodsb                           ; IO APIC ID
           lodsb                           ; Reserved
           xor eax, eax
           lodsd                           ; IO APIC Address
           push rdi
           push rcx
           mov rdi, os_IOAPICAddress
           xor ecx, ecx
           mov cl, [os_IOAPICCount]
           shl cx, 3                       ; Quick multiply by 8
           add rdi, rcx
           pop rcx
           stosd                           ; Store the IO APIC Address
           lodsd                           ; System Vector Base
           stosd                           ; Store the IO APIC Vector Base
           pop rdi
           inc byte [os_IOAPICCount]
           jmp readAPICstructures          ; Read the next structure
   
   APICinterruptsourceoverride:
           xor eax, eax
           lodsb                           ; Length (will be set to 10)
           add ebx, eax
           lodsb                           ; Bus
           lodsb                           ; Source
   ;       call os_print_newline
   ;       call os_debug_dump_al
   ;       mov al, ' '
   ;       call os_print_char
           lodsd                           ; Global System Interrupt
   ;       call os_debug_dump_eax
           lodsw                           ; Flags
           jmp readAPICstructures          ; Read the next structure
   
   APICx2apic:
           xor eax, eax
           xor edx, edx
           lodsb                           ; Length (will be set to 16)
           add ebx, eax
           lodsw                           ; Reserved; Must be Zero
           lodsd
           xchg eax, edx                   ; Save the x2APIC ID to EDX
           lodsd                           ; Flags (Bit 0 set if enabled/usable)
           bt eax, 0                       ; Test to see if usable
           jnc APICx2apicEnd               ; Read the next structure if CPU not usable
           xchg eax, edx                   ; Restore the x2APIC ID back to EAX
           call os_debug_dump_eax
           call os_print_newline
           ; Save the ID's somewhere
   APICx2apicEnd:
           lodsd                           ; ACPI Processor UID
           jmp readAPICstructures          ; Read the next structure
   
   APICignore:
           xor eax, eax
           lodsb                           ; We have a type that we ignore, read the next byte
           add ebx, eax
           add rsi, rax
           sub rsi, 2                      ; For the two bytes just read
           jmp readAPICstructures          ; Read the next structure
   
   parseAPICTable_done:
           pop rdx
           pop rcx
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   parseHPETTable:
           lodsd                           ; Length of HPET in bytes
           lodsb                           ; Revision
           lodsb                           ; Checksum
           lodsd                           ; OEMID (First 4 bytes)
           lodsw                           ; OEMID (Last 2 bytes)
           lodsq                           ; OEM Table ID
           lodsd                           ; OEM Revision
           lodsd                           ; Creator ID
           lodsd                           ; Creator Revision
           lodsd                           ; Event Timer Block ID
           lodsd                           ; Base Address Settings
           lodsq                           ; Base Address Value
           mov [os_HPETAddress], rax       ; Save the Address of the HPET
           lodsb                           ; HPET Number
           lodsw                           ; Main Counter Minimum
           lodsw                           ; Page Protection And OEM Attribute
           ret
   ; -----------------------------------------------------------------------------
#+end_src
** init CPU
   #+begin_src nasm :tangle no
   init_cpu:
   
   ;; ; Disable Cache
   ;;         mov rax, cr0
   ;;         btr rax, 29                     ; Clear No Write Thru (Bit 29)
   ;;         bts rax, 30                     ; Set Cache Disable (Bit 30)
   ;;         mov cr0, rax
   ;;  
   ;; ; Flush Cache
   ;;         wbinvd
   
   ; Disable Paging Global Extensions
           mov rax, cr4
           btr rax, 7                      ; Clear Paging Global Extensions (Bit 7)
           mov cr4, rax
           mov rax, cr3
           mov cr3, rax
   
   ; Disable MTRRs and Configure default memory type to UC
           mov ecx, 0x000002FF
           rdmsr
           and eax, 0xFFFFF300             ; Clear MTRR Enable (Bit 11), Fixed Range MTRR Enable (Bit 10), and Default Memory Type (Bits 7:0) to UC (0x00)
           wrmsr
   
   ; Setup variable-size address ranges
   ; Cache 0-64 MiB as type 6 (WB) cache
   ; See example in Intel Volume 3A. Example Base and Mask Calculations
   ;       mov ecx, 0x00000200             ; MTRR_Phys_Base_MSR(0)
   ;       mov edx, 0x00000000             ; Base is EDX:EAX, 0x0000000000000006
   ;       mov eax, 0x00000006             ; Type 6 (write-back cache)
   ;       wrmsr
   ;       mov ecx, 0x00000201             ; MTRR_Phys_Mask_MSR(0)
   ;;      mov edx, 0x00000000             ; Mask is EDX:EAX, 0x0000000001000800 (Because bochs sucks)
   ;;      mov eax, 0x01000800             ; Bit 11 set for Valid
   ;       mov edx, 0x0000000F             ; Mask is EDX:EAX, 0x0000000F80000800 (2 GiB)
   ;       mov eax, 0x80000800             ; Bit 11 set for Valid
   ;       wrmsr
   
   ; MTRR notes:
   ; Base 0x0000000000000000 = 0 MiB
   ; Base 0x0000000080000000 = 2048 MiB, 2048 is 0x800
   ; Base 0x0000000100000000 = 4096 MiB, 4096 is 0x1000
   ; Mask 0x0000000F80000000 = 2048 MiB, 0xFFFFFFFFF - F80000000 = 7FFFFFFF = 2147483647 (~2 GiB)
   ; Mask 0x0000000FC0000000 = 1024 MiB, 0xFFFFFFFFF - FC0000000 = 3FFFFFFF = 1073741823 (~1 GiB)
   ; Mask 0x0000000FFC000000 = 64 MiB,   0xFFFFFFFFF - FFC000000 =  3FFFFFF =   67108863 (~64 MiB)
   
   ;; Disable Cache
   ;        mov rax, cr0
   ;        btr rax, 29                     ; Clear No Write Thru (Bit 29)
   ;        bts rax, 30                     ; Set Cache Disable (Bit 30)
   ;        mov cr0, rax
   
   ; Flush Cache
   ;        wbinvd
   
   
   ; Enable MTRRs
           mov ecx, 0x000002FF
           rdmsr
           bts eax, 11                     ; Set MTRR Enable (Bit 11), Only enables Variable Range MTRR's
           wrmsr  
   
   ; Enable Paging Global Extensions
         mov rax, cr4
         bts rax, 7                      ; Set Paging Global Extensions (Bit 7)
         mov cr4, rax
   
   ; Enable Floating Point
           mov rax, cr0
           bts rax, 1                      ; Set Monitor co-processor (Bit 1)
           btr rax, 2                      ; Clear Emulation (Bit 2)
           mov cr0, rax
   
   ; Enable SSE
           mov rax, cr4
           bts rax, 9                      ; Set Operating System Support for FXSAVE and FXSTOR instructions (Bit 9)
           bts rax, 10                     ; Set Operating System Support for Unmasked SIMD Floating-Point Exceptions (Bit 10)
           mov cr4, rax
   
   ; Enable Math Co-processor
           finit
   
   ; Enable and Configure Local APIC
           mov rsi, [os_LocalAPICAddress]
           cmp rsi, 0x00000000
           je noMP                         ; Skip MP init if we didn't get a valid LAPIC address
   
           xor eax, eax                    ; Clear Task Priority (bits 7:4) and Priority Sub-Class (bits 3:0)
           mov dword [rsi+0x80], eax       ; Task Priority Register (TPR)
   
           mov eax, 0x01000000             ; Set bits 31-24 for all cores to be in Group 1
           mov dword [rsi+0xD0], eax       ; Logical Destination Register
   
           xor eax, eax
           sub eax, 1                      ; Set EAX to 0xFFFFFFFF; Bits 31-28 set for Flat Mode
           mov dword [rsi+0xE0], eax       ; Destination Format Register
   
           mov eax, dword [rsi+0xF0]       ; Spurious Interrupt Vector Register
           mov al, 0xF8
           bts eax, 8                      ; Enable APIC (Set bit 8)
           mov dword [rsi+0xF0], eax
   
           mov eax, dword [rsi+0x320]      ; LVT Timer Register
           bts eax, 16                     ; Set bit 16 for mask interrupts
           mov dword [rsi+0x320], eax
   
         ; mov eax, dword [rsi+0x350]      ; LVT LINT0 Register
         ; mov al, 0                       ;Set interrupt vector (bits 7:0)
         ; bts eax, 8                      ;Delivery Mode (111b==ExtlNT] (bits 10:8)
         ; bts eax, 9
         ; bts eax, 10
         ; bts eax, 15                     ;bit15:Set trigger mode to Level (0== Edge, 1== Level)
         ; btr eax, 16                     ;bit16:unmask interrupts (0==Unmasked, 1== Masked)
         ; mov dword [rsi+0x350], eax
   
         ; mov eax, dword [rsi+0x360]      ; LVT LINT1 Register
         ; mov al, 0                       ;Set interrupt vector (bits 7:0)
         ; bts eax, 8                      ;Delivery Mode (111b==ExtlNT] (bits 10:8)
         ; bts eax, 9
         ; bts eax, 10
         ; bts eax, 15                     ;bit15:Set trigger mode to Edge (0== Edge, 1== Level)
         ; btr eax, 16                     ;bit16:unmask interrupts (0==Unmasked, 1== Masked)
         ; mov dword [rsi+0x360], eax
   
         ; mov eax, dword [rsi+0x370]      ; LVT Error Register
         ; mov al, 0                       ;Set interrupt vector (bits 7:0)
         ; bts eax, 16                     ;bit16:Mask interrupts (0==Unmasked, 1== Masked)
         ; mov dword [rsi+0x370], eax   
   
      ; Flush Cache
              wbinvd
      
      ; Enable Cache
              mov rax, cr0
              btr rax, 29                     ; Clear No Write Thru (Bit 29)
              btr rax, 30                     ; Clear CD (Bit 30)
              mov cr0, rax
   
   ret
   #+end_src
** init PIC
   #+begin_src nasm :tangle no
   init_pic:
           ; Enable specific interrupts
           in al, 0x21
           mov al, 11111001b               ; Enable Cascade, Keyboard
           out 0x21, al
           in al, 0xA1
           mov al, 11111110b               ; Enable RTC
           out 0xA1, al

           ; Set the periodic flag in the RTC
           mov al, 0x0B                    ; Status Register B
           out 0x70, al                    ; Select the address
           in al, 0x71                     ; Read the current settings
           push rax
           mov al, 0x0B                    ; Status Register B
           out 0x70, al                    ; Select the address
           pop rax
           bts ax, 6                       ; Set Periodic(6)
           out 0x71, al                    ; Write the new settings

           sti                             ; Enable interrupts

           ; Acknowledge the RTC
           mov al, 0x0C                    ; Status Register C
           out 0x70, al                    ; Select the address
           in al, 0x71                     ; Read the current settings

           ret
   #+end_src
** init SMP
   #+begin_src nasm :tangle no
   init_smp:
           mov al, '5'                     ; Start of MP init
           mov [0x000B809C], al
           mov al, '0'
           mov [0x000B809E], al
   
   ; Check if we want the AP's to be enabled.. if not then skip to end
         cmp byte [cfg_smpinit], 1       ; Check if SMP should be enabled
         jne noMP                        ; If not then skip SMP init
   
   ; Start the AP's one by one
           xor eax, eax
           xor edx, edx
           mov rsi, [os_LocalAPICAddress]
           add rsi, 0x20                   ; Add the offset for the APIC ID location
           lodsd                           ; APIC ID is stored in bits 31:24
           shr rax, 24                     ; AL now holds the BSP CPU's APIC ID
           mov dl, al                      ; Store BSP APIC ID in DL
   
           mov al, '8'                     ; Start the AP's
           mov [0x000B809E], al
   
           mov rsi, 0x0000000000005100
           xor eax, eax
           xor ecx, ecx
           mov cx, [cpu_detected]
   smp_send_INIT:
           cmp cx, 0
           je smp_send_INIT_done
           lodsb
   
           cmp al, dl                      ; Is it the BSP?
           je smp_send_INIT_skipcore
   
           ; Broadcast 'INIT' IPI to APIC ID in AL
           mov rdi, [os_LocalAPICAddress]
           shl eax, 24
           mov dword [rdi+0x310], eax      ; Interrupt Command Register (ICR); bits 63-32
           mov eax, 0x00004500
           mov dword [rdi+0x300], eax      ; Interrupt Command Register (ICR); bits 31-0
   smp_send_INIT_verify:
           mov eax, [rdi+0x300]            ; Interrupt Command Register (ICR); bits 31-0
           bt eax, 12                      ; Verify that the command completed
           jc smp_send_INIT_verify
   
   smp_send_INIT_skipcore:
           dec cl
           jmp smp_send_INIT
   
   smp_send_INIT_done:
   
           mov rax, [os_Counter_RTC]
           add rax, 10
   wait1:
           mov rbx, [os_Counter_RTC]
           cmp rax, rbx
           jg wait1
   
           mov rsi, 0x0000000000005100
           xor ecx, ecx
           mov cx, [cpu_detected]
   smp_send_SIPI:
           cmp cx, 0
           je smp_send_SIPI_done
           lodsb
   
           cmp al, dl                      ; Is it the BSP?
           je smp_send_SIPI_skipcore
   
           ; Broadcast 'Startup' IPI to destination using vector 0x08 to specify entry-point is at the memory-address 0x00008000
           mov rdi, [os_LocalAPICAddress]
           shl eax, 24
           mov dword [rdi+0x310], eax      ; Interrupt Command Register (ICR); bits 63-32
           mov eax, 0x00004608             ; Vector 0x08
           mov dword [rdi+0x300], eax      ; Interrupt Command Register (ICR); bits 31-0
   smp_send_SIPI_verify:
           mov eax, [rdi+0x300]            ; Interrupt Command Register (ICR); bits 31-0
           bt eax, 12                      ; Verify that the command completed
           jc smp_send_SIPI_verify
   
   smp_send_SIPI_skipcore:
           dec cl
           jmp smp_send_SIPI
   
   smp_send_SIPI_done:
   
           mov al, 'A'
           mov [0x000B809E], al
   
   ; Let things settle (Give the AP's some time to finish)
           mov rax, [os_Counter_RTC]
           add rax, 20
   wait3:
           mov rbx, [os_Counter_RTC]
           cmp rax, rbx
           jg wait3
   
   ; Finish up
   noMP:
           lock inc word [cpu_activated]   ; BSP adds one here
   
           xor eax, eax
           mov rsi, [os_LocalAPICAddress]
           add rsi, 0x20                   ; Add the offset for the APIC ID location
           lodsd                           ; APIC ID is stored in bits 31:24
           shr rax, 24                     ; AL now holds the CPU's APIC ID (0 - 255)
           mov [os_BSP], eax               ; Store the BSP APIC ID
   
           mov al, 'C'
           mov [0x000B809E], al
   
   ; Calculate speed of CPU (At this point the RTC is firing at 1024Hz)
           cpuid
           xor edx, edx
           xor eax, eax
           mov rcx, [os_Counter_RTC]
           add rcx, 10
           rdtsc
           push rax
   speedtest:
           mov rbx, [os_Counter_RTC]
           cmp rbx, rcx
           jl speedtest
           rdtsc
           pop rdx
           sub rax, rdx
           xor edx, edx
           mov rcx, 10240
           div rcx
           mov [cpu_speed], ax
   
   ; Clear the periodic flag in the RTC
           mov al, 0x0B                    ; Status Register B
           out 0x70, al                    ; Select the address
           in al, 0x71                     ; Read the current settings
           push rax
           mov al, 0x0B                    ; Status Register B
           out 0x70, al                    ; Select the address
           pop rax
           btc ax, 6                       ; Set Periodic(6)
           out 0x71, al                    ; Write the new settings
   
           mov al, 'E'
           mov [0x000B809E], al
   
           cli                             ; Disable Interrupts
   
           ret
#+end_src
** syscalls
   #+begin_src nasm :tangle no
   ; -----------------------------------------------------------------------------
   ; os_move_cursor -- Moves the virtual cursor in text mode
   ;  IN:  AH, AL = row, column
   ; OUT:  Nothing. All registers preserved
   os_move_cursor:
           push rcx
           push rbx
           push rax
   
           xor ebx, ebx
           mov [screen_cursor_x], ah
           mov [screen_cursor_y], al
           mov bl, ah
   
           ; Calculate the new offset
           and rax, 0x00000000000000FF     ; only keep the low 8 bits
           mov cl, 80
           mul cl                          ; AX = AL * CL
           add ax, bx
           shl ax, 1                       ; multiply by 2
   
           add rax, 0x00000000000B8000
           mov [screen_cursor_offset], rax
   
           pop rax
           pop rbx
           pop rcx
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_print_newline -- Reset cursor to start of next line and scroll if needed
   ;  IN:  Nothing
   ; OUT:  Nothing, all registers perserved
   os_print_newline:
           push rax
   
           mov ah, 0                       ; Set the cursor x value to 0
           mov al, [screen_cursor_y]       ; Grab the cursor y value
           cmp al, 24                      ; Compare to see if we are on the last line
           je os_print_newline_scroll      ; If so then we need to scroll the sreen
   
           inc al                          ; If not then we can go ahead an increment the y value
           jmp os_print_newline_done
   
   os_print_newline_scroll:
           mov ax, 0x0000                  ; If we have reached the end then wrap back to the front
   
   os_print_newline_done:
           call os_move_cursor             ; update the cursor
   
           pop rax
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_print_string -- Displays text
   ;  IN:  RSI = message location (zero-terminated string)
   ; OUT:  Nothing, all registers perserved
   os_print_string:
           push rsi
           push rax
   
           cld                             ; Clear the direction flag.. we want to increment through the string
   
   os_print_string_nextchar:
           lodsb                           ; Get char from string and store in AL
           cmp al, 0                       ; Strings are Zero terminated.
           je os_print_string_done         ; If char is Zero then it is the end of the string
   
           cmp al, 13                      ; Check if there was a newline character in the string
           je os_print_string_newline      ; If so then we print a new line
   
           call os_print_char
   
           jmp os_print_string_nextchar
   
   os_print_string_newline:
           call os_print_newline
           jmp os_print_string_nextchar
   
   os_print_string_done:
           pop rax
           pop rsi
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_print_char -- Displays a char
   ;  IN:  AL = char to display
   ; OUT:  Nothing. All registers preserved
   os_print_char:
           push rdi
   
           mov rdi, [screen_cursor_offset]
           stosb
           add qword [screen_cursor_offset], 2     ; Add 2 (1 byte for char and 1 byte for attribute)
   
           pop rdi
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_print_char_hex -- Displays a char in hex mode
   ;  IN:  AL = char to display
   ; OUT:  Nothing. All registers preserved
   os_print_char_hex:
           push rbx
           push rax
   
           mov rbx, hextable
   
           push rax                        ; save rax for the next part
           shr al, 4                       ; we want to work on the high part so shift right by 4 bits
           xlatb
           call os_print_char
   
           pop rax
           and al, 0x0f                    ; we want to work on the low part so clear the high part
           xlatb
           call os_print_char
   
           pop rax
           pop rbx
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_debug_dump_(rax|eax|ax|al) -- Dump content of RAX, EAX, AX, or AL to the screen in hex format
   ;  IN:  RAX = content to dump
   ; OUT:  Nothing, all registers preserved
   os_debug_dump_rax:
           ror rax, 56
           call os_print_char_hex
           rol rax, 8
           call os_print_char_hex
           rol rax, 8
           call os_print_char_hex
           rol rax, 8
           call os_print_char_hex
           rol rax, 32
   os_debug_dump_eax:
           ror rax, 24
           call os_print_char_hex
           rol rax, 8
           call os_print_char_hex
           rol rax, 16
   os_debug_dump_ax:
           ror rax, 8
           call os_print_char_hex
           rol rax, 8
   os_debug_dump_al:
           call os_print_char_hex
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_dump_regs -- Dump the values on the registers to the screen (For debug purposes)
   ; IN/OUT: Nothing
   os_dump_regs:
           push r15
           push r14
           push r13
           push r12
           push r11
           push r10
           push r9
           push r8
           push rsp
           push rbp
           push rdi
           push rsi
           push rdx
           push rcx
           push rbx
           push rax
   
           mov byte [os_dump_reg_stage], 0x00      ; Reset the stage to 0 since we are starting
           mov rcx, rsp
           call os_print_newline
   
   os_dump_regs_again:
           mov rsi, os_dump_reg_string00
           xor rax, rax
           xor rbx, rbx
           mov al, [os_dump_reg_stage]
           mov bl, 5                               ; each string is 5 bytes
           mul bl                                  ; ax = bl x al
           add rsi, rax
           call os_print_string                    ; Print the register name
   
           mov rax, [rcx]
           add rcx, 8
           call os_debug_dump_rax
   
           add byte [os_dump_reg_stage], 1
           cmp byte [os_dump_reg_stage], 0x10
           jne os_dump_regs_again
   
           pop rax
           pop rbx
           pop rcx
           pop rdx
           pop rsi
           pop rdi
           pop rbp
           pop rsp
           pop r8
           pop r9
           pop r10
           pop r11
           pop r12
           pop r13
           pop r14
           pop r15
   
           ret
   
   os_dump_reg_string00: db '  A:', 0
   os_dump_reg_string01: db '  B:', 0
   os_dump_reg_string02: db '  C:', 0
   os_dump_reg_string03: db '  D:', 0
   os_dump_reg_string04: db ' SI:', 0
   os_dump_reg_string05: db ' DI:', 0
   os_dump_reg_string06: db ' BP:', 0
   os_dump_reg_string07: db ' SP:', 0
   os_dump_reg_string08: db '  8:', 0
   os_dump_reg_string09: db '  9:', 0
   os_dump_reg_string0A: db ' 10:', 0
   os_dump_reg_string0B: db ' 11:', 0
   os_dump_reg_string0C: db ' 12:', 0
   os_dump_reg_string0D: db ' 13:', 0
   os_dump_reg_string0E: db ' 14:', 0
   os_dump_reg_string0F: db ' 15:', 0
   os_dump_reg_stage: db 0x00
   ; -----------------------------------------------------------------------------
   
   
   
   ; -----------------------------------------------------------------------------
   ; os_dump_mem -- Dump some memory content to the screen (For debug purposes)
   ; IN: RSI = memory to dump (512bytes)
   ;OUT:
   os_dump_mem:
           push rdx
           push rcx
           push rbx
           push rax
   
           push rsi
   
           mov rcx, 512
   dumpit:
           lodsb
           call os_print_char_hex
           dec rcx
           cmp rcx, 0
           jne dumpit
   
           pop rsi
   
   ;       call os_print_newline
   
           pop rax
           pop rbx
           pop rcx
           pop rdx
   
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_int_to_string -- Convert a binary interger into an string string
   ;  IN:  RAX = binary integer
   ;       RDI = location to store string
   ; OUT:  RDI = pointer to end of string
   ;       All other registers preserved
   ; Min return value is 0 and max return value is 18446744073709551615 so your
   ; string needs to be able to store at least 21 characters (20 for the number
   ; and 1 for the string terminator).
   ; Adapted from http://www.cs.usfca.edu/~cruse/cs210s09/rax2uint.s
   os_int_to_string:
           push rdx
           push rcx
           push rbx
           push rax
   
           mov rbx, 10                             ; base of the decimal system
           xor rcx, rcx                            ; number of digits generated
   os_int_to_string_next_divide:
           xor rdx, rdx                            ; RAX extended to (RDX,RAX)
           div rbx                                 ; divide by the number-base
           push rdx                                ; save remainder on the stack
           inc rcx                                 ; and count this remainder
           cmp rax, 0x0                            ; was the quotient zero?
           jne os_int_to_string_next_divide        ; no, do another division
   os_int_to_string_next_digit:
           pop rdx                                 ; else pop recent remainder
           add dl, '0'                             ; and convert to a numeral
           mov [rdi], dl                           ; store to memory-buffer
           inc rdi
           loop os_int_to_string_next_digit        ; again for other remainders
           mov al, 0x00
           stosb                                   ; Store the null terminator at the end of the string
   
           pop rax
           pop rbx
           pop rcx
           pop rdx
           ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; create_gate
   ; rax = address of handler
   ; rdi = gate # to configure
   create_gate:
           push rdi
           push rax
   
           shl rdi, 4                      ; quickly multiply rdi by 16
           stosw                           ; store the low word (15..0)
           shr rax, 16
           add rdi, 4                      ; skip the gate marker
           stosw                           ; store the high word (31..16)
           shr rax, 16
           stosd                           ; store the high dword (63..32)
   
           pop rax
           pop rdi
   
           ret
   ; -----------------------------------------------------------------------------
   #+end_src
** interrupt
   #+begin_src nasm :tangle no
   ; -----------------------------------------------------------------------------
   ; Default exception handler
   exception_gate:
           mov rsi, int_string
           call os_print_string
           mov rsi, exc_string
           call os_print_string
   exception_gate_halt:
           cli                             ; Disable interrupts
           hlt                             ; Halt the system
           jmp exception_gate_halt
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Default interrupt handler
   interrupt_gate:                         ; handler for all other interrupts
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Keyboard interrupt. IRQ 0x01, INT 0x21
   ; This IRQ runs whenever there is input on the keyboard
   align 16
   keyboard:
           push rdi
           push rax
   
           xor eax, eax
   
           in al, 0x60                     ; Get the scancode from the keyboard
           test al, 0x80
           jnz keyboard_done
   
           mov [0x000B8088], al            ; Dump the scancode to the screen
   
           mov rax, [os_Counter_RTC]
           add rax, 10
           mov [os_Counter_RTC], rax
   
   keyboard_done:
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0x20, al
   
           pop rax
           pop rdi
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Cascade interrupt. IRQ 0x02, INT 0x22
   cascade:
           push rax
   
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0x20, al
   
           pop rax
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Real-time clock interrupt. IRQ 0x08, INT 0x28
   align 16
   rtc:
           push rdi
           push rax
   
           add qword [os_Counter_RTC], 1   ; 64-bit counter started at bootup
   
           mov al, 'R'
           mov [0x000B8092], al
           mov rax, [os_Counter_RTC]
           and al, 1                       ; Clear all but lowest bit (Can only be 0 or 1)
           add al, 48
           mov [0x000B8094], al
           mov al, 0x0C                    ; Select RTC register C
           out 0x70, al                    ; Port 0x70 is the RTC index, and 0x71 is the RTC data
           in al, 0x71                     ; Read the value in register C
   
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0xA0, al
           out 0x20, al
   
           pop rax
           pop rdi
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; Spurious interrupt. INT 0xFF
   align 16
   spurious:                               ; handler for spurious interrupts
           mov al, 'S'
           mov [0x000B8080], al
           iretq
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; CPU Exception Gates
   exception_gate_00:
           mov al, 0x00
           jmp exception_gate_main
   
   exception_gate_01:
           mov al, 0x01
           jmp exception_gate_main
   
   exception_gate_02:
           mov al, 0x02
           jmp exception_gate_main
   
   exception_gate_03:
           mov al, 0x03
           jmp exception_gate_main
   
   exception_gate_04:
           mov al, 0x04
           jmp exception_gate_main
   
   exception_gate_05:
           mov al, 0x05
           jmp exception_gate_main
   
   exception_gate_06:
           mov al, 0x06
           jmp exception_gate_main
   
   exception_gate_07:
           mov al, 0x07
           jmp exception_gate_main
   
   exception_gate_08:
           mov al, 0x08
           jmp exception_gate_main
   
   exception_gate_09:
           mov al, 0x09
           jmp exception_gate_main
   
   exception_gate_10:
           mov al, 0x0A
           jmp exception_gate_main
   
   exception_gate_11:
           mov al, 0x0B
           jmp exception_gate_main
   
   exception_gate_12:
           mov al, 0x0C
           jmp exception_gate_main
   
   exception_gate_13:
           mov al, 0x0D
           jmp exception_gate_main
   
   exception_gate_14:
           mov al, 0x0E
           jmp exception_gate_main
   
   exception_gate_15:
           mov al, 0x0F
           jmp exception_gate_main
   
   exception_gate_16:
           mov al, 0x10
           jmp exception_gate_main
   
   exception_gate_17:
           mov al, 0x11
           jmp exception_gate_main
   
   exception_gate_18:
           mov al, 0x12
           jmp exception_gate_main
   
   exception_gate_19:
           mov al, 0x13
           jmp exception_gate_main
   
   exception_gate_main:
           call os_print_newline
           mov rsi, int_string
           call os_print_string
           mov rsi, exc_string00
           and rax, 0xFF                   ; Clear out everything in RAX except for AL
           shl eax, 3                              ; Quick multiply by 3
           add rsi, rax                            ; Use the value in RAX as an offset to get to the right message
           call os_print_string
           mov rsi, adr_string
           call os_print_string
           mov rax, [rsp]
           call os_debug_dump_rax
           call os_print_newline
           call os_dump_regs
   
   exception_gate_main_hang:
           nop
           jmp exception_gate_main_hang    ; Hang. User must reset machine at this point
   
   ; Strings for the error messages
   int_string db 'Pure64 - Exception ', 0
   adr_string db ' @ 0x', 0
   exc_string db '?? - Unknown', 0
   align 16
   exc_string00 db '00 - DE', 0
   exc_string01 db '01 - DB', 0
   exc_string02 db '02     ', 0
   exc_string03 db '03 - BP', 0
   exc_string04 db '04 - OF', 0
   exc_string05 db '05 - BR', 0
   exc_string06 db '06 - UD', 0
   exc_string07 db '07 - NM', 0
   exc_string08 db '08 - DF', 0
   exc_string09 db '09     ', 0            ; No longer generated on new CPU's
   exc_string10 db '10 - TS', 0
   exc_string11 db '11 - NP', 0
   exc_string12 db '12 - SS', 0
   exc_string13 db '13 - GP', 0
   exc_string14 db '14 - PF', 0
   exc_string15 db '15     ', 0
   exc_string16 db '16 - MF', 0
   exc_string17 db '17 - AC', 0
   exc_string18 db '18 - MC', 0
   exc_string19 db '19 - XM', 0         
   #+end_src
** [CONFIG] system variables
   #+begin_src nasm :tangle no
   ;CONFIG
   cfg_smpinit:            db 0;1    ; By default SMP is enabled. Set to 0 to disable.
   ;Video Electronics Standards Association
   ; IMPORTANT
   ; stick to text mode
   ; for VESA/VBE has its limitations and maybe not supported by some video cards
   ; for example, my sony laptop's mode is 1366*768
   ; it is not supported by VESA/VBE anyway
   cfg_vesa:               db 0    ; By default VESA is disabled. Set to 1 to enable.
   cfg_default:            db 0    ; By default we don't need a config file so set to 0. If a config file is found set to 1.
   cfg_e820:               db 1    ; By default E820 should be present. Pure64 will set this to 0 if not found/usable.
   cfg_mbr:                db 0    ; Did we boot off of a disk with a proper MBR
   cfg_hdd:                db 0    ; Was a bootable drive detected
   
   ; Memory locations
   E820Map:                equ 0x0000000000004000
   InfoMap:                equ 0x0000000000005000
   SystemVariables:        equ 0x0000000000005A00
   VBEModeInfoBlock:       equ 0x0000000000005C00  ; 256 bytes
   ahci_cmdlist:           equ 0x0000000000070000  ; 4096 bytes    0x070000 -> 0x071FFF
   ahci_cmdtable:          equ 0x0000000000072000  ; 57344 bytes   0x072000 -> 0x07FFFF
   
   ; DQ - Starting at offset 0, increments by 0x8
   os_ACPITableAddress:    equ SystemVariables + 0x00
   screen_cursor_offset:   equ SystemVariables + 0x08
   os_LocalX2APICAddress:  equ SystemVariables + 0x10
   os_Counter_Timer:       equ SystemVariables + 0x18
   os_Counter_RTC:         equ SystemVariables + 0x20
   os_LocalAPICAddress:    equ SystemVariables + 0x28
   os_IOAPICAddress:       equ SystemVariables + 0x30
   os_HPETAddress:         equ SystemVariables + 0x38
   
   ; DD - Starting at offset 128, increments by 4
   os_BSP:                 equ SystemVariables + 128
   mem_amount:             equ SystemVariables + 132
   os_VideoBase:           equ SystemVariables + 136
   
   ; DW - Starting at offset 256, increments by 2
   cpu_speed:              equ SystemVariables + 256
   cpu_activated:          equ SystemVariables + 258
   cpu_detected:           equ SystemVariables + 260
   
   ; DB - Starting at offset 384, increments by 1
   screen_cursor_x:        equ SystemVariables + 386
   screen_cursor_y:        equ SystemVariables + 387
   memtempstring:          equ SystemVariables + 390
   speedtempstring:        equ SystemVariables + 400
   cpu_amount_string:      equ SystemVariables + 410
   os_key:                 equ SystemVariables + 421
   os_IOAPICCount:         equ SystemVariables + 424
   
   ;MISC
   screen_cols:            db 80
   screen_rows:            db 25
   hextable:               db '0123456789ABCDEF'
   
   ;STRINGS
   msg_initializing:       db 'initializing pure64 kernelloader', 13, 10, 0
   msg_done:               db ' Done', 0
   msg_CPU:                db '[CPU: ', 0
   msg_mhz:                db 'MHz x', 0
   msg_MEM:                db ']  [MEM: ', 0
   msg_mb:                 db ' MiB]', 0
   msg_startingkernel:     db 'kernel loaded, trying to run it ...', 13, 13, 0
   msg_no64:               db 'ERROR: This computer does not support 64-bit mode.', 0
   msg_novesa:             db 'VESA error VESA error VESA error VESA error VESA error VESA error !!!!!', 0
   
   ; VESA
   ; Mandatory information for all VBE revisions
   VBEModeInfoBlock.ModeAttributes         equ VBEModeInfoBlock + 0        ; DW - mode attributes
   VBEModeInfoBlock.WinAAttributes         equ VBEModeInfoBlock + 2        ; DB - window A attributes
   VBEModeInfoBlock.WinBAttributes         equ VBEModeInfoBlock + 3        ; DB - window B attributes
   VBEModeInfoBlock.WinGranularity         equ VBEModeInfoBlock + 4        ; DW - window granularity in KB
   VBEModeInfoBlock.WinSize                equ VBEModeInfoBlock + 6        ; DW - window size in KB
   VBEModeInfoBlock.WinASegment            equ VBEModeInfoBlock + 8        ; DW - window A start segment
   VBEModeInfoBlock.WinBSegment            equ VBEModeInfoBlock + 10       ; DW - window B start segment
   VBEModeInfoBlock.WinFuncPtr             equ VBEModeInfoBlock + 12       ; DD - real mode pointer to window function
   VBEModeInfoBlock.BytesPerScanLine       equ VBEModeInfoBlock + 16       ; DW - bytes per scan line
   ; Mandatory information for VBE 1.2 and above
   VBEModeInfoBlock.XResolution            equ VBEModeInfoBlock + 18       ; DW - horizontal resolution in pixels or characters
   VBEModeInfoBlock.YResolution            equ VBEModeInfoBlock + 20       ; DW - vertical resolution in pixels or characters
   VBEModeInfoBlock.XCharSize              equ VBEModeInfoBlock + 22       ; DB - character cell width in pixels
   VBEModeInfoBlock.YCharSize              equ VBEModeInfoBlock + 23       ; DB - character cell height in pixels
   VBEModeInfoBlock.NumberOfPlanes         equ VBEModeInfoBlock + 24       ; DB - number of memory planes
   VBEModeInfoBlock.BitsPerPixel           equ VBEModeInfoBlock + 25       ; DB - bits per pixel
   VBEModeInfoBlock.NumberOfBanks          equ VBEModeInfoBlock + 26       ; DB - number of banks
   VBEModeInfoBlock.MemoryModel            equ VBEModeInfoBlock + 27       ; DB - memory model type
   VBEModeInfoBlock.BankSize               equ VBEModeInfoBlock + 28       ; DB - bank size in KB
   VBEModeInfoBlock.NumberOfImagePages     equ VBEModeInfoBlock + 29       ; DB - number of image pages
   VBEModeInfoBlock.Reserved               equ VBEModeInfoBlock + 30       ; DB - reserved (0x00 for VBE 1.0-2.0, 0x01 for VBE 3.0)
   ; Direct Color fields (required for direct/6 and YUV/7 memory models)
   VBEModeInfoBlock.RedMaskSize            equ VBEModeInfoBlock + 31       ; DB - size of direct color red mask in bits
   VBEModeInfoBlock.RedFieldPosition       equ VBEModeInfoBlock + 32       ; DB - bit position of lsb of red mask
   VBEModeInfoBlock.GreenMaskSize          equ VBEModeInfoBlock + 33       ; DB - size of direct color green mask in bits
   VBEModeInfoBlock.GreenFieldPosition     equ VBEModeInfoBlock + 34       ; DB - bit position of lsb of green mask
   VBEModeInfoBlock.BlueMaskSize           equ VBEModeInfoBlock + 35       ; DB - size of direct color blue mask in bits
   VBEModeInfoBlock.BlueFieldPosition      equ VBEModeInfoBlock + 36       ; DB - bit position of lsb of blue mask
   VBEModeInfoBlock.RsvdMaskSize           equ VBEModeInfoBlock + 37       ; DB - size of direct color reserved mask in bits
   VBEModeInfoBlock.RsvdFieldPosition      equ VBEModeInfoBlock + 38       ; DB - bit position of lsb of reserved mask
   VBEModeInfoBlock.DirectColorModeInfo    equ VBEModeInfoBlock + 39       ; DB - direct color mode attributes
   ; Mandatory information for VBE 2.0 and above
   VBEModeInfoBlock.PhysBasePtr            equ VBEModeInfoBlock + 40       ; DD - physical address for flat memory frame buffer
   VBEModeInfoBlock.Reserved1              equ VBEModeInfoBlock + 44       ; DD - Reserved - always set to 0
   VBEModeInfoBlock.Reserved2              equ VBEModeInfoBlock + 48       ; DD - Reserved - always set to 0
   
   
   ; -----------------------------------------------------------------------------
   align 16
   GDTR64:                                 ; Global Descriptors Table Register
           dw gdt64_end - gdt64 - 1        ; limit of GDT (size minus one)
           dq 0x0000000000001000           ; linear address of GDT
   
   gdt64:                                  ; This structure is copied to 0x0000000000001000
   SYS64_NULL_SEL equ $-gdt64              ; Null Segment
           dq 0x0000000000000000
   SYS64_CODE_SEL equ $-gdt64              ; Code segment, read/execute, nonconforming
           dq 0x0020980000000000           ; 0x00209A0000000000
   SYS64_DATA_SEL equ $-gdt64              ; Data segment, read/write, expand down
           dq 0x0000900000000000           ; 0x0020920000000000
   gdt64_end:
   
   IDTR64:                                 ; Interrupt Descriptor Table Register
           dw 256*16-1                     ; limit of IDT (size minus one) (4096 bytes - 1)
           dq 0x0000000000000000           ; linear address of IDT
#+end_src
** set the size & the magic number
   #+begin_src nasm :tangle no
   times (SizeOfKernelloader * 1024) - ($-$$) - 4 db 0
   dd MagicNumberOfKernelloader   ;; 4 bytes 
   #+end_src
* --------------------------------------------------
* memory map
  This memory map shows how physical memory looks after Pure64 is finished.
  |    Start   Address | Size    |        End Address | Description                                                           |
  |--------------------+---------+--------------------+-----------------------------------------------------------------------|
  | 0x0000000000000000 | 4 KiB   | 0x0000000000000FFF | IDT - 256 descriptors (each descriptor is 16 bytes)                   |
  | 0x0000000000001000 | 4 KiB   | 0x0000000000001FFF | GDT - 256 descriptors (each descriptor is 16 bytes)                   |
  |--------------------+---------+--------------------+-----------------------------------------------------------------------|
  | 0x0000000000002000 | 4 KiB   | 0x0000000000002FFF | PML4 - 512 entries, first entry points to PDP at 0x3000               |
  | 0x0000000000003000 | 4 KiB   | 0x0000000000003FFF | PDP - 512 enties                                                      |
  | 0x0000000000004000 | 16 KiB  | 0x0000000000007FFF | Pure64 Data                                                           |
  | 0x0000000000008000 | 32 KiB  | 0x000000000000FFFF | Pure64 - After the OS is loaded and running this memory is free again |
  | 0x0000000000010000 | 256 KiB | 0x000000000004FFFF | PD - Room to map 64 GiB                                               |
  | 0x0000000000050000 | 320 KiB | 0x000000000009FFFF | Free                                                                  |
  | 0x00000000000A0000 | 384 KiB | 0x00000000000FFFFF | ROM Area                                                              |
  |                    |         |                    | VGA mem at 0xA0000 (128 KiB) Color text starts at 0xB8000             |
  |                    |         |                    | Video BIOS at 0xC0000 (64 KiB)                                        |
  |                    |         |                    | Motherboard BIOS at F0000 (64 KiB)                                    |
  |--------------------+---------+--------------------+-----------------------------------------------------------------------|
  | 0x0000000000100000 |         | 0xFFFFFFFFFFFFFFFF | Your software is loaded here                                          |
  When creating your Operating System or Demo you can use the sections marked free
  however it is the safest to use memory above 1 MiB
* information table
  Pure64 stores an information table in memory
  that contains various pieces of data about the computer
  before it passes control over to the software you want it to load.
  The Pure64 information table is located at 0x0000000000005000 and ends at 0x00000000000057FF (2048 bytes).
  |  Memory Address | Variable Size | Name         | Description                                               |
  |-----------------+---------------+--------------+-----------------------------------------------------------|
  |          0x5000 | 64-bit        | ACPI         | Address of the ACPI tables                                |
  |          0x5008 | 32-bit        | BSP_ID       | APIC ID of the BSP                                        |
  |          0x5010 | 16-bit        | CPUSPEED     | Speed of the CPUs in MegaHertz (MHz)                      |
  |          0x5012 | 16-bit        | CORES_ACTIVE | The number of CPU cores that were activated in the system |
  |          0x5014 | 16-bit        | CORES_DETECT | The number of CPU cores that were detected in the system  |
  | 0x5016 - 0x501F |               |              | For future use                                            |
  |          0x5020 | 32-bit        | RAMAMOUNT    | Amount of system RAM in Mebibytes (MiB)                   |
  | 0x5022 - 0x502F |               |              | For future use                                            |
  |          0x5030 | 8-bit         | IOAPIC_COUNT | Number of IO-APICs in the system                          |
  | 0x5031 - 0x503F |               |              | For future use                                            |
  |          0x5040 | 64-bit        | HPET         | Base memory address for the High Precision Event Timer    |
  | 0x5048 - 0x505F |               |              | For future use                                            |
  |          0x5060 | 64-bit        | LAPIC        | Local APIC address                                        |
  | 0x5068 - 0x507F | 64-bit        | IOAPIC       | IO-APIC addresses (based on IOAPIC_COUNT)                 |
  |          0x5080 | 32-bit        | VIDEO_BASE   | Base memory for video (if graphics mode set)              |
  |          0x5084 | 16-bit        | VIDEO_X      | X resolution                                              |
  |          0x5086 | 16-bit        | VIDEO_Y      | Y resolution                                              |
  |          0x5088 | 8-bit         | VIDEO_DEPTH  | Color depth                                               |
  |       0x5100... | 8-bit         | APIC_ID      | APIC ID's for valid CPU cores (based on CORES_ACTIVE)     |
  A copy of the E820 System Memory Map is stored at memory address 0x0000000000004000. Each E820 record is 24 bytes in length and the memory map is terminated by a blank record.
  | Variable         | Variable Size | Description                                   |
  |------------------+---------------+-----------------------------------------------|
  | Starting Address | 64-bit        | The starting address for this record          |
  | Length           | 64-bit        | The length of memory for this record          |
  | Memory Type      | 32-bit        | Type 1 is usable memory, Type 2 is not usable |
  For more information on the E820 Memory Map: OSDev wiki on E820
* ==================================================
