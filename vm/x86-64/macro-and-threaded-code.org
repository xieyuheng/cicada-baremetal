#+TITLE: macro and threaded code of cicada extensible virtual machine
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* macro
** note about stacks
   1. when "push", a stack-pointer moves to lower address
   2. under the a stack-pointer,
      there always stores the value of the-top-of-the-stack
** registers & pop & push
   #+begin_src fasm :tangle macro.inc
   ;; if you want to extend cicada in assembly,
   ;; the following four registers must not be used
   ;; =================================
   define Return_stack_pointer    r15
   define Argument_stack_pointer  r14
   define Grey_pair_stack_pointer r13
   ;; =================================

   define Explainer_pointer     rax
   define Temporary_register    r11
   define Temporary_register2   r10


   macro push_return_stack Register {
          sub Return_stack_pointer, Cell_width
          mov [Return_stack_pointer], Register
          }
   macro pop_return_stack Register {
          mov Register, [Return_stack_pointer]
          add Return_stack_pointer, Cell_width
          }

   macro push_argument_stack Register {
          sub Argument_stack_pointer, Cell_width
          mov [Argument_stack_pointer], Register
          }
   macro pop_argument_stack Register {
          mov Register, [Argument_stack_pointer]
          add Argument_stack_pointer, Cell_width
          }
   #+end_src
** word-types & next
*** note
    1. notations :
       1) "the dictionary" as a datastructure is a single-linked-list
       2) an entry in "the dictionary" is "a word"
       3) "a word" as a datastructure looks like the following :
          (unit : Cell_width)
          | 1 | name-string-header            |
          | m | name-string                   |
          | 1 | SizeOfFunctionBody            |
          | 1 | identification                |
          | 1 | link                          |
          | 1 | type                          |
          | 1 | address-of-name-string-header |
          | 1 | address-of-explainer          |
          | n | body                          |
       4) so, I adopt two notations to represent "a word" :
          word[link]      == address in a word where the link is stored
          word[explainer] == address in a word where the address-of-explainer is stored
          word[explainer] == address in a word before the function-body
          word[explainer] == address in a word as the head of a function-body
    2. this "next" do tail-call-optimization
    3. every word-type needs a explainer (or elucidator)
    4. a explainer may explain more then one word-types
    5. note that, for now there are only two ways to jump to a explainer
       1) next
       2) execute
    6. not matter what way you use to set :
       [Explainer_pointer] == address-of-explainer (of a word you want to jump to)
       then :
       jmp qword[Explainer_pointer]
       it will works just well
    7. "next" will "pop_return_stack"
       1) on the other hand,
          explain_function_body is the only explainer
          who "push_return_stack"
       2) so, it is these two functions, "next" and "explain_function_body"
          which handle the nested function calls
*** implementation
    #+begin_src fasm :tangle macro.inc
    macro next {
       ;; 1. if NOT at the end of the function body
       ;;    (* Return-stack::
       ;;         [address of explainer] -- [address of explainer] + Cell_width *)
       ;; 2. if at the end of the function body
       ;;    (* Return-stack::
       ;;         [address of explainer] -- *)
       ;; and jump to the explainer of the [address of explainer]
    local at_the_end_of_function_body
       pop_return_stack rbx
       mov Explainer_pointer, qword[rbx]
       add rbx, Cell_width
       cmp dword[rbx], Exit
       je at_the_end_of_function_body
       cmp dword[rbx], 已矣
       je at_the_end_of_function_body
       push_return_stack rbx
    at_the_end_of_function_body:
       jmp qword[Explainer_pointer]
       }

    ;; initial Link to point to NULL
    Link = 0

    macro defWord WordString, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    SizeOfFunctionBodyOf#Word:
            xx (EndOfFunctionBodyOf#Word - Word)/Cell_width - 1
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx explain_function_body
    ;;--------------------------------------
            ;; here follows a list of word[explainer]
            }
    macro defWordEnd Word {
    EndOfFunctionBodyOf#Word:
    }

    macro defKeyWord KeyWordString, KeyWord {
    hereInitializedData
    ;;--------------------------------------
    KeyWordStringHeaderOf#KeyWord:
            xx (EndOfKeyWordStringOf#KeyWord - KeyWordStringOf#KeyWord)
    ;;--------------------------------------
    KeyWordStringOf#KeyWord:
            db KeyWordString
    EndOfKeyWordStringOf#KeyWord:
    ;;--------------------------------------
    SizeOfFunctionBodyOf#KeyWord:
            xx (EndOfFunctionBodyOf#KeyWord - KeyWord)/Cell_width - 1
    ;;--------------------------------------
    IdentificationOf#KeyWord:
            xx IdentificationOf#KeyWord
    ;;--------------------------------------
    LinkOf#KeyWord:
            xx Link
            Link = LinkOf#KeyWord
    ;;--------------------------------------
    TypeOf#KeyWord:
            xx 1
    ;;--------------------------------------
    AddressOfKeyWordStringHeaderOf#KeyWord:
            xx KeyWordStringHeaderOf#KeyWord
    ;;======================================
    KeyWord:   xx explain_function_body
    ;;--------------------------------------
            ;; here follows a list of word[explainer]
            }
    macro defKeyWordEnd KeyWord {
    EndOfFunctionBodyOf#KeyWord:
    }

    ;; assembly code have no explainer
    macro defCode WordString, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx AssemblerCodeOf#Word
    ;;--------------------------------------
    AssemblerCodeOf#Word:
            ;; here follows the assembly code
            }

    macro defVar WordString, InitialValue, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx explain_variable
    ;;--------------------------------------
            xx InitialValue
    ;;--------------------------------------
            }

    macro defConst WordString, InitialValue, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx explain_constant
    ;;--------------------------------------
            xx InitialValue
    ;;--------------------------------------
            }

    ;; in stack:
    ;;   string[address, length]
    ;; in memory:
    ;;   ||  1 : length  ||
    ;;   ||  n : string  ||
    macro defConstString WordString, ConstStringValue, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx explain_constant_string
    ;;--------------------------------------
            xx (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
    ;;--------------------------------------
    ConstStringValueOf#Word:
            db ConstStringValue
    EndOfConstStringValueOf#Word:
    ;;--------------------------------------
            }
    #+end_src
* ==================================================
* basic-REPL
  #+begin_src fasm :tangle threaded-code.inc
  defWord "basic-REPL", basic_REPL
     ;; (* unknown -- unknown *)
     ;; ><><>< init srack ???
     .read_phrase:
     xx read_phrase
     xx compile_phrase, call_phrase
     xx _branch, (.read_phrase-$)/Cell_width
  defWordEnd basic_REPL

  defWord "execute-word", execute_word
     ;; (* string[address, length] -- unknown *)
     xx dup2, string_denote_integer?, _false?branch, 4
     xx   string_to_integer__with_error, drop
     xx   Exit
     xx dup2, find, dup, _false?branch, 6
     xx   xxswapx, drop2
     xx   word_link_to_word_explainer, execute
     xx   Exit
     xx drop ;; drop zero
     xx Message_undefined_word, print_string
     xx print_string
     xx _literal, ASCII_linefeed, write_char
     xx Exit
  defWordEnd execute_word

  defConstString "Message:undefined-word", "   UNDEFINED WORD: ", Message_undefined_word
  #+end_src
* phrase
** note
   1. again not fancy stuff
      functions about phrase are just for runtime
      with a buffer been overwrited each time the functions run
** read-phrase
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData
   ;; ------------------------
   Size_of_buffer_for_read_phrase = 1024*1024

   Buffer_for_read_phrase labeling
           preserve Size_of_buffer_for_read_phrase


   ;; 1. use "read_word__while_saving_to_string"
   ;; 2. 每次 读一个 词 然后看 词界 是否是 回车
   ;;    如果是 就做一个 phrase 然后返回
   ;;    如果不是 就继续读
   ;; 3. only ":" ";", as a pair of bra-ket, are been handled by a counter here
   ;;    >< this is not the right thing
   ;;    因为 比如说 当出现 "(" 的时候
   ;;    后面所跟的字符串 一定要保证 能够被 正确地 "(" 处理
   ;;    也就是 read-phrase 说这个函数
   ;;    只应该接受 那些 bra-ket 正确匹配了的 以回车结尾的 字符串
   ;; 4. 这个 错误以后再弥补
   ;;    因为我需要快把基本的东西实现出来
   ;;    让解释器 重新跑起来 以方便做测试
   ;; 5. add "Exit" to the end of the string

   defWord "read-phrase", read_phrase
      ;; (*  -- string[address, length] *)
      xx _literal, Buffer_for_read_phrase
      xx _literal, 0

      xx _literal, 0, push_lambda_stack ;; leave a counter of ":"

      .read_word__while_saving_to_string:
      xx read_word__while_saving_to_string
      ;; (* string[address, length], word[address, length] *)

      xx dup2, Bra__cosemi, equal_string?, _false?branch, (.dup2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack, add1, push_lambda_stack
      xx   _branch, (.read_word__while_saving_to_string-$)/Cell_width

      .dup2:
      xx dup2, Ket__cosemi, equal_string?, _false?branch, (.xxoverxx-$)/Cell_width
      xx   pop_lambda_stack, sub1, push_lambda_stack

      .xxoverxx:
      ;; to see the what char the "word-boundary,end" is
      xx xxoverxx, addition, sub1, fetch_byte
      xx _literal, ASCII_linefeed, equal?, false?, _false?branch, (.drop2-$)/Cell_width
      xx   drop2
      xx   _branch, (.read_word__while_saving_to_string-$)/Cell_width

      .drop2:
      xx drop2

      xx pop_lambda_stack
      xx dup, zero?, _false?branch, (.push_lambda_stack-$)/Cell_width
      xx   drop
      ;;   (* add "Exit" to the end of the string *)
      xx   _literal, " ", string_append_char
      xx   _literal, "E", string_append_char
      xx   _literal, "x", string_append_char
      xx   _literal, "i", string_append_char
      xx   _literal, "t", string_append_char
      xx   _literal, " ", string_append_char
      xx   Exit

      .push_lambda_stack:
      xx push_lambda_stack
      xx _branch, (.read_word__while_saving_to_string-$)/Cell_width
   defWordEnd read_phrase
   #+end_src
** compile-phrase
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData
   ;; ------------------------
   Size_of_buffer_of_function_body__for_compile_phrase = 1024*1024
   Size_of_buffer_of_data_section__for_compile_phrase = 1024*1024

   Buffer_of_function_body__for_compile_phrase labeling
           preserve Size_of_buffer_of_function_body__for_compile_phrase
   Buffer_of_data_section__for_compile_phrase labeling
           preserve Size_of_buffer_of_data_section__for_compile_phrase


   defWord "compile-phrase", compile_phrase
      ;; (* word-string[address, length] --  *)
      xx Here, fetch, push_lambda_stack
      xx Current_data_section, fetch, push_lambda_stack
      xx   _literal, Buffer_of_function_body__for_compile_phrase, Here, save
      xx   _literal, Buffer_of_data_section__for_compile_phrase, Current_data_section, save
      xx   _Function_body_explainer, append_number_to_here
      xx   append_word_description_to_here
      xx pop_lambda_stack, Current_data_section, save
      xx pop_lambda_stack, Here, save
      xx Exit
   defWordEnd compile_phrase
   #+end_src
** call-phrase
   #+begin_src fasm :tangle threaded-code.inc
   defWord "call-phrase", call_phrase
      ;; (* -- unknown *)
      xx _literal, Buffer_of_function_body__for_compile_phrase
      xx execute
      xx Exit
   defWordEnd call_phrase
   #+end_src
* primitive functions
** Var & Const
   #+begin_src fasm :tangle threaded-code.inc
   defVar "Here",  0, Here

   defVar "first-word-in-dictionary", LinkOfTheLatestWordInAssembly , FirstWordInDictionary
   ;; note that:
   ;;   the above is LinkOfTheLatestWordInThisFile
   ;;   NOT TheLatestWordInThisFile

   ;; ------------------------------------------
   defConst "Cell-width", Cell_width, _Cell_width

   defConst "False", 0, False
   defConst "True",  1, True
   #+end_src
** special key words (with chinese support)
   #+begin_src fasm :tangle threaded-code.inc
   ;; this word should not be found
   ;; the interface of this word is the next word "literal"
   defCode "", _literal
      ;; (* -- number *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      pop_return_stack rbx
      mov  rax, [rbx]
      push_argument_stack rax
      add  rbx, Cell_width
      cmp dword[rbx], Exit
      je _literal__meet_end
      cmp dword[rbx], 已矣
      je _literal__meet_end
      push_return_stack rbx
   _literal__meet_end:
      next

   ;; no error handling for string_full_of_blank
   defKeyWord "literal", literal
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _literal, append_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _false?branch, 5
      xx   string_to_integer__with_error, drop, append_number_to_here
      xx   Exit
      xx find, word_link_to_word_explainer, execute, append_number_to_here
      xx Exit
   defKeyWordEnd literal


   ;; the following handles _branch to "Exit"
   ;; >< alth branch to "Exit" should never be used
   defCode "", _branch
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + offset * Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      ;; and "next"
      ;; (could be optimize by not using "next")
      pop_return_stack rbx
      mov  rax, [rbx]
      imul rax, Cell_width
      add  rbx, rax
      cmp dword[rbx], Exit
      je _branch__meet_end
      cmp dword[rbx], 已矣
      je _branch__meet_end
      push_return_stack rbx
   _branch__meet_end:
      next

   ;; no error handling for string_full_of_blank
   defKeyWord "branch", branch
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _branch, append_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _false?branch, 5
      xx   string_to_integer__with_error, drop, append_number_to_here
      xx   Exit
      xx find, word_link_to_word_explainer, execute, append_number_to_here
      xx Exit
   defKeyWordEnd branch


   ;; the following handles _false?branch to "Exit"
   defCode "", _false?branch
      ;; (* True of False -- *)
      ;; 0. if NOT _branch
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + offset * Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      ;; and "next"
      ;; (could be optimize by not using "next")
      pop_argument_stack rax
      test rax, rax
      jnz _false?branch__not_to_branch

      pop_return_stack rbx
      mov  rax, [rbx]
      imul rax, Cell_width
      add  rbx, rax
      cmp dword[rbx], Exit
      je _false?branch__meet_end
      cmp dword[rbx], 已矣
      je _false?branch__meet_end
      push_return_stack rbx
   _false?branch__meet_end:
      next

   _false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, Cell_width
      cmp dword[rbx], Exit
      je _false?branch__not_to_branch__meet_end
      cmp dword[rbx], 已矣
      je _false?branch__not_to_branch__meet_end
      push_return_stack rbx
   _false?branch__not_to_branch__meet_end:
      next

   ;; no error handling for string_full_of_blank
   defKeyWord "false?branch", false?branch
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _false?branch, append_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _false?branch, 5
      xx   string_to_integer__with_error, drop, append_number_to_here
      xx   Exit
      xx find, word_link_to_word_explainer, execute, append_number_to_here
      xx Exit
   defKeyWordEnd false?branch

   ;; ><><><
   ;; Chinese version
   ;; 即 转 假则转
   #+end_src
** stack processing
*** drop & dup
    #+begin_src fasm :tangle threaded-code.inc
    defCode "drop", drop
       ;; (* a -- *)
       pop_argument_stack rax
       next

    defCode "drop2", drop2
       ;; (* a b -- *)
       pop_argument_stack rax
       pop_argument_stack rax
       next

    defCode "dup", dup
       ;; (* a -- a a *)
       mov  rax, [Argument_stack_pointer]
       push_argument_stack rax
       next

    defCode "dup2", dup2
       ;; (* a b -- a b a b *)
       mov  rbx, [Argument_stack_pointer]
       mov  rax, [Argument_stack_pointer + Cell_width]
       push_argument_stack rax
       push_argument_stack rbx
       next
    #+end_src
*** over
    #+begin_src fasm :tangle threaded-code.inc
    defCode "over", over
       ;; (* a b -- a b | a *)
       mov  rax, [Argument_stack_pointer + Cell_width]
       push_argument_stack rax
       next

    defCode "x|over|xx", xoverxx
       ;; (* a | b c -- a | b c | a *)
       mov  rax, [Argument_stack_pointer + (2 * Cell_width)]
       push_argument_stack rax
       next

    defCode "xx|over|x", xxoverx
       ;; (* a b | c -- a b | c | a b *)
       mov  rax, [Argument_stack_pointer + (2 * Cell_width)]
       push_argument_stack rax
       mov  rax, [Argument_stack_pointer + (2 * Cell_width)] ;; not (1 * Cell_width)
       push_argument_stack rax
       next

    defCode "xx|over|xx", xxoverxx
       ;; (* a b | c d -- a b | c d | a b *)
       mov  rax, [Argument_stack_pointer + (3 * Cell_width)]
       push_argument_stack rax
       mov  rax, [Argument_stack_pointer + (3 * Cell_width)] ;; not (2 * Cell_width)
       push_argument_stack rax
       next

    defCode "x|over|xxx", xoverxxx
       ;; (* a | b c d -- a | b c d | a *)
       mov  rax, [Argument_stack_pointer + (3 * Cell_width)]
       push_argument_stack rax
       next

    defCode "xx|over|xxxx", xxoverxxxx
       ;; (* a b | c d e f -- a b | c d e f | a b *)
       mov  rax, [Argument_stack_pointer + (5 * Cell_width)]
       push_argument_stack rax
       mov  rax, [Argument_stack_pointer + (5 * Cell_width)] ;; not (4 * Cell_width)
       push_argument_stack rax
       next
    #+end_src
*** tuck
    #+begin_src fasm :tangle threaded-code.inc
    defCode "tuck", tuck
       ;; (* a b -- b | a b *)
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rax
       push_argument_stack rbx
       next

    defCode "x|tuck|xx", xtuckxx
       ;; (* a | b c -- b c | a | b c *)
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next

    defCode "xx|tuck|x", xxtuckx
       ;; (* a b | c -- c | a b | c *)
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next

    defCode "xx|tuck|xx", xxtuckxx
       ;; (* a b | c d -- c d | a b | c d *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rdx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       next

    defCode "xxx|tuck|x", xxxtuckx
       ;; (* a b c | d -- d | a b c | d *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rdx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       next
    #+end_src
*** swap
    #+begin_src fasm :tangle threaded-code.inc
    defCode "swap", swap
       ;; (* a b -- b a *)
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rax
       next

    defCode "x|swap|xx", xswapxx
       ;; (* a | b c -- b c | a *)
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rax
       next

    defCode "xx|swap|x", xxswapx
       ;; (* a b | c -- c | a b *)
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       next

    defCode "x|swap|xxx", xswapxxx
       ;; (* a | b c d -- b c d | a *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       push_argument_stack rax
       next

    defCode "xxx|swap|x", xxxswapx
       ;; (* a b c | d -- d | a b c *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rdx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next

    defCode "xx|swap|xx", xxswapxx
       ;; (* a b | c d -- c d | a b *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rdx
       push_argument_stack rax
       push_argument_stack rbx
       next


    defCode "x|swap|xxxx", xswapxxxx
       ;; (* a | b c d e -- b c d e | a *)
       pop_argument_stack r8 ;; e
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       push_argument_stack r8 ;; e
       push_argument_stack rax
       next

    defCode "xxxx|swap|x", xxxxswapx
       ;; (* a b c d | e --  e | a b c d *)
       pop_argument_stack r8 ;; e
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack r8 ;; e
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       next


    defCode "xx|swap|xxxx", xxswapxxxx
       ;; (* a b | c d e f -- c d e f | a b *)
       pop_argument_stack r9 ;; f
       pop_argument_stack r8 ;; e
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rdx
       push_argument_stack r8 ;; e
       push_argument_stack r9 ;; f
       push_argument_stack rax
       push_argument_stack rbx
       next

    defCode "xxxx|swap|xx", xxxxswapxx
       ;; (* a b c d | e f --  e f | a b c d *)
       pop_argument_stack r9 ;; f
       pop_argument_stack r8 ;; e
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack r8 ;; e
       push_argument_stack r9 ;; f
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       next
    #+end_src
*** ohters
    #+begin_src fasm :tangle threaded-code.inc
    defCode "|123->321|", abc_to_cba
       pop_argument_stack rax
       pop_argument_stack rbx
       pop_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next
    #+end_src
** fixnum
   #+begin_src fasm :tangle threaded-code.inc
   defCode "add1", add1
      ;; (* n -- n+1 *)
      inc qword[Argument_stack_pointer]
      next

   defCode "add2", add2
      ;; (* n -- n+1 *)
      add qword[Argument_stack_pointer], 2
      next

   defCode "add3", add3
      ;; (* n -- n+1 *)
      add qword[Argument_stack_pointer], 3
      next

   defCode "add4", add4
      ;; (* n -- n+4 *)
      add qword[Argument_stack_pointer], 4
      next

   defCode "add8", add8
      ;; (* n -- n+8 *)
      add qword[Argument_stack_pointer], 8
      next


   defCode "sub1", sub1
      ;; (* n -- n-1 *)
      dec qword[Argument_stack_pointer]
      next

   defCode "sub2", sub2
      ;; (* n -- n-1 *)
      sub qword[Argument_stack_pointer], 2
      next

   defCode "sub3", sub3
      ;; (* n -- n-1 *)
      sub qword[Argument_stack_pointer], 3
      next

   defCode "sub4", sub4
      ;; (* n -- n-4 *)
      sub qword[Argument_stack_pointer], 4
      next

   defCode "sub8", sub8
      ;; (* n -- n-8 *)
      sub qword[Argument_stack_pointer], 8
      next


   defCode "+", addition
      ;; (* a b -- a+b *)
      pop_argument_stack rax
      add qword[Argument_stack_pointer], rax
      next

   defCode "-", subtraction
      ;; (* a b -- a-b *)
      pop_argument_stack rax
      sub qword[Argument_stack_pointer], rax
      next

   defCode "*", multiple
      ;; (* a b -- a*b *)
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next

   defCode "mod/", moddiv
      ;; (* a, b -- a mod b, quotient *)
      ;; (* dividend, divisor -- remainder, quotient *)
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next
   #+end_src
** math
   #+begin_src fasm :tangle threaded-code.inc
   defWord "negate", negate
      ;; (* n --  -n *)
      xx _literal, 0
      xx swap, subtraction
      xx Exit
   defWordEnd negate

   defWord "help:power", help_power
      ;; (* a, m, n -- a^n *)
      xx dup, zero?, _false?branch, 5
      xx   drop, swap, drop
      xx   Exit
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx help_power
      xx Exit
   defWordEnd help_power

   defWord "power", power
      ;; n must be naturl number for now
      ;; (* a, n -- a^n *)
      xx _literal, 1
      xx swap
      xx help_power
      xx Exit
   defWordEnd power
   #+end_src
** memory
   #+begin_src fasm :tangle threaded-code.inc
   ;; ``save'' and ``fetch'' default to a Cell_width (== 8 bytes)
   ;; the rule of ``fetch2'' and so on are:
   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ||  1 : value-2  ||
   ;;     ||  1 : value-3  ||
   ;;     ...
   ;;   on stack:
   ;;     [ ... , value-3, value-2, value-1]
   ;; of course we have:
   ;;   fetch2 : memory=copy=>stack
   ;;   save2  : stack->memory

   defCode "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov qword[rbx], rax
      next

   defCode "save2", save2
      ;; ( value-2, value-1, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov qword[rbx], rax
      pop_argument_stack rax
      mov qword[rbx + Cell_width], rax
      next



   defCode "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, qword[rbx]
      push_argument_stack rax
      next

   defCode "fetch2", fetch2
      ;; ( address -- value-1, value-2 )
      pop_argument_stack  rbx
      mov rax, qword[rbx + Cell_width]
      push_argument_stack rax
      mov rax, qword[rbx]
      push_argument_stack rax
      next



   defCode "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add qword[rbx], rax
      next

   defCode "sub-save", sub_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub qword[rbx], rax
      next


   defCode "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   defCode "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   defCode "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next


   defCode "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   defCode "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word[rbx]
      push_argument_stack rax
      next

   defCode "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword[rbx]
      push_argument_stack rax
      next




   defCode "copy-byte", copy_byte
      ;; ( source address, destination address --
      ;;   source address + 1, destination address + 1 )
      mov rbx, [Argument_stack_pointer + Cell_width] ;; source address
      mov al,  byte[rbx]                        ;; get a char from source address
      pop_argument_stack rdi                        ;; destination address
      stosb                                     ;; copy to destination
      push_argument_stack rdi                       ;; destination address is incremented by stosb
      inc qword[Argument_stack_pointer + Cell_width] ;; increment source address
      next

   defCode "copy-byte-string", copy_byte_string
      ;; ( source address, destination address, length -- )
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      rep movsb
      next
   #+end_src
** string
   #+begin_src fasm :tangle threaded-code.inc
   ;; return false when length == 0
   defCode "compare-string?", compare_string?
      ;; (* address of string-1, address of string-2, length -- True or False *)
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next

   defWord "equal-string?", equal_string?
      ;; (* string-1[address-1, length-1], string-2[address-2, length-2] -- True or False *)
      xx xoverxx, equal?, _false?branch, 4
      xx swap, compare_string?, Exit
      xx drop, drop, drop, False
      xx Exit
   defWordEnd equal_string?


   ;; ><><>< there are no proper error handling for the following two functions

   defCode "head-of-string", head_of_string
      ;; (* string[address, length] -- first char *)
      pop_argument_stack rcx
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte [rbx]
      push_argument_stack rax
      next

   defCode "tail-of-string", tail_of_string
      ;; (* string[address, length] -- string[address + 1, length - 1] *)
      pop_argument_stack rcx
      pop_argument_stack rbx
      dec rcx
      inc rbx
      push_argument_stack rbx
      push_argument_stack rcx
      next

   defWord "tail-and-head-of-string", tail_and_head_of_string
      ;; (* string[address, length] -- string[address + 1, length - 1], first char *)
      xx dup2, tail_of_string
      xx xxswapxx
      xx head_of_string
      xx Exit
   defWordEnd tail_and_head_of_string
   #+end_src
** predicates
   1. 0 as False
      1 as True
   2. there can not be bool-type in low-level forth-like-language
   3. ``notFalse?'' is NOT ``true?''
   4. ``false?'' is ``zero?''
      ``true?'' is ``one?''
   #+begin_src fasm :tangle threaded-code.inc
   defCode "==", equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      sete  al
      movzx rax, al
      push_argument_stack rax
      next

   defCode "=/=", not_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rbx, rax
      setne al
      movzx rax, al
      push_argument_stack rax
      next

   defCode "<", less_than?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setl  al
      movzx rax, al
      push_argument_stack rax
      next

   defCode ">", greater_than?
      pop_argument_stack   rbx
      pop_argument_stack   rax
      cmp   rax, rbx
      setg  al
      movzx rax, al
      push_argument_stack  rax
      next

   defCode "<=", less_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setle al
      movzx rax, al
      push_argument_stack rax
      next

   defCode ">=", greater_or_equal?
      pop_argument_stack rbx
      pop_argument_stack rax
      cmp   rax, rbx
      setge al
      movzx rax, al
      push_argument_stack rax
      next

   defCode "zero?", zero?
      pop_argument_stack rax
      test  rax,rax
      setz  al
      movzx rax, al
      push_argument_stack rax
      next

   defCode "not-zero?", not_zero?
      pop_argument_stack rax
      test  rax,rax
      setnz al
      movzx rax, al
      push_argument_stack rax
      next


   defWord "one?", one?
      xx _literal, 1, equal?
      xx Exit
   defWordEnd one?

   defWord "true?", true?
      xx one?
      xx Exit
   defWordEnd true?

   defWord "false?", false?
      xx zero?
      xx Exit
   defWordEnd false?
   #+end_src
** predicates about char
   #+begin_src fasm :tangle threaded-code.inc
   defWord "char-denote-number?", char_denote_number?
      ;; (* char -- True or False *)
      xx dup
      xx _literal, '0', less_than?, _false?branch, 4
      xx   drop, False
      xx   Exit
      xx _literal, '9', greater_than?, _false?branch, 3
      xx   False
      xx   Exit
      xx True
      xx Exit
   defWordEnd char_denote_number?
   #+end_src
** bitwise operations
   1. ``bitwise_and'' and ``bitwise_or'' handle 64 bits value
   2. x y bitwise_and
      ==
      x bitwise_invert y bitwise_invert bitwise_or bitwise_invert
   #+begin_src fasm :tangle threaded-code.inc
   defCode "bitwise-and", bitwise_and
      ;; ( a, b -- a and b )
      pop_argument_stack rbx
      and [Argument_stack_pointer], rbx
      next

   defCode "bitwise-or", bitwise_or
      ;; ( a, b -- a or b )
      pop_argument_stack rbx
      or  [Argument_stack_pointer], rbx
      next

   defCode "bitwise-xor", bitwise_xor
      ;; ( a, b -- a xor b )
      pop_argument_stack rbx
      xor [Argument_stack_pointer], rbx
      next

   defCode "bitwise-invert", bitwise_invert
      ;; ( a -- invert a )
      not qword[Argument_stack_pointer]
      next
   #+end_src
** single bit operations
   1. offset is of LSB
   2. offset in [0, ..., 63]
   3. step   in [1, ..., 64]
   #+begin_src fasm :tangle threaded-code.inc
   ;; BT copies a bit from a given register to the carry flag
   defCode "fetch-bit", fetch_bit
      ;; ( fixnum, offset -- bit )
      pop_argument_stack rbx
      pop_argument_stack rax
      bt rax, rbx
      setc al
      movzx rax, al
      push_argument_stack rax
      next

   defCode "set-bit", setBit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      bts rax, rbx
      push_argument_stack rax
      next

   defCode "clear-bit", clearBit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      btr rax, rbx
      push_argument_stack rax
      next

   defCode "invert-bit", invertBit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      btc rax, rbx
      push_argument_stack rax
      next



   ;; "bsf" "bsr"
   ;; instructions scan a word or double word for first set bit
   ;; and store the index of this bit into destination operand
   ;; which must be general register
   ;; The bit string being scanned is specified by source operand
   ;; it may be either general register or memory
   ;; The ZF flag is set if the entire string is zero (no set bits are found)
   ;; otherwise it is cleared

   ;; If no set bit is found
   ;; the value of the destination register is undefined
   ;; "bsf" scans from low order to high order (starting from bit index zero)
   ;; "bsr" scans from high order to low order


   ;; note that:
   ;; if can not find ``SetBit''
   ;; the following functions will return -1

   defCode "find-lowest-set-bit", find_lowest_set_bit
      ;; ( fixnum -- offset )
      pop_argument_stack rax
      bsf rax, rax
      jz @f
      push_argument_stack rax
      next
   @@:
      mov rax, -1
      push_argument_stack rax
      next

   defCode "find-highest-set-bit", find_highest_set_bit
      ;; ( fixnum -- offset )
      pop_argument_stack rax
      bsr rax, rax
      jz @f
      push_argument_stack rax
      next
   @@:
      mov rax, -1
      push_argument_stack rax
      next
   #+end_src
** bits shift & rotate
   #+begin_src fasm :tangle threaded-code.inc
   ;; "shl"
   ;; shifts the destination operand left
   ;; by the number of bits specified in the second operand
   ;; The destination operand can be general register or memory
   ;; The second operand can be an immediate value or the CL register
   ;; as bits exit from the left, zeros in from the right
   ;; The last bit that exited is stored in CF
   ;; "sal" is a synonym for "shl"
   defCode "shift-left", shift_left
      ;; ( fixnum, step -- fixnum * 2^step )
      pop_argument_stack rcx
      shl qword[Argument_stack_pointer], cl
      next

   defCode "shift-right", shift_right
      ;; ( fixnum, step -- fixnum / 2^step )
      pop_argument_stack rcx
      shr qword[Argument_stack_pointer], cl
      next

   defCode "shift-right-preserve-sign", shift_right_preserve_sign
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      sar qword[Argument_stack_pointer], cl
      next
   #+end_src
** [NOT USING] bits shift & rotate
   #+begin_src fasm
   ;; note that:
   ;; ``double'' is 128 bit value here

   ;; "shld"
   ;; shifts bits of the destination operand to the left
   ;; by the number of bits specified in third operand,
   ;; while shifting
   ;; move high order bits from the source operand
   ;; into the destination operand on the right.
   ;; The source operand remains unmodified.
   ;; The destination operand can be a word or double word general register or memory,
   ;; the source operand must be a general register,
   ;; third operand can be an immediate value or the CL register.
   defCode "double-shift-left", double_shift_left
      ;; ( fixnum-1, fixnum-2, step --
      ;;   new fixnum-1, new fixnum-2 )
      pop_argument_stack rcx
      pop_argument_stack rax
      shld qword[Argument_stack_pointer], rax, cl
      shl rax, cl
      push_argument_stack rax
      next


   ;; "shrd"
   ;; shifts bits of the destination operand to the right,
   ;; while shifting
   ;; move low order bits from the source operand
   ;; into the destination operand on the left.
   ;; The source operand remains unmodified.
   ;; Rules for operands are the same as for the "shld" instruction.
   defCode "double-shift-right", double_shift_right
      ;; ( fixnum-1, fixnum-2, step --
      ;;   new fixnum-1, new fixnum-2 )
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      shrd rbx, rax, cl
      shr rax, cl
      push_argument_stack rax
      push_argument_stack rbx
      next

   defCode "double-shift-right-preserve-sign", double_shift_right_preserve_sign
      ;; ( fixnum-1, fixnum-2, step --
      ;;   new fixnum-1, new fixnum-2 )
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      shrd rbx, rax, cl
      sar rax, cl
      push_argument_stack rax
      push_argument_stack rbx
      next




   defCode "rotate-left", rotate_left
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      rol qword[Argument_stack_pointer], cl
      next

   defCode "rotate-right", rotate_right
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      ror qword[Argument_stack_pointer], cl
      next
   #+end_src
** about Return-stack
   #+begin_src fasm :tangle threaded-code.inc
   defCode "push-return-stack", _push_return_stack
      ;; (* address --> ReturnStack: address *)
      pop_argument_stack  rax
      push_return_stack rax
      next

   defCode "pop-return-stack", _pop_return_stack
      ;; (* ReturnStack: address --> address *)
      pop_return_stack  rax
      push_argument_stack rax
      next

   ;; up to now
   ;; the above two class classic forth words
   ;; have not been used by cicada yet


   defCode "fetch-return-stack-pointer", fetch_return_stack_pointer
      ;; (* -- an address in the ReturnStack *)
      push_argument_stack Return_stack_pointer
      next

   defCode "reset-return-stack-pointer", reset_return_stack_pointer
      ;; (* an address in the ReturnStack -- *)
      pop_argument_stack Return_stack_pointer
      next

   defCode "drop-return-stack", drop_return_stack
      ;; (* -- *)
      add Return_stack_pointer, Cell_width
      next
   #+end_src
** about Argument-stack
   #+begin_src fasm :tangle threaded-code.inc
   ;; to know why the following funny thing happens,
   ;; see the definition of the macro ``push_argument_stack'',
   defCode "make-self-reference-value", make_self_reference_value
      ;; ( -- address )
      push_argument_stack Argument_stack_pointer
      next

   defWord "fetch-argument-stack-pointer", fetch_argument_stack_pointer
      xx make_self_reference_value, add8, Exit
   defWordEnd fetch_argument_stack_pointer

   defCode "reset-argument-stack-pointer", reset_argument_stack_pointer
      ;; ( address -- )
      pop_argument_stack Argument_stack_pointer
      next
   #+end_src
** about Grey-pair-stack
   #+begin_src fasm :tangle threaded-code.inc
   defCode "push-grey-pair-stack", push_grey_pair_stack
      ;; (* pair[address] --> GreyPairStack: pair[address] *)
      pop_argument_stack rax
      lea Grey_pair_stack_pointer, [Grey_pair_stack_pointer - Cell_width]
      mov [Grey_pair_stack_pointer], rax
      next

   defCode "pop-grey-pair-stack", pop_grey_pair_stack
      ;; (* GreyPairStack: pair[address] --> pair[address] *)
      mov rax, [Grey_pair_stack_pointer]
      lea Grey_pair_stack_pointer, [Grey_pair_stack_pointer + Cell_width]
      push_argument_stack rax
      next

   defCode "empty-grey-pair-stack?", empty_grey_pair_stack?
      ;; (* -- True or False *)
      mov rax, Grey_pair_stack_top
      cmp Grey_pair_stack_pointer, rax
      ;; note that:
      ;; Grey_pair_stack_pointer >= Grey_pair_stack_top
      ;; means stack over flow
      setge al
      movzx rax, al
      push_argument_stack rax
      next
   #+end_src
** about Lambda-stack
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. not to much stack-processing is needed here
   ;; 2. LambdaStack can be used to save the faked-local-vars

   defVar "Lambda-stack-pointer", Lambda_stack_top, Lambda_stack_pointer

   defWord "push-lambda-stack", push_lambda_stack
      ;; (* ArgumentStack::  value -->
      ;;    LambdaStack::    value *)
      xx _literal, Cell_width, Lambda_stack_pointer, sub_save
      xx Lambda_stack_pointer, fetch, save
      xx Exit
   defWordEnd push_lambda_stack

   defWord "pop-lambda-stack", pop_lambda_stack
      ;; (* LambdaStack::    value -->
      ;;    ArgumentStack::  value *)
      xx Lambda_stack_pointer, fetch, fetch
      xx _literal, Cell_width, Lambda_stack_pointer, add_save
      xx Exit
   defWordEnd pop_lambda_stack

   defWord "ready", ready
      ;; (* ArgumentStack::  value-a, value-b -->
      ;;    LambdaStack::    value-a, value-b *)
      ;; (* beware of the order of the two values *)
      xx swap, push_lambda_stack, push_lambda_stack
      xx Exit
   defWordEnd ready

   defWord "get-back", get_back
      ;; (* beware of the order of the two values *)
      ;; (* LambdaStack::    value-a, value-b -->
      ;;    ArgumentStack::  value-a, value-b *)
      xx pop_lambda_stack, pop_lambda_stack, swap
      xx Exit
   defWordEnd get_back
   #+end_src
* number
** note
   1. 现在 的 number 就只是 "integer" 而已
      更多的跟数学有关的东西将在 cicada 中设计新的语法来实现
   2. 在 "integer" 这个函数中 我将只支持 对四种进位制的 字符串的 阅读
      1. 十进制 :: 10#1231 10#-1231 或者 1231 -1231
      2. 二进制 :: 2#101001 2#-101001
      3. 八进制 :: 8#712537 8#-712537
      4. 十六进制 :: 16#f123acb3 16#-F123ACB3 (大写小写字母都可以)
   3. and still, one can use "_" to separate the number to make it more readable
      example : 2#1111_0101_0001
   4. actually, the base can be any 10 based number
      even greater then 36
      but when the base is greater then 36
      not all integer can be represented under this base
      for we only have 36 chars
   5. 可以发现 这样对一个 字符串 是不是代表了一个 整数的 判断就简单多了
** base-of-string
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. just take the 10 based number on the left of "#" as base
   ;;    while the base must be not-zero
   ;;    (actually, when it is zero, just let the zero return,
   ;;     it will be viewed as a parsing error.)
   ;; 2. if can not find "#" in the string
   ;;    or there is nothing after the first occur of "#"
   ;;    or there is nothing in front of the first occur of "#"
   ;;    or the string on the left of "#" can not be simply viewed as a 10 based number
   ;;    or it is zero
   ;;    just reture zero
   ;; 3. this function is really a perfect example
   ;;    of how to make good use of Lambda-stack :)
   defWord "base-of-string", base_of_string
      ;; (* string[address, length] -- base  or zero *)
      xx _literal, 0, push_lambda_stack ;; init counter for help__base_of_string__push_char
      xx help__base_of_string__push_char
      xx dup, false?, _false?branch, 2
      xx   Exit
      xx drop
      xx _literal, 0  ;; init base for help__base_of_string__pop_char
      xx pop_lambda_stack
      xx _literal, 0
      xx push_lambda_stack  ;; init index for help__base_of_string__pop_char
      xx help__base_of_string__pop_char
      xx Exit
   defWordEnd base_of_string

   defWord "help:help:base-of-string,push-char,clear-lambda-stack", help__help__base_of_string__push_char__clear_lambda_stack
      ;; (* char-counter[N] -- *)
      ;; (* Lambda-stack::  char, ... --  *)
      xx dup, zero?, _false?branch, 3
      xx   drop
      xx   Exit
      xx sub1, pop_lambda_stack, drop
      xx help__help__base_of_string__push_char__clear_lambda_stack
      xx Exit
   defWordEnd help__help__base_of_string__push_char__clear_lambda_stack

   defWord "help:base-of-string,push-char", help__base_of_string__push_char
      ;; (* string[address, length] -- True *)
      ;; (* Lambda-stack:: char-counter[0] -- char-counter[N], char, ... *)
      ;; (* or *)
      ;; (* string[address, length] -- False *)
      ;; (* Lambda-stack:: char-counter[0] -- *)
      xx dup, _literal, 2, less_than?, _false?branch, 7
      xx   drop2
      xx   pop_lambda_stack
      xx   help__help__base_of_string__push_char__clear_lambda_stack
      xx   _literal, 0
      xx   Exit
      xx tail_and_head_of_string
      xx dup, _literal, '#', equal?, _false?branch, 6
      xx   drop, drop2
      xx   _literal, 1
      xx   Exit
      xx dup, char_denote_number?, false?, _false?branch, 8
      xx   drop, drop2
      xx   pop_lambda_stack
      xx   help__help__base_of_string__push_char__clear_lambda_stack
      xx   _literal, 0
      xx   Exit
      xx pop_lambda_stack, add1
      xx swap, push_lambda_stack, push_lambda_stack
      xx help__base_of_string__push_char
      xx Exit
   defWordEnd help__base_of_string__push_char

   ;; over-flow of 64 bits is not handled
   defWord "help:base-of-string,pop-char", help__base_of_string__pop_char
      ;; (* base, char-counter[N] -- base *)
      ;; (* Lambda-stack::  index, char, ... -- *)
      xx dup, zero?, _false?branch, 5
      xx   drop
      xx   pop_lambda_stack, drop
      xx   Exit
      xx sub1
      xx swap, pop_lambda_stack
      ;; (* char-counter[N], base, index *)
      xx dup, _literal, 10, swap, power
      xx   pop_lambda_stack
      xx   _literal, '0', subtraction
      xx   multiple
      xx   swap, add1, push_lambda_stack
      xx   addition
      xx swap
      xx help__base_of_string__pop_char
      xx Exit
   defWordEnd help__base_of_string__pop_char
   #+end_src
** digit-of-string
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. just take whatever the sub-string on the rigth of "#"
   ;;    while the length of this sub-string must be not-zero
   ;; 2. if can not find "#" in the string
   ;;    or there is nothing after the first occur of "#"
   ;;    or there is nothing in front of the first occur of "#"
   ;;    just reture zero
   defWord "digit-of-string", digit_of_string
      ;; (* string[address, length] -- digit[address, length]  or zero *)
      xx dup2, head_of_string
      xx _literal, '#', equal?, _false?branch, 5
      xx   drop2
      xx   _literal, 0
      xx   Exit
      xx help__digit_of_string
      xx Exit
   defWordEnd digit_of_string

   ;; this helper-function do not handle "#123" as error
   ;; i.e. when there is nothing in front of the first occur of "#"
   ;; it does not reture 0
   defWord "help:digit-of-string", help__digit_of_string
      ;; (* string[address, length] -- digit[address, length]  or zero *)
      xx dup, _literal, 2, less_than?, _false?branch, 5
      xx   drop2
      xx   _literal, 0
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, '#', equal?, _false?branch, 2
      xx   Exit
      xx help__digit_of_string
      xx Exit
   defWordEnd help__digit_of_string
   #+end_src
** char->number
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. if char is not in [0-9] [A-Z] [a-z]
   ;;    reture -1 to denote error
   defWord "char->number", char_to_number
      ;; (* char -- the number it denotes *)
      xx dup, _literal, '0', less_than?, _false?branch, 5
      xx   drop
      xx   _literal, -1
      xx   Exit
      xx dup, _literal, '9', less_or_equal?, _false?branch, 5
      xx   _literal, '0'
      xx   subtraction
      xx   Exit
      xx dup, _literal, 'A', less_than?, _false?branch, 5
      xx   drop
      xx   _literal, -1
      xx   Exit
      xx dup, _literal, 'Z', less_or_equal?, _false?branch, 8
      xx   _literal, 'A', subtraction
      xx   _literal, 10, addition
      xx   Exit
      xx dup, _literal, 'a', less_than?, _false?branch, 5
      xx   drop
      xx   _literal, -1
      xx   Exit
      xx dup, _literal, 'z', less_or_equal?, _false?branch, 8
      xx   _literal, 'a', subtraction
      xx   _literal, 10, addition
      xx   Exit
      xx drop
      xx _literal, -1
      xx Exit
   defWordEnd char_to_number
   #+end_src
** with-base:char-denote-number?
   #+begin_src fasm :tangle threaded-code.inc
   defWord "with-base:char-denote-number?", with_base__char_denote_number?
      ;; (* base, char -- True of False *)
      ;; (* char -- True or False *)
      xx char_to_number
      xx dup, _literal, -1, equal?, _false?branch, 4
      xx   drop2
      xx   False
      xx   Exit
      xx greater_than?, _false?branch, 3
      xx   True
      xx   Exit
      xx False
      xx Exit
   defWordEnd with_base__char_denote_number?
   #+end_src
** with-base:string-denote-digit?
   #+begin_src fasm :tangle threaded-code.inc
   ;; in the following function "with-base:string-denote-digit?"
   ;; I also need to handle the separater "_"

   ;; use with-base:char-denote-number?
   ;; to check if each "digit-cher" greater_or_equal then "base"

   defWord "with-base:string-denote-digit?", with_base__string_denote_digit?
      ;; (* base, string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 5
      xx   drop2, drop
      xx   False
      xx   Exit
      xx dup2, head_of_string, _literal, '-', equal?, _false?branch, 2
      ;; note the way how to uses "if then" here
      ;; it is enough to use "if then" to handle
      ;; an optional executed function call, without the use of "Exit"
      xx   tail_of_string
      xx dup2, string_full_of_underscore?, _false?branch, 5
      xx   drop2, drop
      xx   False
      xx   Exit
      xx help__with_base__string_denote_digit?
      xx Exit
   defWordEnd with_base__string_denote_digit?

   ;; this helper function :
   ;; 0. when meet zero-length string always reture True
   defWord "string-full-of-underscore?", string_full_of_underscore?
      ;; (* string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 4
      xx   drop2
      xx   True
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, '_', equal?, _false?branch, 3
      xx   string_full_of_underscore?
      xx   Exit
      xx drop2
      xx False
      xx Exit
   defWordEnd string_full_of_underscore?

   ;; this helper function :
   ;; 0. when meet zero-length string always reture True
   ;; 1. do not handle "-"
   ;; 2. do not handle string-full-of-underscore
   defWord "help:with-base:string-denote-digit?", help__with_base__string_denote_digit?
      ;; (* base, string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 5
      xx   drop2, drop
      xx   True
      xx   Exit
      xx tail_and_head_of_string
      xx dup, _literal, '_', equal?, _false?branch, 4
      xx   drop
      xx   help__with_base__string_denote_digit?
      xx   Exit
      xx xoverxxx, swap
      xx with_base__char_denote_number?, _false?branch, 3
      xx   help__with_base__string_denote_digit?
      xx   Exit
      xx drop2, drop
      xx False
      xx Exit
   defWordEnd help__with_base__string_denote_digit?


   defWord "with-base:string-denote-digit?without-sign", with_base__string_denote_digit?without_sign
      ;; (* base, string[address, length] -- True or False *)
      xx dup2, head_of_string, _literal, '-', equal?, _false?branch, 5
      xx   drop2, drop
      xx   False
      xx   Exit
      xx with_base__string_denote_digit?
      xx Exit
   defWordEnd with_base__string_denote_digit?without_sign
   #+end_src
** string-denote-base#digit? & string-denote-digit?
   #+begin_src fasm :tangle threaded-code.inc
   ;; now with very good factoring
   ;; we can write the following function easily :)

   ;; with "#"
   defWord "string-denote-base#digit?", string_denote_base_digit?
      ;; (* string[address, length] -- True or False *)
      xx dup2, base_of_string
      xx dup, zero?, _false?branch, 5
      xx   drop  ;; drop zero
      xx   drop2 ;; drop string
      xx   False
      xx   Exit
      xx xxswapx
      xx digit_of_string
      xx dup, zero?, _false?branch, 5
      xx   drop  ;; drop zero
      xx   drop  ;; drop base
      xx   False
      xx   Exit
      xx with_base__string_denote_digit?
      xx Exit
   defWordEnd string_denote_base_digit?

   ;; without "#"
   defWord "string-denote-digit?", string_denote_digit?
      ;; (* string[address, length] -- True or False *)
      xx _literal, 10, xxswapx
      xx with_base__string_denote_digit?
      xx Exit
   defWordEnd string_denote_digit?
   #+end_src
** string-denote-integer?
   #+begin_src fasm :tangle threaded-code.inc
   ;; in the following functions
   ;; I also need to handle the separater "_"

   ;; two sub-type of string as above
   defWord "string-denote-integer?", string_denote_integer?
      ;; (* string[address, length] -- True or False *)
      xx dup2, string_denote_digit?, _false?branch, 4
      xx   drop2, True
      xx   Exit
      xx string_denote_base_digit?, _false?branch, 3
      xx   True
      xx   Exit
      xx False
      xx Exit
   defWordEnd string_denote_integer?
   #+end_src
** with-base:string->natural-number,with-error
   #+begin_src fasm :tangle threaded-code.inc
   ;; we need to return an error indication
   ;; so we let the following function returns two items on the stack
   ;; is this the right way to do it?
   ;; for sometimes one might do not want to call "debuger"
   ;; when calling "string->integer" and meet a parsing error
   defWord "with-base:string->natural-number,with-error", with_base__string_to_natural_number__with_error
      ;; (* base, string[address, length] -- natural-number, True *)
      ;; (* or *)
      ;; (* base, string[address, length] -- 0, False *)
      xx xoverxx, xxoverx
      xx with_base__string_denote_digit?without_sign, false?, _false?branch, 7
      xx   drop2, drop
      xx   _literal, 0
      xx   False
      xx   Exit
      xx _literal, 0, push_lambda_stack ;; number-counter[0]
      xx help_push__with_base__string_to_natural_number__with_error
      xx _literal, 0 ;; sum
      xx _literal, 0 ;; index
      xx help_pop__with_base__string_to_natural_number__with_error
      xx Exit
   defWordEnd with_base__string_to_natural_number__with_error


   defWord "help-push:with-base:string->natural-number,with-error", help_push__with_base__string_to_natural_number__with_error
      ;; (* base, string[address, length] -- base *)
      ;; (* Lambda-stack:: number-counter[0] -- number-counter[N], number, ... *)
      xx dup, zero?, _false?branch, 3
      xx   drop2
      xx   Exit
      xx tail_and_head_of_string
      xx dup, _literal, '_', equal?, _false?branch, 4
      xx   drop
      xx   help_push__with_base__string_to_natural_number__with_error
      xx   Exit
      xx char_to_number, pop_lambda_stack, add1
      xx swap, push_lambda_stack, push_lambda_stack
      xx help_push__with_base__string_to_natural_number__with_error
      xx Exit
   defWordEnd help_push__with_base__string_to_natural_number__with_error

   defWord "help-pop:with-base:string->natural-number,with-error", help_pop__with_base__string_to_natural_number__with_error
      ;; (* base, sum, index -- natural-number, True *)
      ;; (* Lambda-stack:: number-counter[N], number, ... -- *)
      xx pop_lambda_stack
      xx dup, zero?, _false?branch, 7
      xx   drop
      xx   drop, swap, drop
      xx   True
      xx   Exit
      xx pop_lambda_stack, swap, sub1, push_lambda_stack
      ;; (* base, sum, index, number *)
      xx xoverxxx, xoverxx
      xx power
      ;; (* base, sum, index, number, base^index *)
      xx multiple
      xx push_lambda_stack
      xx swap, pop_lambda_stack, addition
      xx swap, add1
      xx help_pop__with_base__string_to_natural_number__with_error
      xx Exit
   defWordEnd help_pop__with_base__string_to_natural_number__with_error
   #+end_src
** with-base:string->integer,with-error
   #+begin_src fasm :tangle threaded-code.inc
   defWord "with-base:string->integer,with-error", with_base__string_to_integer__with_error
      ;; (* base, string[address, length] -- natural-number, True *)
      ;; (* or *)
      ;; (* base, string[address, length] -- 0, False *)
      xx xoverxx, xxoverx
      xx with_base__string_denote_digit?, false?, _false?branch, 7
      xx   drop2, drop
      xx   _literal, 0
      xx   False
      xx   Exit
      xx dup2, head_of_string, _literal, '-', equal?, _false?branch, 7
      xx   tail_of_string
      xx   with_base__string_to_natural_number__with_error
      xx   swap
      xx   negate
      xx   swap
      xx   Exit
      xx with_base__string_to_natural_number__with_error
      xx Exit
   defWordEnd with_base__string_to_integer__with_error
   #+end_src
** string->integer,with-error
   #+begin_src fasm :tangle threaded-code.inc
   defWord "string->integer,with-error", string_to_integer__with_error
      ;; (* string[address, length] -- integer, True *)
      ;; (* or *)
      ;; (* string[address, length] -- 0, False *)
      xx dup2, string_denote_base_digit?, _false?branch, 7
      xx   dup2, base_of_string
      xx   xxswapx, digit_of_string
      xx   with_base__string_to_integer__with_error
      xx   Exit
      xx dup2, string_denote_digit?, _false?branch, 6
      xx   _literal, 10
      xx   xxswapx
      xx   with_base__string_to_integer__with_error
      xx   Exit
      xx drop2
      xx _literal, 0
      xx False
      xx Exit
   defWordEnd string_to_integer__with_error
   #+end_src
* string misc
** read_string_into_buffer
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData
   ;; ------------------------------------------
   ;; note that, Subsequent calls will overwrite Basic_string_buffer
   MaxStringLength = 1024*1024

   Basic_string_buffer labeling
           preserve MaxStringLength

   defConst "Basic-string-buffer", Basic_string_buffer, _Basic_string_buffer

   defWord "read-string-into-buffer", read_string_into_buffer
      ;; (*  -- string[address of Basic_string_buffer, length] *)
      xx _literal, Basic_string_buffer ;; (* leave one of the return values *)
      xx _literal, 0                   ;; (* leave length counter *)

      xx _literal, Basic_string_buffer

      .read_char:
      xx read_char, dup, _literal, '"', equal?, _false?branch, 3
      xx   drop2
      xx   Exit

      xx over, save_byte, add1
      xx swap, add1, swap
      xx _branch, (- ($ - .read_char) / Cell_width)
   defWordEnd read_string_into_buffer
   #+end_src
** find-char-address & find-char-index
   #+begin_src fasm :tangle threaded-code.inc
   ;; : find-char-address
   ;;   (* char, [address, length] -- address or -1 *)
   ;;   dup zero? if
   ;;     drop2 drop
   ;;     -1
   ;;     Exit
   ;;   then
   ;;   tailAndHeadOfString
   ;;   x|over|xxx == if
   ;;     drop swap drop
   ;;     sub1
   ;;     Exit
   ;;   then
   ;;   find-char-address
   ;;   Exit
   ;; ; defineRecursiveFunction

   defWord "find-char-address", find_char_address
      ;; (* char, [address, length] -- address or -1 *)
      xx dup, zero?, _false?branch, 6
      xx   drop2, drop
      xx   _literal, -1
      xx   Exit
      xx tail_and_head_of_string
      xx xoverxxx, equal?, _false?branch, 6
      xx   drop, swap, drop
      xx   sub1
      xx   Exit
      xx find_char_address
      xx Exit
   defWordEnd find_char_address

   ;; : find-char-index
   ;;   (* char, [address, length] -- index or -1 *)
   ;;   (* index start from Zero *)
   ;;   over
   ;;   xxx|swap|x
   ;;   find-char-address
   ;;   dup 0 < if
   ;;     swap drop
   ;;     Exit
   ;;   then
   ;;   swap -
   ;;   Exit
   ;; ; define-function

   defWord "find-char-index", find_char_index
      ;; (* char, [address, length] -- index or -1 *)
      ;; (* index start from Zero *)
      xx over
      xx xxxswapx
      xx find_char_address
      xx dup, _literal, 0, less_than?, _false?branch, 4
      xx   swap, drop
      xx   Exit
      xx swap, subtraction
      xx Exit
   defWordEnd find_char_index


   ;; (* test:
   ;;  * 'k' s" k" find-char-index . (* 0 *) cr
   ;;  * 'k' s" kkk" find-char-index . (* 0 *) cr
   ;;  * 'k' s" skkk" find-char-index . (* 1 *) cr
   ;;  * 'k' s"  kkk" find-char-index . (* 1 *) cr
   ;;  * 'k' s" 0123456789k" find-char-index . (* 10 *) cr
   ;;  * 'k' s" "0123456789 find-char-index . (* -1 *) cr
   ;;  *)
   #+end_src
** cr
   #+begin_src fasm :tangle threaded-code.inc
   defWord "cr", cr
      ;; (* -- *)
      xx _literal, ASCII_linefeed, write_char
      xx Exit
   defWordEnd cr
   #+end_src
* key-word
** if else then
   #+begin_src fasm :tangle threaded-code.inc
   ;; one predicate can make two branchs
   ;; three predicates can make four branchs
   ;; three predicates may only make three branchs
   ;; but indeed there must be an invisible branch

   defKeyWord "if", _if
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack::
      ;;       -- address after _false?branch *)
      ;; (* compile::
      ;;      _false?branch[address of explainer], 0 *)
      xx _literal, _false?branch, append_number_to_here
      xx Here, fetch, push_lambda_stack
      xx _literal, 0, append_number_to_here ;; (* leave a place *)
      xx Exit
   defKeyWordEnd _if

   defKeyWord "else", _else
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack ::
      ;;      [address after _false?branch] -- [address after _branch] *)
      ;; (* compile ::
      ;;      _branch[address of explainer], 0 *)
      ;; (* compile to [address after _false?branch] ::
      ;;      [appropriate offset] *)
      xx _literal, _branch, append_number_to_here
      xx pop_lambda_stack
      xx   Here, fetch, push_lambda_stack
      xx   _literal, 0, append_number_to_here ;; (* leave a place *)
      xx Here, fetch, over, subtraction, _literal, Cell_width, moddiv, swap, drop
      xx swap, save
      xx Exit
   defKeyWordEnd _else

   defKeyWord "then", _then
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack ::
      ;;      [address after _false?branch] or [address after _branch] --  *)
      ;; (* compile to [address after _false?branch] or [address after _branch] ::
      ;;      [appropriate offset] *)
      xx pop_lambda_stack
      xx Here, fetch, over, subtraction, _literal, Cell_width, moddiv, swap, drop
      xx swap, save
      xx Exit
   defKeyWordEnd _then
   #+end_src
** comment
   #+begin_src fasm :tangle threaded-code.inc
   defConstString "Bra:comment", "(*", Bra__comment
   defConstString "Ket:comment", "*)", Ket__comment

   defKeyWord "(*", ignore_comment
      ;; (* word-string[address, length] -- word-string[address, length] *)
      xx tail_and_head_of_word_string
      xx dup2, Bra__comment, equal_string?, _false?branch, 5
      xx   drop2, ignore_comment, _branch, -9
      ;; beware of the tail-call-optimization
      ;; a tail-recursive-call is really a loop
      xx Ket__comment, equal_string?, _false?branch, -13
      xx   Exit
   defKeyWordEnd ignore_comment
   #+end_src
** colon
   #+begin_src fasm :tangle threaded-code.inc
   defWord "append-number-to-current-data-section", append_number_to_current_data_section
      ;; (* a 64 bits number -- *)
      ;; reset "Current_data_section", which points next free memory
      xx Current_data_section, fetch
      xx save
      xx Current_data_section, fetch
      xx _literal, Cell_width, addition
      xx Current_data_section, save
      xx Exit
   defWordEnd append_number_to_current_data_section

   ;; note that:
   ;; a string in stack is string[address, length]
   ;; a string in memory is ||  1 : length  ||  n : string  ||  1 : 0  ||
   defWord "append-string-to-current-data-section", append_string_to_current_data_section
      ;; (* string[address, length] -- *)
      ;; for update Current_data_section
      xx dup, push_lambda_stack
      xx   dup, append_number_to_current_data_section
      xx   Current_data_section, fetch, swap, copy_byte_string
      ;; update Current_data_section
      xx pop_lambda_stack
      xx Current_data_section, fetch, addition
      xx _literal, 0, over, save_byte
      xx add1
      xx Current_data_section, save
      xx Exit
   defWordEnd append_string_to_current_data_section



   ;; cosemi = colon + semicolon
   defConstString "Bra:cosemi", ":", Bra__cosemi
   defConstString "Ket:cosemi", ";", Ket__cosemi

   ;; 1. 为了使得 data section 的处理变得简单
   ;;    即 不用去计算 function section 的长度
   ;;    而使用 类似 哈佛构架的办法 把数据与函数分开
   ;; 2. 利用 Current_data_section 这个变量
   ;; 3. 为了处理嵌套的 ":" ";" 而对 ":" 的出现进行计数
   ;; 4. do not copy byte by byte
   ;;    but use "copy-byte-string"
   defKeyWord ":", colon
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile ::
      ;;      string[address, length] *)
      ;; (* compile to [data section] ::
      ;;      string-header and string ended by 0 *)
      xx dup2
      xx _literal, 0, push_lambda_stack ;; ":" counter
      .tail_and_head_of_word_string:
      xx tail_and_head_of_word_string
      xx dup2, Bra__cosemi, equal_string?, _false?branch, (.dup2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack, add1, push_lambda_stack
      xx   _branch, (.tail_and_head_of_word_string-$)/Cell_width
      .dup2:
      xx dup2, Ket__cosemi, equal_string?, _false?branch, (.drop2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack
      xx   dup, zero?, _false?branch, (.sub1-$)/Cell_width
      xx     drop
      ;;     (* word-string-begin[address, length], word-string-end[address, length] *)
      xx     dup2, ready
      ;;       (* calculate the length and copy to [data section] *)
      xx       drop, swap, drop
      xx       _literal, 2, subtraction ;; sub the length of "; "
      xx       over, subtraction
      xx         Current_data_section, fetch
      xx         _literal, Cell_width, addition
      xx         over, push_lambda_stack  ;; (* length to compile to here *)
      xx         push_lambda_stack        ;; (* address to compile to here *)
      xx       append_string_to_current_data_section
      ;;       (* compile the string into function-body *)
      ;;       (* address to compile to here *)
      xx       _literal, _literal, append_number_to_here
      xx       pop_lambda_stack, append_number_to_here
      ;;       (* length to compile to here *)
      xx       _literal, _literal, append_number_to_here
      xx       pop_lambda_stack, append_number_to_here
      xx     get_back
      xx     Exit
      .sub1:
      xx   sub1, push_lambda_stack
      xx   _branch, (.tail_and_head_of_word_string-$)/Cell_width
      .drop2:
      xx drop2
      xx _branch, (.tail_and_head_of_word_string-$)/Cell_width
      xx Exit
   defKeyWordEnd colon




   ;; ><><><
   ;; Chinese version

   defConstString "Bra:fuzhe", "夫", Bra__fuzhe
   defConstString "Ket:fuzhe", "者", Ket__fuzhe

   defKeyWord "夫", 夫
      ;; (* word-string[address, length] -- word-string[address, length] *)
      xx Exit
   defKeyWordEnd 夫
   #+end_src
* the dictionary & the lexicographer
** explainers & execute & Exit
   #+begin_src fasm :tangle threaded-code.inc
   defCode "execute", execute
      ;; ( word[address of explainer] -- )
      pop_argument_stack Explainer_pointer
      jmp qword[Explainer_pointer]

   ;; when someone try to find a word in the dictionary,
   ;; the explainer of that word explains the word for him or her

   ;; explain_function_body 会贴贴一个 纸条 到 木条 上

   ;; the version handles empty function-body
   hereCode
   explain_function_body:
      ;;  Explainer_pointer  == address
      ;; [Explainer_pointer] == explain_function_body
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;          -- [address of explainer] + Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;          -- *)
      ;; and jump to the explainer of the [address of explainer]
      mov rbx, Explainer_pointer
      add rbx, Cell_width
      mov Explainer_pointer, [rbx]
      add rbx, Cell_width
      cmp dword[rbx], Exit
      je at_the_end_of_function_body
      cmp dword[rbx], 已矣
      je at_the_end_of_function_body
      push_return_stack rbx
   at_the_end_of_function_body:
      jmp qword[Explainer_pointer]

   ;; ;; the version does NOT handle empty function-body
   ;; hereCode
   ;; explain_function_body:
   ;;    ;;  Explainer_pointer  == address
   ;;    ;; [Explainer_pointer] == explain_function_body
   ;;    ;; must NOT at the end of the function body
   ;;    ;; (* Return-stack::
   ;;    ;;       -- [address of explainer] + Cell_width *)
   ;;    ;; and jump to the explainer of the [address of explainer]
   ;;    mov rbx, Explainer_pointer
   ;;    add rbx, Cell_width
   ;;    mov Explainer_pointer, [rbx]
   ;;    add rbx, Cell_width
   ;;    push_return_stack rbx
   ;;    jmp qword[Explainer_pointer]


   hereCode
   explain_variable:
      ;;  Explainer_pointer  == address
      ;; [Explainer_pointer] == explainVar
      ;; (* -- address *)
      add Explainer_pointer, Cell_width
      push_argument_stack Explainer_pointer
      next

   hereCode
   explain_constant:
      ;;  Explainer_pointer  == address
      ;; [Explainer_pointer] == explainConst
      ;; (* -- value *)
      add Explainer_pointer, Cell_width
      mov Explainer_pointer, [Explainer_pointer]
      push_argument_stack Explainer_pointer
      next

   hereCode
   explain_constant_string:
      ;;  Explainer_pointer  == address
      ;; [Explainer_pointer] == explainConstString
      ;; (* -- string[address, length] *)
      add Explainer_pointer, (2 * Cell_width)
      push_argument_stack Explainer_pointer
      sub Explainer_pointer, Cell_width
      mov Explainer_pointer, [Explainer_pointer]
      push_argument_stack Explainer_pointer
      next

   ;; the following Exit helps tail-call-optimization
   ;; it just let you decide where is the end of FunctionBody
   ;; in a FunctionBody, the ``Exit'' as a word will never be called
   defConst "Exit", Exit, Exit
   defConst "已矣", 已矣, 已矣

   defConst "Function-body-explainer",   explain_function_body,     _Function_body_explainer
   defConst "Variable-explainer",        explain_variable,          _Variable_explainer
   defConst "Constant-explainer",        explain_constant,          _Constant_explainer
   defConst "Constant-string-explainer", explain_constant_string,   _Constant_string_explainer
   #+end_src
** find (dictionary look up)
   #+begin_src fasm :tangle threaded-code.inc
   ;; recall
   ;; a word in the dictionary (unit : Cell_width = 8 bytes)
   ;; ==
   ;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
   ;;    ||  m : name-string  ||
   ;;    ||  1 : SizeOfFunctionBody  ||
   ;;    ||  1 : identification  ||
   ;;    ||  1 : link  ||
   ;;    ||  1 : type  ||
   ;;    ||  1 : address-of-name-string-header  ||
   ;;    ||  1 : address-of-explainer  ||
   ;;    ||  n : body  ||
   ;; where
   ;;   ||  1 : type  ||
   ;; ==
   ;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
   ;; type-bit-63 is for HiddenWord
   ;; type-bit-0,1,2 are for word type
   ;; 0 -- function
   ;; 1 -- key word


   WordType_HiddenMask = (1 shl 63)

   defWord "word-link->name-string", word_link_to_name_string
      ;; (* link[address] -- string[address, length] *)
      xx _literal, Cell_width
      xx _literal, 2, multiple
      xx addition
      xx fetch
      xx dup, _literal, Cell_width, addition
      xx swap, fetch
      xx Exit
   defWordEnd word_link_to_name_string

   defWord "word-link->word-explainer", word_link_to_word_explainer
      ;; (* word[address of link] -- word[address of explainer] *)
      xx _literal, Cell_width
      xx _literal, 3, multiple
      xx addition
      xx Exit
   defWordEnd word_link_to_word_explainer

   defWord "word-link->word-type", word_link_to_word_type
      ;; (* word[address of link] -- word-type *)
      xx _literal, Cell_width
      xx addition, fetch
      xx Exit
   defWordEnd word_link_to_word_type


   defWord "help,find", help__find
      ;; (* wordString[address, length], link[address] -- word[address of link] or Zero *)
      xx dup, zero?, _false?branch, 4
      xx   xxswapx, drop2
      xx   Exit
      xx xxtuckx, word_link_to_name_string, xxoverxx, equal_string?, _false?branch, 3
      xx   drop2
      xx   Exit
      xx xswapxx, fetch
      xx help__find
      xx Exit
   defWordEnd help__find

   defWord "find", find
      ;; (* wordString[address, length] -- word[address of link] or Zero *)
      xx FirstWordInDictionary, fetch
      xx help__find
      xx Exit
   defWordEnd find
   #+end_src
** about word
*** note about distinguishing word from input
    1. read-char 给 input 做好了抽象
       使得 从 input 中读字符
       和 取一个字符串的头一个字符 不同的是
       从 input 读字符是 有来无回的
    2. 每次只有发现在 blank 和 non-blank 的边界的时候
       才能知道这是一个 word 的边界
       比如: "   kkk   "
       开始发现 kkk 这个 word 的时候
       处在开头的 边界位置的 "k" 一定已经从 input 中被取出来了
       结束发现 kkk 这个 word 的时候
       处在结尾的 边界位置的 " " 一定已经从 input 中被取出来了
    3. 这就是 我需要 read-word,while-saving-to-string 的原因
       即 我要 在某种程度上 改变 "有来无回" 的情况
*** read-word,while-saving-to-string
    #+begin_src fasm :tangle threaded-code.inc
    ;; 1. the following functions are for read-phrase
    ;; 2. 需要 一个 另一个版本的 read_word
    ;;    来 帮助 实现 read-word-string,for-lexicographer
    ;; 3. 这是必要的
    ;;    因为 否则 用来读字符串的函数就实现不好

    ;; (* helper functions *)
    defWord "string-append-char", string_append_char
       ;; (* string[address, length], char -- string[address, length+1] *)
       xx xxoverx, addition, save_byte
       xx add1
       xx Exit
    defWordEnd string_append_char

    ;; 这个版本的函数 每次读一个 char 之后 都会先把它存到字符串中

    defWord "read-first-non-blank-char,while-saving-to-string", read_first_non_blank_char__while_saving_to_string
       ;; (* string[address, length] --
       ;;    string-with-char[address, length], FirstNonBlankChar *)
       xx read_char, dup, push_lambda_stack
       xx   string_append_char
       xx pop_lambda_stack
       xx dup, _literal, ASCII_space, greater_than?, _false?branch, 2
       xx   Exit
       xx drop
       xx read_first_non_blank_char__while_saving_to_string
       xx Exit
    defWordEnd read_first_non_blank_char__while_saving_to_string


    hereUnInitializedData
    ;; ------------------------------------------
    ;; note that, Subsequent calls will overwrite Buffer_for_read_word
    ;; this is why there is another function ``read_word_for_runtime''
    Max_word_length = 1024

    Buffer_for_read_word__while_saving_to_string labeling
            preserve Max_word_length

    defWord "read-word,while-saving-to-string", read_word__while_saving_to_string
       ;; (* string[address, length] --
       ;;    string-with-word[address, length], word-string[address, length] *)

       xx read_first_non_blank_char__while_saving_to_string
       xx _literal, Buffer_for_read_word__while_saving_to_string, save_byte
       xx _literal, 1, push_lambda_stack
       xx _literal, Buffer_for_read_word__while_saving_to_string, add1
       xx push_lambda_stack

       .read_char:
       xx read_char
       xx dup, xxoverxx, addition, save_byte, swap, add1, swap
       xx dup, _literal, ASCII_space, greater_than?, _false?branch, ((.then - $) / Cell_width)
       xx   pop_lambda_stack, tuck, save_byte, add1
       xx   pop_lambda_stack, add1
       xx   push_lambda_stack
       xx   push_lambda_stack
       xx   _branch, (-($ - .read_char) / Cell_width)
       .then:

       xx drop
       xx pop_lambda_stack, drop
       xx _literal, Buffer_for_read_word__while_saving_to_string
       xx pop_lambda_stack
       xx Exit
    defWordEnd read_word__while_saving_to_string
    #+end_src
** about word-string
*** find-word-boundary-address & find-word-boundary-index
    #+begin_src fasm :tangle threaded-code.inc
    defWord "find-word-boundary-address,begin", find_word_boundary_address__begin
       ;; (* [address, length] -- address or -1 *)
       xx dup, zero?, _false?branch, 5
       xx   drop2
       xx   _literal, -1
       xx   Exit
       xx tail_and_head_of_string
       xx _literal, ASCII_space, greater_than?, _false?branch, 4
       xx   drop
       xx   sub1
       xx   Exit
       xx find_word_boundary_address__begin
       xx Exit
    defWordEnd find_word_boundary_address__begin

    ;; end will always success
    ;; so be careful when use it to save and fetch from string
    ;; ><><>< 也许我应该给每个 string 都加的 0 做结尾 这样也许会好一些
    defWord "find-word-boundary-address,end", find_word_boundary_address__end
       ;; (* [address, length] -- address or -1 *)
       xx dup, zero?, _false?branch, 3
       xx   drop
       xx   Exit
       ;; 对第一个做特殊处理 以保证 不再 word 内时 也能有效
       xx tail_and_head_of_string
       xx _literal, ASCII_space
       xx less_or_equal?, _false?branch, (.dup-$)/Cell_width
       xx   dup2, find_word_boundary_address__begin
       xx   dup, _literal, -1, equal?, _false?branch, 6
       xx     drop, drop2
       xx     _literal, -1
       xx     Exit
       xx   xxtuckx
       xx   xswapxx
       xx   subtraction, subtraction
       .dup:
       xx dup, zero?, _false?branch, 3
       xx   drop
       xx   Exit
       xx tail_and_head_of_string
       xx _literal, ASCII_space, less_or_equal?, _false?branch, 4
       xx   drop
       xx   sub1
       xx   Exit
       xx _branch, (.dup-$)/Cell_width
       xx Exit
    defWordEnd find_word_boundary_address__end


    defWord "find-word-boundary-index,begin", find_word_boundary_index__begin
       ;; (* [address, length] -- index or -1 *)
       ;; (* index start from Zero *)
       xx over
       xx swap
       xx find_word_boundary_address__begin
       xx dup, _literal, -1, equal?, _false?branch, 4
       xx   swap, drop
       xx   Exit
       xx swap, subtraction
       xx Exit
    defWordEnd find_word_boundary_index__begin

    defWord "find-word-boundary-index,end", find_word_boundary_index__end
       ;; (* [address, length] -- index or -1 *)
       ;; (* index start from Zero *)
       xx over
       xx swap
       xx find_word_boundary_address__end
       xx dup, _literal, -1, equal?, _false?branch, 4
       xx   swap, drop
       xx   Exit
       xx swap, subtraction
       xx Exit
    defWordEnd find_word_boundary_index__end



    ;; test:
    ;; :" k" find-word-boundary-index,begin . (* 0 *) cr
    ;; :" kkk" find-word-boundary-index,begin . (* 0 *) cr
    ;; :"  kkk" find-word-boundary-index,begin . (* 1 *) cr
    ;;
    ;; :" k" find-word-boundary-index,end . (* 1 *) cr
    ;; :" kkk" find-word-boundary-index,end . (* 3 *) cr
    ;; :"  kkk" find-word-boundary-index,end . (* 4 *) cr
    ;; :"   kkk" find-word-boundary-index,end . (* 5 *) cr
    #+end_src
*** tail-and-head-of-word-string
    1. word-string is string of word, NOT word as string
    2. >< I should add a recursive-definition of this datastructure
    #+begin_src fasm :tangle threaded-code.inc
    ;; this helper function :
    ;; 0. when meet zero-length string always reture True
    defWord "string-full-of-blank?", string_full_of_blank?
       ;; (* string[address, length] -- True or False *)
       xx dup, zero?, _false?branch, 4
       xx   drop2
       xx   True
       xx   Exit
       xx tail_and_head_of_string
       xx _literal, ASCII_space, less_or_equal?, _false?branch, 3
       xx   string_full_of_blank?
       xx   Exit
       xx drop2
       xx False
       xx Exit
    defWordEnd string_full_of_blank?

    ;; the following 3 functions can not apply on string-full-of-blank
    ;; before call them
    ;; one should make sure the argument is not string-full-of-blank

    defWord "head-of-word-string", head_of_word_string
       ;; (* word-string[address, length] -- word[address, length] *)
       xx dup2, find_word_boundary_address__begin
       ;; ><><>< need error check here in the future
       ;; 也就是 先假设上面的函数 返回正确的 address
       xx xxswapx
       xx find_word_boundary_address__end
       xx over, subtraction
       xx Exit
    defWordEnd head_of_word_string

    defWord "tail-of-word-string", tail_of_word_string
       ;; (* word-string[address, length] -- word-string[new address, length - n] *)
       xx dup2, find_word_boundary_index__end
       ;; ><><>< need error check here in the future
       ;; 也就是 先假设上面的函数 返回正确的 address
       xx tuck
       xx subtraction
       xx xxswapx
       xx addition
       xx swap
       xx Exit
    defWordEnd tail_of_word_string

    defWord "tail-and-head-of-word-string", tail_and_head_of_word_string
       ;; (* word-string[address, length] --
       ;;    word-string[new address, length - n], word[address, length] *)
       xx dup2
       xx tail_of_word_string
       xx xxswapxx
       xx head_of_word_string
       xx Exit
    defWordEnd tail_and_head_of_word_string
    #+end_src
** the basic lexicographer
*** append-word-description-to-here
    #+begin_src fasm :tangle threaded-code.inc
    defWord "append-number-to-here", append_number_to_here
       ;; (* a 64 bits number -- *)
       ;; reset "Here", which points next free memory
       xx Here, fetch
       xx save
       xx Here, fetch
       xx _literal, Cell_width, addition
       xx Here, save
       xx Exit
    defWordEnd append_number_to_here

    ;; note that:
    ;; a string in stack is string[address, length]
    ;; a string in memory is ||  1 : length  ||  n : string  ||  1 : 0  ||
    defWord "append-string-to-here", append_string_to_here
       ;; (* string[address, length] -- *)
       ;; for update Here
       xx dup, push_lambda_stack
       xx   dup, append_number_to_here
       xx   Here, fetch, swap, copy_byte_string
       ;; update Here
       xx pop_lambda_stack
       xx Here, fetch, addition
       xx _literal, 0, over, save_byte
       xx add1
       xx Here, save
       xx Exit
    defWordEnd append_string_to_here


    defWord "string-denote-key-word?", string_denote_key_word?
       ;; (* string[address, length] -- True or False *)
       xx find, word_link_to_word_type
       xx _literal, 111b, bitwise_and
       xx _literal, 1, equal?, _false?branch, 3
       xx   True
       xx   Exit
       xx False
       xx Exit
    defWordEnd string_denote_key_word?


    defWord "help:append-word-description-to-here,number", help__append_word_description_to_here__number
       ;; (* string[address, length] -- *)
       ;; reading-error reported by ``number'' is not handled
       xx _literal, _literal, append_number_to_here
       xx string_to_integer__with_error, drop, append_number_to_here
       xx Exit
    defWordEnd help__append_word_description_to_here__number

    ;; error handling when not found is after debuger
    defWord "help:append-word-description-to-here,word", help__append_word_description_to_here__word
       ;; (* string[address, length] -- *)
       xx find, word_link_to_word_explainer, append_number_to_here
       xx Exit
    defWordEnd help__append_word_description_to_here__word

    defWord "help:append-word-description-to-here,key-word", help__append_word_description_to_here__key_word
       ;; (* word-string[address, length], string[address, length] -- word-string[address, length] *)
       xx find, word_link_to_word_explainer, execute
       xx Exit
    defWordEnd help__append_word_description_to_here__key_word


    defWord "append-word-description-to-here", append_word_description_to_here
       ;; (* word-string[address, length] -- *)
       xx dup2, string_full_of_blank?, _false?branch, 3
       xx   drop2
       xx   Exit
       xx tail_and_head_of_word_string
       xx dup2, string_denote_integer?, _false?branch, 4
       xx   help__append_word_description_to_here__number
       xx   append_word_description_to_here
       xx   Exit
       xx dup2, string_denote_key_word?, _false?branch, 4
       xx   help__append_word_description_to_here__key_word
       xx   append_word_description_to_here
       xx   Exit
       ;; else
       xx   help__append_word_description_to_here__word
       xx   append_word_description_to_here
       xx   Exit
    defWordEnd append_word_description_to_here
    #+end_src
*** define-function
    #+begin_src fasm :tangle threaded-code.inc
    defWord "create-word-header", create_word_header ;; by string
       ;; (* string[address, length] -- word[address of link] *)
       ;; for address-of-name-string-header
       xx Here, fetch, push_lambda_stack
       xx   append_string_to_here
       xx   Here, fetch, append_number_to_here ;; (* identification *)
       xx   Here, fetch ;; (* leave the word[link] as return-value *)
       xx   _literal, 0, append_number_to_here ;; (* link *)
       xx   _literal, 0, append_number_to_here ;; (* type *)
       ;; address-of-name-string-header
       xx pop_lambda_stack, append_number_to_here
       xx Exit
    defWordEnd create_word_header

    defWord "create-word-header-for-function", create_word_header_for_function ;; by string
       ;; (* SizeOfFunctionBody *) is new
       ;; (* string[address, length] -- word[address of link] *)
       ;; for address-of-name-string-header
       xx Here, fetch, push_lambda_stack
       xx   append_string_to_here
       xx   _literal, 0, append_number_to_here ;; (* SizeOfFunctionBody *)
       xx   Here, fetch, append_number_to_here ;; (* identification *)
       xx   Here, fetch ;; (* leave the word[link] as return-value *)
       xx   _literal, 0, append_number_to_here ;; (* link *)
       xx   _literal, 0, append_number_to_here ;; (* type *)
       xx pop_lambda_stack, append_number_to_here ;; address-of-name-string-header
       xx Exit
    defWordEnd create_word_header_for_function

    defWord "add-new-word-to-dictionary", add_new_word_to_dictionary
       ;; reset FirstWordInDictionary to point to the newly defined word
       ;; (* word[address of link] -- *)
       xx dup
       xx FirstWordInDictionary, fetch
       xx swap
       xx save
       xx FirstWordInDictionary, save
       xx Exit
    defWordEnd add_new_word_to_dictionary

    defWord "set-size-of-function-body", set_size_of_function_body
       ;; (* words-string[address, the number of words], word[address of link] --
       ;;    words-string[address, the number of words], word[address of link] *)
       xx dup
       xx _literal, Cell_width, subtraction
       xx _literal, Cell_width, subtraction
       xx xoverxx
       xx swap
       xx save
       xx Exit
    defWordEnd set_size_of_function_body

    ;; 当在函数定义内引用自身的时候
    ;; 总会形成递归调用
    ;; 如果字典中已经 有要定义的函数了 也不会去找它
    ;; 唯一不 使得这种特性变得不理想的情形是:
    ;; 你在重新定义一个词的时候 需要调用旧的词本身
    ;; 这种情况非常少 并且出现的时候也很容易解决
    defWord "define-function", define_function
       ;; (* words-string[address, the number of words] -- *)
       ;;  to create a new word
       ;;  is to use some words to describe the new word,
       ;;  and let an explainer to explain the description of the new word.
       ;;  to define a new word
       ;;  is to add the new created word to the dictionary.
       xx tail_and_head_of_word_string
       xx create_word_header_for_function
       xx set_size_of_function_body
       xx add_new_word_to_dictionary
       xx _Function_body_explainer, append_number_to_here
       xx append_word_description_to_here
       xx Exit
    defWordEnd define_function
    #+end_src
* --------------------------------------------------
* memory allocation
** Pair-constructions-array
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   ;;   (unit : byte)
   ;; ========================
   ;;   ||  1 : color     ||
   ;; ------------------------
   ;;   ||  8 : type tag  ||
   ;;   ||  8 : value     ||
   ;; ------------------------
   ;;   ||  8 : type tag  ||
   ;;   ||  8 : value     ||
   ;; ========================
   hereUnInitializedData
   Clr_bytes_size = 1
   Car_bytes_size = 16
   Cdr_bytes_size = 16
   Cons_bytes_size = Clr_bytes_size + Car_bytes_size + Cdr_bytes_size
   Number_of_pair_constructions = 100 * 1024

           preserve Clr_bytes_size
   In_front_of_the_first_pair_construction labeling
           preserve (Car_bytes_size + Cdr_bytes_size)

           preserve Clr_bytes_size
   First_pair_construction labeling
           preserve (Car_bytes_size + Cdr_bytes_size)

           ;; ==========================
           preserve ((Number_of_pair_constructions - 2) * Cons_bytes_size)
           ;; ==========================

           preserve Clr_bytes_size
   Last_pair_construction labeling
           preserve (Car_bytes_size + Cdr_bytes_size)

   defConst "Clr-bytes-size"  , Clr_bytes_size  , _Clr_bytes_size
   defConst "Car-bytes-size"  , Car_bytes_size  , _Car_bytes_size
   defConst "Cdr-bytes-size"  , Cdr_bytes_size  , _Cdr_bytes_size
   defConst "Cons-bytes-size" , Cons_bytes_size , _Cons_bytes_size

   defConst "Number-of-pair-constructions", Number_of_pair_constructions, _Number_of_pair_constructions

   defConst "In-front-of-the-first-pair-construction", In_front_of_the_first_pair_construction, _In_front_of_the_first_pair_construction
   defConst "First-pair-construction", First_pair_construction, _First_pair_construction
   defConst "Last-pair-construction",  Last_pair_construction,  _Last_pair_construction

   defVar "Current-free-pair-construction", First_pair_construction, Current_free_pair_construction
    #+end_src
** Hash-Table-For-Symbol
   using linear probing
   so, the load factor must be lower then 0.5
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   ;; a Symbol_entry (unit : byte)
   ;; ===========================
   ;;  ||   8 : Symbol_value   ||
   ;; ---------------------------
   ;;  ||   1 : Symbol_length  ||
   ;; ---------------------------
   ;;  || 56+ : Symbol_string  ||
   ;; ===========================

   Symbol_length_bytes_size = 1
   Symbol_value_bytes_size  = 8
   Symbol_string_bytes_size = 56+0
   Symbol_max_length       = 56
   Symbol_entry_bytes_size = Symbol_value_bytes_size + Symbol_length_bytes_size + Symbol_string_bytes_size
   ;; Number_of_symbol_entrys = 1000003
   ;; Number_of_symbol_entrys = 1000033
   ;; Number_of_symbol_entrys = 1000333
   ;; Number_of_symbol_entrys = 100003
   Number_of_symbol_entrys = 100333
   ;; Number_of_symbol_entrys = 997
   ;; Number_of_symbol_entrys = 499
   ;; Number_of_symbol_entrys = 230 ;; for a special test

   First_symbol_entry labeling
           preserve Symbol_entry_bytes_size

           ;; ========================
           preserve ((Number_of_symbol_entrys - 2) * Symbol_entry_bytes_size)
           ;; ========================

   Last_symbol_entry labeling
           preserve Symbol_entry_bytes_size

   defConst "Number-of-symbol-entrys",  Number_of_symbol_entrys,  _Number_of_symbol_entrys
   defConst "Symbol-value-bytes-size",  Symbol_value_bytes_size,  _Symbol_value_bytes_size
   defConst "Symbol-length-bytes-size", Symbol_length_bytes_size, _Symbol_length_bytes_size
   defConst "Symbol-string-bytes-size", Symbol_string_bytes_size, _Symbol_string_bytes_size
   defConst "Symbol-max-length",        Symbol_max_length,        _Symbol_max_length
   defConst "Symbol-entry-bytes-size",  Symbol_entry_bytes_size,  _Symbol_entry_bytes_size

   defConst "First-symbol-entry", First_symbol_entry, _First_symbol_entry
   defConst "Last-symbol-entry",  Last_symbol_entry,  _Last_symbol_entry
   #+end_src
** two String_heap s
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   Size_of_string_heap = 5*1024*1024

   String_heap_1 labeling
           preserve Size_of_string_heap

   String_heap_2 labeling
           preserve Size_of_string_heap


   defConst "Size-of-string-heap", Size_of_string_heap, _Size_of_string_heap

   defConst "String-heap-1", String_heap_1, _String_heap_1
   defConst "String-heap-2", String_heap_2, _String_heap_2
   #+end_src
** Buffer-for-load-file
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   Size_of_buffer_for_load_file = 4*1024*1024

   Buffer_for_load_file labeling
                preserve Size_of_buffer_for_load_file

   defConst "Size-of-buffer-for-load-file", Size_of_buffer_for_load_file, _Size_of_buffer_for_load_file

   defConst "Buffer-for-load-file", Buffer_for_load_file, _Buffer_for_load_file

   #+end_src
** Data_section
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   Size_of_data_section = 4*1024*1024

   Data_section labeling
                preserve Size_of_data_section

   defConst "Data-section", Data_section, _Data_section
   defConst "Size-of-data-section", Size_of_data_section, _Size_of_data_section

   defVar "Current-data-section", Data_section, Current_data_section
   #+end_src
** ------------------------------------------
** Stacks
   1. after push the first value into ArgumentStack
      Argument_stack_pointer will point to the address of this value
   2. before push the first value into ArgumentStack
      Argument_stack_pointer point to StackTop
      and StackTop will never be used
   4. beware to understand how ``StackBottom'' and ``StackTop'' work
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData
   ;; ReturnStack
   Size_of_return_stack = 100*1024*8

   Return_stack_bottom labeling
           preserve Size_of_return_stack
   Return_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; ArgumentStack
   Size_of_argument_stack = 100*1024*8

   Argument_stack_bottom labeling
           preserve Size_of_argument_stack
   Argument_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; GreyPairStack
   Size_of_grey_pair_stack = 100*1024*8

   Grey_pair_stack_bottom labeling
           preserve Size_of_grey_pair_stack
   Grey_pair_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; LambdaStack
   Size_of_lambda_stack = 100*1024*8

   Lambda_stack_bottom labeling
           preserve Size_of_lambda_stack
   Lambda_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; StackForEvalString
   Size_of_stack_for_eval_string = 1024*8

   Stack_for_eval_string_bottom labeling
           preserve Size_of_stack_for_eval_string
   Stack_for_eval_string_top labeling
           preserve 100*8


   defConst "Return-stack-top",    Return_stack_top,    _Return_stack_top
   defConst "Return-stack-bottom", Return_stack_bottom, _Return_stack_bottom

   defConst "Argument-stack-top",    Argument_stack_top,    _Argument_stack_top
   defConst "Argument-stack-bottom", Argument_stack_bottom, _Argument_stack_bottom

   defConst "Lambda-stack-top",    Lambda_stack_top,    _Lambda_stack_top
   defConst "Lambda-stack-bottom", Lambda_stack_bottom, _Lambda_stack_bottom

   defConst "Stack-for-eval-string-top",    Stack_for_eval_string_top,    _Stack_for_eval_string_top
   defConst "Stack-for-eval-string-bottom", Stack_for_eval_string_bottom, _Stack_for_eval_string_bottom
   #+end_src
* ==================================================
