#+TITLE: macro and threaded code of cicada extensible virtual machine
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* macro
** ASCII
   #+begin_src fasm :tangle macro.inc
   ASCII_backspace = 8
   ASCII_tab       = 9
   ASCII_linefeed  = 10
   ASCII_newline   = 10
   ASCII_esc       = 27
   ASCII_escape    = 27
   ASCII_space     = 32
   ASCII_delete    = 127
   #+end_src
** registers & push & pop
   #+begin_src fasm :tangle macro.inc
   ;; 1. when "push", a stack-pointer moves to lower address
   ;; 2. under the a stack-pointer,
   ;;    there always stores the value of the-top-of-the-stack


   ;; if you want to extend cicada in assembly,
   ;; the following registers must not be used

   ;; =================================
   define Return_stack_pointer    r15
   define Argument_stack_pointer  r14
   define Grey_pair_stack_pointer r13
   ;; =================================

   ;; the following is just for the clarity of semantic
   ;; for when ever you jump to a explainer
   ;; this "rax" will be used as an argument of the explainer
   define Explainer_pointer rax


   macro push_return_stack Register {
          sub Return_stack_pointer, Cell_width
          mov [Return_stack_pointer], Register
          }
   macro pop_return_stack Register {
          mov Register, [Return_stack_pointer]
          add Return_stack_pointer, Cell_width
          }

   macro push_argument_stack Register {
          sub Argument_stack_pointer, Cell_width
          mov [Argument_stack_pointer], Register
          }
   macro pop_argument_stack Register {
          mov Register, [Argument_stack_pointer]
          add Argument_stack_pointer, Cell_width
          }
   #+end_src
** word-types & next
*** note
    1. notations :
       1) "the dictionary" as a datastructure is a single-linked-list
       2) an entry in "the dictionary" is "a word"
       3) "a word" as a datastructure looks like the following :
          (unit : Cell_width)
          | 1 | name-string-header            |
          | m | name-string                   |
          | 1 | SizeOfFunctionBody            |
          | 1 | identification                |
          | 1 | link                          |
          | 1 | type                          |
          | 1 | address-of-name-string-header |
          | 1 | address-of-explainer          |
          | n | body                          |
       4) so, I adopt two notations to represent "a word" :
          word[link]      == address in a word where the link is stored
          word[explainer] == address in a word where the address-of-explainer is stored
          word[explainer] == address in a word before the function-body
          word[explainer] == address in a word as the head of a function-body
    2. this "next" do tail-call-optimization
    3. every word-type needs a explainer (or elucidator)
    4. a explainer may explain more then one word-types
    5. note that, for now there are only two ways to jump to a explainer
       1) next
       2) execute
    6. not matter what way you use to set :
       [Explainer_pointer] == address-of-explainer (of a word you want to jump to)
       then :
       jmp qword[Explainer_pointer]
       it will works just well
    7. "next" will "pop_return_stack"
       1) on the other hand,
          explain_verb is the only explainer
          who "push_return_stack"
       2) so, it is these two functions, "next" and "explain_verb"
          which handle the nested function calls
*** implementation
    #+begin_src fasm :tangle macro.inc
    macro next {
       ;; 1. if NOT at the end of the function body
       ;;    (* Return-stack::
       ;;         [address of explainer] -- [address of explainer] + Cell_width *)
       ;; 2. if at the end of the function body
       ;;    (* Return-stack::
       ;;         [address of explainer] -- *)
       ;; and jump to the explainer of the [address of explainer]
    local at_the_end_of_function_body
       pop_return_stack rbx
       mov Explainer_pointer, qword[rbx]
       add rbx, Cell_width
       cmp dword[rbx], Exit
       je at_the_end_of_function_body
       cmp dword[rbx], 已矣
       je at_the_end_of_function_body
       push_return_stack rbx
    at_the_end_of_function_body:
       jmp qword[Explainer_pointer]
       }

    ;; initial Link to point to NULL
    Link = 0

    macro def_verb WordString, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    SizeOfFunctionBodyOf#Word:
            xx (EndOfFunctionBodyOf#Word - Word)/Cell_width - 1
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx explain_verb
    ;;--------------------------------------
            ;; here follows a list of word[explainer]
            }
    macro def_verb_end Word {
    EndOfFunctionBodyOf#Word:
    }

    macro def_key_word KeyWordString, KeyWord {
    hereInitializedData
    ;;--------------------------------------
    KeyWordStringHeaderOf#KeyWord:
            xx (EndOfKeyWordStringOf#KeyWord - KeyWordStringOf#KeyWord)
    ;;--------------------------------------
    KeyWordStringOf#KeyWord:
            db KeyWordString
    EndOfKeyWordStringOf#KeyWord:
    ;;--------------------------------------
    SizeOfFunctionBodyOf#KeyWord:
            xx (EndOfFunctionBodyOf#KeyWord - KeyWord)/Cell_width - 1
    ;;--------------------------------------
    IdentificationOf#KeyWord:
            xx IdentificationOf#KeyWord
    ;;--------------------------------------
    LinkOf#KeyWord:
            xx Link
            Link = LinkOf#KeyWord
    ;;--------------------------------------
    TypeOf#KeyWord:
            xx 1
    ;;--------------------------------------
    AddressOfKeyWordStringHeaderOf#KeyWord:
            xx KeyWordStringHeaderOf#KeyWord
    ;;======================================
    KeyWord:   xx explain_verb
    ;;--------------------------------------
            ;; here follows a list of word[explainer]
            }
    macro def_key_word_end KeyWord {
    EndOfFunctionBodyOf#KeyWord:
    }

    ;; assembly code have no explainer
    macro def_assembly_code WordString, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx AssemblerCodeOf#Word
    ;;--------------------------------------
    AssemblerCodeOf#Word:
            ;; here follows the assembly code
            }


    macro def_noun WordString, Word {
    hereInitializedData
    ;;--------------------------------------
    WordStringHeaderOf#Word:
            xx (EndOfWordStringOf#Word - WordStringOf#Word)
    ;;--------------------------------------
    WordStringOf#Word:
            db WordString
    EndOfWordStringOf#Word:
    ;;--------------------------------------
    SizeOfNounBodyOf#Word:
            xx (EndOfNounBodyOf#Word - Word)/Cell_width - 1
    ;;--------------------------------------
    IdentificationOf#Word:
            xx IdentificationOf#Word
    ;;--------------------------------------
    LinkOf#Word:
            xx Link
            Link = LinkOf#Word
    ;;--------------------------------------
    TypeOf#Word:
            xx 0
    ;;--------------------------------------
    AddressOfWordStringHeaderOf#Word:
            xx WordStringHeaderOf#Word
    ;;======================================
    Word:   xx explain_noun
    ;;--------------------------------------
            ;; here follows a list of value
            }

    macro def_noun_end Word {
    EndOfNounBodyOf#Word:
    }

    ;; in stack:
    ;;   string[address, length]
    ;; in memory:
    ;;   ||  1 : length  ||
    ;;   ||  n : string  ||
    macro def_string WordString, ConstStringValue, Word {
    hereInitializedData

    def_noun WordString, Word
       xx ConstStringValueOf#Word
       xx (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
    def_noun_end Word

    ;;--------------------------------------
    ConstStringValueOf#Word:
            db ConstStringValue
    EndOfConstStringValueOf#Word:
            db 0
            }
    #+end_src
* ==================================================
* noun
** important nouns
   #+begin_src fasm :tangle threaded-code.inc
   def_noun "Here", Here
      xx 0
   def_noun_end Here


   def_noun "First-word-in-dictionary" , First_word_in_dictionary
      xx LinkOfLatest_word_in_assembly
   def_noun_end  First_word_in_dictionary

   ;; note that:
   ;;   the above is LinkOfTheLatestWordInThisFile
   ;;   NOT TheLatestWordInThisFile


   def_noun "Cell-width", _Cell_width
      xx Cell_width
   def_noun_end _Cell_width
   #+end_src
** true and false
   #+begin_src fasm :tangle threaded-code.inc
   def_noun "False", False
      xx 0
   def_noun_end False

   def_noun "True", True
      xx 1
   def_noun_end True
   #+end_src
* verb
** fixnum
   #+begin_src fasm :tangle threaded-code.inc
   def_assembly_code "add1", add1
      ;; (* n -- n+1 *)
      inc qword[Argument_stack_pointer]
      next

   def_assembly_code "add2", add2
      ;; (* n -- n+1 *)
      add qword[Argument_stack_pointer], 2
      next

   def_assembly_code "add3", add3
      ;; (* n -- n+1 *)
      add qword[Argument_stack_pointer], 3
      next

   def_assembly_code "add4", add4
      ;; (* n -- n+4 *)
      add qword[Argument_stack_pointer], 4
      next

   def_assembly_code "add8", add8
      ;; (* n -- n+8 *)
      add qword[Argument_stack_pointer], 8
      next


   def_assembly_code "sub1", sub1
      ;; (* n -- n-1 *)
      dec qword[Argument_stack_pointer]
      next

   def_assembly_code "sub2", sub2
      ;; (* n -- n-1 *)
      sub qword[Argument_stack_pointer], 2
      next

   def_assembly_code "sub3", sub3
      ;; (* n -- n-1 *)
      sub qword[Argument_stack_pointer], 3
      next

   def_assembly_code "sub4", sub4
      ;; (* n -- n-4 *)
      sub qword[Argument_stack_pointer], 4
      next

   def_assembly_code "sub8", sub8
      ;; (* n -- n-8 *)
      sub qword[Argument_stack_pointer], 8
      next


   def_assembly_code "add", addition
      ;; (* a b -- a+b *)
      pop_argument_stack rax
      add qword[Argument_stack_pointer], rax
      next

   def_verb "+", _add
      xx addition
      xx Exit
   def_verb_end _add


   def_assembly_code "sub", subtraction
      ;; (* a b -- a-b *)
      pop_argument_stack rax
      sub qword[Argument_stack_pointer], rax
      next

   def_verb "-", _sub
      xx subtraction
      xx Exit
   def_verb_end _sub


   def_assembly_code "mul", multiple
      ;; (* a b -- a*b *)
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      imul rbx, rax
      ;; imul will ignore overflow
      ;; when there are two registers as arg
      ;; imul will save the result into the first register
      push_argument_stack rbx
      next

   def_verb "*", _mul
      xx multiple
      xx Exit
   def_verb_end _mul



   def_assembly_code "moddiv", moddiv
      ;; (* a, b -- a mod b, quotient *)
      ;; (* dividend, divisor -- remainder, quotient *)
      ;; the arg of idiv is divisor
      ;; the lower half of dividend is taken from rax
      ;; the upper half of dividend is taken from rdx
      xor  rdx, rdx   ;; high-part of dividend is not used
      pop_argument_stack  rbx ;; 2ed arg
      pop_argument_stack  rax ;; 1st arg
      idiv rbx
      ;; the remainder is stored in rdx
      ;; the quotient  is stored in rax
      push_argument_stack rdx ;; remainder
      push_argument_stack rax ;; quotient
      next


   def_verb "divmod", divmod
      ;; (* a, b -- quotient, a mod b *)
      xx moddiv, swap
      xx Exit
   def_verb_end divmod


   def_verb "div", division
      ;; (* a, b -- quotient *)
      xx divmod, drop
      xx Exit
   def_verb_end division

   def_verb "/", _div
      ;; (* a, b -- quotient *)
      xx division
      xx Exit
   def_verb_end _div


   def_verb "mod", module
      ;; (* a, b -- a mod b *)
      xx moddiv, drop
      xx Exit
   def_verb_end module


   def_verb "negate", negate
      ;; (* n --  -n *)
      xx _literal, 0
      xx swap, subtraction
      xx Exit
   def_verb_end negate

   def_verb "help:power", help_power
      ;; (* a, m, n -- a^n *)
      xx dup, zero?, _false?branch, 5
      xx   drop, swap, drop
      xx   Exit
      xx sub1
      xx swap
      xx   xoverxx, multiple
      xx swap
      xx help_power
      xx Exit
   def_verb_end help_power

   def_verb "power", power
      ;; n must be naturl number for now
      ;; (* a, n -- a^n *)
      xx _literal, 1
      xx swap
      xx help_power
      xx Exit
   def_verb_end power
   #+end_src
** memory
   #+begin_src fasm :tangle threaded-code.inc
   ;; "save" and "fetch" default to a Cell_width (== 8 bytes)
   ;; the rule of "fetch2" and so on are:
   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ||  1 : value-2  ||
   ;;     ||  1 : value-3  ||
   ;;     ...
   ;;   on stack:
   ;;     (* value-1, value-2, value-3, ... *)
   ;; of course we have:
   ;;   fetch2 : memory=copy=>stack
   ;;   save2  : stack->memory

   def_assembly_code "save", save
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov qword[rbx], rax
      next

   def_assembly_code "save-byte", save_byte
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov byte[rbx], al
      next

   def_assembly_code "save-two-bytes", save_two_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov word [rbx], ax
      next

   def_assembly_code "save-four-bytes", save_four_bytes
      ;; ( value, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      mov dword [rbx], eax
      next

   def_assembly_code "n-save", n_save
      ;; (* value-n, ..., value-1, address, n -- *)
      pop_argument_stack rcx
      pop_argument_stack rdx
      mov rax, Cell_width
      imul rax, rcx
      add rdx, rax
      ;; for address is based on 0
      ;; but n is based on 1
      sub rdx, Cell_width
   .loop:
      pop_argument_stack rax
      mov qword [rdx], rax
      sub rdx, Cell_width
      loop .loop
      next

   def_verb "save2", save2
      ;; (* value-2, value-1, address -- *)
      xx _literal, 2
      xx n_save
      xx Exit
   def_verb_end save2

   def_assembly_code "n-save-byte", n_save_byte
      ;; (* value-n, ..., value-1, address, n -- *)
      pop_argument_stack rcx
      pop_argument_stack rdx
      add rdx, rcx
      dec rdx
   .loop:
      pop_argument_stack rax
      mov byte [rdx], al
      dec rdx
      loop .loop
      next




   def_assembly_code "fetch", fetch
      ;; ( address -- value )
      pop_argument_stack  rbx
      mov rax, qword[rbx]
      push_argument_stack rax
      next

   def_assembly_code "fetch-byte", fetch_byte
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte[rbx]
      push_argument_stack rax
      next

   def_assembly_code "fetch-two-bytes", fetch_two_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov ax, word[rbx]
      push_argument_stack rax
      next

   def_assembly_code "fetch-four-bytes", fetch_four_bytes
      ;; ( address -- value )
      pop_argument_stack rbx
      xor rax, rax
      mov eax, dword[rbx]
      push_argument_stack rax
      next

   ;;   in memory:
   ;;     ||  1 : value-1  ||
   ;;     ...
   ;;     ||  1 : value-n  ||
   def_assembly_code "n-fetch", n_fetch
      ;; (* address, n -- value-1, ..., value-n *)
      pop_argument_stack  rcx
      pop_argument_stack  rdx
   .loop:
      mov rax, qword[rdx]
      push_argument_stack rax
      add rdx, Cell_width
      loop .loop
      next

   def_assembly_code "n-fetch-byte", n_fetch_byte
      ;; (* address, n -- byte-1, ..., byte-n *)
      pop_argument_stack  rcx
      pop_argument_stack  rdx
      xor rax, rax
   .loop:
      mov al, byte [rdx]
      push_argument_stack rax
      inc rdx
      loop .loop
      next

   def_verb "fetch2", fetch2
      ;; (* address -- value-1, value-2 *)
      xx _literal, 2
      xx n_fetch
      xx Exit
   def_verb_end fetch2




   def_assembly_code "add-save", add_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      add qword[rbx], rax
      next

   def_assembly_code "sub-save", sub_save
      ;; ( number to add, address -- )
      pop_argument_stack rbx
      pop_argument_stack rax
      sub qword[rbx], rax
      next



   def_assembly_code "copy-byte-string", copy_byte_string
      ;; ( source address, destination address, length -- )
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      rep movsb
      next
   #+end_src
** >< note about stack
   1. maybe design key-word
      to add better support to other stack
      not only Argument-stack
** Argument-stack
*** pointer
    #+begin_src fasm :tangle threaded-code.inc
    ;; to know why the following funny thing happens,
    ;; see the definition of the macro "push_argument_stack",

    ;;  macro push_argument_stack Register {
    ;;         sub Argument_stack_pointer, Cell_width
    ;;         mov [Argument_stack_pointer], Register
    ;;         }

    def_assembly_code "make-self-reference-value,in-argument-stack", make_self_reference_value__in_argument_stack
       ;; ( -- address )
       push_argument_stack Argument_stack_pointer
       next

    def_verb "fetch-argument-stack-pointer", fetch_argument_stack_pointer
       ;; ( -- address )
       xx make_self_reference_value__in_argument_stack
       xx _literal, Cell_width, addition
       xx Exit
    def_verb_end fetch_argument_stack_pointer

    def_assembly_code "reset-argument-stack-pointer", reset_argument_stack_pointer
       ;; ( address -- )
       pop_argument_stack Argument_stack_pointer
       next
    #+end_src
*** drop
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "drop", drop
       ;; (* a -- *)
       pop_argument_stack rax
       next

    def_assembly_code "n-drop", n_drop
       ;; (* value-n, ..., value-1, n -- *)
       pop_argument_stack rcx
    .loop:
       pop_argument_stack rax
       loop .loop
       next

    def_assembly_code "drop2", drop2
       ;; (* a b -- *)
       pop_argument_stack rax
       pop_argument_stack rax
       next
    #+end_src
*** dup
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "dup", dup
       ;; (* a -- a a *)
       mov  rax, [Argument_stack_pointer]
       push_argument_stack rax
       next

    def_assembly_code "n-dup", n_dup
       ;; (* value-n, ..., value-1, n --
       ;;    value-n, ..., value-1, value-n, ..., value-1 *)
       pop_argument_stack rcx
       imul rbx, rcx, Cell_width
       sub rbx, Cell_width
    .loop:
       mov  rax, [Argument_stack_pointer + rbx]
       push_argument_stack rax
       loop .loop
       next

    def_assembly_code "dup2", dup2
       ;; (* a b -- a b a b *)
       mov  rbx, [Argument_stack_pointer]
       mov  rax, [Argument_stack_pointer + Cell_width]
       push_argument_stack rax
       push_argument_stack rbx
       next
    #+end_src
*** over
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "over", over
       ;; (* a b -- a b | a *)
       mov  rax, [Argument_stack_pointer + Cell_width]
       push_argument_stack rax
       next

    def_assembly_code "x|over|xx", xoverxx
       ;; (* a | b c -- a | b c | a *)
       mov  rax, [Argument_stack_pointer + (2 * Cell_width)]
       push_argument_stack rax
       next

    def_assembly_code "xx|over|x", xxoverx
       ;; (* a b | c -- a b | c | a b *)
       mov  rax, [Argument_stack_pointer + (2 * Cell_width)]
       push_argument_stack rax
       mov  rax, [Argument_stack_pointer + (2 * Cell_width)] ;; not (1 * Cell_width)
       push_argument_stack rax
       next

    def_assembly_code "xx|over|xx", xxoverxx
       ;; (* a b | c d -- a b | c d | a b *)
       mov  rax, [Argument_stack_pointer + (3 * Cell_width)]
       push_argument_stack rax
       mov  rax, [Argument_stack_pointer + (3 * Cell_width)] ;; not (2 * Cell_width)
       push_argument_stack rax
       next

    def_assembly_code "x|over|xxx", xoverxxx
       ;; (* a | b c d -- a | b c d | a *)
       mov  rax, [Argument_stack_pointer + (3 * Cell_width)]
       push_argument_stack rax
       next

    def_assembly_code "xx|over|xxxx", xxoverxxxx
       ;; (* a b | c d e f -- a b | c d e f | a b *)
       mov  rax, [Argument_stack_pointer + (5 * Cell_width)]
       push_argument_stack rax
       mov  rax, [Argument_stack_pointer + (5 * Cell_width)] ;; not (4 * Cell_width)
       push_argument_stack rax
       next


    def_assembly_code "x-y-over", x_y_over
       ;; (* [x 个], [y 个], x, y -- [x 个], [y 个], [x 个] *)
       pop_argument_stack r9 ;; y
       pop_argument_stack r8 ;; x
       mov rcx, r8
       add r8, r9
       dec r8
       imul r8, Cell_width
       ;; rcx == x
       ;; r8 == (x+y-1)*Cell_width
       ;; r9 == y
       ;; 我懒得优化它
    .loop:
       mov  rax, [Argument_stack_pointer + r8]
       push_argument_stack rax
       loop .loop
       next
    #+end_src
*** tuck
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "tuck", tuck
       ;; (* a b -- b | a b *)
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rax
       push_argument_stack rbx
       next

    def_assembly_code "x|tuck|xx", xtuckxx
       ;; (* a | b c -- b c | a | b c *)
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next

    def_assembly_code "xx|tuck|x", xxtuckx
       ;; (* a b | c -- c | a b | c *)
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next

    def_assembly_code "xx|tuck|xx", xxtuckxx
       ;; (* a b | c d -- c d | a b | c d *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rcx
       push_argument_stack rdx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       next

    def_assembly_code "xxx|tuck|x", xxxtuckx
       ;; (* a b c | d -- d | a b c | d *)
       pop_argument_stack rdx
       pop_argument_stack rcx
       pop_argument_stack rbx
       pop_argument_stack rax
       push_argument_stack rdx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       push_argument_stack rdx
       next

    def_verb "x-y-tuck", x_y_tuck
       ;; (* [x 个], [y 个], x, y -- [y 个], [x 个], [y 个] *)
       xx dup2
       xx ready
       xx x_y_swap
       xx get_back, swap
       xx x_y_over
       xx Exit
    def_verb_end x_y_tuck
    #+end_src
*** swap
    #+begin_src fasm :tangle threaded-code.inc
        def_assembly_code "swap", swap
           ;; (* a b -- b a *)
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rax
           next

        def_assembly_code "x|swap|xx", xswapxx
           ;; (* a | b c -- b c | a *)
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rcx
           push_argument_stack rax
           next

        def_assembly_code "xx|swap|x", xxswapx
           ;; (* a b | c -- c | a b *)
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rcx
           push_argument_stack rax
           push_argument_stack rbx
           next

        def_assembly_code "x|swap|xxx", xswapxxx
           ;; (* a | b c d -- b c d | a *)
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rcx
           push_argument_stack rdx
           push_argument_stack rax
           next

        def_assembly_code "xxx|swap|x", xxxswapx
           ;; (* a b c | d -- d | a b c *)
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rdx
           push_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rcx
           next

        def_assembly_code "xx|swap|xx", xxswapxx
           ;; (* a b | c d -- c d | a b *)
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rcx
           push_argument_stack rdx
           push_argument_stack rax
           push_argument_stack rbx
           next


        def_assembly_code "x|swap|xxxx", xswapxxxx
           ;; (* a | b c d e -- b c d e | a *)
           pop_argument_stack r8 ;; e
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rcx
           push_argument_stack rdx
           push_argument_stack r8 ;; e
           push_argument_stack rax
           next

        def_assembly_code "xxxx|swap|x", xxxxswapx
           ;; (* a b c d | e --  e | a b c d *)
           pop_argument_stack r8 ;; e
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack r8 ;; e
           push_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rcx
           push_argument_stack rdx
           next


        def_assembly_code "xx|swap|xxxx", xxswapxxxx
           ;; (* a b | c d e f -- c d e f | a b *)
           pop_argument_stack r9 ;; f
           pop_argument_stack r8 ;; e
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack rcx
           push_argument_stack rdx
           push_argument_stack r8 ;; e
           push_argument_stack r9 ;; f
           push_argument_stack rax
           push_argument_stack rbx
           next

        def_assembly_code "xxxx|swap|xx", xxxxswapxx
           ;; (* a b c d | e f --  e f | a b c d *)
           pop_argument_stack r9 ;; f
           pop_argument_stack r8 ;; e
           pop_argument_stack rdx
           pop_argument_stack rcx
           pop_argument_stack rbx
           pop_argument_stack rax
           push_argument_stack r8 ;; e
           push_argument_stack r9 ;; f
           push_argument_stack rax
           push_argument_stack rbx
           push_argument_stack rcx
           push_argument_stack rdx
           next


        def_assembly_code "x-y-swap", x_y_swap
           ;; (* [x 个], [y 个], x, y -- [y 个], [x 个] *)
           pop_argument_stack r9 ;; y
           pop_argument_stack r8 ;; x

           mov rcx, r9
        .loop_y_push:
           pop_argument_stack rax
           push rax
           loop .loop_y_push

           mov rcx, r8
        .loop_x_push_return_stack:
           pop_argument_stack rax
           push_return_stack rax
           loop .loop_x_push_return_stack

           mov rcx, r9
        .loop_y_pop:
           pop rax
           push_argument_stack rax
           loop .loop_y_pop

           mov rcx, r8
        .loop_x_pop_return_stack:
           pop_return_stack rax
           push_argument_stack rax
           loop .loop_x_pop_return_stack

           next
    #+end_src
*** ohters
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "|123->321|", abc_to_cba
       pop_argument_stack rax
       pop_argument_stack rbx
       pop_argument_stack rcx
       push_argument_stack rax
       push_argument_stack rbx
       push_argument_stack rcx
       next
    #+end_src
** Return-stack
*** pointer
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "fetch-return-stack-pointer", fetch_return_stack_pointer
       ;; (* -- an address in the ReturnStack *)
       push_argument_stack Return_stack_pointer
       next

    def_assembly_code "reset-return-stack-pointer", reset_return_stack_pointer
       ;; (* an address in the ReturnStack -- *)
       pop_argument_stack Return_stack_pointer
       next
    #+end_src
*** push & pop
    #+begin_src fasm :tangle threaded-code.inc
    ;; in my implementation
    ;; the following two class classic Forth words
    ;; should be used carefully

    def_assembly_code "push-return-stack", _push_return_stack
       ;; (* address --> ReturnStack: address *)
       pop_argument_stack  rax
       push_return_stack rax
       next

    def_assembly_code "pop-return-stack", _pop_return_stack
       ;; (* ReturnStack: address --> address *)
       pop_return_stack  rax
       push_argument_stack rax
       next
    #+end_src
*** drop
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "drop-return-stack", drop_return_stack
       ;; (* -- *)
       add Return_stack_pointer, Cell_width
       next
    #+end_src
** Grey-pair-stack
*** pointer
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "empty-grey-pair-stack?", empty_grey_pair_stack?
       ;; (* -- True or False *)
       mov rax, Grey_pair_stack_top
       cmp Grey_pair_stack_pointer, rax
       ;; note that:
       ;; Grey_pair_stack_pointer >= Grey_pair_stack_top
       ;; means stack over flow
       setge al
       movzx rax, al
       push_argument_stack rax
       next
    #+end_src
*** push & pop
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "push-grey-pair-stack", push_grey_pair_stack
       ;; (* pair[address] --> GreyPairStack: pair[address] *)
       pop_argument_stack rax
       lea Grey_pair_stack_pointer, [Grey_pair_stack_pointer - Cell_width]
       mov [Grey_pair_stack_pointer], rax
       next

    def_assembly_code "pop-grey-pair-stack", pop_grey_pair_stack
       ;; (* GreyPairStack: pair[address] --> pair[address] *)
       mov rax, [Grey_pair_stack_pointer]
       lea Grey_pair_stack_pointer, [Grey_pair_stack_pointer + Cell_width]
       push_argument_stack rax
       next
    #+end_src
** Lambda-stack
*** pointer
    #+begin_src fasm :tangle threaded-code.inc
    ;; 1. not to much stack-processing is needed here
    ;; 2. LambdaStack can be used to save the faked-local-vars

    def_noun "Lambda-stack-pointer", Lambda_stack_pointer
       xx  Lambda_stack_top
    def_noun_end Lambda_stack_pointer
    #+end_src
*** push & pop
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "push-lambda-stack", push_lambda_stack
       ;; (* ArgumentStack::  value -->
       ;;    LambdaStack::    value *)
       xx _literal, Cell_width, _address, Lambda_stack_pointer, sub_save
       xx Lambda_stack_pointer, save
       xx Exit
    def_verb_end push_lambda_stack

    def_verb "pop-lambda-stack", pop_lambda_stack
       ;; (* LambdaStack::    value -->
       ;;    ArgumentStack::  value *)
       xx Lambda_stack_pointer, fetch
       xx _literal, Cell_width, _address, Lambda_stack_pointer, add_save
       xx Exit
    def_verb_end pop_lambda_stack
    #+end_src
*** ready & get-back
    #+begin_src fasm :tangle threaded-code.inc
    ;; 如果 ready 只是和 get-back 成对使用的话
    ;; 就没必要添加两个 swap 了
    ;; but we need more than that

    def_verb "ready", ready
       ;; (* ArgumentStack::  value-a, value-b -->
       ;;    LambdaStack::    value-a, value-b *)
       ;; (* beware of the order of the two values *)
       xx swap, push_lambda_stack, push_lambda_stack
       xx Exit
    def_verb_end ready

    def_verb "get-back", get_back
       ;; (* beware of the order of the two values *)
       ;; (* LambdaStack::    value-a, value-b -->
       ;;    ArgumentStack::  value-a, value-b *)
       xx pop_lambda_stack, pop_lambda_stack, swap
       xx Exit
    def_verb_end get_back
    #+end_src
*** shift
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "argument-stack-shift-to-lambda-stack", argument_stack_shift_to_lambda_stack
       ;; (* value-n, ..., value-1, n -- *)
       ;; (* Lambda-stack ::
       ;; (* value-1, ..., value-n, n -- *)
       xx _literal, 0, push_lambda_stack
       .dup:
       xx dup, zero?, _false?branch, (.sub1-$)/Cell_width
       xx   drop
       xx   Exit
       .sub1:
       xx sub1
       xx swap
       xx pop_lambda_stack, add1
       xx swap
       xx push_lambda_stack
       xx push_lambda_stack
       xx _branch, (.dup-$)/Cell_width
    def_verb_end argument_stack_shift_to_lambda_stack

    ;; def_verb "t", t
    ;;    xx _literal, 7
    ;;    xx _literal, 8
    ;;    xx _literal, 9
    ;;    xx _literal, 3
    ;;    xx argument_stack_shift_to_lambda_stack
    ;;    xx pop_lambda_stack, print_little_number ; 3
    ;;    xx pop_lambda_stack, print_little_number ; 7
    ;;    xx pop_lambda_stack, print_little_number ; 8
    ;;    xx pop_lambda_stack, print_little_number ; 9
    ;;    xx Exit
    ;; def_verb_end t
    #+end_src
** >< string
   #+begin_src fasm :tangle threaded-code.inc
   ;; return false when length == 0
   def_assembly_code "compare-string?", compare_string?
      ;; (* address of string-1, address of string-2, length -- True or False *)
      pop_argument_stack rcx
      pop_argument_stack rdi
      pop_argument_stack rsi
      repe cmpsb
      sete al
      movzx rax, al
      push_argument_stack rax
      next

   def_verb "equal-string?", equal_string?
      ;; (* string-1[address-1, length-1], string-2[address-2, length-2] -- True or False *)
      xx xoverxx, equal?, _false?branch, 4
      xx swap, compare_string?, Exit
      xx drop, drop, drop, False
      xx Exit
   def_verb_end equal_string?


   ;; ><><>< there are no proper error handling for the following two functions

   def_assembly_code "head-of-string", head_of_string
      ;; (* string[address, length] -- first char *)
      pop_argument_stack rcx
      pop_argument_stack rbx
      xor rax, rax
      mov al, byte [rbx]
      push_argument_stack rax
      next

   def_assembly_code "tail-of-string", tail_of_string
      ;; (* string[address, length] -- string[address + 1, length - 1] *)
      pop_argument_stack rcx
      pop_argument_stack rbx
      dec rcx
      inc rbx
      push_argument_stack rbx
      push_argument_stack rcx
      next

   def_verb "tail-and-head-of-string", tail_and_head_of_string
      ;; (* string[address, length] -- string[address + 1, length - 1], first char *)
      xx dup2, tail_of_string
      xx xxswapxx
      xx head_of_string
      xx Exit
   def_verb_end tail_and_head_of_string


   ;; this helper function :
   ;; 0. when meet zero-length string always reture True
   def_verb "string-full-of-blank?", string_full_of_blank?
      ;; (* string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 4
      xx   drop2
      xx   True
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, ASCII_space, less_or_equal?, _false?branch, 3
      xx   string_full_of_blank?
      xx   Exit
      xx drop2
      xx False
      xx Exit
   def_verb_end string_full_of_blank?
   #+end_src
** predicates
*** about true and false
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "true?", true?
       xx one?
       xx Exit
    def_verb_end true?

    def_verb "false?", false?
       xx zero?
       xx Exit
    def_verb_end false?
    #+end_src
*** about fixnum
    1. 0 as False
       1 as True
    2. there can not be bool-type in low-level forth-like-language
    4. "false?" is "zero?"
       "true?" is "one?"
    #+begin_src fasm :tangle threaded-code.inc
    def_assembly_code "==", equal?
       pop_argument_stack rbx
       pop_argument_stack rax
       cmp   rbx, rax
       sete  al
       movzx rax, al
       push_argument_stack rax
       next

    def_assembly_code "=/=", not_equal?
       pop_argument_stack rbx
       pop_argument_stack rax
       cmp   rbx, rax
       setne al
       movzx rax, al
       push_argument_stack rax
       next

    def_assembly_code "<", less_than?
       pop_argument_stack rbx
       pop_argument_stack rax
       cmp   rax, rbx
       setl  al
       movzx rax, al
       push_argument_stack rax
       next

    def_assembly_code ">", greater_than?
       pop_argument_stack   rbx
       pop_argument_stack   rax
       cmp   rax, rbx
       setg  al
       movzx rax, al
       push_argument_stack  rax
       next

    def_assembly_code "<=", less_or_equal?
       pop_argument_stack rbx
       pop_argument_stack rax
       cmp   rax, rbx
       setle al
       movzx rax, al
       push_argument_stack rax
       next

    def_assembly_code ">=", greater_or_equal?
       pop_argument_stack rbx
       pop_argument_stack rax
       cmp   rax, rbx
       setge al
       movzx rax, al
       push_argument_stack rax
       next


    def_assembly_code "zero?", zero?
       pop_argument_stack rax
       test  rax,rax
       setz  al
       movzx rax, al
       push_argument_stack rax
       next

    def_verb "one?", one?
       xx _literal, 1, equal?
       xx Exit
    def_verb_end one?
    #+end_src
*** about char
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "char-denote-number?", char_denote_number?
       ;; (* char -- True or False *)
       xx dup
       xx _literal, '0', less_than?, _false?branch, 4
       xx   drop, False
       xx   Exit
       xx _literal, '9', greater_than?, _false?branch, 3
       xx   False
       xx   Exit
       xx True
       xx Exit
    def_verb_end char_denote_number?
    #+end_src
** bitwise operations
   #+begin_src fasm :tangle threaded-code.inc
   def_assembly_code "bitwise-and", bitwise_and
      ;; ( a, b -- a and b )
      pop_argument_stack rbx
      and [Argument_stack_pointer], rbx
      next

   def_assembly_code "bitwise-or", bitwise_or
      ;; ( a, b -- a or b )
      pop_argument_stack rbx
      or  [Argument_stack_pointer], rbx
      next

   def_assembly_code "bitwise-xor", bitwise_xor
      ;; ( a, b -- a xor b )
      pop_argument_stack rbx
      xor [Argument_stack_pointer], rbx
      next

   def_assembly_code "bitwise-invert", bitwise_invert
      ;; ( a -- invert a )
      not qword[Argument_stack_pointer]
      next
   #+end_src
** single bit operations
   1. offset is of LSB
   2. offset in [0, ..., 63]
   3. step   in [1, ..., 64]
   4. >< need error handling on them
   #+begin_src fasm :tangle threaded-code.inc
   ;; BT copies a bit from a given register to the carry flag
   def_assembly_code "fetch-bit", fetch_bit
      ;; ( fixnum, offset -- bit )
      pop_argument_stack rbx
      pop_argument_stack rax
      bt rax, rbx
      setc al
      movzx rax, al
      push_argument_stack rax
      next


   def_assembly_code "set-bit", set_bit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      bts rax, rbx
      push_argument_stack rax
      next

   def_assembly_code "clear-bit", clear_bit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      btr rax, rbx
      push_argument_stack rax
      next

   def_assembly_code "invert-bit", invert_bit
      ;; ( fixnum, offset -- fixnum )
      pop_argument_stack rbx
      pop_argument_stack rax
      btc rax, rbx
      push_argument_stack rax
      next



   ;; "bsf" "bsr"
   ;; instructions scan a word or double word for first set bit
   ;; and store the index of this bit into destination operand
   ;; which must be general register
   ;; The bit string being scanned is specified by source operand
   ;; it may be either general register or memory
   ;; The ZF flag is set if the entire string is zero (no set bits are found)
   ;; otherwise it is cleared

   ;; If no set bit is found
   ;; the value of the destination register is undefined
   ;; "bsf" scans from low order to high order (starting from bit index zero)
   ;; "bsr" scans from high order to low order


   ;; note that:
   ;; if can not find "SetBit"
   ;; the following functions will return -1

   def_assembly_code "find-lowest-set-bit", find_lowest_set_bit
      ;; ( fixnum -- offset )
      pop_argument_stack rax
      bsf rax, rax
      jz @f
      push_argument_stack rax
      next
   @@:
      mov rax, -1
      push_argument_stack rax
      next

   def_assembly_code "find-highest-set-bit", find_highest_set_bit
      ;; ( fixnum -- offset )
      pop_argument_stack rax
      bsr rax, rax
      jz @f
      push_argument_stack rax
      next
   @@:
      mov rax, -1
      push_argument_stack rax
      next
   #+end_src
** bits shift & rotate
   #+begin_src fasm :tangle threaded-code.inc
   ;; "shl"
   ;; shifts the destination operand left
   ;; by the number of bits specified in the second operand
   ;; The destination operand can be general register or memory
   ;; The second operand can be an immediate value or the CL register
   ;; as bits exit from the left, zeros in from the right
   ;; The last bit that exited is stored in CF
   ;; "sal" is a synonym for "shl"
   def_assembly_code "shift-left", shift_left
      ;; ( fixnum, step -- fixnum * 2^step )
      pop_argument_stack rcx
      shl qword[Argument_stack_pointer], cl
      next

   def_assembly_code "shift-right", shift_right
      ;; ( fixnum, step -- fixnum / 2^step )
      pop_argument_stack rcx
      shr qword[Argument_stack_pointer], cl
      next

   def_assembly_code "shift-right-preserve-sign", shift_right_preserve_sign
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      sar qword[Argument_stack_pointer], cl
      next
   #+end_src
** [NOT USING] bits shift & rotate
   #+begin_src fasm
   ;; note that:
   ;; "double" is 128 bit value here

   ;; "shld"
   ;; shifts bits of the destination operand to the left
   ;; by the number of bits specified in third operand,
   ;; while shifting
   ;; move high order bits from the source operand
   ;; into the destination operand on the right.
   ;; The source operand remains unmodified.
   ;; The destination operand can be a word or double word general register or memory,
   ;; the source operand must be a general register,
   ;; third operand can be an immediate value or the CL register.
   def_assembly_code "double-shift-left", double_shift_left
      ;; ( fixnum-1, fixnum-2, step --
      ;;   new fixnum-1, new fixnum-2 )
      pop_argument_stack rcx
      pop_argument_stack rax
      shld qword[Argument_stack_pointer], rax, cl
      shl rax, cl
      push_argument_stack rax
      next


   ;; "shrd"
   ;; shifts bits of the destination operand to the right,
   ;; while shifting
   ;; move low order bits from the source operand
   ;; into the destination operand on the left.
   ;; The source operand remains unmodified.
   ;; Rules for operands are the same as for the "shld" instruction.
   def_assembly_code "double-shift-right", double_shift_right
      ;; ( fixnum-1, fixnum-2, step --
      ;;   new fixnum-1, new fixnum-2 )
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      shrd rbx, rax, cl
      shr rax, cl
      push_argument_stack rax
      push_argument_stack rbx
      next

   def_assembly_code "double-shift-right-preserve-sign", double_shift_right_preserve_sign
      ;; ( fixnum-1, fixnum-2, step --
      ;;   new fixnum-1, new fixnum-2 )
      pop_argument_stack rcx
      pop_argument_stack rbx
      pop_argument_stack rax
      shrd rbx, rax, cl
      sar rax, cl
      push_argument_stack rax
      push_argument_stack rbx
      next




   def_assembly_code "rotate-left", rotate_left
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      rol qword[Argument_stack_pointer], cl
      next

   def_assembly_code "rotate-right", rotate_right
      ;; ( fixnum, step -- new fixnum )
      pop_argument_stack rcx
      ror qword[Argument_stack_pointer], cl
      next
   #+end_src
* key-word
** literal branch false?branch
   #+begin_src fasm :tangle threaded-code.inc
   ;; with chinese support

   ;; this word should not be found
   ;; the interface of this word is the next word "literal"
   def_assembly_code "_literal", _literal
      ;; (* -- number *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      pop_return_stack rbx
      mov  rax, [rbx]
      push_argument_stack rax
      add  rbx, Cell_width
      cmp dword[rbx], Exit
      je _literal__meet_end
      cmp dword[rbx], 已矣
      je _literal__meet_end
      push_return_stack rbx
   _literal__meet_end:
      next

   ;; no error handling for string_full_of_blank
   def_key_word "literal", literal
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _literal, compile_number_to_here
      xx tail_and_head_of_word_string
      ;; need error handling when not found
      xx find, word_to_explainer, compile_number_to_here
      xx Exit
   def_key_word_end literal


   ;; the following handles _branch to "Exit"
   ;; >< alth branch to "Exit" should never be used
   def_assembly_code "_branch", _branch
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + offset * Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      ;; and "next"
      ;; (could be optimize by not using "next")
      pop_return_stack rbx
      mov  rax, [rbx]
      imul rax, Cell_width
      add  rbx, rax
      cmp dword[rbx], Exit
      je _branch__meet_end
      cmp dword[rbx], 已矣
      je _branch__meet_end
      push_return_stack rbx
   _branch__meet_end:
      next

   ;; no error handling for string_full_of_blank
   def_key_word "branch", branch
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _branch, compile_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _false?branch, 5
      xx   string_to_integer__with_error, drop, compile_number_to_here
      xx   Exit
      ;; need error handling when branch followed by a non integer
      xx Exit
   def_key_word_end branch


   ;; the following handles _false?branch to "Exit"
   def_assembly_code "_false?branch", _false?branch
      ;; (* True of False -- *)
      ;; 0. if NOT _branch
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + offset * Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      ;; and "next"
      ;; (could be optimize by not using "next")
      pop_argument_stack rax
      test rax, rax
      jnz _false?branch__not_to_branch

      pop_return_stack rbx
      mov  rax, [rbx]
      imul rax, Cell_width
      add  rbx, rax
      cmp dword[rbx], Exit
      je _false?branch__meet_end
      cmp dword[rbx], 已矣
      je _false?branch__meet_end
      push_return_stack rbx
   _false?branch__meet_end:
      next

   _false?branch__not_to_branch:
      pop_return_stack rbx
      add rbx, Cell_width
      cmp dword[rbx], Exit
      je _false?branch__not_to_branch__meet_end
      cmp dword[rbx], 已矣
      je _false?branch__not_to_branch__meet_end
      push_return_stack rbx
   _false?branch__not_to_branch__meet_end:
      next

   ;; no error handling for string_full_of_blank
   def_key_word "false?branch", false?branch
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _false?branch, compile_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _false?branch, 5
      xx   string_to_integer__with_error, drop, compile_number_to_here
      xx   Exit
      ;; need error handling when branch followed by a non integer
      xx Exit
   def_key_word_end false?branch
   #+end_src
** chinese literal branch false?branch
   #+begin_src fasm :tangle threaded-code.inc
   ;; this word should not be found
   ;; the interface of this word is the next word "即"
   def_assembly_code "_即", _即
      ;; (* -- number *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      pop_return_stack rbx
      mov  rax, [rbx]
      push_argument_stack rax
      add  rbx, Cell_width
      cmp dword[rbx], Exit
      je _即__meet_end
      cmp dword[rbx], 已矣
      je _即__meet_end
      push_return_stack rbx
   _即__meet_end:
      next

   ;; no error handling for string_full_of_blank
   def_key_word "即", 即
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _即[address of explainer], number *)
      xx _即, _即, compile_number_to_here
      xx tail_and_head_of_word_string
      ;; need error handling when not found
      xx find, word_to_explainer, compile_number_to_here
      xx Exit
   def_key_word_end 即



   ;; the following handles _转 to "Exit"
   ;; >< alth branch to "Exit" should never be used
   def_assembly_code "_转", _转
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + offset * Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      ;; and "next"
      ;; (could be optimize by not using "next")
      pop_return_stack rbx
      mov  rax, [rbx]
      imul rax, Cell_width
      add  rbx, rax
      cmp dword[rbx], Exit
      je _转__meet_end
      cmp dword[rbx], 已矣
      je _转__meet_end
      push_return_stack rbx
   _转__meet_end:
      next



   ;; no error handling for string_full_of_blank
   def_key_word "转", 转
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _即[address of explainer], number *)
      xx _即, _转, compile_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _假则转, 5
      xx   string_to_integer__with_error, drop, compile_number_to_here
      xx   Exit
      ;; need error handling when branch followed by a non integer
      xx Exit
   def_key_word_end 转

   ;; the following handles _假则转 to "Exit"
   def_assembly_code "_假则转", _假则转
      ;; (* True of False -- *)
      ;; 0. if NOT _转
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + offset * Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      ;; and "next"
      ;; (could be optimize by not using "next")
      pop_argument_stack rax
      test rax, rax
      jnz _假则转__not_to_转

      pop_return_stack rbx
      mov  rax, [rbx]
      imul rax, Cell_width
      add  rbx, rax
      cmp dword[rbx], Exit
      je _假则转__meet_end
      cmp dword[rbx], 已矣
      je _假则转__meet_end
      push_return_stack rbx
   _假则转__meet_end:
      next

   _假则转__not_to_转:
      pop_return_stack rbx
      add rbx, Cell_width
      cmp dword[rbx], Exit
      je _假则转__not_to_转__meet_end
      cmp dword[rbx], 已矣
      je _假则转__not_to_转__meet_end
      push_return_stack rbx
   _假则转__not_to_转__meet_end:
      next

   ;; no error handling for string_full_of_blank
   def_key_word "假则转", 假则转
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _即[address of explainer], number *)
      xx _即, _假则转, compile_number_to_here
      xx tail_and_head_of_word_string
      xx dup2, string_denote_integer?, _假则转, 5
      xx   string_to_integer__with_error, drop, compile_number_to_here
      xx   Exit
      ;; need error handling when branch followed by a non integer
      xx Exit
   def_key_word_end 假则转
   #+end_src
** address
   #+begin_src fasm :tangle threaded-code.inc
   def_assembly_code "", _address
      ;; (* -- address *)
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- address + Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;         address -- *)
      pop_return_stack rbx
      mov  rax, [rbx]
      add  rax, Cell_width
      push_argument_stack rax
      add  rbx, Cell_width
      cmp dword[rbx], Exit
      je _address__meet_end
      cmp dword[rbx], 已矣
      je _literal__meet_end
      push_return_stack rbx
   _address__meet_end:
      next


   ;; no error handling for string_full_of_blank
   def_key_word "address", address
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _address, compile_number_to_here
      xx tail_and_head_of_word_string
      ;; need error handling when not found
      xx find, word_to_explainer, compile_number_to_here
      xx Exit
   def_key_word_end address
   #+end_src
** chinese address
   #+begin_src fasm :tangle threaded-code.inc
   ;; no error handling for string_full_of_blank
   def_key_word "址", 址
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile::
      ;;      _literal[address of explainer], number *)
      xx _literal, _address, compile_number_to_here
      xx tail_and_head_of_word_string
      ;; need error handling when not found
      xx find, word_to_explainer, compile_number_to_here
      xx Exit
   def_key_word_end 址
   #+end_src
** ----------------------------------
** if else then
   #+begin_src fasm :tangle threaded-code.inc
   ;; one predicate can make two branchs
   ;; three predicates can make four branchs
   ;; three predicates may only make three branchs
   ;; but indeed there must be an invisible branch

   def_key_word "if", _if
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack::
      ;;       -- address after _false?branch *)
      ;; (* compile::
      ;;      _false?branch[address of explainer], 0 *)
      xx _literal, _false?branch, compile_number_to_here
      xx Here, push_lambda_stack
      xx _literal, 0, compile_number_to_here ;; (* leave a place *)
      xx Exit
   def_key_word_end _if

   def_key_word "else", _else
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack ::
      ;;      [address after _false?branch] -- [address after _branch] *)
      ;; (* compile ::
      ;;      _branch[address of explainer], 0 *)
      ;; (* compile to [address after _false?branch] ::
      ;;      [appropriate offset] *)
      xx _literal, _branch, compile_number_to_here
      xx pop_lambda_stack
      xx   Here, push_lambda_stack
      xx   _literal, 0, compile_number_to_here ;; (* leave a place *)
      xx Here, over, subtraction, _literal, Cell_width, moddiv, swap, drop
      xx swap, save
      xx Exit
   def_key_word_end _else

   def_key_word "then", _then
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack ::
      ;;      [address after _false?branch] or [address after _branch] --  *)
      ;; (* compile to [address after _false?branch] or [address after _branch] ::
      ;;      [appropriate offset] *)
      xx pop_lambda_stack
      xx Here, over, subtraction, _literal, Cell_width, moddiv, swap, drop
      xx swap, save
      xx Exit
   def_key_word_end _then
   #+end_src
** chinese if else then
   #+begin_src fasm :tangle threaded-code.inc
   def_key_word "则", 则
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack::
      ;;       -- address after _false?branch *)
      ;; (* compile::
      ;;      _false?branch[address of explainer], 0 *)
      xx _literal, _false?branch, compile_number_to_here
      xx Here, push_lambda_stack
      xx _literal, 0, compile_number_to_here ;; (* leave a place *)
      xx Exit
   def_key_word_end 则

   def_key_word "否则", 否则
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack ::
      ;;      [address after _false?branch] -- [address after _branch] *)
      ;; (* compile ::
      ;;      _branch[address of explainer], 0 *)
      ;; (* compile to [address after _false?branch] ::
      ;;      [appropriate offset] *)
      xx _literal, _branch, compile_number_to_here
      xx pop_lambda_stack
      xx   Here, push_lambda_stack
      xx   _literal, 0, compile_number_to_here ;; (* leave a place *)
      xx Here, over, subtraction, _literal, Cell_width, moddiv, swap, drop
      xx swap, save
      xx Exit
   def_key_word_end 否则

   def_key_word "再", 再
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* Lambda-stack ::
      ;;      [address after _false?branch] or [address after _branch] --  *)
      ;; (* compile to [address after _false?branch] or [address after _branch] ::
      ;;      [appropriate offset] *)
      xx pop_lambda_stack
      xx Here, over, subtraction, _literal, Cell_width, moddiv, swap, drop
      xx swap, save
      xx Exit
   def_key_word_end 再
   #+end_src
** comment
   #+begin_src fasm :tangle threaded-code.inc
   def_string "Bra:comment", "(*", Bra__comment
   def_string "Ket:comment", "*)", Ket__comment

   def_key_word "(*", ignore_comment
      ;; (* word-string[address, length] -- word-string[address, length] *)
      xx tail_and_head_of_word_string
      xx dup2, Bra__comment, equal_string?, _false?branch, 5
      xx   drop2, ignore_comment, _branch, -9
      ;; beware of the tail-call-optimization
      ;; a tail-recursive-call is really a loop
      xx Ket__comment, equal_string?, _false?branch, -13
      xx   Exit
   def_key_word_end ignore_comment
   #+end_src
** colon
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "compile-number-to-current-data-section", compile_number_to_current_data_section
      ;; (* a 64 bits number -- *)
      ;; reset "Current_data_section", which points next free memory
      xx Current_data_section
      xx save
      xx Current_data_section
      xx _literal, Cell_width, addition
      xx _address, Current_data_section, save
      xx Exit
   def_verb_end compile_number_to_current_data_section

   def_verb "compile-byte-to-current-data-section", compile_byte_to_current_data_section
      ;; (* a 64 bits number -- *)
      ;; reset "Current_data_section", which points next free memory
      xx Current_data_section
      xx save_byte
      xx _literal, 1
      xx _address, Current_data_section, add_save
      xx Exit
   def_verb_end compile_byte_to_current_data_section

   ;; note that:
   ;; a string in stack is string[address, length]
   ;; a string in memory is ||  1 cell : length  ||  n byte : string  ||  1 byte : 0  ||
   def_verb "compile-string-to-current-data-section", compile_string_to_current_data_section
      ;; (* string[address, length] -- *)
      ;; for update Current_data_section
      xx dup, push_lambda_stack
      xx   dup, compile_number_to_current_data_section
      xx   Current_data_section, swap, copy_byte_string
      ;; update Current_data_section
      xx pop_lambda_stack
      xx Current_data_section, addition
      xx _literal, 0, over, save_byte
      xx add1
      xx _address, Current_data_section, save
      xx Exit
   def_verb_end compile_string_to_current_data_section



   ;; cosemi = colon + semicolon
   def_string "Bra:cosemi", ":", Bra__cosemi
   def_string "Ket:cosemi", ";", Ket__cosemi

   ;; 1. 为了使得 data section 的处理变得简单
   ;;    即 不用去计算 function section 的长度
   ;;    而使用 类似 哈佛构架的办法 把数据与函数分开
   ;; 2. 利用 Current_data_section 这个变量
   ;; 3. 为了处理嵌套的 ":" ";" 而对 ":" 的出现进行计数
   ;; 4. do not copy byte by byte
   ;;    but use "copy-byte-string"
   def_key_word ":", colon
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile ::
      ;;      string[address, length] *)
      ;; (* compile to [data section] ::
      ;;      string-header and string ended by 0 *)
      xx dup2
      xx _literal, 0, push_lambda_stack ;; ":" counter
      .tail_and_head_of_word_string:
      xx tail_and_head_of_word_string
      xx dup2, Bra__cosemi, equal_string?, _false?branch, (.dup2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack, add1, push_lambda_stack
      xx   _branch, (.tail_and_head_of_word_string-$)/Cell_width
      .dup2:
      xx dup2, Ket__cosemi, equal_string?, _false?branch, (.drop2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack
      xx   dup, zero?, _false?branch, (.sub1-$)/Cell_width
      xx     drop
      ;;     (* word-string-begin[address, length], word-string-end[address, length] *)
      xx     dup2, ready
      ;;       (* calculate the length and copy to [data section] *)
      xx       drop, swap, drop
      xx       _literal, 2, subtraction ;; sub the length of "; "
      xx       over, subtraction
      xx         Current_data_section
      xx         _literal, Cell_width, addition
      xx         over, push_lambda_stack  ;; (* length to compile to here *)
      xx         push_lambda_stack        ;; (* address to compile to here *)
      xx       compile_string_to_current_data_section
      ;;       (* compile the string into function-body *)
      ;;       (* address to compile to here *)
      xx       _literal, _literal, compile_number_to_here
      xx       pop_lambda_stack, compile_number_to_here
      ;;       (* length to compile to here *)
      xx       _literal, _literal, compile_number_to_here
      xx       pop_lambda_stack, compile_number_to_here
      xx     get_back
      xx     Exit
      .sub1:
      xx   sub1, push_lambda_stack
      xx   _branch, (.tail_and_head_of_word_string-$)/Cell_width
      .drop2:
      xx drop2
      xx _branch, (.tail_and_head_of_word_string-$)/Cell_width
      xx Exit
   def_key_word_end colon
   #+end_src
** chinese colon
   #+begin_src fasm :tangle threaded-code.inc
   def_string "Bra:fuzhe", "夫", Bra__fuzhe
   def_string "Ket:fuzhe", "者", Ket__fuzhe

   def_key_word "夫", 夫
      ;; (* word-string[address, length] -- word-string[address, length] *)
      ;; (* compile ::
      ;;      string[address, length] *)
      ;; (* compile to [data section] ::
      ;;      string-header and string ended by 0 *)
      xx dup2
      xx _literal, 0, push_lambda_stack ;; counter
      .tail_and_head_of_word_string:
      xx tail_and_head_of_word_string
      xx dup2, Bra__fuzhe, equal_string?, _false?branch, (.dup2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack, add1, push_lambda_stack
      xx   _branch, (.tail_and_head_of_word_string-$)/Cell_width
      .dup2:
      xx dup2, Ket__fuzhe, equal_string?, _false?branch, (.drop2-$)/Cell_width
      xx   drop2
      xx   pop_lambda_stack
      xx   dup, zero?, _false?branch, (.sub1-$)/Cell_width
      xx     drop
      ;;     (* word-string-begin[address, length], word-string-end[address, length] *)
      xx     dup2, ready
      ;;       (* calculate the length and copy to [data section] *)
      xx       drop, swap, drop
      xx       Ket__fuzhe, swap, drop, add1
      xx       subtraction ;; sub the length of Ket__fuzhe
      xx       over, subtraction
      xx         Current_data_section
      xx         _literal, Cell_width, addition
      xx         over, push_lambda_stack  ;; (* length to compile to here *)
      xx         push_lambda_stack        ;; (* address to compile to here *)
      xx       compile_string_to_current_data_section
      ;;       (* compile the string into function-body *)
      ;;       (* address to compile to here *)
      xx       _literal, _literal, compile_number_to_here
      xx       pop_lambda_stack, compile_number_to_here
      ;;       (* length to compile to here *)
      xx       _literal, _literal, compile_number_to_here
      xx       pop_lambda_stack, compile_number_to_here
      xx     get_back
      xx     Exit
      .sub1:
      xx   sub1, push_lambda_stack
      xx   _branch, (.tail_and_head_of_word_string-$)/Cell_width
      .drop2:
      xx drop2
      xx _branch, (.tail_and_head_of_word_string-$)/Cell_width
      xx Exit
   def_key_word_end 夫
   #+end_src
* --------------------------------------------------
* basic-REPL
  #+begin_src fasm :tangle threaded-code.inc
  def_verb "basic-REPL", basic_REPL
     ;; (* unknown -- unknown *)
     ;; ><><>< init srack ???
     .read_phrase:
     xx read_phrase
     xx eval_phrase
     xx _branch, (.read_phrase-$)/Cell_width
  def_verb_end basic_REPL

  def_verb "execute-word", execute_word
     ;; (* string[address, length] -- unknown *)
     xx dup2, string_denote_integer?, _false?branch, 4
     xx   string_to_integer__with_error, drop
     xx   Exit
     xx dup2, find, dup, _false?branch, 6
     xx   xxswapx, drop2
     xx   word_to_explainer, execute
     xx   Exit
     xx drop ;; drop zero
     xx Message_undefined_word, print_string
     xx print_string
     xx _literal, ASCII_linefeed, write_byte
     xx Exit
  def_verb_end execute_word

  def_string "Message:undefined-word", "   UNDEFINED WORD: ", Message_undefined_word
  #+end_src
* phrase
** note
   1. "ok" and "no" are two reversed word in cicada now
      they are for the runtime function "read-phrase"
      interesting design ^_^
      but they can not even show up in comment
   2. functions about phrase are just for runtime
      with a buffer been overwrited each time the functions run
      nested calling is not allowed
   3. nested calling needs GC about string
   4. 没有 GC 根本就很难把东西 实现正确
      比如在这里
      如果 把 字符出 的 存储空间 分配在 Buffer_for_read_phrase 中的话
      那么 两个 phrase 中给出的两个字符串 就有可能 相互 覆盖
   5. ><><>< BUG
      可见必须有 GC 才能把这里处理好
      但是我不能把 GC 写在汇编中
      所以 这些问题 等我写出编译器之后再解决
      现在所接受的 错误假设是
      "当一个 phrase 结束时, 就假设其中的数据全部都无法被引用了"
** read-phrase
   #+begin_src fasm :tangle threaded-code.inc
   def_string "ok", "ok", ok
   def_string "no", "no", no

   hereUnInitializedData
   ;; ------------------------
   Size_of_buffer_for_read_phrase = 1024*1024

   Buffer_for_read_phrase labeling
           preserve Size_of_buffer_for_read_phrase


   def_verb "read-phrase", read_phrase
      ;; (*  -- string[address, length] *)
      xx _literal, Buffer_for_read_phrase
      xx _literal, 0

      .read_word__while_saving_to_string:
      xx read_word__while_saving_to_string
      ;; (* string[address, length], word[address, length] *)

      .ok:
      xx dup2, ok, equal_string?, _false?branch, (.dup2-$)/Cell_width
      xx   swap, drop, add1, subtraction
      xx   Exit

      .dup2:
      xx dup2, no, equal_string?, _false?branch, (.drop2-$)/Cell_width
      xx   drop2
      xx   drop2
      xx   read_phrase
      xx   Exit

      .drop2:
      xx drop2
      xx _branch, (.read_word__while_saving_to_string-$)/Cell_width
   def_verb_end read_phrase
   #+end_src
** eval-phrase
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "eval-phrase", eval_phrase
      ;; (* word-string[address, length] -- unknown *)
      xx compile_phrase, call_compiled_phrase
      xx Exit
   def_verb_end eval_phrase
   #+end_src
** compile-phrase
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData
   ;; ------------------------
   Size_of_buffer_of_function_body__for_compile_phrase = 1024*1024
   Size_of_buffer_of_data_section__for_compile_phrase = 1024*1024

   Buffer_of_function_body__for_compile_phrase labeling
           preserve Size_of_buffer_of_function_body__for_compile_phrase
   Buffer_of_data_section__for_compile_phrase labeling
           preserve Size_of_buffer_of_data_section__for_compile_phrase


   def_verb "compile-phrase", compile_phrase
      ;; (* word-string[address, length] --  *)
      xx Here, push_lambda_stack
      xx Current_data_section, push_lambda_stack
      xx   _literal, Buffer_of_function_body__for_compile_phrase, _address, Here, save
      xx   _literal, Buffer_of_data_section__for_compile_phrase, _address, Current_data_section, save
      xx   Verb_explainer, compile_number_to_here
      xx   compile_word_description_to_here
      xx   The_Exit, compile_number_to_here
      xx pop_lambda_stack, _address, Current_data_section, save
      xx pop_lambda_stack, _address, Here, save
      xx Exit
   def_verb_end compile_phrase
   #+end_src
** call-compiled-phrase
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "call-compiled-phrase", call_compiled_phrase
      ;; (* -- unknown *)
      xx _literal, Buffer_of_function_body__for_compile_phrase
      xx execute
      xx Exit
   def_verb_end call_compiled_phrase
   #+end_src
* number reader
** note
   1. 现在 的 number 就只是 "integer" 而已
      更多的跟数学有关的东西将在 cicada 中设计新的语法来实现
   2. 在 "integer" 这个函数中 我将只支持 对四种进位制的 字符串的 阅读
      1. 十进制 :: 10#1231 10#-1231 或者 1231 -1231
      2. 二进制 :: 2#101001 2#-101001
      3. 八进制 :: 8#712537 8#-712537
      4. 十六进制 :: 16#f123acb3 16#-F123ACB3 (大写小写字母都可以)
   3. and still, one can use "_" to separate the number to make it more readable
      example : 2#1111_0101_0001
   4. actually, the base can be any 10 based number
      even greater then 36
      but when the base is greater then 36
      not all integer can be represented under this base
      for we only have 36 chars
   5. 可以发现 这样对一个 字符串 是不是代表了一个 整数的 判断就简单多了
** base-of-string
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. just take the 10 based number on the left of "#" as base
   ;;    while the base must be not-zero
   ;;    (actually, when it is zero, just let the zero return,
   ;;     it will be viewed as a parsing error.)
   ;; 2. if can not find "#" in the string
   ;;    or there is nothing after the first occur of "#"
   ;;    or there is nothing in front of the first occur of "#"
   ;;    or the string on the left of "#" can not be simply viewed as a 10 based number
   ;;    or it is zero
   ;;    just reture zero
   ;; 3. this function is really a perfect example
   ;;    of how to make good use of Lambda-stack :)
   def_verb "base-of-string", base_of_string
      ;; (* string[address, length] -- base  or zero *)
      xx _literal, 0, push_lambda_stack ;; init counter for help__base_of_string__push_char
      xx help__base_of_string__push_char
      xx dup, false?, _false?branch, 2
      xx   Exit
      xx drop
      xx _literal, 0  ;; init base for help__base_of_string__pop_char
      xx pop_lambda_stack
      xx _literal, 0
      xx push_lambda_stack  ;; init index for help__base_of_string__pop_char
      xx help__base_of_string__pop_char
      xx Exit
   def_verb_end base_of_string

   def_verb "help:help:base-of-string,push-char,clear-lambda-stack", help__help__base_of_string__push_char__clear_lambda_stack
      ;; (* char-counter[N] -- *)
      ;; (* Lambda-stack::  char, ... --  *)
      xx dup, zero?, _false?branch, 3
      xx   drop
      xx   Exit
      xx sub1, pop_lambda_stack, drop
      xx help__help__base_of_string__push_char__clear_lambda_stack
      xx Exit
   def_verb_end help__help__base_of_string__push_char__clear_lambda_stack

   def_verb "help:base-of-string,push-char", help__base_of_string__push_char
      ;; (* string[address, length] -- True *)
      ;; (* Lambda-stack:: char-counter[0] -- char-counter[N], char, ... *)
      ;; (* or *)
      ;; (* string[address, length] -- False *)
      ;; (* Lambda-stack:: char-counter[0] -- *)
      xx dup, _literal, 2, less_than?, _false?branch, 7
      xx   drop2
      xx   pop_lambda_stack
      xx   help__help__base_of_string__push_char__clear_lambda_stack
      xx   _literal, 0
      xx   Exit
      xx tail_and_head_of_string
      xx dup, _literal, '#', equal?, _false?branch, 6
      xx   drop, drop2
      xx   _literal, 1
      xx   Exit
      xx dup, char_denote_number?, false?, _false?branch, 8
      xx   drop, drop2
      xx   pop_lambda_stack
      xx   help__help__base_of_string__push_char__clear_lambda_stack
      xx   _literal, 0
      xx   Exit
      xx pop_lambda_stack, add1
      xx swap, push_lambda_stack, push_lambda_stack
      xx help__base_of_string__push_char
      xx Exit
   def_verb_end help__base_of_string__push_char

   ;; over-flow of 64 bits is not handled
   def_verb "help:base-of-string,pop-char", help__base_of_string__pop_char
      ;; (* base, char-counter[N] -- base *)
      ;; (* Lambda-stack::  index, char, ... -- *)
      xx dup, zero?, _false?branch, 5
      xx   drop
      xx   pop_lambda_stack, drop
      xx   Exit
      xx sub1
      xx swap, pop_lambda_stack
      ;; (* char-counter[N], base, index *)
      xx dup, _literal, 10, swap, power
      xx   pop_lambda_stack
      xx   _literal, '0', subtraction
      xx   multiple
      xx   swap, add1, push_lambda_stack
      xx   addition
      xx swap
      xx help__base_of_string__pop_char
      xx Exit
   def_verb_end help__base_of_string__pop_char
   #+end_src
** digit-of-string
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. just take whatever the sub-string on the rigth of "#"
   ;;    while the length of this sub-string must be not-zero
   ;; 2. if can not find "#" in the string
   ;;    or there is nothing after the first occur of "#"
   ;;    or there is nothing in front of the first occur of "#"
   ;;    just reture zero
   def_verb "digit-of-string", digit_of_string
      ;; (* string[address, length] -- digit[address, length]  or zero *)
      xx dup2, head_of_string
      xx _literal, '#', equal?, _false?branch, 5
      xx   drop2
      xx   _literal, 0
      xx   Exit
      xx help__digit_of_string
      xx Exit
   def_verb_end digit_of_string

   ;; this helper-function do not handle "#123" as error
   ;; i.e. when there is nothing in front of the first occur of "#"
   ;; it does not reture 0
   def_verb "help:digit-of-string", help__digit_of_string
      ;; (* string[address, length] -- digit[address, length]  or zero *)
      xx dup, _literal, 2, less_than?, _false?branch, 5
      xx   drop2
      xx   _literal, 0
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, '#', equal?, _false?branch, 2
      xx   Exit
      xx help__digit_of_string
      xx Exit
   def_verb_end help__digit_of_string
   #+end_src
** char->number
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. if char is not in [0-9] [A-Z] [a-z]
   ;;    reture -1 to denote error
   def_verb "char->number", char_to_number
      ;; (* char -- the number it denotes *)
      xx dup, _literal, '0', less_than?, _false?branch, 5
      xx   drop
      xx   _literal, -1
      xx   Exit
      xx dup, _literal, '9', less_or_equal?, _false?branch, 5
      xx   _literal, '0'
      xx   subtraction
      xx   Exit
      xx dup, _literal, 'A', less_than?, _false?branch, 5
      xx   drop
      xx   _literal, -1
      xx   Exit
      xx dup, _literal, 'Z', less_or_equal?, _false?branch, 8
      xx   _literal, 'A', subtraction
      xx   _literal, 10, addition
      xx   Exit
      xx dup, _literal, 'a', less_than?, _false?branch, 5
      xx   drop
      xx   _literal, -1
      xx   Exit
      xx dup, _literal, 'z', less_or_equal?, _false?branch, 8
      xx   _literal, 'a', subtraction
      xx   _literal, 10, addition
      xx   Exit
      xx drop
      xx _literal, -1
      xx Exit
   def_verb_end char_to_number
   #+end_src
** with-base:char-denote-number?
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "with-base:char-denote-number?", with_base__char_denote_number?
      ;; (* base, char -- True of False *)
      ;; (* char -- True or False *)
      xx char_to_number
      xx dup, _literal, -1, equal?, _false?branch, 4
      xx   drop2
      xx   False
      xx   Exit
      xx greater_than?, _false?branch, 3
      xx   True
      xx   Exit
      xx False
      xx Exit
   def_verb_end with_base__char_denote_number?
   #+end_src
** with-base:string-denote-digit?
   #+begin_src fasm :tangle threaded-code.inc
   ;; in the following function "with-base:string-denote-digit?"
   ;; I also need to handle the separater "_"

   ;; use with-base:char-denote-number?
   ;; to check if each "digit-cher" greater_or_equal then "base"

   def_verb "with-base:string-denote-digit?", with_base__string_denote_digit?
      ;; (* base, string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 5
      xx   drop2, drop
      xx   False
      xx   Exit
      xx dup2, head_of_string, _literal, '-', equal?, _false?branch, 2
      ;; note the way how to uses "if then" here
      ;; it is enough to use "if then" to handle
      ;; an optional executed function call, without the use of "Exit"
      xx   tail_of_string
      xx dup2, string_full_of_underscore?, _false?branch, 5
      xx   drop2, drop
      xx   False
      xx   Exit
      xx help__with_base__string_denote_digit?
      xx Exit
   def_verb_end with_base__string_denote_digit?

   ;; this helper function :
   ;; 0. when meet zero-length string always reture True
   def_verb "string-full-of-underscore?", string_full_of_underscore?
      ;; (* string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 4
      xx   drop2
      xx   True
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, '_', equal?, _false?branch, 3
      xx   string_full_of_underscore?
      xx   Exit
      xx drop2
      xx False
      xx Exit
   def_verb_end string_full_of_underscore?

   ;; this helper function :
   ;; 0. when meet zero-length string always reture True
   ;; 1. do not handle "-"
   ;; 2. do not handle string-full-of-underscore
   def_verb "help:with-base:string-denote-digit?", help__with_base__string_denote_digit?
      ;; (* base, string[address, length] -- True or False *)
      xx dup, zero?, _false?branch, 5
      xx   drop2, drop
      xx   True
      xx   Exit
      xx tail_and_head_of_string
      xx dup, _literal, '_', equal?, _false?branch, 4
      xx   drop
      xx   help__with_base__string_denote_digit?
      xx   Exit
      xx xoverxxx, swap
      xx with_base__char_denote_number?, _false?branch, 3
      xx   help__with_base__string_denote_digit?
      xx   Exit
      xx drop2, drop
      xx False
      xx Exit
   def_verb_end help__with_base__string_denote_digit?


   def_verb "with-base:string-denote-digit?without-sign", with_base__string_denote_digit?without_sign
      ;; (* base, string[address, length] -- True or False *)
      xx dup2, head_of_string, _literal, '-', equal?, _false?branch, 5
      xx   drop2, drop
      xx   False
      xx   Exit
      xx with_base__string_denote_digit?
      xx Exit
   def_verb_end with_base__string_denote_digit?without_sign
   #+end_src
** string-denote-base#digit? & string-denote-digit?
   #+begin_src fasm :tangle threaded-code.inc
   ;; now with very good factoring
   ;; we can write the following function easily :)

   ;; with "#"
   def_verb "string-denote-base#digit?", string_denote_base_digit?
      ;; (* string[address, length] -- True or False *)
      xx dup2, base_of_string
      xx dup, zero?, _false?branch, 5
      xx   drop  ;; drop zero
      xx   drop2 ;; drop string
      xx   False
      xx   Exit
      xx xxswapx
      xx digit_of_string
      xx dup, zero?, _false?branch, 5
      xx   drop  ;; drop zero
      xx   drop  ;; drop base
      xx   False
      xx   Exit
      xx with_base__string_denote_digit?
      xx Exit
   def_verb_end string_denote_base_digit?

   ;; without "#"
   def_verb "string-denote-digit?", string_denote_digit?
      ;; (* string[address, length] -- True or False *)
      xx _literal, 10, xxswapx
      xx with_base__string_denote_digit?
      xx Exit
   def_verb_end string_denote_digit?
   #+end_src
** string-denote-integer?
   #+begin_src fasm :tangle threaded-code.inc
   ;; in the following functions
   ;; I also need to handle the separater "_"

   ;; two sub-type of string as above
   def_verb "string-denote-integer?", string_denote_integer?
      ;; (* string[address, length] -- True or False *)
      xx dup2, string_denote_digit?, _false?branch, 4
      xx   drop2, True
      xx   Exit
      xx string_denote_base_digit?, _false?branch, 3
      xx   True
      xx   Exit
      xx False
      xx Exit
   def_verb_end string_denote_integer?
   #+end_src
** with-base:string->natural-number,with-error
   #+begin_src fasm :tangle threaded-code.inc
   ;; we need to return an error indication
   ;; so we let the following function returns two items on the stack
   ;; is this the right way to do it?
   ;; for sometimes one might do not want to call "debuger"
   ;; when calling "string->integer" and meet a parsing error
   def_verb "with-base:string->natural-number,with-error", with_base__string_to_natural_number__with_error
      ;; (* base, string[address, length] -- natural-number, True *)
      ;; (* or *)
      ;; (* base, string[address, length] -- 0, False *)
      xx xoverxx, xxoverx
      xx with_base__string_denote_digit?without_sign, false?, _false?branch, 7
      xx   drop2, drop
      xx   _literal, 0
      xx   False
      xx   Exit
      xx _literal, 0, push_lambda_stack ;; number-counter[0]
      xx help_push__with_base__string_to_natural_number__with_error
      xx _literal, 0 ;; sum
      xx _literal, 0 ;; index
      xx help_pop__with_base__string_to_natural_number__with_error
      xx Exit
   def_verb_end with_base__string_to_natural_number__with_error


   def_verb "help-push:with-base:string->natural-number,with-error", help_push__with_base__string_to_natural_number__with_error
      ;; (* base, string[address, length] -- base *)
      ;; (* Lambda-stack:: number-counter[0] -- number-counter[N], number, ... *)
      xx dup, zero?, _false?branch, 3
      xx   drop2
      xx   Exit
      xx tail_and_head_of_string
      xx dup, _literal, '_', equal?, _false?branch, 4
      xx   drop
      xx   help_push__with_base__string_to_natural_number__with_error
      xx   Exit
      xx char_to_number, pop_lambda_stack, add1
      xx swap, push_lambda_stack, push_lambda_stack
      xx help_push__with_base__string_to_natural_number__with_error
      xx Exit
   def_verb_end help_push__with_base__string_to_natural_number__with_error

   def_verb "help-pop:with-base:string->natural-number,with-error", help_pop__with_base__string_to_natural_number__with_error
      ;; (* base, sum, index -- natural-number, True *)
      ;; (* Lambda-stack:: number-counter[N], number, ... -- *)
      xx pop_lambda_stack
      xx dup, zero?, _false?branch, 7
      xx   drop
      xx   drop, swap, drop
      xx   True
      xx   Exit
      xx pop_lambda_stack, swap, sub1, push_lambda_stack
      ;; (* base, sum, index, number *)
      xx xoverxxx, xoverxx
      xx power
      ;; (* base, sum, index, number, base^index *)
      xx multiple
      xx push_lambda_stack
      xx swap, pop_lambda_stack, addition
      xx swap, add1
      xx help_pop__with_base__string_to_natural_number__with_error
      xx Exit
   def_verb_end help_pop__with_base__string_to_natural_number__with_error
   #+end_src
** with-base:string->integer,with-error
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "with-base:string->integer,with-error", with_base__string_to_integer__with_error
      ;; (* base, string[address, length] -- natural-number, True *)
      ;; (* or *)
      ;; (* base, string[address, length] -- 0, False *)
      xx xoverxx, xxoverx
      xx with_base__string_denote_digit?, false?, _false?branch, 7
      xx   drop2, drop
      xx   _literal, 0
      xx   False
      xx   Exit
      xx dup2, head_of_string, _literal, '-', equal?, _false?branch, 7
      xx   tail_of_string
      xx   with_base__string_to_natural_number__with_error
      xx   swap
      xx   negate
      xx   swap
      xx   Exit
      xx with_base__string_to_natural_number__with_error
      xx Exit
   def_verb_end with_base__string_to_integer__with_error
   #+end_src
** string->integer,with-error
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "string->integer,with-error", string_to_integer__with_error
      ;; (* string[address, length] -- integer, True *)
      ;; (* or *)
      ;; (* string[address, length] -- 0, False *)
      xx dup2, string_denote_base_digit?, _false?branch, 7
      xx   dup2, base_of_string
      xx   xxswapx, digit_of_string
      xx   with_base__string_to_integer__with_error
      xx   Exit
      xx dup2, string_denote_digit?, _false?branch, 6
      xx   _literal, 10
      xx   xxswapx
      xx   with_base__string_to_integer__with_error
      xx   Exit
      xx drop2
      xx _literal, 0
      xx False
      xx Exit
   def_verb_end string_to_integer__with_error
   #+end_src
* string misc
** find-char-address & find-char-index
   #+begin_src fasm :tangle threaded-code.inc
   ;; : find-char-address
   ;;   (* char, [address, length] -- address or -1 *)
   ;;   dup zero? if
   ;;     drop2 drop
   ;;     -1
   ;;     Exit
   ;;   then
   ;;   tailAndHeadOfString
   ;;   x|over|xxx == if
   ;;     drop swap drop
   ;;     sub1
   ;;     Exit
   ;;   then
   ;;   find-char-address
   ;;   Exit
   ;; ; defineRecursiveFunction

   def_verb "find-char-address", find_char_address
      ;; (* char, [address, length] -- address or -1 *)
      xx dup, zero?, _false?branch, 6
      xx   drop2, drop
      xx   _literal, -1
      xx   Exit
      xx tail_and_head_of_string
      xx xoverxxx, equal?, _false?branch, 6
      xx   drop, swap, drop
      xx   sub1
      xx   Exit
      xx find_char_address
      xx Exit
   def_verb_end find_char_address

   def_verb "find-char-index", find_char_index
      ;; (* char, [address, length] -- index or -1 *)
      ;; (* index start from Zero *)
      xx over
      xx xxxswapx
      xx find_char_address
      xx dup, _literal, 0, less_than?, _false?branch, 4
      xx   swap, drop
      xx   Exit
      xx swap, subtraction
      xx Exit
   def_verb_end find_char_index


   ;; (* test:
   ;;  * 'k' s" k" find-char-index . (* 0 *) cr
   ;;  * 'k' s" kkk" find-char-index . (* 0 *) cr
   ;;  * 'k' s" skkk" find-char-index . (* 1 *) cr
   ;;  * 'k' s"  kkk" find-char-index . (* 1 *) cr
   ;;  * 'k' s" 0123456789k" find-char-index . (* 10 *) cr
   ;;  * 'k' s" "0123456789 find-char-index . (* -1 *) cr
   ;;  *)
   #+end_src
** cr
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "cr", cr
      ;; (* -- *)
      xx _literal, ASCII_linefeed, write_byte
      xx Exit
   def_verb_end cr
   #+end_src
* >< hash-table for symbol
** note
   1. "string-hash->index index-hashback->string"
      is a identity function
      and if the argument is a index returned by "string-hash->index"
      "index-hashback->string string-hash->index"
      also is a identity function
   2. you can set a value  (of size Cell-width)
      to every symbol in this hash-table
      by:
      (* value, index *) index->address save
      dynamic type system make use of it
      for I implement type-tag as a special symbol
      but you should NOT set a pair to a symbol
      for I can not afford to let gc scan the whole hash-table to mark it
   3. hash-function (string)
      ==> (sum-up [byte_n * 2^n]) mod Number-of-symbol-entrys
      + where:
        0 <= n < Symbol-max-length
        and the Number-of-symbol-entrys is a prime number
      after sum-up, the greatest number < 2^(Symbol-max-length + 8)
      so I let Symbol-max-length == 64 - 8 == 56
      only first Symbol-max-length of the string is used by the hash-function
   -----------------------------
   1. string-hash->index index-hashback->string
      这两个函数的复合 所得到的 将是一个 恒等函数
      并且 如果 参数 是 一个 由 string-hash->index 返回的 index
      那么 index-hashback->string string-hash->index
      这两个函数的复合 所得到的 也将是一个 恒等函数
   2. 也就是说 在每次系统运行的时候
      这两个函数都会伪装成一个 无穷集上的 一对互逆映射
      但是 要知道 这是不可能的 计算机 对无穷集的实现只能是假的
   3. 散列表中的每一项 都有一个域
      可以用来保存一个 大小为 Cell-width 的值
      其使用方式如下
      (* value, index *) index->address save
      动态类型系统 把这个 量解释为 类型的类型
      但是需要注意的是
      不能用这个 域来保存 pair
      因为 我不能让 garbage-collectior 在每个工作周期的开始时
      扫描整个 hash-table
   3. 用类似数学表达式 来表示 这里所使用的 散列函数 如下 :
      hash-function (string)
      ==> (sum-up [byte_n * 2^n]) mod Number-of-symbol-entrys
      + 其中 :
        0 <= n < Symbol-max-length
        并且 Number-of-symbol-entrys 是一个素数
      在用 sum-up 相加之后 最大的可能的和 < 2^(Symbol-max-length + 8)
      所以 我定义 Symbol-max-length == 64 - 8 == 56
      每个字符串中 只有前 Symbol-max-length 个字符被 hash-function 使用到了
      因此 前 Symbol-max-length 个字符 相同的两个字符串 一定会相互冲突
** string-hash->index & index-hashback->string
   #+begin_src fasm :tangle threaded-code.inc
   ;; (* a Symbol-entry [unit : byte]
   ;;  * ==========================
   ;;  *  ||   8 : Symbol-value   ||
   ;;  * --------------------------
   ;;  *  ||   1 : Symbol-length  ||
   ;;  * --------------------------
   ;;  *  || 56+ : Symbol-string  ||
   ;;  * ==========================
   ;;  * where Symbol-max-length = 56
   ;;  *)

   #+end_src
* >< type
** note
   1. garbage-collectior needs type
      for it have to be able to distinguish
      <pair> from <non-pair>
      i.e. address from value
   2. a type-tag is implemented as a symbol
      i.e. a index of hash-table for symbol
      and the structure of an entry in hash-table
      can be made rich enough to hold needed informations
      for example, a type field is very useful
      i.e. a type field in an entry of the hash-table
      can denote the type of type
      thus <pair> and <non-pair> are distinguished
   3. 但是
      其实 这些类型标签 只是 在 pair 的数组中
      才有相对完备的 去 区分量的类型的功能
      而在 某些情况下 它们是不充分的
      这在于
      因为我没有 限制所有的量都 必须是这种带有 类型标签的
      占据 两个 Cell 的量
      这导致了
      在某些情况下 我还是必须使用 地址 来判断某个量是不是 <pair>
      虽然导致了 一些不谐
      但是 这是可以接受的
      因为 实现 <pair> 的只不过是一个 结构化的 数组而已
   4. 我必须做一些相对复杂的 对数组中所保存的量 的匹配
      才能 在某些特殊的情况下 对 pair 做判断
      比如 对于 noun
      为了在 garbage-collectior 的工作周期的开始时 初始化被染色的 pair
      我需要 看这个 noun 的大小是不是 大于1
      同时 还需要在其中找 <pair>
      当找到的时候 需要看 入栈之时 这个 <pair> 是不是在最末尾
      如果不是 在最末尾 那么它和它之后的那个量才有可能 组成一个 带有类型标签的量
      这是 需要看它之后 的那个量 作为一个地址 是不是 在 pair 的数组 中的合适的位置
      如果是的话 就认为 这个 noun 中保存了一个 动态类型的量
      此时 根据 garbage-collectior 的需要 来处理这个量 就可以了
   5. 另外关于 garbage-collectior 的一个难点是
      当我允许在数据段中出现 链表 的时候
      这些 链表 必须是绝对静态的
      并且要知道 这些 链表是在 pair 的数组之外的
      garbage-collectior 应该以特殊的方式处理这些 东西
      我想 这是可以实现的
      这个问题留到具体实现的候再去考虑
** implementation
* dictionary & lexicographer
** explainers & execute & Exit
   #+begin_src fasm :tangle threaded-code.inc
   def_assembly_code "execute", execute
      ;; ( word[address of explainer] -- )
      pop_argument_stack Explainer_pointer
      jmp qword[Explainer_pointer]

   ;; when someone try to find a word in the dictionary,
   ;; the explainer of that word explains the word for him or her

   ;; explain_verb 会贴贴一个 纸条 到 木条 上

   hereCode
   explain_verb:
      ;;  Explainer_pointer  == address
      ;; [Explainer_pointer] == explain_verb
      ;; 1. if NOT at the end of the function body
      ;;    (* Return-stack::
      ;;          -- [address of explainer] + Cell_width *)
      ;; 2. if at the end of the function body
      ;;    (* Return-stack::
      ;;          -- *)
      ;; and jump to the explainer of the [address of explainer]
      mov rbx, Explainer_pointer

      add rbx, Cell_width
      ;; to handle empty function-body
      cmp dword[rbx], Exit
      je empty_function_body
      cmp dword[rbx], 已矣
      je empty_function_body

      mov Explainer_pointer, [rbx]
      add rbx, Cell_width
      ;; to handle function-body of size 1
      cmp dword[rbx], Exit
      je at_the_end_of_function_body
      cmp dword[rbx], 已矣
      je at_the_end_of_function_body

      push_return_stack rbx

   at_the_end_of_function_body:
      jmp qword[Explainer_pointer]

   empty_function_body:
      next


   hereCode
   explain_noun:
      ;;  Explainer_pointer  == address
      ;; [Explainer_pointer] == explain_noun
      ;; (* -- value, ... *)
      mov rbx, Explainer_pointer
      sub rbx, (5 * Cell_width)
      mov rcx, [rbx]
   .loop:
      add Explainer_pointer, Cell_width
      mov rbx, [Explainer_pointer]
      push_argument_stack rbx
      dec rcx
      test rcx, rcx
      jnz .loop
      next


   ;; the following Exit helps tail-call-optimization
   ;; it just let you decide where is the end of FunctionBody
   ;; in a FunctionBody, the "Exit" as a word will never be called

   def_noun "Exit", Exit
      xx Exit
   def_noun_end Exit

   ;; we need the following
   ;; for this word is so special
   def_noun "The-Exit", The_Exit
      xx Exit
   def_noun_end The_Exit

   ;; def_verb "t", t
   ;;    xx The_Exit
   ;;    xx The_Exit
   ;;    xx equal?, print_little_number
   ;;    xx Exit
   ;; def_verb_end t

   def_noun "已矣", 已矣
      xx 已矣
   def_noun_end 已矣

   ;; ><><>< that is the Chinese version of "The-Exit"

   def_noun "Verb-explainer", Verb_explainer
      xx explain_verb
   def_noun_end Verb_explainer

   def_noun "Noun-explainer", Noun_explainer
      xx explain_noun
   def_noun_end Noun_explainer
   #+end_src
** word->field-of-word
   #+begin_src fasm :tangle threaded-code.inc
   ;; recall
   ;; a word in the dictionary (unit : Cell_width = 8 bytes)
   ;; ==
   ;;    ||  1 : name-string-header  ||
   ;;    ||  m : name-string  ||
   ;;    ||  1 : SizeOfFunctionBody  ||
   ;;    ||  1 : identification  ||
   ;;    ||  1 : link  ||
   ;;    ||  1 : type  ||
   ;;    ||  1 : address-of-name-string-header  ||
   ;;    ||  1 : address-of-explainer  ||
   ;;    ||  n : body  ||
   ;; where
   ;;   ||  1 : type  ||
   ;; ==
   ;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
   ;; type-bit-63 is for HiddenWord
   ;; type-bit-0,1,2 are for word type
   ;; 0 -- function
   ;; 1 -- key word

   WordType_HiddenMask = (1 shl 63)

   def_verb "word->size", word_to_size
      ;; (* word.link[address] -- word.size[value] *)
      xx _literal, Cell_width
      xx _literal, -2, multiple
      xx addition, fetch
      xx Exit
   def_verb_end word_to_size

   def_verb "word->address-of-size", word_to_address_of_size
      ;; (* word.link[address] -- word.address-of-size[address] *)
      xx _literal, Cell_width
      xx _literal, -2, multiple
      xx addition
      xx Exit
   def_verb_end word_to_address_of_size

   def_verb "word->id", word_to_id
      ;; (* word.link[address] -- word.id[address also as value] *)
      xx _literal, Cell_width
      xx _literal, -1, multiple
      xx addition
      xx Exit
   def_verb_end word_to_id

   def_verb "word->type", word_to_type
      ;; (* word.link[address] -- word.type[value] *)
      xx _literal, Cell_width
      xx addition, fetch
      xx Exit
   def_verb_end word_to_type

   def_verb "word->address-of-type", word_to_address_of_type
      ;; (* word.link[address] -- word.type[address] *)
      xx _literal, Cell_width
      xx addition
      xx Exit
   def_verb_end word_to_address_of_type

   def_verb "word->name-string", word_to_name_string
      ;; (* link[address] -- string[address, length] *)
      xx _literal, Cell_width
      xx _literal, 2, multiple
      xx addition
      xx fetch
      xx dup, _literal, Cell_width, addition
      xx swap, fetch
      xx Exit
   def_verb_end word_to_name_string

   def_verb "word->explainer", word_to_explainer
      ;; (* word[address of link] -- word[address of explainer] *)
      xx _literal, Cell_width
      xx _literal, 3, multiple
      xx addition
      xx Exit
   def_verb_end word_to_explainer

   def_verb "word->description", word_to_description
      ;; (* word.link[address] -- word.description[address] *)
      xx _literal, Cell_width
      xx _literal, 4, multiple
      xx addition
      xx Exit
   def_verb_end word_to_description
   #+end_src
** find (dictionary look up)
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "help,find", help__find
      ;; (* wordString[address, length], link[address] -- word[address of link] or Zero *)
      xx dup, zero?, _false?branch, 6
      xx   drop, drop2
      xx   _literal, 0
      xx   Exit
      xx dup, push_lambda_stack
      xx word_to_name_string, xxoverxx
      xx equal_string?, _false?branch, 4
      xx   drop2, pop_lambda_stack
      xx   Exit
      xx pop_lambda_stack, fetch
      xx help__find
      xx Exit
   def_verb_end help__find

   def_verb "find", find
      ;; (* wordString[address, length] -- word[address of link] or Zero *)
      xx First_word_in_dictionary
      xx help__find
      xx Exit
   def_verb_end find
   #+end_src
** note about distinguishing word from input
   1. read-byte 给 input 做好了抽象
      使得 从 input 中读字符
      和 取一个字符串的头一个字符 不同的是
      从 input 读字符是 有来无回的
   2. 每次只有发现在 blank 和 non-blank 的边界的时候
      才能知道这是一个 word 的边界
      比如: "   kkk   "
      开始发现 kkk 这个 word 的时候
      处在开头的 边界位置的 "k" 一定已经从 input 中被取出来了
      结束发现 kkk 这个 word 的时候
      处在结尾的 边界位置的 " " 一定已经从 input 中被取出来了
   3. 这就是 我需要 read-word,while-saving-to-string 的原因
      即 我要 在某种程度上 改变 "有来无回" 的情况
** read-word,while-saving-to-string
   #+begin_src fasm :tangle threaded-code.inc
   ;; 1. the following functions are for read-phrase
   ;; 2. 需要 一个 另一个版本的 read_word
   ;;    来 帮助 实现 read-word-string,for-lexicographer
   ;; 3. 这是必要的
   ;;    因为 否则 用来读字符串的函数就实现不好

   ;; (* helper functions *)
   def_verb "string-append-char", string_append_char
      ;; (* string[address, length], char -- string[address, length+1] *)
      xx xxoverx, addition, save_byte
      xx add1
      xx Exit
   def_verb_end string_append_char

   ;; 这个版本的函数 每次读一个 char 之后 都会先把它存到字符串中

   def_verb "read-first-non-blank-char,while-saving-to-string", read_first_non_blank_char__while_saving_to_string
      ;; (* string[address, length] --
      ;;    string-with-char[address, length], FirstNonBlankChar *)
      xx read_byte, dup, push_lambda_stack
      xx   string_append_char
      xx pop_lambda_stack
      xx dup, _literal, ASCII_space, greater_than?, _false?branch, 2
      xx   Exit
      xx drop
      xx read_first_non_blank_char__while_saving_to_string
      xx Exit
   def_verb_end read_first_non_blank_char__while_saving_to_string


   hereUnInitializedData
   ;; ------------------------------------------
   ;; note that, Subsequent calls will overwrite Buffer_for_read_word
   ;; this is why there is another function "read_word_for_runtime"
   Max_word_length = 1024

   Buffer_for_read_word__while_saving_to_string labeling
           preserve Max_word_length

   def_verb "read-word,while-saving-to-string", read_word__while_saving_to_string
      ;; (* string[address, length] --
      ;;    string-with-word[address, length], word-string[address, length] *)

      xx read_first_non_blank_char__while_saving_to_string
      xx _literal, Buffer_for_read_word__while_saving_to_string, save_byte
      xx _literal, 1, push_lambda_stack
      xx _literal, Buffer_for_read_word__while_saving_to_string, add1
      xx push_lambda_stack

      .read_byte:
      xx read_byte
      xx dup, xxoverxx, addition, save_byte, swap, add1, swap
      xx dup, _literal, ASCII_space, greater_than?, _false?branch, ((.then - $) / Cell_width)
      xx   pop_lambda_stack, tuck, save_byte, add1
      xx   pop_lambda_stack, add1
      xx   push_lambda_stack
      xx   push_lambda_stack
      xx   _branch, (-($ - .read_byte) / Cell_width)
      .then:

      xx drop
      xx pop_lambda_stack, drop
      xx _literal, Buffer_for_read_word__while_saving_to_string
      xx pop_lambda_stack
      xx Exit
   def_verb_end read_word__while_saving_to_string
   #+end_src
** find-word-boundary-address & find-word-boundary-index
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "find-word-boundary-address,begin", find_word_boundary_address__begin
      ;; (* [address, length] -- address or -1 *)
      xx dup, zero?, _false?branch, 5
      xx   drop2
      xx   _literal, -1
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, ASCII_space, greater_than?, _false?branch, 4
      xx   drop
      xx   sub1
      xx   Exit
      xx find_word_boundary_address__begin
      xx Exit
   def_verb_end find_word_boundary_address__begin

   ;; end will always success
   ;; so be careful when use it to save and fetch from string
   def_verb "find-word-boundary-address,end", find_word_boundary_address__end
      ;; (* [address, length] -- address or -1 *)
      xx dup, zero?, _false?branch, 3
      xx   drop
      xx   Exit
      ;; 对第一个做特殊处理 以保证 不再 word 内时 也能有效
      xx tail_and_head_of_string
      xx _literal, ASCII_space
      xx less_or_equal?, _false?branch, (.dup-$)/Cell_width
      xx   dup2, find_word_boundary_address__begin
      xx   dup, _literal, -1, equal?, _false?branch, 6
      xx     drop, drop2
      xx     _literal, -1
      xx     Exit
      xx   xxtuckx
      xx   xswapxx
      xx   subtraction, subtraction
      .dup:
      xx dup, zero?, _false?branch, 3
      xx   drop
      xx   Exit
      xx tail_and_head_of_string
      xx _literal, ASCII_space, less_or_equal?, _false?branch, 4
      xx   drop
      xx   sub1
      xx   Exit
      xx _branch, (.dup-$)/Cell_width
      xx Exit
   def_verb_end find_word_boundary_address__end


   def_verb "find-word-boundary-index,begin", find_word_boundary_index__begin
      ;; (* [address, length] -- index or -1 *)
      ;; (* index start from Zero *)
      xx over
      xx swap
      xx find_word_boundary_address__begin
      xx dup, _literal, -1, equal?, _false?branch, 4
      xx   swap, drop
      xx   Exit
      xx swap, subtraction
      xx Exit
   def_verb_end find_word_boundary_index__begin

   def_verb "find-word-boundary-index,end", find_word_boundary_index__end
      ;; (* [address, length] -- index or -1 *)
      ;; (* index start from Zero *)
      xx over
      xx swap
      xx find_word_boundary_address__end
      xx dup, _literal, -1, equal?, _false?branch, 4
      xx   swap, drop
      xx   Exit
      xx swap, subtraction
      xx Exit
   def_verb_end find_word_boundary_index__end



   ;; test:
   ;; :" k" find-word-boundary-index,begin . (* 0 *) cr
   ;; :" kkk" find-word-boundary-index,begin . (* 0 *) cr
   ;; :"  kkk" find-word-boundary-index,begin . (* 1 *) cr
   ;;
   ;; :" k" find-word-boundary-index,end . (* 1 *) cr
   ;; :" kkk" find-word-boundary-index,end . (* 3 *) cr
   ;; :"  kkk" find-word-boundary-index,end . (* 4 *) cr
   ;; :"   kkk" find-word-boundary-index,end . (* 5 *) cr
   #+end_src
** tail-and-head-of-word-string
   #+begin_src fasm :tangle threaded-code.inc
   ;; the following 3 functions can not apply on string-full-of-blank
   ;; before call them
   ;; one should make sure the argument is not string-full-of-blank

   def_verb "head-of-word-string", head_of_word_string
      ;; (* word-string[address, length] -- word[address, length] *)
      xx dup2, find_word_boundary_address__begin
      ;; ><><>< need error check here in the future
      ;; 也就是 先假设上面的函数 返回正确的 address
      xx xxswapx
      xx find_word_boundary_address__end
      xx over, subtraction
      xx Exit
   def_verb_end head_of_word_string

   def_verb "tail-of-word-string", tail_of_word_string
      ;; (* word-string[address, length] -- word-string[new address, length - n] *)
      xx dup2, find_word_boundary_index__end
      ;; ><><>< need error check here in the future
      ;; 也就是 先假设上面的函数 返回正确的 address
      xx tuck
      xx subtraction
      xx xxswapx
      xx addition
      xx swap
      xx Exit
   def_verb_end tail_of_word_string

   def_verb "tail-and-head-of-word-string", tail_and_head_of_word_string
      ;; (* word-string[address, length] --
      ;;    word-string[new address, length - n], word[address, length] *)
      xx dup2
      xx tail_of_word_string
      xx xxswapxx
      xx head_of_word_string
      xx Exit
   def_verb_end tail_and_head_of_word_string
   #+end_src
** compile-word-description-to-here
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "compile-number-to-here", compile_number_to_here
      ;; (* a 64 bits number -- *)
      ;; reset "Here", which points next free memory
      xx Here
      xx save
      xx Here
      xx _literal, Cell_width, addition
      xx _address, Here, save
      xx Exit
   def_verb_end compile_number_to_here

   ;; note that:
   ;; a string in stack is string[address, length]
   ;; a string in memory is
   ;;   ||  1 : length  ||  n : string  ||  1 : 0  ||
   def_verb "compile-string-to-here", compile_string_to_here
      ;; (* string[address, length] -- *)
      ;; for update Here
      xx dup, push_lambda_stack
      xx   dup, compile_number_to_here
      xx   Here, swap, copy_byte_string
      ;; update Here
      xx pop_lambda_stack
      xx Here, addition
      xx _literal, 0, over, save_byte
      xx add1
      xx _address, Here, save
      xx Exit
   def_verb_end compile_string_to_here


   def_verb "help:compile-word-description-to-here,number", help__compile_word_description_to_here__number
      ;; (* string[address, length] -- *)
      ;; reading-error reported by "number" is not handled
      xx _literal, _literal, compile_number_to_here
      xx string_to_integer__with_error, drop, compile_number_to_here
      xx Exit
   def_verb_end help__compile_word_description_to_here__number

   ;; error handling when not found is after debuger
   def_verb "help:compile-word-description-to-here,word", help__compile_word_description_to_here__word
      ;; (* string[address, length] -- *)
      xx find, word_to_explainer, compile_number_to_here
      xx Exit
   def_verb_end help__compile_word_description_to_here__word

   def_verb "help:compile-word-description-to-here,key-word", help__compile_word_description_to_here__key_word
      ;; (* word-string[address, length], string[address, length] -- word-string[address, length] *)
      xx find, word_to_explainer, execute
      xx Exit
   def_verb_end help__compile_word_description_to_here__key_word


   def_verb "compile-word-description-to-here", compile_word_description_to_here
      ;; (* word-string[address, length] -- *)
      xx dup2, string_full_of_blank?, _false?branch, 3
      xx   drop2
      xx   Exit

      xx tail_and_head_of_word_string
      ;; ;; (* for debug *)
      ;; xx dup2, print_string, cr

      xx dup2, string_denote_integer?, _false?branch, 4
      xx   help__compile_word_description_to_here__number
      xx   compile_word_description_to_here
      xx   Exit
      xx dup2, string_denote_key_word?, _false?branch, 4
      xx   help__compile_word_description_to_here__key_word
      xx   compile_word_description_to_here
      xx   Exit
      ;; else
      ;; 这里一定要对查找的结果进行 错误处理
      xx   help__compile_word_description_to_here__word
      xx   compile_word_description_to_here
      xx   Exit
   def_verb_end compile_word_description_to_here
   #+end_src
** define-verb
*** note
    1. to create a new word
       is to use some words to describe the new word
       and let an explainer to explain the description of the new word
    2. to define a new word
       is to add the new created word to the dictionary
    3. 当在函数定义内引用自身的时候
       总会形成递归调用
       如果词典中已经 有要定义的函数了 也不会去找它
       唯一不 使得这种特性变得不理想的情形是:
       你在重新定义一个词的时候 需要调用旧的词本身
       这种情况非常少 并且出现的时候也很容易解决
*** string_denote_key_word?
    #+begin_src fasm :tangle threaded-code.inc
    ;; a string denotes key-word or not
    ;; is not depended on the morphology of the string
    def_verb "string-denote-key-word?", string_denote_key_word?
       ;; (* string[address, length] -- True or False *)
       xx find
       xx dup, _literal, 0, equal?, _false?branch, 2   
       xx   Exit
       xx word_to_type
       xx _literal, 111b, bitwise_and
       xx _literal, 1, equal?, _false?branch, 3
       xx   True
       xx   Exit
       xx False
       xx Exit
    def_verb_end string_denote_key_word?
    #+end_src
*** helper functions
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "create-word-header", create_word_header
       ;; (* string[address, length] -- word[address of link] *)
       xx Here, push_lambda_stack ;; for address-of-name-string-header
       xx   compile_string_to_here
       xx   _literal, 0, compile_number_to_here ;; (* SizeOfFunctionBody *)
       xx   Here, compile_number_to_here ;; (* identification *)
       xx   Here ;; (* leave the word[link] as return-value *)
       xx   _literal, 0, compile_number_to_here ;; (* link *)
       xx   _literal, 0, compile_number_to_here ;; (* type *)
       xx pop_lambda_stack, compile_number_to_here ;; address-of-name-string-header
       xx Exit
    def_verb_end create_word_header

    def_verb "add-new-word-to-dictionary", add_new_word_to_dictionary
       ;; reset First_word_in_dictionary to point to the newly defined word
       ;; (* word[address of link] -- *)
       xx dup
       xx First_word_in_dictionary
       xx swap
       xx save
       xx _address, First_word_in_dictionary, save
       xx Exit
    def_verb_end add_new_word_to_dictionary

    ;; the following function
    ;; must be called at the end of word definition
    ;; i.e. after "compile_word_description_to_here"
    ;; for it uses "Here" as an implicit argument
    def_verb "set-size-of-word", set_size_of_word
       ;; (* word[address of link] -- *)
       xx dup, word_to_description
       xx Here, swap, subtraction
       xx _literal, Cell_width, division
       xx swap, word_to_address_of_size
       xx save
       xx Exit
    def_verb_end set_size_of_word
    #+end_src
*** implementation
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "define-verb", define_verb
       ;; (* words-string[address, length] -- *)
       xx tail_and_head_of_word_string
       xx create_word_header
       xx dup, push_lambda_stack
       xx   add_new_word_to_dictionary
       xx   Verb_explainer, compile_number_to_here
       xx   compile_word_description_to_here
       xx pop_lambda_stack
       xx set_size_of_word
       xx Exit
    def_verb_end define_verb

    def_verb "define-function", define_function
       ;; (* words-string[address, length] -- *)
       xx define_verb
       xx Exit
    def_verb_end define_function
    #+end_src
** eval-string,for-define
*** note
    1. eval == compile and call
    2. here the Buffer_of_data_section will NOT be overwrited
       while Buffer_of_function_body will be overwrited
    3. just use the global data section
    4. nested calling is not allowed
       nested calling needs GC about string
*** implementation
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "eval-string,for-define", eval_string__for_define
       ;; (* string[address, length] -- *)
       xx compile_string__for_define, call_compiled_string__for_define
       xx Exit
    def_verb_end eval_string__for_define
    #+end_src
*** compile-string
    #+begin_src fasm :tangle threaded-code.inc
    hereUnInitializedData
    ;; ------------------------
    Size_of_buffer_of_function_body__for_compile_string__for_define = 1024*1024

    Buffer_of_function_body__for_compile_string__for_define labeling
            preserve Size_of_buffer_of_function_body__for_compile_string__for_define


    def_verb "compile-string,for-define", compile_string__for_define
       ;; (* word-string[address, length] --  *)
       xx Here, push_lambda_stack

       xx   _literal, Buffer_of_function_body__for_compile_string__for_define
       xx   _address, Here, save

       xx   Verb_explainer, compile_number_to_here
       xx   compile_word_description_to_here
       xx   The_Exit, compile_number_to_here

       xx pop_lambda_stack, _address, Here, save
       xx Exit
    def_verb_end compile_string__for_define
    #+end_src
*** call-compiled-string
    #+begin_src fasm :tangle threaded-code.inc
    def_verb "call-compiled-string,for-define", call_compiled_string__for_define
       ;; (* -- unknown *)
       xx _literal, Buffer_of_function_body__for_compile_string__for_define
       xx execute
       xx Exit
    def_verb_end call_compiled_string__for_define
    #+end_src
** compile-word-description-to-here,for-noun
   #+begin_src fasm :tangle threaded-code.inc
   def_noun "Mark:compile-word-description-to-here,for-noun", Mark__compile_word_description_to_here__for_noun
      xx 0
   def_noun_end Mark__compile_word_description_to_here__for_noun

   def_verb "compile-word-description-to-here,for-noun", compile_word_description_to_here__for_noun
      ;; (* word-string[address, length] -- *)
      xx push_lambda_stack, push_lambda_stack
      xx   fetch_argument_stack_pointer
      xx   _address, Mark__compile_word_description_to_here__for_noun, save
      xx pop_lambda_stack, pop_lambda_stack

      xx eval_string__for_define

      ;; note that, when push stack grows to lower address
      xx fetch_argument_stack_pointer
      xx Mark__compile_word_description_to_here__for_noun
      xx swap, subtraction
      xx _literal, Cell_width, division
      ;; need error handling on negate number

      ;; (* ..., value, counter *)
      xx argument_stack_shift_to_lambda_stack
      xx pop_lambda_stack
      .dup:
      xx dup, zero?, _false?branch, (.sub1-$)/Cell_width
      xx   drop
      xx   Exit
      .sub1:
      xx sub1
      xx pop_lambda_stack, compile_number_to_here
      xx _branch, (.dup-$)/Cell_width
   def_verb_end compile_word_description_to_here__for_noun
   #+end_src
** define
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "define", _define
      ;; (* words-string[address, length] -- *)
      xx tail_and_head_of_word_string
      xx create_word_header
      xx dup, push_lambda_stack
      xx   add_new_word_to_dictionary
      xx   Noun_explainer, compile_number_to_here
      xx   compile_word_description_to_here__for_noun
      xx pop_lambda_stack
      xx set_size_of_word
      xx Exit
   def_verb_end _define
   #+end_src
** define-key-word
   #+begin_src fasm :tangle threaded-code.inc
   def_verb "define-key-word", define_key_word
      ;; (* words-string[address, length] -- *)
      xx tail_and_head_of_word_string
      xx create_word_header
      xx dup, push_lambda_stack
      xx   add_new_word_to_dictionary
      xx   Verb_explainer, compile_number_to_here
      xx   compile_word_description_to_here
      xx pop_lambda_stack
      xx dup, set_size_of_word
      xx word_to_address_of_type
      xx _literal, 1, swap, save_byte
      xx Exit
   def_verb_end define_key_word
   #+end_src
* chinese lexicographer
  #+begin_src fasm :tangle threaded-code.inc
  def_verb "动词也", 动词也
     ;; (* words-string[address, length] -- *)
     xx define_verb
     xx Exit
  def_verb_end 动词也

  def_verb "函数也", 函数也
     ;; (* words-string[address, length] -- *)
     xx define_function
     xx Exit
  def_verb_end 函数也

  def_verb "也", 也
     ;; (* words-string[address, length] -- *)
     xx _define
     xx Exit
  def_verb_end 也

  def_verb "虚词也", 虚词也
     ;; (* words-string[address, length] -- *)
     xx define_key_word
     xx Exit
  def_verb_end 虚词也
  #+end_src
* --------------------------------------------------
* memory allocation
** Pair-constructions-array
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   ;;   (unit : byte)
   ;; ========================
   ;;   ||  1 : color     ||
   ;; ------------------------
   ;;   ||  8 : type tag  ||
   ;;   ||  8 : value     ||
   ;; ------------------------
   ;;   ||  8 : type tag  ||
   ;;   ||  8 : value     ||
   ;; ========================
   hereUnInitializedData
   Clr_bytes_size = 1
   Car_bytes_size = 16
   Cdr_bytes_size = 16
   Cons_bytes_size = Clr_bytes_size + Car_bytes_size + Cdr_bytes_size
   Number_of_pair_constructions = 100 * 1024

           preserve Clr_bytes_size
   In_front_of_the_first_pair_construction labeling
           preserve (Car_bytes_size + Cdr_bytes_size)

           preserve Clr_bytes_size
   First_pair_construction labeling
           preserve (Car_bytes_size + Cdr_bytes_size)

           ;; ==========================
           preserve ((Number_of_pair_constructions - 2) * Cons_bytes_size)
           ;; ==========================

           preserve Clr_bytes_size
   Last_pair_construction labeling
           preserve (Car_bytes_size + Cdr_bytes_size)

   def_noun "Clr-bytes-size"    , _Clr_bytes_size
      xx  Clr_bytes_size
   def_noun_end   _Clr_bytes_size

   def_noun "Car-bytes-size"    , _Car_bytes_size
      xx  Car_bytes_size
   def_noun_end   _Car_bytes_size

   def_noun "Cdr-bytes-size"    , _Cdr_bytes_size
      xx  Cdr_bytes_size
   def_noun_end   _Cdr_bytes_size

   def_noun "Cons-bytes-size"  , _Cons_bytes_size
      xx  Cons_bytes_size
   def_noun_end  _Cons_bytes_size


   def_noun "Number-of-pair-constructions", _Number_of_pair_constructions
      xx  Number_of_pair_constructions
   def_noun_end _Number_of_pair_constructions


   def_noun "In-front-of-the-first-pair-construction", _In_front_of_the_first_pair_construction
      xx  In_front_of_the_first_pair_construction
   def_noun_end _In_front_of_the_first_pair_construction

   def_noun "First-pair-construction", _First_pair_construction
      xx  First_pair_construction
   def_noun_end _First_pair_construction

   def_noun "Last-pair-construction",  _Last_pair_construction
      xx   Last_pair_construction
   def_noun_end  _Last_pair_construction


   def_noun "Current-free-pair-construction", Current_free_pair_construction
      xx  First_pair_construction
   def_noun_end Current_free_pair_construction
   #+end_src
** Hash-Table-For-Symbol
   using linear probing
   so, the load factor must be lower then 0.5
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   ;; a Symbol_entry (unit : byte)
   ;; ===========================
   ;;  ||   8 : Symbol_value   ||
   ;; ---------------------------
   ;;  ||   1 : Symbol_length  ||
   ;; ---------------------------
   ;;  || 56+ : Symbol_string  ||
   ;; ===========================

   Symbol_length_bytes_size = 1
   Symbol_value_bytes_size  = 8
   Symbol_string_bytes_size = 56+0
   Symbol_max_length       = 56
   Symbol_entry_bytes_size = Symbol_value_bytes_size + Symbol_length_bytes_size + Symbol_string_bytes_size
   ;; Number_of_symbol_entrys = 1000003
   ;; Number_of_symbol_entrys = 1000033
   ;; Number_of_symbol_entrys = 1000333
   ;; Number_of_symbol_entrys = 100003
   Number_of_symbol_entrys = 100333
   ;; Number_of_symbol_entrys = 997
   ;; Number_of_symbol_entrys = 499
   ;; Number_of_symbol_entrys = 230 ;; for a special test

   First_symbol_entry labeling
           preserve Symbol_entry_bytes_size

           ;; ========================
           preserve ((Number_of_symbol_entrys - 2) * Symbol_entry_bytes_size)
           ;; ========================

   Last_symbol_entry labeling
           preserve Symbol_entry_bytes_size

   def_noun "Number-of-symbol-entrys",  _Number_of_symbol_entrys
      xx   Number_of_symbol_entrys
   def_noun_end  _Number_of_symbol_entrys

   def_noun "Symbol-value-bytes-size",  _Symbol_value_bytes_size
      xx   Symbol_value_bytes_size
   def_noun_end  _Symbol_value_bytes_size

   def_noun "Symbol-length-bytes-size", _Symbol_length_bytes_size
      xx  Symbol_length_bytes_size
   def_noun_end _Symbol_length_bytes_size

   def_noun "Symbol-string-bytes-size", _Symbol_string_bytes_size
      xx  Symbol_string_bytes_size
   def_noun_end _Symbol_string_bytes_size

   def_noun "Symbol-max-length",        _Symbol_max_length
      xx         Symbol_max_length
   def_noun_end        _Symbol_max_length

   def_noun "Symbol-entry-bytes-size",  _Symbol_entry_bytes_size
      xx   Symbol_entry_bytes_size
   def_noun_end  _Symbol_entry_bytes_size


   def_noun "First-symbol-entry", _First_symbol_entry
      xx  First_symbol_entry
   def_noun_end _First_symbol_entry

   def_noun "Last-symbol-entry",  _Last_symbol_entry
      xx   Last_symbol_entry
   def_noun_end  _Last_symbol_entry
   #+end_src
** two String_heap s
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   Size_of_string_heap = 5*1024*1024

   String_heap_1 labeling
           preserve Size_of_string_heap

   String_heap_2 labeling
           preserve Size_of_string_heap


   def_noun "Size-of-string-heap", _Size_of_string_heap
      xx  Size_of_string_heap
   def_noun_end _Size_of_string_heap


   def_noun "String-heap-1", _String_heap_1
      xx  String_heap_1
   def_noun_end _String_heap_1

   def_noun "String-heap-2", _String_heap_2
      xx  String_heap_2
   def_noun_end _String_heap_2
   #+end_src
** Buffer-for-load-file
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   Size_of_buffer_for_load_file = 4*1024*1024

   Buffer_for_load_file labeling
                preserve Size_of_buffer_for_load_file

   def_noun "Size-of-buffer-for-load-file", _Size_of_buffer_for_load_file
      xx  Size_of_buffer_for_load_file
   def_noun_end _Size_of_buffer_for_load_file

   def_noun "Buffer-for-load-file", _Buffer_for_load_file
      xx  Buffer_for_load_file
   def_noun_end _Buffer_for_load_file
   #+end_src
** Data_section
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData

   Size_of_data_section = 4*1024*1024

   Data_section labeling
                preserve Size_of_data_section

   def_noun "Data-section", _Data_section
      xx  Data_section
   def_noun_end _Data_section

   def_noun "Size-of-data-section", _Size_of_data_section
      xx  Size_of_data_section
   def_noun_end _Size_of_data_section


   def_noun "Current-data-section", Current_data_section
      xx  Data_section
   def_noun_end Current_data_section
   #+end_src
** ------------------------------------------
** Stacks
   1. after push the first value into ArgumentStack
      Argument_stack_pointer will point to the address of this value
   2. before push the first value into ArgumentStack
      Argument_stack_pointer point to StackTop
      and StackTop will never be used
   4. beware to understand how "StackBottom" and "StackTop" work
   #+begin_src fasm :tangle threaded-code.inc
   hereUnInitializedData
   ;; ReturnStack
   Size_of_return_stack = 100*1024*8

   Return_stack_bottom labeling
           preserve Size_of_return_stack
   Return_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; ArgumentStack
   Size_of_argument_stack = 100*1024*8

   Argument_stack_bottom labeling
           preserve Size_of_argument_stack
   Argument_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; GreyPairStack
   Size_of_grey_pair_stack = 100*1024*8

   Grey_pair_stack_bottom labeling
           preserve Size_of_grey_pair_stack
   Grey_pair_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; LambdaStack
   Size_of_lambda_stack = 100*1024*8

   Lambda_stack_bottom labeling
           preserve Size_of_lambda_stack
   Lambda_stack_top labeling
           preserve 100*8


   hereUnInitializedData
   ;; StackForEvalString
   Size_of_stack_for_eval_string = 1024*8

   Stack_for_eval_string_bottom labeling
           preserve Size_of_stack_for_eval_string
   Stack_for_eval_string_top labeling
           preserve 100*8


   def_noun "Return-stack-top",    _Return_stack_top
      xx     Return_stack_top
   def_noun_end    _Return_stack_top

   def_noun "Return-stack-bottom", _Return_stack_bottom
      xx  Return_stack_bottom
   def_noun_end _Return_stack_bottom


   def_noun "Argument-stack-top",    _Argument_stack_top
      xx     Argument_stack_top
   def_noun_end    _Argument_stack_top

   def_noun "Argument-stack-bottom", _Argument_stack_bottom
      xx  Argument_stack_bottom
   def_noun_end _Argument_stack_bottom


   def_noun "Lambda-stack-top",    _Lambda_stack_top
      xx     Lambda_stack_top
   def_noun_end    _Lambda_stack_top

   def_noun "Lambda-stack-bottom", _Lambda_stack_bottom
      xx  Lambda_stack_bottom
   def_noun_end _Lambda_stack_bottom


   def_noun "Stack-for-eval-string-top",    _Stack_for_eval_string_top
      xx     Stack_for_eval_string_top
   def_noun_end    _Stack_for_eval_string_top

   def_noun "Stack-for-eval-string-bottom", _Stack_for_eval_string_bottom
      xx  Stack_for_eval_string_bottom
   def_noun_end _Stack_for_eval_string_bottom
   #+end_src
* ==================================================
