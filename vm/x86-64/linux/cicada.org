#+TITLE: cicada for linux
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* preface
** linux header
*** parameters order of syscall
    #+begin_src fasm :tangle cicada.fasm
    define sys_6_r8  r8
    define sys_5_r9  r9
    define sys_4_r10 r10
    define sys_3_rdx rdx
    define sys_2_rsi rsi
    define sys_1_rdi rdi
    define sys_n_rax rax
    #+end_src
*** parameters order of function call
    #+begin_src fasm :tangle cicada.fasm
    define fun_6_r9  r9
    define fun_5_r8  r8
    define fun_4_rcx rcx
    define fun_3_rdx rdx
    define fun_2_rsi rsi
    define fun_1_rdi rdi
    #+end_src
*** linux syscall numbers
    #+begin_src fasm :tangle cicada.fasm
    ;; see /usr/include/asm/unistd_64.h (on archlinux)

    define syscall_read                      0
    define syscall_write                     1
    define syscall_open                      2
    define syscall_close                     3

    define syscall_stat                      4
    define syscall_fstat                     5
    define syscall_lstat                     6
    define syscall_poll                      7
    define syscall_lseek                     8
    define syscall_mmap                      9
    define syscall_mprotect                  10
    define syscall_munmap                    11
    define syscall_brk                       12
    define syscall_rt_sigaction              13
    define syscall_rt_sigprocmask            14
    define syscall_rt_sigreturn              15
    define syscall_ioctl                     16
    define syscall_pread64                   17
    define syscall_pwrite64                  18
    define syscall_readv                     19
    define syscall_writev                    20
    define syscall_access                    21
    define syscall_pipe                      22
    define syscall_select                    23
    define syscall_sched_yield               24
    define syscall_mremap                    25
    define syscall_msync                     26
    define syscall_mincore                   27
    define syscall_madvise                   28
    define syscall_shmget                    29
    define syscall_shmat                     30
    define syscall_shmctl                    31
    define syscall_dup2                      32
    define syscall_dup2                      33
    define syscall_pause                     34
    define syscall_nanosleep                 35
    define syscall_getitimer                 36
    define syscall_alarm                     37
    define syscall_setitimer                 38
    define syscall_getpid                    39
    define syscall_sendfile                  40
    define syscall_socket                    41
    define syscall_connect                   42
    define syscall_accept                    43
    define syscall_sendto                    44
    define syscall_recvfrom                  45
    define syscall_sendmsg                   46
    define syscall_recvmsg                   47
    define syscall_shutdown                  48
    define syscall_bind                      49
    define syscall_listen                    50
    define syscall_getsockname               51
    define syscall_getpeername               52
    define syscall_socketpair                53
    define syscall_setsockopt                54
    define syscall_getsockopt                55
    define syscall_clone                     56
    define syscall_fork                      57
    define syscall_vfork                     58
    define syscall_execve                    59

    define syscall_exit                      60

    define syscall_wait4                     61
    define syscall_kill                      62
    define syscall_uname                     63
    define syscall_semget                    64
    define syscall_semop                     65
    define syscall_semctl                    66
    define syscall_shmdt                     67
    define syscall_msgget                    68
    define syscall_msgsnd                    69
    define syscall_msgrcv                    70
    define syscall_msgctl                    71
    define syscall_fcntl                     72
    define syscall_flock                     73
    define syscall_fsync                     74
    define syscall_fdatasync                 75
    define syscall_truncate                  76
    define syscall_ftruncate                 77
    define syscall_getdents                  78
    define syscall_getcwd                    79
    define syscall_chdir                     80
    define syscall_fchdir                    81
    define syscall_rename                    82
    define syscall_mkdir                     83
    define syscall_rmdir                     84
    define syscall_creat                     85
    define syscall_link                      86
    define syscall_unlink                    87
    define syscall_symlink                   88
    define syscall_readlink                  89
    define syscall_chmod                     90
    define syscall_fchmod                    91
    define syscall_chown                     92
    define syscall_fchown                    93
    define syscall_lchown                    94
    define syscall_umask                     95
    define syscall_gettimeofday              96
    define syscall_getrlimit                 97
    define syscall_getrusage                 98
    define syscall_sysinfo                   99
    define syscall_times                     100
    define syscall_ptrace                    101
    define syscall_getuid                    102
    define syscall_syslog                    103
    define syscall_getgid                    104
    define syscall_setuid                    105
    define syscall_setgid                    106
    define syscall_geteuid                   107
    define syscall_getegid                   108
    define syscall_setpgid                   109
    define syscall_getppid                   110
    define syscall_getpgrp                   111
    define syscall_setsid                    112
    define syscall_setreuid                  113
    define syscall_setregid                  114
    define syscall_getgroups                 115
    define syscall_setgroups                 116
    define syscall_setresuid                 117
    define syscall_getresuid                 118
    define syscall_setresgid                 119
    define syscall_getresgid                 120
    define syscall_getpgid                   121
    define syscall_setfsuid                  122
    define syscall_setfsgid                  123
    define syscall_getsid                    124
    define syscall_capget                    125
    define syscall_capset                    126
    define syscall_rt_sigpending             127
    define syscall_rt_sigtimedwait           128
    define syscall_rt_sigqueueinfo           129
    define syscall_rt_sigsuspend             130
    define syscall_sigaltstack               131
    define syscall_utime                     132
    define syscall_mknod                     133
    define syscall_uselib                    134
    define syscall_personality               135
    define syscall_ustat                     136
    define syscall_statfs                    137
    define syscall_fstatfs                   138
    define syscall_sysfs                     139
    define syscall_getpriority               140
    define syscall_setpriority               141
    define syscall_sched_setparam            142
    define syscall_sched_getparam            143
    define syscall_sched_setscheduler        144
    define syscall_sched_getscheduler        145
    define syscall_sched_get_priority_max    146
    define syscall_sched_get_priority_min    147
    define syscall_sched_rr_get_interval     148
    define syscall_mlock                     149
    define syscall_munlock                   150
    define syscall_mlockall                  151
    define syscall_munlockall                152
    define syscall_vhangup                   153
    define syscall_modify_ldt                154
    define syscall_pivot_root                155
    define syscall__sysctl                   156
    define syscall_prctl                     157
    define syscall_arch_prctl                158
    define syscall_adjtimex                  159
    define syscall_setrlimit                 160
    define syscall_chroot                    161
    define syscall_sync                      162
    define syscall_acct                      163
    define syscall_settimeofday              164
    define syscall_mount                     165
    define syscall_umount2                   166
    define syscall_swapon                    167
    define syscall_swapoff                   168
    define syscall_reboot                    169
    define syscall_sethostname               170
    define syscall_setdomainname             171
    define syscall_iopl                      172
    define syscall_ioperm                    173
    define syscall_create_module             174
    define syscall_init_module               175
    define syscall_delete_module             176
    define syscall_get_kernel_syms           177
    define syscall_query_module              178
    define syscall_quotactl                  179
    define syscall_nfsservctl                180
    define syscall_getpmsg                   181
    define syscall_putpmsg                   182
    define syscall_afs_syscall               183
    define syscall_tuxcall                   184
    define syscall_security                  185
    define syscall_gettid                    186
    define syscall_readahead                 187
    define syscall_setxattr                  188
    define syscall_lsetxattr                 189
    define syscall_fsetxattr                 190
    define syscall_getxattr                  191
    define syscall_lgetxattr                 192
    define syscall_fgetxattr                 193
    define syscall_listxattr                 194
    define syscall_llistxattr                195
    define syscall_flistxattr                196
    define syscall_removexattr               197
    define syscall_lremovexattr              198
    define syscall_fremovexattr              199
    define syscall_tkill                     200
    define syscall_time                      201
    define syscall_futex                     202
    define syscall_sched_setaffinity         203
    define syscall_sched_getaffinity         204
    define syscall_set_thread_area           205
    define syscall_io_setup                  206
    define syscall_io_destroy                207
    define syscall_io_getevents              208
    define syscall_io_submit                 209
    define syscall_io_cancel                 210
    define syscall_get_thread_area           211
    define syscall_lookup_dcookie            212
    define syscall_epoll_create              213
    define syscall_epoll_ctl_old             214
    define syscall_epoll_wait_old            215
    define syscall_remap_file_pages          216
    define syscall_getdents64                217
    define syscall_set_tid_address           218
    define syscall_restart_syscall           219
    define syscall_semtimedop                220
    define syscall_fadvise64                 221
    define syscall_timer_create              222
    define syscall_timer_settime             223
    define syscall_timer_gettime             224
    define syscall_timer_getoverrun          225
    define syscall_timer_delete              226
    define syscall_clock_settime             227
    define syscall_clock_gettime             228
    define syscall_clock_getres              229
    define syscall_clock_nanosleep           230
    define syscall_exit_group                231
    define syscall_epoll_wait                232
    define syscall_epoll_ctl                 233
    define syscall_tgkill                    234
    define syscall_utimes                    235
    define syscall_vserver                   236
    define syscall_mbind                     237
    define syscall_set_mempolicy             238
    define syscall_get_mempolicy             239
    define syscall_mq_open                   240
    define syscall_mq_unlink                 241
    define syscall_mq_timedsend              242
    define syscall_mq_timedreceive           243
    define syscall_mq_notify                 244
    define syscall_mq_getsetattr             245
    define syscall_kexec_load                246
    define syscall_waitid                    247
    define syscall_add_key                   248
    define syscall_request_key               249
    define syscall_keyctl                    250
    define syscall_ioprio_set                251
    define syscall_ioprio_get                252
    define syscall_inotify_init              253
    define syscall_inotify_add_watch         254
    define syscall_inotify_rm_watch          255
    define syscall_migrate_pages             256
    define syscall_openat                    257
    define syscall_mkdirat                   258
    define syscall_mknodat                   259
    define syscall_fchownat                  260
    define syscall_futimesat                 261
    define syscall_newfstatat                262
    define syscall_unlinkat                  263
    define syscall_renameat                  264
    define syscall_linkat                    265
    define syscall_symlinkat                 266
    define syscall_readlinkat                267
    define syscall_fchmodat                  268
    define syscall_faccessat                 269
    define syscall_pselect6                  270
    define syscall_ppoll                     271
    define syscall_unshare                   272
    define syscall_set_robust_list           273
    define syscall_get_robust_list           274
    define syscall_splice                    275
    define syscall_tee                       276
    define syscall_sync_file_range           277
    define syscall_vmsplice                  278
    define syscall_move_pages                279
    define syscall_utimensat                 280
    define syscall_epoll_pwait               281
    define syscall_signalfd                  282
    define syscall_timerfd_create            283
    define syscall_eventfd                   284
    define syscall_fallocate                 285
    define syscall_timerfd_settime           286
    define syscall_timerfd_gettime           287
    define syscall_accept4                   288
    define syscall_signalfd4                 289
    define syscall_eventfd2                  290
    define syscall_epoll_create1             291
    define syscall_dup3                      292
    define syscall_pipe2                     293
    define syscall_inotify_init1             294
    define syscall_preadv                    295
    define syscall_pwritev                   296
    define syscall_rt_tgsigqueueinfo         297
    define syscall_perf_event_open           298
    define syscall_recvmmsg                  299
    define syscall_fanotify_init             300
    define syscall_fanotify_mark             301
    define syscall_prlimit64                 302
    define syscall_name_to_handle_at         303
    define syscall_open_by_handle_at         304
    define syscall_clock_adjtime             305
    define syscall_syncfs                    306
    define syscall_sendmmsg                  307
    define syscall_setns                     308
    define syscall_getcpu                    309
    define syscall_process_vm_readv          310
    define syscall_process_vm_writev         311
    define syscall_kcmp                      312
    define syscall_finit_module              313
    #+end_src
*** about open & read & write
    #+begin_src fasm :tangle cicada.fasm
    STDIN  = 0
    STDOUT = 1
    STDERR = 2

    open_read         = 0
    open_write        = 1
    open_readAndWrite = 2

    open_creat      = 0100o
    open_rewrite    = 1000o ;; rewrite if file exist
    open_append     = 2000o

    open_excl       = 0200o ;; ensure that THIS call creates the file
    open_noctty     = 0400o
    open_nonblock   = 4000o
    open_nondelay   = open_nonblock
    open_sync       = 10000o
    open_async      = 20000o
    open_direct     = 40000o
        ;; to minimize cache effects of the I/O to and from this file.

    open_largefile  = 100000o
    open_directory  = 200000o
    open_nofollow   = 400000o ;; If pathname is a symbolic link, then the open fails.



    ;; fetch from /usr/include/unistd.h
    ;; lseek is for to make reposition read/write file offset
    ;; seek_set       the offset is set to offset bytes
    ;; seek_current   the offset is set to its current location plus offset bytes
    ;; seek_end       the offset is set to the size of the file plus offset bytes
    define seek_set       0 ;; seek from beginning of file
    define seek_current   1 ;; seek from current position
    define seek_end       2 ;; seek from end of file
    define seek_data      3 ;; seek to next data
    define seek_hole      4 ;; seek to next hole
    #+end_src
*** [NEVER USED] error number
    never used for in fasm one can not use "extrn" in ELF segment
    #+begin_src fasm :tangle no
    ;; 设计这种用出错码机制的人是傻逼
    ;; 给这些出错码命名的人是心理扭曲的变态狂

    ;; fetch from /usr/include/asm-generic/errno-base.h
    define     EPERM            1      ;; Operation not permitted
    define     ENOENT           2      ;; No such file or directory
    define     ESRCH            3      ;; No such process
    define     EINTR            4      ;; Interrupted system call
    define     EIO              5      ;; I/O error
    define     ENXIO            6      ;; No such device or address
    define     E2BIG            7      ;; Argument list too long
    define     ENOEXEC          8      ;; Exec format error
    define     EBADF            9      ;; Bad file number
    define     ECHILD          10      ;; No child processes
    define     EAGAIN          11      ;; Try again
    define     ENOMEM          12      ;; Out of memory
    define     EACCES          13      ;; Permission denied
    define     EFAULT          14      ;; Bad address
    define     ENOTBLK         15      ;; Block device required
    define     EBUSY           16      ;; Device or resource busy
    define     EEXIST          17      ;; File exists
    define     EXDEV           18      ;; Cross-device link
    define     ENODEV          19      ;; No such device
    define     ENOTDIR         20      ;; Not a directory
    define     EISDIR          21      ;; Is a directory
    define     EINVAL          22      ;; Invalid argument
    define     ENFILE          23      ;; File table overflow
    define     EMFILE          24      ;; Too many open files
    define     ENOTTY          25      ;; Not a typewriter
    define     ETXTBSY         26      ;; Text file busy
    define     EFBIG           27      ;; File too large
    define     ENOSPC          28      ;; No space left on device
    define     ESPIPE          29      ;; Illegal seek
    define     EROFS           30      ;; Read-only file system
    define     EMLINK          31      ;; Too many links
    define     EPIPE           32      ;; Broken pipe
    define     EDOM            33      ;; Math argument out of domain of func
    define     ERANGE          34      ;; Math result not representable




    ;; fetch from /usr/include/asm-generic/errno.h

    define EDEADLK         35      ;; Resource deadlock would occur
    define ENAMETOOLONG    36      ;; File name too long
    define ENOLCK          37      ;; No record locks available
    define ENOSYS          38      ;; Function not implemented
    define ENOTEMPTY       39      ;; Directory not empty
    define ELOOP           40      ;; Too many symbolic links encountered
    define EWOULDBLOCK     EAGAIN  ;; Operation would block
    define ENOMSG          42      ;; No message of desired type
    define EIDRM           43      ;; Identifier removed
    define ECHRNG          44      ;; Channel number out of range
    define EL2NSYNC        45      ;; Level 2 not synchronized
    define EL3HLT          46      ;; Level 3 halted
    define EL3RST          47      ;; Level 3 reset
    define ELNRNG          48      ;; Link number out of range
    define EUNATCH         49      ;; Protocol driver not attached
    define ENOCSI          50      ;; No CSI structure available
    define EL2HLT          51      ;; Level 2 halted
    define EBADE           52      ;; Invalid exchange
    define EBADR           53      ;; Invalid request descriptor
    define EXFULL          54      ;; Exchange full
    define ENOANO          55      ;; No anode
    define EBADRQC         56      ;; Invalid request code
    define EBADSLT         57      ;; Invalid slot

    define EDEADLOCK       EDEADLK

    define EBFONT          59      ;; Bad font file format
    define ENOSTR          60      ;; Device not a stream
    define ENODATA         61      ;; No data available
    define ETIME           62      ;; Timer expired
    define ENOSR           63      ;; Out of streams resources
    define ENONET          64      ;; Machine is not on the network
    define ENOPKG          65      ;; Package not installed
    define EREMOTE         66      ;; Object is remote
    define ENOLINK         67      ;; Link has been severed
    define EADV            68      ;; Advertise error
    define ESRMNT          69      ;; Srmount error
    define ECOMM           70      ;; Communication error on send
    define EPROTO          71      ;; Protocol error
    define EMULTIHOP       72      ;; Multihop attempted
    define EDOTDOT         73      ;; RFS specific error
    define EBADMSG         74      ;; Not a data message
    define EOVERFLOW       75      ;; Value too large for defined data type
    define ENOTUNIQ        76      ;; Name not unique on network
    define EBADFD          77      ;; File descriptor in bad state
    define EREMCHG         78      ;; Remote address changed
    define ELIBACC         79      ;; Can not access a needed shared library
    define ELIBBAD         80      ;; Accessing a corrupted shared library
    define ELIBSCN         81      ;; .lib section in a.out corrupted
    define ELIBMAX         82      ;; Attempting to link in too many shared libraries
    define ELIBEXEC        83      ;; Cannot exec a shared library directly
    define EILSEQ          84      ;; Illegal byte sequence
    define ERESTART        85      ;; Interrupted system call should be restarted
    define ESTRPIPE        86      ;; Streams pipe error
    define EUSERS          87      ;; Too many users
    define ENOTSOCK        88      ;; Socket operation on non-socket
    define EDESTADDRREQ    89      ;; Destination address required
    define EMSGSIZE        90      ;; Message too long
    define EPROTOTYPE      91      ;; Protocol wrong type for socket
    define ENOPROTOOPT     92      ;; Protocol not available
    define EPROTONOSUPPORT 93      ;; Protocol not supported
    define ESOCKTNOSUPPORT 94      ;; Socket type not supported
    define EOPNOTSUPP      95      ;; Operation not supported on transport endpoint
    define EPFNOSUPPORT    96      ;; Protocol family not supported
    define EAFNOSUPPORT    97      ;; Address family not supported by protocol
    define EADDRINUSE      98      ;; Address already in use
    define EADDRNOTAVAIL   99      ;; Cannot assign requested address
    define ENETDOWN        100     ;; Network is down
    define ENETUNREACH     101     ;; Network is unreachable
    define ENETRESET       102     ;; Network dropped connection because of reset
    define ECONNABORTED    103     ;; Software caused connection abort
    define ECONNRESET      104     ;; Connection reset by peer
    define ENOBUFS         105     ;; No buffer space available
    define EISCONN         106     ;; Transport endpoint is already connected
    define ENOTCONN        107     ;; Transport endpoint is not connected
    define ESHUTDOWN       108     ;; Cannot send after transport endpoint shutdown
    define ETOOMANYREFS    109     ;; Too many references: cannot splice
    define ETIMEDOUT       110     ;; Connection timed out
    define ECONNREFUSED    111     ;; Connection refused
    define EHOSTDOWN       112     ;; Host is down
    define EHOSTUNREACH    113     ;; No route to host
    define EALREADY        114     ;; Operation already in progress
    define EINPROGRESS     115     ;; Operation now in progress
    define ESTALE          116     ;; Stale file handle
    define EUCLEAN         117     ;; Structure needs cleaning
    define ENOTNAM         118     ;; Not a XENIX named type file
    define ENAVAIL         119     ;; No XENIX semaphores available
    define EISNAM          120     ;; Is a named type file
    define EREMOTEIO       121     ;; Remote I/O error
    define EDQUOT          122     ;; Quota exceeded

    define ENOMEDIUM       123     ;; No medium found
    define EMEDIUMTYPE     124     ;; Wrong medium type
    define ECANCELED       125     ;; Operation Canceled
    define ENOKEY          126     ;; Required key not available
    define EKEYEXPIRED     127     ;; Key has expired
    define EKEYREVOKED     128     ;; Key has been revoked
    define EKEYREJECTED    129     ;; Key was rejected by service

    ;; for robust mutexes
    define EOWNERDEAD      130     ;; Owner died
    define ENOTRECOVERABLE 131     ;; State not recoverable

    define ERFKILL         132     ;; Operation not possible due to RF-kill

    define EHWPOISON       133     ;; Memory page has hardware error
    #+end_src
** [one segments version] equ
   #+begin_src fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate

   ;; 64-bits
   xx equ dq
   Cell_width = 8

   ;; ><><><
   ;; the following comment-out-ed segment headers
   ;; are for the bugs of fasm
   ;; and for to support early version of compiler
   ;; which does not support ELF

   ;; for ELF
   hereCode               equ ; segment readable executable
   hereInitializedData    equ ; segment readable writeable

   ;; about UnInitializedData
   labeling  equ :
   preserve  equ rb

   hereUnInitializedData  equ ; segment readable writeable
   #+end_src
** equ
   #+begin_src fasm :tangle cicada.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate

   ;; 64-bits
   xx equ dq
   Cell_width = 8


   hereCode               equ align 16
   hereInitializedData    equ ;; nothing


   ;; about UnInitializedData

   ;; all unit are byte
   ;; LowestMemoryAddress always can be use to save value

   ;; ==========================================
   LowestMemoryAddress = TheLowestMemoryAddress
   FirstLowestMemoryAddress = LowestMemoryAddress

   labeling  equ = LowestMemoryAddress
   preserve  equ LowestMemoryAddress = LowestMemoryAddress +

   alignTo16InMemoryMap equ LowestMemoryAddress = LowestMemoryAddress + (16 - (LowestMemoryAddress mod 16))

   hereUnInitializedData  equ alignTo16InMemoryMap
   #+end_src
** ASCII
   #+begin_src fasm :tangle cicada.fasm
   ASCII_backspace = 8
   ASCII_tab       = 9
   ASCII_linefeed  = 10
   ASCII_newline   = 10
   ASCII_esc       = 27
   ASCII_escape    = 27
   ASCII_space     = 32
   ASCII_delete    = 127
   #+end_src
** format header
   #+begin_src fasm :tangle cicada.fasm
   format elf64 executable 3
   #+end_src
** ld
*** elf
    #+begin_src fasm :tangle cicada.fasm
    macro Elf32_Sym name,value,size,bind,type,other,shndx
    {
     dd name+0
     dd value+0
     dd size+0
     db (bind+0) shl 4 + (type+0)
     db other+0
     dw shndx+0
    }

    virtual at 0
     Elf32_Sym
     sizeof.Elf32_Sym = $
    end virtual

    macro Elf32_Rel offset,symbol,type
    {
      dd offset+0
      dd (symbol+0) shl 8 + (type+0)
    }

    virtual at 0
     Elf32_Rel
     sizeof.Elf32_Rel = $
    end virtual

    macro Elf32_Rela offset,symbol,type,addend
    {
      dd offset+0
      dd (symbol+0) shl 8 + (type+0)
      dd addend+0
    }

    virtual at 0
     Elf32_Rela
     sizeof.Elf32_Rela = $
    end virtual

    macro Elf64_Sym name,value,size,bind,type,other,shndx
    {
     dd name+0
     db (bind+0) shl 4 + (type+0)
     db other+0
     dw shndx+0
     dq value+0
     dq size+0
    }

    virtual at 0
     Elf64_Sym
     sizeof.Elf64_Sym = $
    end virtual

    macro Elf64_Rel offset,symbol,type
    {
      dq offset+0
      dq (symbol+0) shl 32 + (type+0)
    }

    virtual at 0
     Elf64_Rel
     sizeof.Elf64_Rel = $
    end virtual

    macro Elf64_Rela offset,symbol,type,addend
    {
      dq offset+0
      dq (symbol+0) shl 32 + (type+0)
      dq addend+0
    }

    virtual at 0
     Elf64_Rela
     sizeof.Elf64_Rela = $
    end virtual

    DT_NULL    = 0
    DT_NEEDED  = 1
    DT_HASH    = 4
    DT_STRTAB  = 5
    DT_SYMTAB  = 6
    DT_RELA    = 7
    DT_RELASZ  = 8
    DT_RELAENT = 9
    DT_STRSZ   = 10
    DT_SYMENT  = 11
    DT_REL     = 17
    DT_RELSZ   = 18
    DT_RELENT  = 19

    STB_LOCAL  = 0
    STB_GLOBAL = 1
    STB_WEAK   = 2

    STT_NOTYPE  = 0
    STT_OBJECT  = 1
    STT_FUNC    = 2
    STT_SECTION = 3
    STT_FILE    = 4

    R_386_NONE     = 0
    R_386_32          = 1
    R_386_PC32        = 2
    R_386_GOT32       = 3
    R_386_PLT32       = 4
    R_386_COPY        = 5
    R_386_GLOB_DAT = 6
    R_386_JMP_SLOT = 7
    R_386_RELATIVE = 8
    R_386_GOTOFF      = 9
    R_386_GOTPC       = 10

    R_X86_64_NONE      = 0
    R_X86_64_64           = 1
    R_X86_64_PC32      = 2
    R_X86_64_GOT32     = 3
    R_X86_64_PLT32     = 4
    R_X86_64_COPY      = 5
    R_X86_64_GLOB_DAT  = 6
    R_X86_64_JUMP_SLOT = 7
    R_X86_64_RELATIVE  = 8
    R_X86_64_GOTPCREL  = 9
    R_X86_64_32           = 10
    R_X86_64_32S          = 11
    R_X86_64_16           = 12
    R_X86_64_PC16      = 13
    R_X86_64_8            = 14
    R_X86_64_PC8          = 15
    R_X86_64_DPTMOD64  = 16
    R_X86_64_DTPOFF64  = 17
    R_X86_64_TPOFF64   = 18
    R_X86_64_TLSGD     = 19
    R_X86_64_TLSLD     = 20
    R_X86_64_DTPOFF32  = 21
    R_X86_64_GOTTPOFF  = 22
    R_X86_64_TPOFF32   = 23
    R_X86_64_PC64      = 24
    R_X86_64_GOTOFF64  = 25
    R_X86_64_GOTPC32   = 26
    #+end_src
*** interpreter & needed & import
    #+begin_src fasm :tangle cicada.fasm
    macro interpreter [library]
    {
     segment interpreter readable
     db library,0
    }


    macro needed [library]
    {
     local str
     match needed,needed@dynamic \{ define needed@dynamic needed,str:library \}
     match ,needed@dynamic \{ define needed@dynamic str:library \}
    }


    define needed@dynamic


    macro import [name]
    {
     common
      local strtab,strsz,symtab,rel,relsz,hash
      segment dynamic readable
      match needed,needed@dynamic
      \{ irp item,needed \\{ match str:library,item \\\{ dq DT_NEEDED,str-strtab \\\} \\} \}
      dq DT_STRTAB,strtab
      dq DT_STRSZ,strsz
      dq DT_SYMTAB,symtab
      dq DT_SYMENT,sizeof.Elf64_Sym
      dq DT_RELA,rela
      dq DT_RELASZ,relasz
      dq DT_RELAENT,sizeof.Elf64_Rela
      dq DT_HASH,hash
      dq DT_NULL,0
      segment readable writeable
      symtab: Elf64_Sym
     forward
      local fstr
      Elf64_Sym fstr-strtab,0,0,STB_GLOBAL,STT_FUNC,0,0
     common
      rela:
      local counter
      counter = 1
     forward
       Elf64_Rela name,counter,R_X86_64_64
       counter = counter+1
     common
      relasz = $-rela
      hash:
      dd 1,counter
      dd 0
      repeat counter
       if %=counter
        dd 0
       else
        dd %
       end if
      end repeat
      strtab db 0
     forward
      fstr db `name,0
     common
      match needed,needed@dynamic
      \{ irp item,needed \\{ match str:library,item \\\{ str db library,0 \\\} \\} \}
      strsz = $-strtab
     forward
      name dq 0
    }
    #+end_src
*** buggy fasm macros
    #+begin_src fasm :tangle cicada.fasm
    interpreter '/lib64/ld-linux-x86-64.so.2'
    needed 'libl.so'
    import l
    #+end_src
** ccall
   #+begin_src fasm :tangle cicada.fasm
   macro ccall function
   {
      push r15
      push r14
      push r13
      push r12
      call qword [function]
      pop r12
      pop r13
      pop r14
      pop r15
   }
   #+end_src
** entry
   #+begin_src fasm :tangle cicada.fasm
   entry cicada_virtual_machine
   segment readable executable writeable
   #+end_src
* ==================================================
* include macro
  #+begin_src fasm :tangle cicada.fasm
  include "../macro.inc"
  #+end_src
* start cicada virtual machine
  #+begin_src fasm :tangle cicada.fasm
  hereCode
  cicada_virtual_machine:

          cld ;; set DF = 0, then rsi and rdi are incremented

          mov Argument_stack_pointer,   Argument_stack_top
          mov Grey_pair_stack_pointer, Grey_pair_stack_top
          mov Return_stack_pointer,   Return_stack_top

          ;; initialize the variable "Here"
          ;; to point at beginning of User_data_area
          mov r8, User_data_area
          mov [Here + Cell_width], r8

          mov rax, cicada_begin_thread
          push_return_stack rax

          next

  hereInitializedData
  cicada_begin_thread:

          xx initialize
          xx basic_REPL
          ;; xx assemblyDebug
  #+end_src
* load-core-file & Initial-files-to-load
  #+begin_src fasm :tangle cicada.fasm
  def_assembly_code "load-core-file", load_core_file
     ;; (* -- *)
     mov rsi, Initial_files_to_load
     mov rdi, Input_buffer
     mov rcx, Size_of_initial_files_to_load
     rep movsb
     ;; reset [Reading_boundary + Cell_width]
     mov [Reading_boundary + Cell_width], rdi
     next

  hereInitializedData
  Initial_files_to_load:
     file "../../../core/english-core.cicada"
     file "../../../core/chinese-core.cicada"
     ;; file "../../../lib/x86-64/linux/compiler.cicada"
  Size_of_initial_files_to_load = ($ - Initial_files_to_load) ;; unit :: byte
  #+end_src
* initialize
  #+begin_src fasm :tangle cicada.fasm
  def_verb "initialize", initialize
         ;; (* -- *)

         xx load_core_file

         xx Exit
  def_verb_end initialize
  #+end_src
* IO
** ioctl for terminal
   #+begin_src fasm :tangle cicada.fasm
   ;; /usr/include/asm-generic/termbits.h
   ;; /usr/include/asm-generic/ioctls.h

   VMIN = 6

   ICRNL   =       0000400o
   IXON    =       0002000o
   ICANON  =       0000002o
   ISIG    =       0000001o
   ECHO    =       0000010o


   hereUnInitializedData

   termios:
   termios.c_iflag:       rd 1
   termios.c_oflag:       rd 1
   termios.c_cflag:       rd 1
   termios.c_lflag:       rd 1
   termios.c_line:        rb 1
   termios.c_cc:          rb 19 ;; NCCS
   termios_size = ($ - termios)

   termios_orig:
   termios_orig.c_iflag:       rd 1
   termios_orig.c_oflag:       rd 1
   termios_orig.c_cflag:       rd 1
   termios_orig.c_lflag:       rd 1
   termios_orig.c_line:        rb 1
   termios_orig.c_cc:          rb 19 ;; NCCS


   ScreenSize:  rw 1


   def_assembly_code "set-terminal-to-read-key", setTerminalToReadKey
      ;; (* -- *)
      mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
      mov sys_2_rsi, 5401h        ;; TERMIOS_GET, TCGETS
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall

      mov rsi, termios_orig
      mov rdi, termios
      mov rcx, termios_size
      cld
      rep movsb

      mov byte [termios.c_cc + VMIN], 1
      ;; icanon off, isig (^C) off, echo off
      and byte [termios.c_lflag + 0], ((- ICANON) and (- ISIG) and (- ECHO))
      ;; ixon off,   icrnl off
      and byte [termios.c_iflag + 1], ((- (IXON shr 8)) or (- (ICRNL shr 8)))
      mov rdx, termios     ;; termios or WinSize structure ptr
      mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall
      next


   def_assembly_code "set-terminal-back-to-read-line", setTerminalBackToReadLine
      ;; (* -- *)
      mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
      mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall
      next


   def_assembly_code "get-screen-size", getScreenSize
      ;; (* -- rows, cols *)
      mov sys_3_rdx, ScreenSize
      ;; [ScreenSize] == for example col=88,row=26 :: 00880026
      mov sys_2_rsi, 5413h ;; TERMIOS_WSIZE, TIOCGWINSZ
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall
      ;; xor rax, rax
      mov ax, word[ScreenSize]
      push_argument_stack rax
      mov ax, word[ScreenSize + 2]
      push_argument_stack rax
      next
   #+end_src
** read-char
   #+begin_src fasm :tangle cicada.fasm
   Size_of_input_buffer = 3*1024*1024

   hereUnInitializedData
   Input_buffer labeling
      preserve Size_of_input_buffer
   End_of_input_buffer labeling


   def_noun "Size-of-input-buffer",  _Size_of_input_buffer
      xx   Size_of_input_buffer
   def_noun_end  _Size_of_input_buffer

   def_noun "Input-buffer",        _Input_buffer
      xx           Input_buffer
   def_noun_end        _Input_buffer

   def_noun "End-of-input-buffer",   _End_of_input_buffer
      xx    End_of_input_buffer
   def_noun_end   _End_of_input_buffer


   ;; 1. two global variables for reading
   ;;    I can easily support `evalString' by change these two variables
   ;; 2. note that, there is no char in the address of a "Reading_boundary"
   ;;    an example of "Reading_boundary" is "End_of_input_buffer"
   ;; 3. when "Current_reading" == "Reading_boundary"
   ;;    for the function "read_char"
   ;;    we need to reset it to read from "Input_buffer"
   ;;    and call "inputLine" to fetch more chars
   ;;    and loop back
   def_noun "Current-reading", Current_reading
      xx   Input_buffer
   def_noun_end Current_reading

   def_noun "Reading-boundary", Reading_boundary
      xx  Input_buffer
   def_noun_end Reading_boundary


   def_assembly_code "read-char", read_char
      ;; read a char from stdin, return it into the ArgumentStack as following
      ;; (*  -- char *)
      ;; read_char calls the Linux read system call to fill Input_buffer
      ;; The other thing that read_char does is
      ;; if it detects that stdin has closed, it exits the program
      ;; which is why when you hit C-d, the system exits
      call _read_char
      ;; _read_char will save the return value in rax
      push_argument_stack rax
      next

   _read_char:
      ;; r8 is a helper-register for "cmp"
      mov r8, [Current_reading + Cell_width]
      cmp r8, [Reading_boundary + Cell_width]
      ;-- IF: [Current_reading + Cell_width] < [Reading_boundary + Cell_width]
      ;-- WK: there is still some chars in the Input_buffer to be processed
      jl read_char_stillSomeChars
      ;-- EL: [Current_reading + Cell_width] >= [Reading_boundary + Cell_width]
      ;-- WK: all chars in Input_buffer have been processed
      mov rax, End_of_input_buffer
      cmp r8, rax
      jg read_char_addBlankAtTheEnding
      mov rax, Input_buffer
      cmp r8, rax
      jl read_char_addBlankAtTheEnding
      jmp read_char_fetchMoreCharsFromStdinToInput_buffer
   read_char_addBlankAtTheEnding:
      ;; otherwise,  when the a string not ending with blank
      ;; `evalString' will not work correctly
      mov rax, Input_buffer
      mov [Current_reading + Cell_width], rax
      mov [Reading_boundary + Cell_width], rax
      xor rax, rax
      mov al, 10
      ret
   read_char_stillSomeChars:
      ;; for the following will just uses the al part of rax
      ;; it is necessary to clear rax
      xor rax, rax
      ;-- DO: fetch a char from Input_buffer to rax
      ;-- NT: after _read_char return rax will be push_argument_stack
      mov al, byte[r8]
      ;-- DO: increment [Current_reading + Cell_width]
      inc r8
      mov [Current_reading + Cell_width], r8
      ret
   ;; note that, in the following subroutine
   ;; set [Current_reading + Cell_width]  == Input_buffer
   ;; set [Reading_boundary + Cell_width] == Input_buffer + length of string that was input (NULL not counted)
   read_char_fetchMoreCharsFromStdinToInput_buffer:
      ;; read to fetch more input chars from STDIN to Input_buffer
      mov sys_3_rdx,     Size_of_input_buffer    ;; max length to be read
      mov sys_2_rsi,     Input_buffer        ;; buffer address
      ;; reset [Current_reading + Cell_width] to Input_buffer
      mov [Current_reading + Cell_width], sys_2_rsi
      xor sys_1_rdi,     sys_1_rdi          ;; stdin
      mov sys_n_rax,     syscall_read
      syscall
      ;; the return value of syscall read
      ;; is a count of the number of bytes transferred
      test rax, rax
      ;-- IF: rax <= 0
      ;-- WK: there is an error or it is end of input
      ;-- DO: exit
      jz read_char_exit
      js read_char_exit
      ;-- EL: rax > 0
      ;-- WK: there are some chars has been fetched by syscall read
      ;-- DO: set [Reading_boundary + Cell_width] to the right place
      ;--     Reading_boundary = Input_buffer + the count of the number of bytes transferred
      ;-- NT: sys_2_rsi = Input_buffer
      ;--     rax = the count of the number of bytes transferred
      add sys_2_rsi, rax
      mov [Reading_boundary + Cell_width], sys_2_rsi
      ;-- DO: jump back
      jmp _read_char


   read_char_exit:
      ;; exit with exit code = the value syscall_read returned
      xor sys_1_rdi, sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall
   #+end_src
** write_char
   #+begin_src fasm :tangle cicada.fasm
   hereInitializedData
   ScratchUsedByWriteChar:
      rb 1

   def_assembly_code "write-char", write_char
      ;; ( char --  ) write a char to stdin
      ;; just calls the Linux write system call
      pop_argument_stack rax
      call _write_char
      next

   _write_char:
      mov sys_1_rdi, 1 ;; stdout
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [ScratchUsedByWriteChar], al
      mov sys_2_rsi, ScratchUsedByWriteChar  ;; address
      mov sys_3_rdx, 1                       ;; max length to be write, just 1
      mov sys_n_rax, syscall_write
      syscall
      ret
   #+end_src
** print-string
   #+begin_src fasm :tangle cicada.fasm
   def_verb "print-string", print_string
      ;; (* string[address, length] -- *)
      xx dup, zero?, _false?branch, 3
      xx   drop2
      xx   Exit
      xx sub1, swap
      xx dup, fetch_byte, write_char
      xx add1, swap
      xx _branch, -14
   def_verb_end print_string
   #+end_src
** file
*** note about error
    1. just use "js" to report a general error
*** buffer->file,with-error
    #+begin_src fasm :tangle cicada.fasm
    ;; buffer->file,with-error == string->file,with-error

    def_verb "buffer->file,with-error", buffer_to_file__with_error
       ;; (* string[address, length], file-name-string[address, length] --
       ;;    [number of char] or [negate number on error] *)
       xx string_to_file__with_error
       xx Exit
    def_verb_end buffer_to_file__with_error

    ;;
    def_assembly_code "string->file,with-error", string_to_file__with_error
       ;; (* string[address, length], file-name-string[address, length] --
       ;;    [number of char] or [negate number on error] *)
       pop_argument_stack rcx
       pop_argument_stack rsi
       pop_argument_stack r8
       pop_argument_stack r9
       call _string_to_file__with_error
       next

    _string_to_file__with_error:
       ;; copy file-name as a null-terminal string
       mov rdi, NameBufferOfString_to_file__with_error
       rep movsb
       xor rax, rax
       mov byte [rdi], al

       ;; 打开文件 & 必要的时候创造新文件 & 每次都覆盖文件已有的内容
       ;; 当文件路径不存在的时候不会创造路径 而出错
       mov     sys_3_rdx, 110100100b   ;; 文件的权限 644 改为别的值的时候会出问题
       mov     sys_2_rsi, open_readAndWrite or open_creat or open_rewrite
       mov     sys_1_rdi, NameBufferOfString_to_file__with_error
       mov     sys_n_rax, syscall_open
       syscall

       mov     qword [FileHandleOfString_to_file__with_error], rax

       or      rax, rax
       js      _string_to_file_meetError

       ;; string->file
       mov     sys_3_rdx, r8
       mov     sys_2_rsi, r9
       mov     sys_1_rdi, qword [FileHandleOfString_to_file__with_error]
       mov     sys_n_rax, syscall_write
       syscall

       or      rax, rax
       js      _string_to_file_meetError

       mov     r10, rax

       ;; 关闭文件
       mov     sys_1_rdi, qword [FileHandleOfString_to_file__with_error]
       mov     sys_n_rax, syscall_close
       syscall

       or      rax, rax
       js      _string_to_file_meetError

       pop_argument_stack r10

       ret

    _string_to_file_meetError:
       push_argument_stack rax

       ret


    FileHandleOfString_to_file__with_error:
       dq 0
    NameBufferOfString_to_file__with_error:
       rb 1024
    #+end_src
*** file->buffer,with-error
    #+begin_src fasm :tangle cicada.fasm
    ;; file->buffer,with-error == file->string,with-error

    def_verb "file->buffer,with-error", file_to_buffer__with_error
       ;; (* file-name-string[address, length], string[address, length] --
       ;;    [number of char] or [negate number on error] *)
       xx file_to_string__with_error
       xx Exit
    def_verb_end file_to_buffer__with_error


    def_assembly_code "file->string,with-error", file_to_string__with_error
       ;; (* file-name-string[address, length], string[address, length] --
       ;;    [number of char] or [negate number on error] *)
       pop_argument_stack r8
       pop_argument_stack r9
       pop_argument_stack rcx
       pop_argument_stack rsi
       call _file_to_string__with_error
       next

    _file_to_string__with_error:
       ;; copy file-name as a null-terminal string
       mov rdi, NameBufferOfFileToString__with_error
       rep movsb
       xor rax, rax
       mov byte [rdi], al

       ;; read only
       mov     sys_2_rsi, open_read
       mov     sys_1_rdi, NameBufferOfFileToString__with_error
       mov     sys_n_rax, syscall_open
       syscall

       mov     qword [FileHandleOfFileToString__with_error], rax

       or      rax, rax
       js      _file_to_string_meetError

       ;; lseek is for to make reposition read/write file offset
       ;; seek_set       the offset is set to offset bytes
       ;; seek_current   the offset is set to its current location plus offset bytes
       ;; seek_end       the offset is set to the size of the file plus offset bytes
       mov     sys_3_rdx, seek_set
       xor     sys_2_rsi, sys_2_rsi  ;; offset
       mov     sys_1_rdi, qword [FileHandleOfFileToString__with_error]
       mov     sys_n_rax, syscall_lseek
       syscall

       or      rax, rax
       js      _file_to_string_meetError

       ;; file->string
       mov     sys_3_rdx, r8
       mov     sys_2_rsi, r9
       mov     sys_1_rdi, qword [FileHandleOfFileToString__with_error]
       mov     sys_n_rax, syscall_read
       syscall

       or      rax, rax
       js      _file_to_string_meetError

       mov     r10, rax

       ;; 关闭文件
       mov     sys_1_rdi, qword [FileHandleOfFileToString__with_error]
       mov     sys_n_rax, syscall_close
       syscall

       or      rax, rax
       js      _file_to_string_meetError

       push_argument_stack r10

       ret

    _file_to_string_meetError:
       push_argument_stack rax

       ret


    FileHandleOfFileToString__with_error:
       dq 0
    NameBufferOfFileToString__with_error:
       rb 1024
    #+end_src
* C functions
** l
   #+begin_src fasm :tangle cicada.fasm
   def_assembly_code "l", _l
      ccall l
      next
   #+end_src
* include threaded code
  #+begin_src fasm :tangle cicada.fasm
  include "../threaded-code.inc"
  #+end_src
* misc
** assemblyDebug
   #+begin_src fasm :tangle cicada.fasm
   def_verb ".", print_little_number
      xx _literal, '0'
      xx addition, write_char
      xx _literal, 32
      xx write_char
      xx _literal, 32
      xx write_char
      xx Exit
   def_verb_end print_little_number

   def_assembly_code "exitWithTOS", exitWithTOS
      pop_argument_stack sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall


   def_verb "assemblyDebug", assemblyDebug
      xx read_phrase
      xx print_string
      xx _branch, -3

        .read_phrase:
        xx read_phrase
        xx eval_phrase
        xx _branch, (.read_phrase-$)/Cell_width

      xx exitWithTOS
   def_verb_end assemblyDebug
   #+end_src
* ending
** User_data_area
   #+begin_src fasm :tangle cicada.fasm
   Size_of_user_data_area = 64 * 1024 * 1024 ;; unit : byte

   hereUnInitializedData
   ;; ------------------------------------------
   User_data_area labeling
   End_of_user_data_area = TheLowestMemoryAddress + Size_of_user_data_area

   def_noun "User-data-area", _User_data_area
      xx  User_data_area
   def_noun_end _User_data_area

   def_noun "End-of-user-data-area", _End_of_user_data_area
      xx  End_of_user_data_area
   def_noun_end _End_of_user_data_area
   #+end_src
** Latest_word_in_assembly
   #+begin_src fasm :tangle cicada.fasm
   ;; this word helps to initialize First_word_in_dictionary
   def_noun "Latest-word-in-assembly", Latest_word_in_assembly
      xx  0
   def_noun_end Latest_word_in_assembly
   #+end_src
** LowestMemoryAddress
   #+begin_src fasm :tangle cicada.fasm
   segment readable writeable
   TheLowestMemoryAddress:
      rb Size_of_user_data_area
   #+end_src
* ==================================================
