SizeOfKernel = 320 ;; unit :: k
LocationOfKernel = 32*1024
MagicNumberOfKernel = 26881h
;; in fasm, "dup" is a reserved word
dup equ duplicate

;; 64-bits
xx equ dq
Cell_width = 8


hereCode               equ align 16
hereInitializedData    equ ;; nothing


;; about UnInitializedData

;; all unit are byte
;; LowestMemoryAddress always can be use to save value

;; ==========================================
LowestMemoryAddress = 32*1024*1024
FirstLowestMemoryAddress = LowestMemoryAddress

labeling  equ = LowestMemoryAddress
preserve  equ LowestMemoryAddress = LowestMemoryAddress +

alignTo16InMemoryMap equ LowestMemoryAddress = LowestMemoryAddress + (16 - (LowestMemoryAddress mod 16))

hereUnInitializedData  equ alignTo16InMemoryMap
ASCII_backspace = 8
ASCII_tab       = 9
ASCII_linefeed  = 10
ASCII_newline   = 10
ASCII_esc       = 27
ASCII_escape    = 27
ASCII_space     = 32
ASCII_delete    = 127
format binary
use16
org LocationOfKernel

start16:
        cli

        xor ax, ax
        mov ds, ax
        mov es, ax
        mov fs, ax
        mov gs, ax
        mov ss, ax
        mov sp, LocationOfKernel

        ;; Make sure the screen is set to 80*25 text mode
        mov ax, 3
        int 0x10

        ;; Disable blinking
        mov ax, 0x1003
        mov bx, 0x0000
        int 0x10

        ;; hide the hardware cursor
        mov ax, 0x0200                  ; VIDEO - SET CURSOR POSITION
        mov bx, 0x0000                  ; Page number
        mov dx, 0x2000                  ; Row / Column
        int 0x10

        ;; enable the A20 gate
        set_A20:
           in al, 0x64
           test al, 0x02
           jnz set_A20
           mov al, 0xD1
           out 0x64, al
        check_A20:
           in al, 0x64
           test al, 0x02
           jnz check_A20
           mov al, 0xDF
           out 0x60, al

        call init_VESA_VBE

        lgdt    [cs:GDTR]

        ;; switch to protected mode
        mov     eax, cr0
        bts     eax, 0                   ; bit-index-0 set
        mov     cr0, eax

        jmp     CODE_SELECTOR_32:start32
;; VESA :: Video Electronics Standards Association
;; VBE :: VESA BIOS Extension
align 16
init_VESA_VBE:
   mov di, VBEInfoBlock
   mov ax, 4f00h
   int 10h
   mov word [VBEInfoBlock.ReturnStatus], ax

   mov di, VBEModeInfoBlock
   mov ax, 4f01h
   int 10h
   mov word [VBEModeInfoBlock.ReturnStatus], ax

   ret

align 16
VBEInfoBlock.ReturnStatus:
   rb 2

align 16
VBEInfoBlock:
   rb 512


align 16
VBEModeInfoBlock.ReturnStatus:
   rb 2
align 16
VBEModeInfoBlock:
   rb 256

;; VESA
;; Mandatory information for all VBE revisions
VBEModeInfoBlock.ModeAttributes         = VBEModeInfoBlock + 0        ; DW - mode attributes
VBEModeInfoBlock.WinAAttributes         = VBEModeInfoBlock + 2        ; DB - window A attributes
VBEModeInfoBlock.WinBAttributes         = VBEModeInfoBlock + 3        ; DB - window B attributes
VBEModeInfoBlock.WinGranularity         = VBEModeInfoBlock + 4        ; DW - window granularity in KB
VBEModeInfoBlock.WinSize                = VBEModeInfoBlock + 6        ; DW - window size in KB
VBEModeInfoBlock.WinASegment            = VBEModeInfoBlock + 8        ; DW - window A start segment
VBEModeInfoBlock.WinBSegment            = VBEModeInfoBlock + 10       ; DW - window B start segment
VBEModeInfoBlock.WinFuncPtr             = VBEModeInfoBlock + 12       ; DD - real mode pointer to window function
VBEModeInfoBlock.BytesPerScanLine       = VBEModeInfoBlock + 16       ; DW - bytes per scan line
;; Mandatory information for VBE 1.2 and above
VBEModeInfoBlock.XResolution            = VBEModeInfoBlock + 18       ; DW - horizontal resolution in pixels or characters
VBEModeInfoBlock.YResolution            = VBEModeInfoBlock + 20       ; DW - vertical resolution in pixels or characters
VBEModeInfoBlock.XCharSize              = VBEModeInfoBlock + 22       ; DB - character cell width in pixels
VBEModeInfoBlock.YCharSize              = VBEModeInfoBlock + 23       ; DB - character cell height in pixels
VBEModeInfoBlock.NumberOfPlanes         = VBEModeInfoBlock + 24       ; DB - number of memory planes
VBEModeInfoBlock.BitsPerPixel           = VBEModeInfoBlock + 25       ; DB - bits per pixel
VBEModeInfoBlock.NumberOfBanks          = VBEModeInfoBlock + 26       ; DB - number of banks
VBEModeInfoBlock.MemoryModel            = VBEModeInfoBlock + 27       ; DB - memory model type
VBEModeInfoBlock.BankSize               = VBEModeInfoBlock + 28       ; DB - bank size in KB
VBEModeInfoBlock.NumberOfImagePages     = VBEModeInfoBlock + 29       ; DB - number of image pages
VBEModeInfoBlock.Reserved               = VBEModeInfoBlock + 30       ; DB - reserved (0x00 for VBE 1.0-2.0, 0x01 for VBE 3.0)
;; Direct Color fields (required for direct/6 and YUV/7 memory models)
VBEModeInfoBlock.RedMaskSize            = VBEModeInfoBlock + 31       ; DB - size of direct color red mask in bits
VBEModeInfoBlock.RedFieldPosition       = VBEModeInfoBlock + 32       ; DB - bit position of lsb of red mask
VBEModeInfoBlock.GreenMaskSize          = VBEModeInfoBlock + 33       ; DB - size of direct color green mask in bits
VBEModeInfoBlock.GreenFieldPosition     = VBEModeInfoBlock + 34       ; DB - bit position of lsb of green mask
VBEModeInfoBlock.BlueMaskSize           = VBEModeInfoBlock + 35       ; DB - size of direct color blue mask in bits
VBEModeInfoBlock.BlueFieldPosition      = VBEModeInfoBlock + 36       ; DB - bit position of lsb of blue mask
VBEModeInfoBlock.RsvdMaskSize           = VBEModeInfoBlock + 37       ; DB - size of direct color reserved mask in bits
VBEModeInfoBlock.RsvdFieldPosition      = VBEModeInfoBlock + 38       ; DB - bit position of lsb of reserved mask
VBEModeInfoBlock.DirectColorModeInfo    = VBEModeInfoBlock + 39       ; DB - direct color mode attributes
;; Mandatory information for VBE 2.0 and above
VBEModeInfoBlock.PhysBasePtr            = VBEModeInfoBlock + 40       ; DD - physical address for flat memory frame buffer
VBEModeInfoBlock.Reserved1              = VBEModeInfoBlock + 44       ; DD - Reserved - always set to 0
VBEModeInfoBlock.Reserved2              = VBEModeInfoBlock + 48       ; DD - Reserved - always set to 0
align 16
GDTR:
   dw GDT_END - GDT - 1                  ;; index of the last byte in table
   dq GDT                                ;; linear address of GDT

   ;; ;; base-address is a 32 bit value containing the linear address where the segment begins.
   ;; ;; limit is a 20 bit value tells the maximum addressable unit (either in 1 byte units, or in pages)
   ;; ;;   Hence, if you choose page granularity (4 KiB) in the flags
   ;; ;;   and set the limit value to 0fffffh the segment will span the full 4 GiB address space
   ;; ;; example :
   ;; ;; base-address [32 bits] :: 2,3,4,7 == 0
   ;; ;; limit        [20 bits] :: 0,1,l6  == 0fffffh
   ;; ;; flags        [ 4 bits] :: h6      == 1100b
   ;; ;; access       [ 8 bits] :: 5       == 10010010b
   ;; ;  0     1     2  3  4  5          6          7
   ;; db 0ffh, 0ffh, 0, 0, 0, 10010010b, 11001111b, 0

   ;; for all of the following desciptors :
   ;;  limit = 0fffffh,  base = 0h

align 16
GDT:
   ;; descriptor-0 is always unused
   dq 0
   ;; descriptor-1
   ;; flat data desciptor
   ;;  flags = 1000b,  access = 10010010b ;; most accessible for data desciptor
   db 0ffh, 0ffh, 0, 0, 0, 10010010b, 10001111b, 0
   ;; descriptor-2
   ;; 32 bits code desciptor
   ;;  flags = 1100b,  access = 10011010b ;; most accessible for code desciptor
   db 0ffh, 0ffh, 0, 0, 0, 10011010b, 11001111b, 0
   ;; descriptor-3
   ;; 64 bits code desciptor
   ;; for long mode
   ;; bit-index-1 of the flags of the GDT code desciptor must be set
   ;; bit-index-2 of the flags of the GDT code desciptor must be clear (as it would be for a 16-bit code segment)
   ;; so we have the following
   ;;  flags = 0010b,  access = 10011010b ;; most accessible for code desciptor
   db 0, 0, 0, 0, 0, 10011010b, 00100000b, 0
   db 0, 0, 0, 0, 0, 10010010b, 00100000b, 0
GDT_END:

NULL_SELECTOR = 0
DATA_SELECTOR_32 = (1 shl 3)    ; flat data selector (ring 0)
CODE_SELECTOR_32 = (2 shl 3)    ; 32-bit code selector (ring 0)
CODE_SELECTOR_64 = (3 shl 3)    ; 64-bit code selector (ring 0)
DATA_SELECTOR_64 = (4 shl 3)    ; 64-bit code selector (ring 0)
times (31 * 1024) - ($-$$) db 0
align 16
use32

start32:
        ;; load 4 GB data descriptor to all data segment registers
        mov     ax, DATA_SELECTOR_32
        mov     ds, ax
        mov     es, ax
        mov     fs, ax
        mov     gs, ax
        mov     ss, ax

        ;; about paging :
        ;; make 4G identity page
        ;; by setting up :
        ;; 1 PageTable4 with 1 entries
        ;; 1 PageTable3 with 4 entries
        ;; 4 PageTable2 with 512 entries each
        ;; 6*4K == 24K of memory are needed to set up these tables

        SizeOfPageTable = 4*1024
        SizeOfPage = 2*1024*1024
        PageTable4 = 1*1024*1024
        PageTable3 = PageTable4 + SizeOfPageTable
        PageTable2 = PageTable3 + SizeOfPageTable

        ;; clear 6*4k for paging tables
        mov     edi, PageTable4
        mov     ecx, (6*4*1024)/4     ; 4*1024 for one table
        xor     eax, eax
        rep     stosd

        ;; make 1 PageTable4 with 1 entry
        mov dword [PageTable4], PageTable3 + 00000111b

        ;; make 1 PageTable3 with 4 entries
        mov     edi, PageTable3
        mov     eax, PageTable2 + 111b
        mov     ecx, 4 ; number of entries
make_PageTable3_entries:
        stosd
        add     edi, 4
        add     eax, SizeOfPageTable
        loop    make_PageTable3_entries

        ;; make 4 PageTable2 with 512 entries each
        mov     edi, PageTable2
        mov     eax, 0 + 10000111b
        mov     ecx, 4*512 ; number of entries
make_PageTable2_entries:
        stosd
        add     edi, 4
        add     eax, SizeOfPage
        loop    make_PageTable2_entries

        ;; load PageTable4 to cr3
        mov     eax, PageTable4
        mov     cr3, eax

        ;; enable PAE :: physical address extensions
        mov     eax, cr4
        bts     eax, 5
        mov     cr4, eax

        ;; enable long mode by setting EFER MSR
        ;; MSR :: model specific register
        mov     ecx, 0C0000080h
        rdmsr
        bts     eax, 8
        wrmsr

        ;; enable paging
        mov     eax, cr0
        bts     eax, 31
        mov     cr0, eax

        ;; and then we are in 32 bits compatibility mode (which is part of lmode)
        ;; must load a SELECTOR with which the flags are setted for lmode
        ;; as the following "jmp" do :
        mov     ax, CODE_SELECTOR_64
        mov     ds, ax
        mov     es, ax
        mov     fs, ax
        mov     gs, ax
        mov     ax, DATA_SELECTOR_64
        mov     ss, ax
        jmp     CODE_SELECTOR_64:start64
align 16
use64

start64:
        ;; Flush Cache
        wbinvd

        ;; Enable Cache
        mov rax, cr0
        btr rax, 29                     ; resets (i.e. clear) No Write Thru (Bit 29)
        btr rax, 30                     ; resets (i.e. clear) CD (Bit 30)
        mov cr0, rax

        ;; about PIC and IRQ
        ;; ICW :: initialization command word (actually byte)

        ;; ICW1
        mov     al, 10001b
        out     20h, al
        mov     al, 10001b
        out     0A0h, al

        ;; ICW2
        ;; IRQ 0-7: from interrupts 32
        mov     al, 32
        out     21h, al
        ;; IRQ 8-15: from interrupts 32 + 8
        mov     al, 32 + 8
        out     0A1h, al

        ;; ICW3
        ;; connected PIC1 with PIC2
        mov     al, 100b
        out     21h, al
        mov     al, 10b
        out     0A1h, al

        ;; ICW4
        ;; x86 environment and manual EOI
        mov     al, 1
        out     21h, al
        out     0A1h, al

        ;; OCW :: operation control word (actually byte)
        ;; OCW is used to enable/disable IRQ and to signal an interrupt is over

        ;; enable IRQ 1:keyboard
        in      al, 21h
        mov     al, 11111101b
        out     21h, al
        in      al, 0A1h
        mov     al, 11111111b
        out     0A1h, al

        ;; create IDT (at linear address 0)
        ;; not like the GDT, the IDT is created by code at address 0
        ;; an IDT entry is called a gate

        ;; at first placeholder is used
        ;; then one should call create_gate to creat each gate

        xor     edi, edi

        mov     ecx, 32
make_exception_gate_placeholders:
        mov     esi, exception_gate_placeholder
        movsq
        movsq
        loop    make_exception_gate_placeholders

        mov     ecx, 256 - 32
make_interrupt_gate_placeholders:
        mov     esi, interrupt_gate_placeholder
        movsq
        movsq
        loop    make_interrupt_gate_placeholders

        lidt    [IDTR]

        jmp cicada_virtual_machine
align 16
; create_gate
; rax = address of handler
; rdi = gate # to configure
create_gate:
        push rdi
        push rax

        shl rdi, 4                      ; quickly multiply rdi by 16
        stosw                           ; store the low word (15..0)
        shr rax, 16
        add rdi, 4                      ; skip the gate marker
        stosw                           ; store the high word (31..16)
        shr rax, 16
        stosd                           ; store the high dword (63..32)

        pop rax
        pop rdi
        ret
align 16
IDTR:
  dw 256*16 - 1 ;; index of the last byte in table
  dq 0          ;; linear address of IDT

;; not like the GDT, the IDT is created by code at address 0
;; an IDT entry is called a gate
;; the size of a gate in 64 bits mode is 16 bytes
;; offset                [64 bits] :: 0,1,6,7,8,9,10,11 ==
;; code-segment-selector [16 bits] :: 2,3 ==
;; reserved              [ 8 bits] :: 4 == 0
;; attributes-and-type   [ 8 bits] :: 5 ==
;; reserved              [32 bits] :: 12,13,14,15,16 == 0

align 16
exception_gate_placeholder:
  dw exception_placeholder and 0ffffh ;; 0,1
  dw CODE_SELECTOR_64                 ;; 2,3
  db 0                                ;; 4
  ;db 10001110b                        ;; 5
  db 10001111b                        ;; 5
  dw exception_placeholder shr (2*8)  ;; 6,7,8,9
  dd exception_placeholder shr (6*8)  ;; 10,11

align 16
interrupt_gate_placeholder:
  dw interrupt_placeholder and 0ffffh ;; 0,1
  dw CODE_SELECTOR_64                 ;; 2,3
  db 0                                ;; 4
  ;db 10001111b                        ;; 5
  db 10001110b                        ;; 5
  dw interrupt_placeholder shr (2*8)  ;; 6,7,8,9
  dd interrupt_placeholder shr (6*8)  ;; 10,11

;; ISR :: Interrupt Service Routine

align 16
exception_placeholder:
        cli
        hlt

align 16
interrupt_placeholder:
        iretq
include "../macro.inc"
hereCode
cicada_virtual_machine:

       cli

       cld ;; set DF = 0, then rsi and rdi are incremented

       ;; to clear memory range FirstLowestMemoryAddress - User_data_area
       mov rdi, FirstLowestMemoryAddress
       mov rcx, (User_data_area - FirstLowestMemoryAddress)/8
       xor rax, rax
       ;; Store rax to [rdi], rcx - 1, rdi + 8, if rcx > 0 then do it again
       rep stosq

       mov Argument_stack_pointer,   Argument_stack_top
       mov Grey_pair_stack_pointer, Grey_pair_stack_top
       mov Return_stack_pointer,   Return_stack_top

       ;; initialize the variable "Here"
       ;; to point at beginning of User_data_area
       mov r8, User_data_area
       mov [Here + Cell_width], r8

       mov rax, cicada_begin_thread
       push_return_stack rax

       next

hereInitializedData
cicada_begin_thread:
       xx initialize
       xx basic_REPL
def_assembly_code "load-core-file", load_core_file
   ;; (* -- *)
   mov rsi, Initial_files_to_load
   mov rdi, Input_buffer
   mov rcx, Size_of_initial_files_to_load
   rep movsb
   ;; reset [Reading_boundary + Cell_width]
   mov [Reading_boundary + Cell_width], rdi
   next

hereInitializedData
Initial_files_to_load:
   file "../../../core/english-core.cicada"
Size_of_initial_files_to_load = ($ - Initial_files_to_load) ;; unit :: byte
def_verb "initialize", initialize
       ;; (* -- *)
       xx closeInterrupt

       xx createBarekeyboard

       ;; text mode is configured by kernelloader
       ;; it is ok to just use it
       xx configureColorPalette
       xx clearScreen
       xx resetCurrentCursor

       xx load_core_file

       xx openInterrupt

       xx Exit
def_verb_end initialize
def_assembly_code "close-interrupt", closeInterrupt
   ;; (* -- *)
   cli
   next

def_assembly_code "open-interrupt", openInterrupt
   ;; (* -- *)
   sti
   next
def_assembly_code "create-gate", createGate
   ;; (* gate number to configure, address of handler -- *)
   pop_argument_stack rax
   pop_argument_stack rdi
   shl rdi, 4     ; quickly multiply rdi by 16
   stosw          ; store the low word (15..0)
   shr rax, 16
   add rdi, 4     ; skip the gate marker
   stosw          ; store the high word (31..16)
   shr rax, 16
   stosd          ; store the high dword (63..32)
   next
; -----------------------------------------------------------------------------
; keyboard interrupt. IRQ 0x01, INT 0x21
; This IRQ runs whenever there is input on the keyboard

hereUnInitializedData
;; ------------------------------------------
;; should be big enough, for no size error check
SizeOfScancodeQueue = 1024

ScancodeQueue labeling
        preserve SizeOfScancodeQueue


align 16
barekeyboard:
        push rax
        push rcx

        xor rax, rax
        in al, 0x60

        mov rcx, [FrontOfScancodeQueue]
        mov byte [ScancodeQueue + rcx], al
        inc rcx
        cmp rcx, SizeOfScancodeQueue
        jne @f
        xor rcx, rcx
@@:
        mov [FrontOfScancodeQueue], rcx

        ;; the interrupt is over
        mov al, 20h
        out 20h, al
        ;call os_smp_wakeup_all          ; A terrible hack

        pop rcx
        pop rax

        iretq


;; two indexes of the array as pointers
;; Rear < Front
align 16
RearOfScancodeQueue:  dq 0
align 16
FrontOfScancodeQueue: dq 1

def_verb "create-barekeyboard", createBarekeyboard
   ;; (* -- *)
   ;; create the function to handle keyboard interrupt
   xx _literal, 32+1
   xx _literal, barekeyboard
   xx createGate
   xx Exit
def_verb_end createBarekeyboard
Palette:
;; These colors are in RGB format
;; Each color byte is actually 6 bits (0x00 - 0x3F)
db 0x00, 0x00, 0x00     ;;  0 Black
db 0x33, 0x00, 0x00     ;;  1 Red
db 0x0F, 0x26, 0x01     ;;  2 Green
db 0x0D, 0x19, 0x29     ;;  3 Blue
db 0x31, 0x28, 0x00     ;;  4 Orange
db 0x1D, 0x14, 0x1E     ;;  5 Purple
db 0x01, 0x26, 0x26     ;;  6 Teal
db 0x2A, 0x2A, 0x2A     ;;  7 Light Gray
db 0x15, 0x15, 0x15     ;;  8 Dark Gray
db 0x3B, 0x0A, 0x0A     ;;  9 Bright Red
db 0x22, 0x38, 0x0D     ;; 10 Bright Green
db 0x1C, 0x27, 0x33     ;; 11 Bright Blue
db 0x3F, 0x3A, 0x13     ;; 12 Yellow
db 0x2B, 0x1F, 0x2A     ;; 13 Bright Purple
db 0x0D, 0x38, 0x38     ;; 14 Bright Teal
db 0x3F, 0x3F, 0x3F     ;; 15 White


def_assembly_code "configure-color-palette", configureColorPalette
       ;; (* -- *)
       xor eax, eax
       mov dx, 0x03C8                  ; DAC Address Write Mode Register
       out dx, al
       mov dx, 0x03C9                  ; DAC Data Register
       mov rbx, 16                     ; 16 lines
.nextline:
       mov rcx, 16                     ; 16 colors
       mov rsi, Palette
.nexttritone:
       lodsb
       out dx, al
       lodsb
       out dx, al
       lodsb
       out dx, al
       dec rcx
       cmp rcx, 0
       jne .nexttritone
       dec rbx
       cmp rbx, 0
       jne .nextline                    ; Set the next 16 colors to the same
       mov eax, 0x14                   ; Fix for color 6
       mov dx, 0x03c8                  ; DAC Address Write Mode Register
       out dx, al
       mov dx, 0x03c9                  ; DAC Data Register
       mov rsi, Palette
       add rsi, 18
       lodsb
       out dx, al
       lodsb
       out dx, al
       lodsb
       out dx, al
       next
def_assembly_code "empty?scan-code-queue", empty?ScancodeQueue
   ;; (* -- True or False *)
   mov rax, [RearOfScancodeQueue]
   mov rbx, [FrontOfScancodeQueue]
   inc rax
   cmp rax, SizeOfScancodeQueue
   jne @f
   xor rax, rax
    @@:
   xor rcx, rcx
   cmp rax, rbx
   jne @f
   inc rcx
    @@:
   push_argument_stack rcx
   next

def_assembly_code "in-scan-code-queue", inScancodeQueue
   ;; (* Scancode -- *)
   pop_argument_stack rax
   mov rcx, [FrontOfScancodeQueue]
   mov byte [ScancodeQueue + rcx], al
   inc rcx
   cmp rcx, SizeOfScancodeQueue
   jne @f
   xor rcx, rcx
    @@:
   mov [FrontOfScancodeQueue], rcx
   next

def_assembly_code "out-scan-code-queue", outScancodeQueue
   ;; (* -- Scancode *)
   mov rcx, [RearOfScancodeQueue]
   inc rcx
   cmp rcx, SizeOfScancodeQueue
   jne @f
   xor rcx, rcx
    @@:
   mov [RearOfScancodeQueue], rcx
   xor rax, rax
   mov al, byte [ScancodeQueue + rcx]
   push_argument_stack rax
   next

def_assembly_code "halt", halt
   ;; (* -- *)
   hlt
   next
def_verb "input-key", inputKey
   ;; (* -- Scancode *)
   ;; when ScancodeQueue is empty
   ;; call"halt" to wait for more keystroke
   ;; note that, when you type fast
   ;; one "halt" maybe breaked by many interrupt events
   xx empty?ScancodeQueue, _false?branch, 4
   xx   halt, _branch, -5
   xx outScancodeQueue
   xx Exit
def_verb_end inputKey
;; 1. handle special Scancode first
;;    then call scancodeToASCII
;; 2. the first special Scancode to handle
;;    is about left_shift
;; 3. when scancodeToASCII returns Zero
;;    this scancode is special
;;    call inputKey to get another scancode
;;    to escape it
;; 4. little by little
;;    handle these special scancode been escaped
def_verb "input-char", inputChar
   ;; (* -- ASCII char *)
   xx inputKey
   xx dup, scancodeIsLeftShift?, _false?branch, 5
   xx   toggleLeftShift
   xx   drop, _branch, -8  ;; inputKey
   xx dup, _literal, 128, greater_than?, _false?branch, 4
   xx   drop, _branch, -17 ;; inputKey
   xx scancodeToASCII
   xx dup, zero?, _false?branch, 4
   xx   drop, _branch, -25 ;; inputKey
   xx Exit
def_verb_end inputChar


def_verb "scan-code-is-left-shift?", scancodeIsLeftShift?
   ;; (* scancode -- True or False*)
   xx dup
   xx _literal, 42, equal?, _false?branch, 4
   xx   drop, True
   xx   Exit
   xx _literal, 128, subtraction
   xx _literal, 42, equal?, _false?branch, 3
   xx   True
   xx   Exit
   xx False
   xx Exit
def_verb_end scancodeIsLeftShift?


;; 1. a global variable about left_shift
;;    is checked by the folloing function
;; 2. whether the scancode is able to convert to ASCII
;;    is not decided by "scancodeToASCII"
;;    but by "inputChar"
def_assembly_code "scan-code->ASCII", scancodeToASCII
   ;; (* scancode -- ASCII char or Zero *)
   pop_argument_stack rax
   mov rbx, [StateOfLeftShift + Cell_width]
   test rbx, rbx
   jz @f
   xor rcx, rcx
   mov cl, byte [BarekeyboardLayout_Upper + rax]
   push_argument_stack rcx
   next
    @@:
   xor rcx, rcx
   mov cl, byte [BarekeyboardLayout_Lower + rax]
   push_argument_stack rcx
   next


def_noun "State-of-left-shift", StateOfLeftShift
  xx  0
def_noun_end StateOfLeftShift


def_assembly_code "toggle-left-shift", toggleLeftShift
   ;; (* -- *)
   mov rax, [StateOfLeftShift + Cell_width]
   test rax, rax
   jz @f
   xor rax, rax
   mov [StateOfLeftShift + Cell_width], rax
   next
    @@:
   inc rax
   mov [StateOfLeftShift + Cell_width], rax
   next


;; BarekeyboardLayout
;; and it will be interesting to design new layout

BarekeyboardLayout_Lower:
;;================================
  db 0 ;; 0:[no such scancode]
;;================================
;; 1                                                                      14
db ASCII_esc, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', ASCII_backspace
;; 15                                                                     28
db ASCII_tab, 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', ASCII_newline
;;================================
  db 0 ;; 29:[left_ctrl]
;;================================
;; 30                                                40
db 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', "'"
;; 41
db '`'
;;================================
  db 0 ;; 42:[left_shift]
;;================================
;; 43                                                53
db '\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/'
;;================================
  db 0 ;; 54:[right_shift]
  db 0 ;; 55(224):[print screen & system request]
  db 0 ;; 56:[left_alt]
;;================================
;; 57
db ASCII_space
;;================================
  db 0 ;; 58:[caps_lock]
;;================================
  rb (128 - 58)
;;================================

BarekeyboardLayout_Upper:
;;================================
  db 0 ;; 0:[no such scancode]
;;================================
;; 1                                                                      14
db ASCII_esc, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', ASCII_backspace
;; 15                                                                     28
db ASCII_tab, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', ASCII_newline
;;================================
  db 0 ;; 29:[left_ctrl]
;;================================
;; 30                                                40
db 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', '"'
;; 41
db '~'
;;================================
  db 0 ;; 42:[left_shift]
;;================================
;; 43                                                53
db '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?'
;;================================
  db 0 ;; 54:[right_shift]
  db 0 ;; 55(224):[print screen & system request]
  db 0 ;; 56:[left_alt]
;;================================
;; 57
db ASCII_space
;;================================
  db 0 ;; 58:[caps_lock]
;;================================
  rb (128 - 58)
;;================================


;; --------------------------------------
;; test

;; def_verb "test_inputChar", test_inputChar
;;    xx inputChar, write_byte, _branch, -3
;;    xx Exit
;; def_verb_end test_inputChar
;; 1. this function is like a little editor
;;    with a buffer of which the size is max length
;; 2. input is echoed here, so output functions are needed
;; 3. the concept of cursor is introduced here
;; 4. some editing features are implemented
;; 5. the most important thing is that
;;    before a user meets "max length"
;;    a "linefeed" must be meeted
;;    and this "linefeed" is counted into the length of the string
;;    that returned by "inputLine"
def_verb "input-line", inputLine
   ;; (* [address, max length] -- string[address, actual length] *)
   xx dup2 ;; leave address and to calculate actual length
   xx _literal, '_', write_byte, decrementCursor

   ;; (* address, max length, [address, length] *)
   xx inputChar

   ;; (* address, max length, [address, length], ASCII char *)
   xx dup, _literal, ASCII_backspace
   xx equal?, _false?branch, 24
   xx   drop
   xx   dup, xoverxxx, equal?, _false?branch, 3
   xx     _branch, -14 ;; inputChar
   xx   _literal, ' ', write_byte, decrementCursor
   ;;   clear the '_', the cursor, leaved by every writed chars
   xx   decrementCursor
   ;;   write the new cursor
   xx   _literal, '_', write_byte, decrementCursor
   xx   add1, swap
   xx   sub1, swap
   xx   _branch, -29 ;; inputChar

   ;; (* address, max length, [address, length], ASCII char *)
   xx over, zero?, _false?branch, 4
   ;;   if really meet max length
   ;;   type any key should sent a little warn (but this is not implemented)
   ;;   even type enter key will NOT "Exit" this function
   xx   drop
   ;;   (* address, max length, [address, length] *)
   xx   _branch, -36 ;; inputChar

   ;; (* address, max length, [address, length], ASCII char *)
   ;; "Exit" only on "newline"
   xx dup, _literal, ASCII_newline
   xx equal?, _false?branch, 17
   xx   _literal, ' ', write_byte, decrementCursor
   ;;   clear the '_', the cursor, leaved by every writed chars
   xx   dup, write_byte
   xx   xoverxx, save_byte
   xx   sub1, swap
   xx   add1, swap
   ;;   (* address, max length, [address, length] *)
   xx   swap, drop
   xx   subtraction
   xx   Exit

   ;; (* address, max length, [address, length], ASCII char *)
   xx dup, write_byte
   xx _literal, '_', write_byte, decrementCursor
   ;; leave a '_' after every writed chars as cursor
   xx xoverxx, save_byte
   xx sub1, swap
   xx add1, swap
   ;; (* address, max length, [address, length] *)
   xx _branch, -72 ;; inputChar

def_verb_end inputLine
hereUnInitializedData
;; ------------------------------------------
Size_of_input_buffer = 3*1024*1024

Input_buffer labeling
        preserve Size_of_input_buffer
End_of_input_buffer labeling


def_noun "Size-of-input-buffer",  _Size_of_input_buffer
  xx   Size_of_input_buffer
def_noun_end  _Size_of_input_buffer

def_noun "Input-buffer",        _Input_buffer
  xx           Input_buffer
def_noun_end        _Input_buffer

def_noun "End-of-input-buffer",   TheEnd_of_input_buffer
  xx    End_of_input_buffer
def_noun_end   TheEnd_of_input_buffer


;; 1. two global variables for reading
;;    I can easily support `evalString' by change these two variables
;; 2. note that, there is no char in the address of a "Reading_boundary"
;;    an example of "Reading_boundary" is "End_of_input_buffer"
;; 3. when "Current_reading" == "Reading_boundary"
;;    for the function "read_byte"
;;    we need to reset it to read from "Input_buffer"
;;    and call "inputLine" to fetch more chars
;;    and loop back
def_noun "Current-reading", Current_reading
  xx   Input_buffer
def_noun_end Current_reading

def_noun "Reading-boundary", Reading_boundary
  xx  Input_buffer
def_noun_end Reading_boundary


def_verb "read-byte", read_byte
   ;; (*  -- char *)
   xx Current_reading
   xx Reading_boundary
   xx less_than?, _false?branch, 8
   ;;   there is still some chars in the Input_buffer
   ;;   (or any other buffer) to be processed
   xx   Current_reading, fetch_byte
   xx   _literal, 1, _address, Current_reading, add_save
   xx   Exit
   ;; all chars in Input_buffer
   ;; (or any other buffer) have been processed
   xx notReadingFromInput_buffer?, _false?branch, 5
   ;;   add blank at the end
   ;;   otherwise,  when the a string not ending with blank
   ;;   "evalString" will not work correctly
   xx   _literal, ASCII_linefeed
   xx   toReadFromInput_buffer
   xx   Exit
   ;; when "Current_reading" == "Reading_boundary"
   ;; we need to reset it to read from "Input_buffer"
   ;; and call "inputLine" to fetch more chars
   ;; and loop back
   xx toReadFromInput_buffer
   xx _Input_buffer, _Size_of_input_buffer
   xx openInterrupt
   xx inputLine
   xx closeInterrupt
   ;; set Reading_boundary ==
   ;;     Input_buffer + length of string that was inputed
   xx _address, Reading_boundary, add_save
   xx drop
   xx _branch, -31
def_verb_end read_byte

def_verb "not-reading-from-input-buffer?", notReadingFromInput_buffer?
   ;; (* -- True of False *)
   xx Current_reading
   xx TheEnd_of_input_buffer, greater_than?, _false?branch, 3
   xx   True
   xx   Exit
   xx Current_reading
   xx _Input_buffer, less_than?, _false?branch, 3
   xx   True
   xx   Exit
   xx False
   xx Exit
def_verb_end notReadingFromInput_buffer?

def_verb "to-read-from-input-buffer", toReadFromInput_buffer
   ;; (* -- *)
   xx _Input_buffer, _address, Current_reading, save
   xx _Input_buffer, _address, Reading_boundary, save
   xx Exit
def_verb_end toReadFromInput_buffer
;; the size of a ScreenBuffer is equal to the size of the screen
;; which is 80*25*2

hereUnInitializedData
;; ------------------------------------------
;; the size of a ScreenBuffer is equal to the size of the screen
;; which is 80*25*2 bytes
;; and cursor and ScreenBuffer are in the same structure
;; the size of its cursor is 2 bytes
SizeOfScreenBuffer = 80*25*2
SizeOfCursor = 8

Cursor0_InAssembly labeling
        preserve SizeOfCursor
ScreenBuffer0_InAssembly labeling
        preserve SizeOfScreenBuffer

def_noun "screen-buffer-0", ScreenBuffer0
  xx  ScreenBuffer0_InAssembly
def_noun_end ScreenBuffer0


def_assembly_code "scroll-screen-buffer", scrollScreenBuffer
   ;; (* screen buffer[address] -- *)
   ;; scrolls a screen Buffer up by one line
   ;; Default_back_color_of_char should be used
   pop_argument_stack rdi              ; Start of video text memory for row 1
   mov rsi, rdi
   add rsi, 0xA0                   ; Start of video text memory for row 2
   cld ;; clear the direction flag as we want to increment through memory
   xor rcx, rcx
   mov cx, (80 * 24)
   rep movsw                       ; Copy the Character and Attribute
   ; Clear the last line in video memory
   mov bl, byte [Default_back_color_of_char + Cell_width]
   shl bl, 4
   mov ah, byte [Default_fore_color_of_char + Cell_width]
   or ah, bl
   mov al, ' '
   mov cx, 80
   rep stosw                       ; Store word in AX to RDI, RCX times
   next

def_assembly_code "clear-screen-buffer", clearScreenBuffer
   ;; (* screen buffer[address] -- *)
   pop_argument_stack rdi              ; Address for start of frame buffer
   cld ;; clear the direction flag as we want to increment through memory
   mov bl, byte [Default_back_color_of_char + Cell_width]
   shl bl, 4
   mov ah, byte [Default_fore_color_of_char + Cell_width]
   or ah, bl
   mov al, ' '
   xor rcx, rcx
   mov cx, (80 * 25)
   rep stosw                       ; Clear the screen. Store word in AX to RDI, RCX times
   next
def_assembly_code "update-screen", updateScreen
   ;; (* screen buffer[address] -- *)
   ;; print a screen buffer to screen
   pop_argument_stack rsi
   cld ;; clear the direction flag as we want to increment through memory
   mov rdi, 0xb8000
   mov cx, 2000                    ; 80 x 25
   rep movsw
   next


def_noun "Current-screen-buffer", Current_screen_buffer
  xx  ScreenBuffer0_InAssembly
def_noun_end Current_screen_buffer


def_verb "scroll-screen", scrollScreen
   ;; (* -- *)
   ;; scrolls a screen Buffer up by one line
   ;; Default_back_color_of_char should be used
   xx Current_screen_buffer
   xx dup, scrollScreenBuffer
   xx updateScreen
   xx Exit
def_verb_end scrollScreen

def_verb "clear-screen", clearScreen
   ;; (* -- *)
   xx Current_screen_buffer
   xx dup, clearScreenBuffer
   xx updateScreen
   xx Exit
def_verb_end clearScreen
def_noun "Number-of-columns-of-screen", NumberOfColumnsOfScreen
  xx  80
def_noun_end NumberOfColumnsOfScreen

def_noun "Number-of-rows-of-screen", NumberOfRowsOfScreen
  xx  25
def_noun_end NumberOfRowsOfScreen

def_noun "Number-of-chars-of-screen", NumberOfCharsOfScreen
  xx  80*25
def_noun_end NumberOfCharsOfScreen


def_verb "get-current-cursor-address", getCurrentCursorAddress
   ;; (* -- CurrentCursor[address] *)
   xx Current_screen_buffer
   xx sub8
   xx Exit
def_verb_end getCurrentCursorAddress

def_verb "reset-current-cursor", resetCurrentCursor
   ;; (* -- *)
   xx _literal, 0, getCurrentCursorAddress, save
   xx Exit
def_verb_end resetCurrentCursor

;; start from 1 to 25
def_verb "get-current-cursor-row", getCurrentCursorRow
   ;; (* -- row *)
   xx getCurrentCursorAddress, fetch
   xx NumberOfColumnsOfScreen, moddiv
   xx swap, drop, add1
   xx Exit
def_verb_end getCurrentCursorRow

;; start from 1 to 80
def_verb "get-current-cursor-column", getCurrentCursorColumn
   ;; (* -- column *)
   xx getCurrentCursorAddress, fetch
   xx NumberOfColumnsOfScreen, moddiv
   xx drop, add1
   xx Exit
def_verb_end getCurrentCursorColumn


def_verb "increment-cursor", incrementCursor
   ;; (* -- *)
   xx getCurrentCursorAddress, fetch, add1
   xx NumberOfCharsOfScreen, equal?, _false?branch, 6
   xx   scrollScreen
   xx   NumberOfColumnsOfScreen, getCurrentCursorAddress, sub_save
   xx   Exit
   xx _literal, 1, getCurrentCursorAddress, add_save
   xx Exit
def_verb_end incrementCursor

def_verb "decrement-cursor", decrementCursor
   ;; (* -- *)
   xx getCurrentCursorAddress, fetch
   xx zero?, _false?branch, 2
   xx   Exit
   xx _literal, 1, getCurrentCursorAddress, sub_save
   xx Exit
def_verb_end decrementCursor
;; text mode (aka. mode 0) -- the most simple output
;; (one can not support UTF-8 in text mode)
;; direct memory access to a linear address start at 0xb8000
;; 80 cols * 25 rows * 2 bytes
;; - The second byte is an ASCII char
;; - The first byte of the 2 bytes is split into forecolor & backcolor

;; Bit 76543210
;;     ||||||||
;;     |||||^^^-fore color
;;     ||||^----fore color bright bit
;;     |^^^-----back color
;;     ^--------back color bright bit (or enables blinking text)

;;   0 : Black               0+8 : Dark Gray
;;   1 : Blue                1+8 : Light Blue
;;   2 : Green               2+8 : Light Green
;;   3 : Cyan                3+8 : Light Cyan
;;   4 : Red                 4+8 : Light Red
;;   5 : Magenta             5+8 : Light Magenta
;;   6 : Brown               6+8 : Yellow
;;   7 : Light Gray          7+8 : White

def_noun "Black-char"    ,     BlackChar
  xx           0
def_noun_end         BlackChar

def_noun "Blue-char"    ,     BlueChar
  xx            1
def_noun_end         BlueChar

def_noun "Green-char"    ,     GreenChar
  xx           2
def_noun_end         GreenChar

def_noun "Cyan-char"    ,     CyanChar
  xx            3
def_noun_end         CyanChar

def_noun "Red-char"    ,     RedChar
  xx             4
def_noun_end         RedChar

def_noun "Magenta-char"    ,     MagentaChar
  xx         5
def_noun_end         MagentaChar

def_noun "Brown-char"    ,     BrownChar
  xx           6
def_noun_end         BrownChar

def_noun "Light-gray-char"    ,     LightGrayChar
  xx      7
def_noun_end         LightGrayChar


def_noun "Dark-gray-char"  ,     DarkGrayChar
  xx        0+8
def_noun_end       DarkGrayChar

def_noun "Light-blue-char"  ,     LightBlueChar
  xx       1+8
def_noun_end       LightBlueChar

def_noun "Light-green-char"  ,     LightGreenChar
  xx      2+8
def_noun_end       LightGreenChar

def_noun "Light-cyan-char"  ,     LightCyanChar
  xx       3+8
def_noun_end       LightCyanChar

def_noun "Light-redchar"  ,     LightRedChar
  xx         4+8
def_noun_end       LightRedChar

def_noun "Light-magenta-char"  ,     LightMagentaChar
  xx    5+8
def_noun_end       LightMagentaChar

def_noun "Yellow-char"  ,     YellowChar
  xx           6+8
def_noun_end       YellowChar

def_noun "White-char"  ,     WhiteChar
  xx            7+8
def_noun_end       WhiteChar



def_assembly_code "put-char-with-color", putCharWithColor
   ;; (* char, back color, fore color -- *)
   ;; put a ASCII char with color to the position of the cursor
   ;; but can not handle ASCII_linefeed as my wish
   pop_argument_stack rcx
   pop_argument_stack rbx
   pop_argument_stack rax

   shl rbx, 4
   or rbx, rcx
   ;; Store the color into AH so STOSW can be used later on
   mov ah, bl

   push rax


   mov rdx, [Current_screen_buffer + Cell_width]
   mov ax, [rdx - 8]

   shl ax, 1                       ; multiply by 2

   mov rbx, rax                    ; Save the row/col offset
   mov rdi, rdx                    ; Address of the screen buffer
   add rdi, rax                    ; screen buffer is needed to scroll the screen


   pop rax

   stosw                           ; Write the character and attribute to screen buffer

   mov rdi, 0xb8000
   add rdi, rbx
   stosw                           ; Write the character and attribute to screen

   next


;;   0 : Black               0+8 : Dark Gray
;;   1 : Blue                1+8 : Light Blue
;;   2 : Green               2+8 : Light Green
;;   3 : Cyan                3+8 : Light Cyan
;;   4 : Red                 4+8 : Light Red
;;   5 : Magenta             5+8 : Light Magenta
;;   6 : Brown               6+8 : Yellow
;;   7 : Light Gray          7+8 : White
def_noun "Default-back-color-of-char", Default_back_color_of_char
  xx  0+8
def_noun_end Default_back_color_of_char

def_noun "Default-fore-color-of-char", Default_fore_color_of_char
  xx  7+8
def_noun_end Default_fore_color_of_char


def_verb "put-char", putChar
   ;; (* char -- *)
   xx Default_back_color_of_char
   xx Default_fore_color_of_char
   xx putCharWithColor
   xx Exit
def_verb_end putChar
def_verb "print-newline", printNewline
   ;; (* -- *)
   xx getCurrentCursorRow
   xx NumberOfRowsOfScreen, equal?, _false?branch, 7
   xx   scrollScreen
   xx   getCurrentCursorColumn, sub1
   xx   getCurrentCursorAddress, sub_save
   xx   Exit
   xx NumberOfColumnsOfScreen
   xx getCurrentCursorColumn, sub1, subtraction
   xx getCurrentCursorAddress, add_save
   xx Exit
def_verb_end printNewline
def_verb "write-byte-with-color", write_byte_with_color
   ;; (* char, back color, fore color --  *)
   xx xoverxx, _literal, ASCII_linefeed
   xx equal?, _false?branch, 5
   xx   drop2, drop, printNewline
   xx   Exit
   xx putCharWithColor
   xx incrementCursor
   xx Exit
def_verb_end write_byte_with_color


def_verb "write-byte", write_byte
   ;; (* char --  *)
   xx dup, _literal, ASCII_linefeed
   xx equal?, _false?branch, 4
   xx   drop, printNewline
   xx   Exit
   xx putChar
   xx incrementCursor
   xx Exit
def_verb_end write_byte
def_verb "print-string", print_string
   ;; (* string[address, length] -- *)
   xx dup, zero?, _false?branch, 3
   xx   drop2
   xx   Exit
   xx sub1, swap
   xx dup, fetch_byte, write_byte
   xx add1, swap
   xx _branch, -14
def_verb_end print_string
include "../threaded-code.inc"
def_assembly_code "reboot", reboot
       ;; (* -- *)
.loop:
       in al, 0x64
       test al, 00000010b              ; Wait for an empty Input Buffer ???
       jne .loop
       mov al, 0xFE
       out 0x64, al                    ; Send the reboot call to the keyboard controller
       jmp .loop
def_verb ".", print_little_number
       xx _literal, '0'
       xx addition, write_byte
       xx _literal, 32
       xx write_byte
       xx _literal, 32
       xx write_byte
       xx Exit
def_verb_end print_little_number
def_noun "Address-of-VBE-info-block", Assembly_VBEInfoBlock
   xx  VBEInfoBlock
def_noun_end Assembly_VBEInfoBlock
hereUnInitializedData
;; ------------------------------------------
User_data_area labeling
End_of_user_data_area = 1*1024*1024*1024

def_noun "User-data-area", _User_data_area
   xx  User_data_area
def_noun_end _User_data_area

def_noun "End-of-user-data-area", _End_of_user_data_area
   xx  End_of_user_data_area
def_noun_end _End_of_user_data_area
;; this word helps to initialize First_word_in_dictionary
def_noun "Latest-word-in-assembly", Latest_word_in_assembly
   xx  0
def_noun_end Latest_word_in_assembly
times (SizeOfKernel * 1024) - ($-$$) - 4 db 0
dd MagicNumberOfKernel  ;; 4 bytes
