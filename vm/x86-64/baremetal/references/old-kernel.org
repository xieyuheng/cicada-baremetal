#+TITLE: old kernel


* ==================================================
* TODO
  1. add support to read and write only a partition the disk
     to achieve this
     we need to read a global variable setted by bootloader
     full GPT support will be implement in cicada
* ==================================================
* old kernel
** org 
   #+begin_src fasm :tangle no
   use64  
   org 1*1024*1024   
   #+end_src
** about the size of kernelloader and kernel
   #+begin_src fasm :tangle no
   SizeOfKernelloader = 6 ;; unit :: k
   LocationOfKernelloader = 8000h
   MagicNumberOfKernelloader = 26766h
   
   SizeOfKernel = 512 ;; unit :: k
   LocationOfKernel = 2*1024*1024
   MagicNumberOfKernel = 26881h
   #+end_src
** memory addresses
   #+begin_src fasm :tangle no
   sys_idt                = 0x0000000000000000  ; 4096 bytes    0x000000 -> 0x000FFF    Interrupt descriptor table
   sys_gdt                = 0x0000000000001000  ; 4096 bytes    0x001000 -> 0x001FFF    Global descriptor table
   sys_pml4               = 0x0000000000002000  ; 4096 bytes    0x002000 -> 0x002FFF    PML4 table
   sys_pdp                = 0x0000000000003000  ; 4096 bytes    0x003000 -> 0x003FFF    PDP table
   sys_Pure64             = 0x0000000000004000  ; 16384 bytes   0x004000 -> 0x007FFF    Pure64 system data
   sys_pd                 = 0x0000000000010000  ; 262144 bytes  0x010000 -> 0x04FFFF    Page directory
   ahci_cmdlist           = 0x0000000000070000  ; 4096 bytes    0x070000 -> 0x071FFF
   ahci_receivedfis       = 0x0000000000071000  ; 4096 bytes    0x071000 -> 0x072FFF
   ahci_cmdtable          = 0x0000000000072000  ; 57344 bytes   0x072000 -> 0x07FFFF
   cli_temp_string        = 0x0000000000080000  ; 1024 bytes    0x080000 -> 0x0803FF
   os_temp_string         = 0x0000000000080400  ; 1024 bytes    0x080400 -> 0x0807FF
   os_args                = 0x0000000000080C00
   bmfs_directory         = 0x0000000000090000  ; 4096 bytes    0x090000 -> 0x090FFF
   os_filehandlers        = 0x0000000000091000  ; 64 bytes (1x64)
   os_filehandlers_seek   = 0x0000000000092000  ; 512 bytes (8x64)
   sys_ROM                = 0x00000000000A0000  ; 393216 bytes  0x0A0000 -> 0x0FFFFF
   os_KernelStart         = 0x0000000000100000  ; 65536 bytes   0x100000 -> 0x10FFFF    Location of Kernel
   os_SystemVariables     = 0x0000000000110000  ; 65536 bytes   0x110000 -> 0x11FFFF    Location of System Variables
   os_MemoryMap           = 0x0000000000120000  ; 131072 bytes  0x120000 -> 0x13FFFF    Location of Memory Map - Room to map 256 GiB with 2 MiB pages
   os_EthernetBuffer      = 0x0000000000140000  ; 262144 bytes  0x140000 -> 0x17FFFF    Location of Ethernet RX Ring Buffer - Room for 170 packets
   os_screen              = 0x0000000000180000  ; 4096 bytes    80x25x2 = 4000
   os_temp                = 0x0000000000190000
   os_ethernet_rx_buffer  = 0x00000000001C0000
   os_eth_rx_buffer       = 0x00000000001C8000
   os_ethernet_tx_buffer  = 0x00000000001D0000
   os_eth_tx_buffer       = 0x00000000001D8000
   cpustatus              = 0x00000000001FEF00  ; Location of CPU status data (256 bytes) Bit 0 = Available, Bit 1 = Free/Busy
   cpuqueue               = 0x00000000001FF000  ; Location of CPU Queue. Each queue item is 16 bytes. (4KiB before the 2MiB mark, Room for 256 entries)
   programlocation        = 0x0000000000200000  ; Location in memory where programs are loaded (the start of 2MiB)
   
   
   
   ; DQ - Starting at offset 0, increments by 8
   os_LocalAPICAddress    = os_SystemVariables + 0
   os_IOAPICAddress       = os_SystemVariables + 8
   os_ClockCounter        = os_SystemVariables + 16
   os_VideoBase           = os_SystemVariables + 24
   screen_cursor_offset   = os_SystemVariables + 32
   os_StackBase           = os_SystemVariables + 40
   os_net_transmit        = os_SystemVariables + 48
   os_net_poll            = os_SystemVariables + 56
   os_net_ack_int         = os_SystemVariables + 64
   os_NetIOBaseMem        = os_SystemVariables + 72
   os_NetMAC              = os_SystemVariables + 80
   os_HPETAddress         = os_SystemVariables + 88
   ahci_base              = os_SystemVariables + 96
   os_NetworkCallback     = os_SystemVariables + 104
   bmfs_TotalBlocks       = os_SystemVariables + 112
   os_KeyboardCallback    = os_SystemVariables + 120
   os_ClockCallback       = os_SystemVariables + 128
   os_net_TXBytes         = os_SystemVariables + 136
   os_net_TXPackets       = os_SystemVariables + 144
   os_net_RXBytes         = os_SystemVariables + 152
   os_net_RXPackets       = os_SystemVariables + 160
   os_hdd_BytesRead       = os_SystemVariables + 168
   os_hdd_BytesWrite      = os_SystemVariables + 176
   
   ; DD - Starting at offset 256, increments by 4
   cpu_speed              = os_SystemVariables + 256    ; in MHz
   os_HPETRate            = os_SystemVariables + 260
   os_MemAmount           = os_SystemVariables + 264    ; in MiB
   ahci_port              = os_SystemVariables + 268
   hd1_size               = os_SystemVariables + 272    ; in MiB
   os_Screen_Pixels       = os_SystemVariables + 276
   os_Screen_Bytes        = os_SystemVariables + 280
   os_Screen_Row_2        = os_SystemVariables + 284
   os_Font_Color          = os_SystemVariables + 288
   
   ; DW - Starting at offset 512, increments by 2
   os_NumCores            = os_SystemVariables + 512
   cpuqueuestart          = os_SystemVariables + 514
   cpuqueuefinish         = os_SystemVariables + 516
   os_QueueLen            = os_SystemVariables + 518
   os_QueueLock           = os_SystemVariables + 520    ; Bit 0 clear for unlocked, set for locked.
   os_NetIOAddress        = os_SystemVariables + 522
   os_EthernetBusyLock    = os_SystemVariables + 524
   os_VideoX              = os_SystemVariables + 526
   os_VideoY              = os_SystemVariables + 528
   os_Screen_Rows         = os_SystemVariables + 530
   os_Screen_Cols         = os_SystemVariables + 532
   os_Screen_Cursor_Row   = os_SystemVariables + 534
   os_Screen_Cursor_Col   = os_SystemVariables + 536
   
   ; DB - Starting at offset 768, increments by 1
   cursorx                = os_SystemVariables + 768    ; cursor row location
   cursory                = os_SystemVariables + 769    ; cursor column location
   scancode               = os_SystemVariables + 770
   key                    = os_SystemVariables + 771
   key_shift              = os_SystemVariables + 772
   screen_cursor_x        = os_SystemVariables + 773
   screen_cursor_y        = os_SystemVariables + 774
   os_PCIEnabled          = os_SystemVariables + 775    ; 1 if PCI is detected
   os_NetEnabled          = os_SystemVariables + 776    ; 1 if a supported network card was enabled
   os_NetIRQ              = os_SystemVariables + 778    ; Set to Interrupt line that NIC is connected to
   os_NetActivity_TX      = os_SystemVariables + 779
   os_NetActivity_RX      = os_SystemVariables + 780
   os_EthernetBuffer_C1   = os_SystemVariables + 781    ; Counter 1 for the Ethernet RX Ring Buffer
   os_EthernetBuffer_C2   = os_SystemVariables + 782    ; Counter 2 for the Ethernet RX Ring Buffer
   os_DiskEnabled         = os_SystemVariables + 783
   os_DiskActivity        = os_SystemVariables + 784
   app_argc               = os_SystemVariables + 785
   os_VideoDepth          = os_SystemVariables + 786
   os_VideoEnabled        = os_SystemVariables + 787
   
   
   
   ; File System
   ; Define the structure of a directory entry
   ;; struc BMFS_DirEnt {
   ;;         .filename       rb 32
   ;;         .start          rq 1  ; starting block index
   ;;         .reserved       rq 1  ; number of blocks reserved
   ;;         .size           rq 1  ; number of bytes
   ;;         .unused         rq 1
   ;; }
   
   BMFS_DirEnt.filename  = 0
   BMFS_DirEnt.start     = 32
   BMFS_DirEnt.reserved  = 32 + 8
   BMFS_DirEnt.size      = 32 + 8 + 8
   BMFS_DirEnt.unused    = 32 + 8 + 8 + 8
   #+end_src
** main
   #+begin_src fasm :tangle no   
   old_kernel_start:   
           call init_64                    ; After this point we are in a working 64-bit environment
           call init_pci                   ; Initialize the PCI bus
           call init_hdd                   ; Initialize the disk
           call init_net                   ; Initialize the network  
   
   
           mov ax, word[os_Screen_Rows]        ; Display the "ready" message and reset cursor to bottom left
           push ax
           sub ax, 3
           mov word [os_Screen_Cursor_Row], ax
           mov word [os_Screen_Cursor_Col], 0
           mov rsi, readymsg
           call os_output
           pop ax
           sub ax, 1
           mov word [os_Screen_Cursor_Row], ax
           mov word [os_Screen_Cursor_Col], 0
   
           mov rax, os_command_line        ; Start the CLI
           call os_smp_enqueue
   
           ; At this point the BSP is just like one of the AP's
      
   
   ap_clear:                               ; All cores start here on first start-up and after an exception
   
           cli                             ; Disable interrupts on this core
   
           ; Get local ID of the core
           mov rsi, [os_LocalAPICAddress]  ; We can't use os_smp_get_id as no configured stack yet
           xor eax, eax                    ; Clear Task Priority (bits 7:4) and Task Priority Sub-Class (bits 3:0)
           mov dword [rsi+0x80], eax       ; APIC Task Priority Register (TPR)
           mov eax, dword [rsi+0x20]       ; APIC ID in upper 8 bits
           shr rax, 24                     ; Shift to the right and AL now holds the CPU's APIC ID
   
           ; Calculate offset into CPU status table
           mov rdi, cpustatus
           add rdi, rax                    ; RDI points to this cores status byte (we will clear it later)
   
           ; Set up the stack
           shl rax, 21                     ; Shift left 21 bits for a 2 MiB stack
           add rax, [os_StackBase]         ; The stack decrements when you "push", start at 2 MiB in
           sub rax, 8
           mov rsp, rax
   
           ; Set the CPU status to "Present" and "Ready"
           mov al, 00000001b               ; Bit 0 set for "Present", Bit 1 clear for "Ready"
           stosb                           ; Set status to Ready for this CPU
   
           sti                             ; Enable interrupts on this core
   
           ; Clear registers. Gives us a clean slate to work with
           xor rax, rax                    ; aka r0
           xor rcx, rcx                    ; aka r1
           xor rdx, rdx                    ; aka r2
           xor rbx, rbx                    ; aka r3
           xor rbp, rbp                    ; aka r5, We skip RSP (aka r4) as it was previously set
           xor rsi, rsi                    ; aka r6
           xor rdi, rdi                    ; aka r7
           xor r8, r8
           xor r9, r9
           xor r10, r10
           xor r11, r11
           xor r12, r12
           xor r13, r13
           xor r14, r14
           xor r15, r15
   
   ap_spin:                                ; Spin until there is a workload in the queue
           cmp word [os_QueueLen], 0       ; Check the length of the queue
           je ap_halt                      ; If the queue was empty then jump to the HLT
           call os_smp_dequeue             ; Try to pull a workload out of the queue
           jnc ap_process                  ; Carry clear if successful, jump to ap_process
   
   ap_halt:                                ; Halt until a wakeup call is received
           hlt                             ; If carry was set we fall through to the HLT
           jmp ap_spin                     ; Try again
   
   ap_process:                             ; Set the status byte to "Busy" and run the code
           push rdi                        ; Push RDI since it is used temporarily
           push rax                        ; Push RAX since os_smp_get_id uses it
           mov rdi, cpustatus
           call os_smp_get_id              ; Set RAX to the APIC ID
           add rdi, rax
           mov al, 00000011b               ; Bit 0 set for "Present", Bit 1 set for "Busy"
           stosb
           pop rax                         ; Pop RAX (holds the workload code address)
           pop rdi                         ; Pop RDI (holds the variable/variable address)
   
           call rax                        ; Run the code
   
           jmp ap_clear                    ; Reset the stack, clear the registers, and wait for something else to work on
   #+end_src
** sysvar
   #+begin_src fasm :tangle no
   SYS64_CODE_SEL  = 8           ; defined by Pure64
   ;------------------------------------------------------------------------------

   ; Constants
   hextable:               db '0123456789ABCDEF'

   ; Strings
   system_status_header:   db 'BareMetal v0.6.1', 0
   readymsg:               db 'kernelloader is ready', 0
   cpumsg:                 db '[cpu: ', 0
   memmsg:                 db ']  [mem: ', 0
   networkmsg:             db ']  [net: ', 0
   diskmsg:                db ']  [hdd: ', 0
   mibmsg:                 db ' MiB', 0
   mhzmsg:                 db ' MHz', 0
   coresmsg:               db ' x ', 0
   namsg:                  db 'N/A', 0
   closebracketmsg:        db ']', 0
   space:                  db ' ', 0
   newline:                db 13, 0
   tab:                    db 9, 0
   memory_message:         db 'Not enough system memory for CPU stacks! System halted.', 0


   cpuqueuemax:            dw 256
   screen_rows:            db 25 ; x
   screen_cols:            db 80 ; y

   ; Function variables
   os_debug_dump_reg_stage:        db 0x00


   keylayoutlower:
   db 0x00, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '-', '=', 0x0e, 0, 'q', 'w', 'e', 'r', 't', 'y', 'u', 'i', 'o', 'p', '[', ']', 0x1c, 0, 'a', 's', 'd', 'f', 'g', 'h', 'j', 'k', 'l', ';', 0x27, '`', 0, '\', 'z', 'x', 'c', 'v', 'b', 'n', 'm', ',', '.', '/', 0, 0, 0, ' ', 0
   keylayoutupper:
   db 0x00, 0, '!', '@', '#', '$', '%', '^', '&', '*', '(', ')', '_', '+', 0x0e, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '{', '}', 0x1c, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ':', 0x22, '~', 0, '|', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', '<', '>', '?', 0, 0, 0, ' ', 0
   ; 0e = backspace
   ; 1c = enter

   palette:                ; These colors are in RGB format. Each color byte is actually 6 bits (0x00 - 0x3F)
   db 0x00, 0x00, 0x00     ;  0 Black
   db 0x33, 0x00, 0x00     ;  1 Red
   db 0x0F, 0x26, 0x01     ;  2 Green
   db 0x0D, 0x19, 0x29     ;  3 Blue
   db 0x31, 0x28, 0x00     ;  4 Orange
   db 0x1D, 0x14, 0x1E     ;  5 Purple
   db 0x01, 0x26, 0x26     ;  6 Teal
   db 0x2A, 0x2A, 0x2A     ;  7 Light Gray
   db 0x15, 0x15, 0x15     ;  8 Dark Gray
   db 0x3B, 0x0A, 0x0A     ;  9 Bright Red
   db 0x22, 0x38, 0x0D     ; 10 Bright Green
   db 0x1C, 0x27, 0x33     ; 11 Bright Blue
   db 0x3F, 0x3A, 0x13     ; 12 Yellow
   db 0x2B, 0x1F, 0x2A     ; 13 Bright Purple
   db 0x0D, 0x38, 0x38     ; 14 Bright Teal
   db 0x3F, 0x3F, 0x3F     ; 15 White


   os_debug_dump_reg_string00:     db '  A:', 0
   os_debug_dump_reg_string01:     db '  B:', 0
   os_debug_dump_reg_string02:     db '  C:', 0
   os_debug_dump_reg_string03:     db '  D:', 0
   os_debug_dump_reg_string04:     db ' SI:', 0
   os_debug_dump_reg_string05:     db ' DI:', 0
   os_debug_dump_reg_string06:     db ' BP:', 0
   os_debug_dump_reg_string07:     db ' SP:', 0
   os_debug_dump_reg_string08:     db '  8:', 0
   os_debug_dump_reg_string09:     db '  9:', 0
   os_debug_dump_reg_string0A:     db ' 10:', 0
   os_debug_dump_reg_string0B:     db ' 11:', 0
   os_debug_dump_reg_string0C:     db ' 12:', 0
   os_debug_dump_reg_string0D:     db ' 13:', 0
   os_debug_dump_reg_string0E:     db ' 14:', 0
   os_debug_dump_reg_string0F:     db ' 15:', 0
   os_debug_dump_reg_string10:     db ' RF:', 0

   os_debug_dump_flag_string0:     db ' C:', 0
   os_debug_dump_flag_string1:     db ' Z:', 0
   os_debug_dump_flag_string2:     db ' S:', 0
   os_debug_dump_flag_string3:     db ' D:', 0
   os_debug_dump_flag_string4:     db ' O:', 0   
   #+end_src
** init
*** 64
    #+begin_src fasm :tangle no
    init_64:
            ; Make sure that memory range 0x110000 - 0x200000 is cleared
            ;  (1+(1/16))M - 2M
            mov rdi, os_SystemVariables
            mov rcx, (200000h-110000h)/8 ; Clear 960 KiB = (15/16)M
            xor rax, rax
            rep stosq                    ; Store rax to [rdi], rcx - 1, rdi + 8, if rcx > 0 then do it again
    
            mov word [os_Screen_Rows], 25
            mov word [os_Screen_Cols], 80    
    
    nographics:
            mov word [os_Screen_Cursor_Row], 0
            mov word [os_Screen_Cursor_Col], 0
            call os_screen_clear            ; Clear screen and display cursor
    
            ; Display CPU information
            mov ax, [os_Screen_Rows]
            sub ax, 5
            mov word [os_Screen_Cursor_Row], ax
            mov word [os_Screen_Cursor_Col], 0
            mov rsi, cpumsg
            call os_output
            xor eax, eax
            mov rsi, 0x5012
            lodsw
            mov rdi, os_temp_string
            mov rsi, rdi
            call os_int_to_string
            call os_output
            mov rsi, coresmsg
            call os_output
            mov rsi, 0x5010
            lodsw
            mov rdi, os_temp_string
            mov rsi, rdi
            call os_int_to_string
            call os_output
            mov rsi, mhzmsg
            call os_output
    
            xor rdi, rdi                    ; Create the 64-bit IDT (at linear address 0x0000000000000000) as defined by Pure64
    
    
    
    
            ; Create exception gate stubs (Pure64 has already set the correct gate markers)
            mov rcx, 32
            mov rax, exception_gate
    make_exception_gate_stubs:
            call create_gate
            add rdi, 1
            sub rcx, 1
            jnz make_exception_gate_stubs
    
            ; Create interrupt gate stubs (Pure64 has already set the correct gate markers)
            mov rcx, 256-32
            mov rax, interrupt_gate
    make_interrupt_gate_stubs:
            call create_gate
            add rdi, 1
            sub rcx, 1
            jnz make_interrupt_gate_stubs
    
    
    
    
            ; Set up the exception gates for all of the CPU exceptions
            mov rcx, 20
            xor rdi, rdi
            mov rax, exception_gate_00
    make_exception_gates:
            call create_gate
            add rdi, 1
            add rax, 16                     ; The exception gates are aligned at 16 bytes
            sub rcx, 1
            jnz make_exception_gates
    
            ; Set up the IRQ handlers (Network IRQ handler is configured in init_net)
            mov rdi, 0x21
            mov rax, keyboard
            call create_gate
            mov rdi, 0x22
            mov rax, cascade
            call create_gate
            mov rdi, 0x28
            mov rax, rtc
            call create_gate
            mov rdi, 0x80
            mov rax, ap_wakeup
            call create_gate
            mov rdi, 0x81
            mov rax, ap_reset
            call create_gate
    
            ; Set up RTC
            ; Rate defines how often the RTC interrupt is triggered
            ; Rate is a 4-bit value from 1 to 15. 1 = 32768Hz, 6 = 1024Hz, 15 = 2Hz
            ; RTC value must stay at 32.768KHz or the computer will not keep the correct time
            ; http://wiki.osdev.org/RTC
    rtc_poll:
            mov al, 0x0A                    ; Status Register A
            out 0x70, al
            in al, 0x71
            test al, 0x80                   ; Is there an update in process?
            jne rtc_poll                    ; If so then keep polling
            mov al, 0x0A                    ; Status Register A
            out 0x70, al
            mov al, 00101101b               ; RTC@32.768KHz (0010), Rate@8Hz (1101)
            out 0x71, al
            mov al, 0x0B                    ; Status Register B
            out 0x70, al                    ; Select the address
            in al, 0x71                     ; Read the current settings
            push rax
            mov al, 0x0B                    ; Status Register B
            out 0x70, al                    ; Select the address
            pop rax
            bts ax, 6                       ; Set Periodic(6)
            out 0x71, al                    ; Write the new settings
            mov al, 0x0C                    ; Acknowledge the RTC
            out 0x70, al
            in al, 0x71
    
            ; Set color palette
            xor eax, eax
            mov dx, 0x03C8                  ; DAC Address Write Mode Register
            out dx, al
            mov dx, 0x03C9                  ; DAC Data Register
            mov rbx, 16                     ; 16 lines
    nextline:
            mov rcx, 16                     ; 16 colors
            mov rsi, palette
    nexttritone:
            lodsb
            out dx, al
            lodsb
            out dx, al
            lodsb
            out dx, al
            dec rcx
            cmp rcx, 0
            jne nexttritone
            dec rbx
            cmp rbx, 0
            jne nextline                    ; Set the next 16 colors to the same
            mov eax, 0x14                   ; Fix for color 6
            mov dx, 0x03c8                  ; DAC Address Write Mode Register
            out dx, al
            mov dx, 0x03c9                  ; DAC Data Register
            mov rsi, palette
            add rsi, 18
            lodsb
            out dx, al
            lodsb
            out dx, al
            lodsb
            out dx, al
    
            xor eax, eax
            xor ebx, ebx
            xor ecx, ecx
            ; Grab data from Pure64's infomap
            mov rsi, 0x5008
            lodsd                           ; Load the BSP ID
            mov ebx, eax                    ; Save it to EBX
            mov rsi, 0x5012
            lodsw                           ; Load the number of activated cores
            mov cx, ax                      ; Save it to CX
            mov rsi, 0x5060
            lodsq
            mov [os_LocalAPICAddress], rax
            lodsq
            mov [os_IOAPICAddress], rax
    
            mov rsi, 0x5012
            lodsw
            mov [os_NumCores], ax
    
            mov rsi, 0x5020
            lodsd
            mov [os_MemAmount], eax         ; In MiB's
    
            mov rsi, 0x5040
            lodsq
            mov [os_HPETAddress], rax
    
            ; Build the OS memory table
            call init_memory_map
    
            ; Initialize all AP's to run our reset code. Skip the BSP
            xor rax, rax
            mov rsi, 0x0000000000005100     ; Location in memory of the Pure64 CPU data
    next_ap:
            cmp cx, 0
            je no_more_aps
            lodsb                           ; Load the CPU APIC ID
            cmp al, bl
            je skip_ap
            call os_smp_reset               ; Reset the CPU
    skip_ap:
            sub cx, 1
            jmp next_ap
    
    no_more_aps:
    
            ; Display memory information
            mov rsi, memmsg
            call os_output
            mov eax, [os_MemAmount]         ; In MiB's
            mov rdi, os_temp_string
            mov rsi, rdi
            call os_int_to_string
            call os_output
            mov rsi, mibmsg
            call os_output
    
            ; Enable specific interrupts
            mov al, 0x01                    ; Keyboard IRQ
            call os_pic_mask_clear
            mov al, 0x02                    ; Cascade IRQ
            call os_pic_mask_clear
            mov al, 0x08                    ; RTC IRQ
            call os_pic_mask_clear
    
            ret
    
    
    ; create_gate
    ; rax = address of handler
    ; rdi = gate # to configure
    create_gate:
            push rdi
            push rax
    
            shl rdi, 4                      ; quickly multiply rdi by 16
            stosw                           ; store the low word (15..0)
            shr rax, 16
            add rdi, 4                      ; skip the gate marker
            stosw                           ; store the high word (31..16)
            shr rax, 16
            stosd                           ; store the high dword (63..32)
    
            pop rax
            pop rdi
            ret
    
    init_memory_map:                        ; Build the OS memory table
            push rax
            push rcx
            push rdi
    
            ; Build a fresh memory map for the system
            mov rdi, os_MemoryMap
            push rdi
            xor rcx, rcx
            mov cx, [os_MemAmount]
            shr cx, 1                       ; Divide actual memory by 2
            mov al, 1
            rep stosb
            pop rdi
            mov al, 2
            stosb                           ; Mark the first 2 MiB as in use (by Kernel and system buffers)
    ;       stosb                           ; As well as the second 2 MiB (by loaded application)
            ; The CLI should take care of the Application memory
    
            ; Allocate memory for CPU stacks (2 MiB's for each core)
            xor rcx, rcx
            mov cx, [os_NumCores]           ; Get the amount of cores in the system
            call os_mem_allocate            ; Allocate a page for each core
            cmp rcx, 0                      ; os_mem_allocate returns 0 on failure
            je system_failure
            add rax, 2097152
            mov [os_StackBase], rax         ; Store the Stack base address
    
            pop rdi
            pop rcx
            pop rax
            ret
    
    
    system_failure:
            mov rsi, memory_message
            call os_output
    system_failure_hang:
            hlt
            jmp system_failure_hang
            ret
    #+end_src
*** pci
    #+begin_src fasm :tangle no
    init_pci:
            mov eax, 0x80000000
            mov dx, PCI_CONFIG_ADDRESS
            out dx, eax
            in eax, dx
            cmp eax, 0x80000000
            jne init_pci_not_found
            mov byte [os_PCIEnabled], 1

    init_pci_not_found:
            ret
    #+end_src
*** hdd
    #+begin_src fasm :tangle no
    init_hdd:
            call init_ahci
            call init_bmfs
            ret
    #+end_src
*** net
    #+begin_src fasm :tangle no
    init_net:
            mov rsi, networkmsg
            call os_output
    
            ; Search for a supported NIC
            xor ebx, ebx                    ; Clear the Bus number
            xor ecx, ecx                    ; Clear the Device/Slot number
            mov edx, 2                      ; Register 2 for Class code/Subclass
    
    init_net_probe_next:
            call os_pci_read_reg
            shr eax, 16                     ; Move the Class/Subclass code to AX
            cmp ax, 0x0200                  ; Network Controller (02) / Ethernet (00)
            je init_net_probe_find_driver   ; Found a Network Controller... now search for a driver
            add ecx, 1
            cmp ecx, 256                    ; Maximum 256 devices/functions per bus
            je init_net_probe_next_bus
            jmp init_net_probe_next
    
    init_net_probe_next_bus:
            xor ecx, ecx
            add ebx, 1
            cmp ebx, 256                    ; Maximum 256 buses
            je init_net_probe_not_found
            jmp init_net_probe_next
    
    init_net_probe_find_driver:
            xor edx, edx                            ; Register 0 for Device/Vendor ID
            call os_pci_read_reg                    ; Read the Device/Vendor ID from the PCI device
            mov r8d, eax                            ; Save the Device/Vendor ID in R8D
            mov rsi, NIC_DeviceVendor_ID
            lodsd                                   ; Load a driver ID - Low half must be 0xFFFF
    init_net_probe_find_next_driver:
            mov rdx, rax                            ; Save the driver ID
    init_net_probe_find_next_device:
            lodsd                                   ; Load a device and vendor ID from our list of supported NICs
            cmp eax, 0x00000000                     ; 0x00000000 means we have reached the end of the list
            je init_net_probe_not_found             ; No supported NIC found
            cmp ax, 0xFFFF                          ; New driver ID?
            je init_net_probe_find_next_driver      ; We found the next driver type
            cmp eax, r8d
            je init_net_probe_found                 ; If Carry is clear then we found a supported NIC
            jmp init_net_probe_find_next_device     ; Check the next device
    
    init_net_probe_found:
            cmp edx, 0x8169FFFF
            je init_net_probe_found_rtl8169
            cmp edx, 0x8254FFFF
            je init_net_probe_found_i8254x
            jmp init_net_probe_not_found
    
    init_net_probe_found_rtl8169:
            call os_net_rtl8169_init
            mov rdi, os_net_transmit
            mov rax, os_net_rtl8169_transmit
            stosq
            mov rax, os_net_rtl8169_poll
            stosq
            mov rax, os_net_rtl8169_ack_int
            stosq
            jmp init_net_probe_found_finish
    
    init_net_probe_found_i8254x:
            call os_net_i8254x_init
            mov rdi, os_net_transmit
            mov rax, os_net_i8254x_transmit
            stosq
            mov rax, os_net_i8254x_poll
            stosq
            mov rax, os_net_i8254x_ack_int
            stosq
            jmp init_net_probe_found_finish
    
    init_net_probe_found_finish:
            xor eax, eax
            mov al, [os_NetIRQ]
    
            add al, 0x20
            mov rdi, rax
            mov rax, network
            call create_gate
    
            ; Enable the Network IRQ
            mov al, [os_NetIRQ]
            call os_pic_mask_clear
    
            mov byte [os_NetEnabled], 1     ; A supported NIC was found. Signal to the OS that networking is enabled
            call os_ethernet_ack_int        ; Call the driver function to acknowledge the interrupt internally
    
            mov cl, 6
            mov rsi, os_NetMAC
    nextbyte:
            lodsb
            call os_debug_dump_al
            sub cl, 1
            cmp cl, 0
            jne nextbyte
            mov rsi, closebracketmsg
            call os_output
            ret
    
    init_net_probe_not_found:
            mov rsi, namsg
            call os_output
            mov rsi, closebracketmsg
            call os_output
            ret
    #+end_src
** syscalls
*** input
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_input -- Take string from keyboard entry
    ;  IN:  RDI = location where string will be stored
    ;       RCX = maximum number of characters to accept
    ; OUT:  RCX = length of string that was input (NULL not counted)
    ;       All other registers preserved
    os_input:
            push rdi
            push rdx                        ; Counter to keep track of max accepted characters
            push rax

            mov rdx, rcx                    ; Max chars to accept
            xor rcx, rcx                    ; Offset from start

    os_input_more:
            mov al, '_'
            call os_output_char             ; Display cursor
            call os_dec_cursor
            call os_input_key
            jnc os_input_halt               ; No key entered... halt until an interrupt is received
            cmp al, 0x1C                    ; If Enter key pressed, finish
            je os_input_done
            cmp al, 0x0E                    ; Backspace
            je os_input_backspace
            cmp al, 32                      ; In ASCII range (32 - 126)?
            jl os_input_more
            cmp al, 126
            jg os_input_more
            cmp rcx, rdx                    ; Check if we have reached the max number of chars
            je os_input_more                ; Jump if we have (should beep as well)
            stosb                           ; Store AL at RDI and increment RDI by 1
            inc rcx                         ; Increment the counter
            call os_output_char             ; Display char
            jmp os_input_more

    os_input_backspace:
            cmp rcx, 0                      ; backspace at the beginning? get a new char
            je os_input_more
            mov al, ' '                     ; 0x20 is the character for a space
            call os_output_char             ; Write over the last typed character with the space
            call os_dec_cursor              ; Decrement the cursor again
            call os_dec_cursor              ; Decrement the cursor
            dec rdi                         ; go back one in the string
            mov byte [rdi], 0x00            ; NULL out the char
            dec rcx                         ; decrement the counter by one
            jmp os_input_more

    os_input_halt:
            hlt                             ; Halt until another keystroke is received
            jmp os_input_more

    os_input_done:
            mov al, 0x00
            stosb                           ; We NULL terminate the string
            mov al, ' '
            call os_output_char

            pop rax
            pop rdx
            pop rdi

            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_input_key -- Scans keyboard for input
    ;
    ;  IN:  Nothing
    ; OUT:  AL = 0 if no key pressed, otherwise ASCII code, other regs preserved
    ;       Carry flag is set if there was a keystroke, clear if there was not
    ;       All other registers preserved
    os_input_key:
            mov al, [key]
            cmp al, 0
            je os_input_key_no_key
            mov byte [key], 0x00    ; clear the variable as the keystroke is in AL now
            stc                     ; set the carry flag
            ret

    os_input_key_no_key:
            clc                     ; clear the carry flag
            ret
    ; -----------------------------------------------------------------------------
    #+end_src
*** screen
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_inc_cursor -- Increment the cursor by one, scroll if needed
    ;  IN:  Nothing
    ; OUT:  All registers preserved
    os_inc_cursor:
            push rax
    
            add word [os_Screen_Cursor_Col], 1
            mov ax, [os_Screen_Cursor_Col]
            cmp ax, [os_Screen_Cols]
            jne os_inc_cursor_done
            mov word [os_Screen_Cursor_Col], 0
            add word [os_Screen_Cursor_Row], 1
            mov ax, [os_Screen_Cursor_Row]
            cmp ax, [os_Screen_Rows]
            jne os_inc_cursor_done
            call os_screen_scroll
            sub word [os_Screen_Cursor_Row], 1
    
    os_inc_cursor_done:
            pop rax
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_dec_cursor -- Decrement the cursor by one
    ;  IN:  Nothing
    ; OUT:  All registers preserved
    os_dec_cursor:
            push rax
    
            cmp word [os_Screen_Cursor_Col], 0
            jne os_dec_cursor_done
            sub word [os_Screen_Cursor_Row], 1
            mov ax, [os_Screen_Cols]
            mov word [os_Screen_Cursor_Col], ax
    
    os_dec_cursor_done:
            sub word [os_Screen_Cursor_Col], 1
    
            pop rax
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_print_newline -- Reset cursor to start of next line and scroll if needed
    ;  IN:  Nothing
    ; OUT:  All registers preserved
    os_print_newline:
            push rax
    
            mov word [os_Screen_Cursor_Col], 0      ; Reset column to 0
            mov ax, [os_Screen_Rows]                ; Grab max rows on screen
            sub ax, 1                               ; and subtract 1
            cmp ax, [os_Screen_Cursor_Row]          ; Is the cursor already on the bottom row?
            je os_print_newline_scroll              ; If so, then scroll
            add word [os_Screen_Cursor_Row], 1      ; If not, increment the cursor to next row
            jmp os_print_newline_done
    
    os_print_newline_scroll:
            call os_screen_scroll
    
    os_print_newline_done:
            pop rax
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_output -- Displays text
    ;  IN:  RSI = message location (zero-terminated string)
    ; OUT:  All registers preserved
    os_output:
            push rcx
    
            call os_string_length
            call os_output_chars
    
            pop rcx
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_output_char -- Displays a char
    ;  IN:  AL  = char to display
    ; OUT:  All registers preserved
    os_output_char:
            push rdi
            push rdx
            push rcx
            push rbx
            push rax
    
    os_output_char_text:
            mov ah, 0x07                    ; Store the attribute into AH so STOSW can be used later on
    
            push rax
            mov ax, [os_Screen_Cursor_Row]
            and rax, 0x000000000000FFFF     ; only keep the low 16 bits
            mov cl, 80                      ; 80 columns per row
            mul cl                          ; AX = AL * CL
            mov bx, [os_Screen_Cursor_Col]
            add ax, bx
            shl ax, 1                       ; multiply by 2
            mov rbx, rax                    ; Save the row/col offset
            mov rdi, os_screen              ; Address of the screen buffer
            add rdi, rax
            pop rax
            stosw                           ; Write the character and attribute to screen buffer
            mov rdi, 0xb8000
            add rdi, rbx
            stosw                           ; Write the character and attribute to screen
    
            jmp os_output_char_done
    
    os_output_char_done:
            call os_inc_cursor
    
            pop rax
            pop rbx
            pop rcx
            pop rdx
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_output_chars -- Displays text
    ;  IN:  RSI = message location (A string, not zero-terminated)
    ;       RCX = number of chars to print
    ; OUT:  All registers preserved
    os_output_chars:
            push rdi
            push rsi
            push rcx
            push rax
    
            cld                             ; Clear the direction flag.. we want to increment through the string
            mov ah, 0x07                    ; Store the attribute into AH so STOSW can be used later on
    
    os_output_chars_nextchar:
            jrcxz os_output_chars_done
            sub rcx, 1
            lodsb                           ; Get char from string and store in AL
            cmp al, 13                      ; Check if there was a newline character in the string
            je os_output_chars_newline      ; If so then we print a new line
            cmp al, 10                      ; Check if there was a newline character in the string
            je os_output_chars_newline      ; If so then we print a new line
            cmp al, 9
            je os_output_chars_tab
            call os_output_char
            jmp os_output_chars_nextchar
    
    os_output_chars_newline:
            mov al, [rsi]
            cmp al, 10
            je os_output_chars_newline_skip_LF
            call os_print_newline
            jmp os_output_chars_nextchar
    
    os_output_chars_newline_skip_LF:
            cmp rcx, 0
            je os_output_chars_newline_skip_LF_nosub
            sub rcx, 1
    os_output_chars_newline_skip_LF_nosub:
            add rsi, 1
            call os_print_newline
            jmp os_output_chars_nextchar
    
    os_output_chars_tab:
            push rcx
            mov ax, [os_Screen_Cursor_Col]  ; Grab the current cursor X value (ex 7)
            mov cx, ax
            add ax, 8                       ; Add 8 (ex 15)
            shr ax, 3                       ; Clear lowest 3 bits (ex 8)
            shl ax, 3                       ; Bug? 'xor al, 7' doesn't work...
            sub ax, cx                      ; (ex 8 - 7 = 1)
            mov cx, ax
            mov al, ' '
    os_output_chars_tab_next:
            call os_output_char
            sub cx, 1
            cmp cx, 0
            jne os_output_chars_tab_next
            pop rcx
            jmp os_output_chars_nextchar
    
    os_output_chars_done:
            pop rax
            pop rcx
            pop rsi
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_scroll_screen -- Scrolls the screen up by one line
    ;  IN:  Nothing
    ; OUT:  All registers preserved
    os_screen_scroll:
            push rsi
            push rdi
            push rcx
            push rax
            pushfq
    
            cld                             ; Clear the direction flag as we want to increment through memory
    
            xor ecx, ecx
    
    os_screen_scroll_text:
            mov rsi, os_screen              ; Start of video text memory for row 2
            add rsi, 0xA0
            mov rdi, os_screen              ; Start of video text memory for row 1
            mov cx, 1920                    ; 80 x 24
            rep movsw                       ; Copy the Character and Attribute
            ; Clear the last line in video memory
            mov ax, 0x0720                  ; 0x07 for black background/white foreground, 0x20 for space (black) character
            mov cx, 80
            rep stosw                       ; Store word in AX to RDI, RCX times
            call os_screen_update
            jmp os_screen_scroll_done
    
    os_screen_scroll_done:
            popfq
            pop rax
            pop rcx
            pop rdi
            pop rsi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_screen_clear -- Clear the screen
    ;  IN:  Nothing
    ; OUT:  All registers preserved
    os_screen_clear:
            push rdi
            push rcx
            push rax
            pushfq
    
            cld                             ; Clear the direction flag as we want to increment through memory
    
            xor ecx, ecx
    
    os_screen_clear_text:
            mov ax, 0x0720                  ; 0x07 for black background/white foreground, 0x20 for space (black) character
            mov rdi, os_screen              ; Address for start of frame buffer
            mov cx, 2000                    ; 80 x 25
            rep stosw                       ; Clear the screen. Store word in AX to RDI, RCX times
            call os_screen_update
            jmp os_screen_clear_done

    os_screen_clear_done:
            popfq
            pop rax
            pop rcx
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_screen_update -- Manually refresh the screen from the frame buffer
    ;  IN:  Nothing
    ; OUT:  All registers preserved
    os_screen_update:
            push rsi
            push rdi
            push rcx
            pushfq
    
            cld                             ; Clear the direction flag as we want to increment through memory
    
            mov rsi, os_screen
            mov rdi, 0xb8000
            mov cx, 2000                    ; 80 x 25
            rep movsw
    
            popfq
            pop rcx
            pop rdi
            pop rsi
            ret
    ; -----------------------------------------------------------------------------
    #+end_src
*** debug
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_debug_dump_reg -- Dump the values on the registers to the screen (For debug purposes)
    ;  IN:  Nothing
    ; OUT:  Nothing, all registers preserved
    os_debug_dump_reg:
            pushfq                          ; Push the registers used by this function
            push rsi
            push rbx
            push rax

            pushfq                          ; Push the flags to the stack
            push r15                        ; Push all of the registers to the stack
            push r14
            push r13
            push r12
            push r11
            push r10
            push r9
            push r8
            push rsp
            push rbp
            push rdi
            push rsi
            push rdx
            push rcx
            push rbx
            push rax

            mov byte [os_debug_dump_reg_stage], 0x00        ; Reset the stage to 0 since we are starting
    os_debug_dump_reg_next:
            mov rsi, os_debug_dump_reg_string00
            xor rax, rax
            xor rbx, rbx
            mov al, [os_debug_dump_reg_stage]
            mov bl, 5                                       ; Each string is 5 bytes
            mul bl                                          ; AX = BL x AL
            add rsi, rax                                    ; Add the offset to get to the correct string
            call os_output                                  ; Print the register name
            pop rax                                         ; Pop the register from the stack
            call os_debug_dump_rax                          ; Print the hex string value of RAX
            inc byte [os_debug_dump_reg_stage]
            cmp byte [os_debug_dump_reg_stage], 0x11        ; Check to see if all 16 registers as well as the flags are displayed
            jne os_debug_dump_reg_next

    os_debug_dump_reg_done:
            call os_print_newline
            pop rax
            pop rbx
            pop rsi
            popfq
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_debug_dump_mem -- Dump some memory content to the screen
    ;  IN:  RSI = Start of memory address to dump
    ;       RCX = Number of bytes to dump
    ; OUT:  Nothing, all registers preserved
    os_debug_dump_mem:
            push rsi
            push rcx                        ; Counter
            push rdx                        ; Total number of bytes to display
            push rax

            cmp rcx, 0                      ; Bail out if no bytes were requested
            je os_debug_dump_mem_done
            mov rax, rsi
            and rax, 0x0F                   ; Isolate the low 4 bytes of RSI
            add rcx, rax                    ; Add to round up the number of bytes needed
            mov rdx, rcx                    ; Save the total number of bytes to display
            add rdx, 15                     ; Make sure we print out another line if needed

            and cl, 0xF0
            and dl, 0xF0

            shr rsi, 4                      ; Round the starting memory address
            shl rsi, 4

    os_debug_dump_mem_print_address:
            mov rax, rsi
            call os_debug_dump_rax

            push rsi
            mov rsi, divider4
            call os_output
            pop rsi

    os_debug_dump_mem_print_contents:
            lodsq
            bswap rax                       ; Switch Endianness
            call os_debug_dump_rax
            push rsi
            mov rsi, divider2
            call os_output
            pop rsi
            lodsq
            bswap rax                       ; Switch Endianness
            call os_debug_dump_rax

            push rsi
            mov rsi, divider4
            call os_output
            pop rsi

    os_debug_dump_mem_print_ascii:
            sub rsi, 0x10
            xor rcx, rcx                    ; Clear the counter
    os_debug_dump_mem_print_ascii_next:
            lodsb
            call os_output_char
            add rcx, 1
            cmp rcx, 16
            jne os_debug_dump_mem_print_ascii_next

            sub rdx, 16
            cmp rdx, 0
            je os_debug_dump_mem_done
            call os_print_newline
            jmp os_debug_dump_mem_print_address

    os_debug_dump_mem_done:
            pop rax
            pop rcx
            pop rdx
            pop rsi
            ret

    divider4: db '    ', 0
    divider2: db '  ', 0
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_debug_dump_(rax|eax|ax|al) -- Dump content of RAX, EAX, AX, or AL to the screen in hex format
    ;  IN:  RAX = content to dump
    ; OUT:  Nothing, all registers preserved
    os_debug_dump_rax:
            rol rax, 8
            call os_debug_dump_al
            rol rax, 8
            call os_debug_dump_al
            rol rax, 8
            call os_debug_dump_al
            rol rax, 8
            call os_debug_dump_al
            rol rax, 32
    os_debug_dump_eax:
            rol eax, 8
            call os_debug_dump_al
            rol eax, 8
            call os_debug_dump_al
            rol eax, 16
    os_debug_dump_ax:
            rol ax, 8
            call os_debug_dump_al
            rol ax, 8
    os_debug_dump_al:
            push rbx
            push rax
            mov rbx, hextable
            push rax                        ; Save RAX since we work in 2 parts
            shr al, 4                       ; Shift high 4 bits into low 4 bits
            xlatb
            call os_output_char
            pop rax
            and al, 0x0f                    ; Clear the high 4 bits
            xlatb
            call os_output_char
            pop rax
            pop rbx
            ret
    #+end_src
*** ethernet
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_ethernet_status -- Check if Ethernet is available
    ;  IN:  Nothing
    ; OUT:  RAX = MAC Address if Ethernet is enabled, otherwise 0
    os_ethernet_status:
            push rsi
            push rcx

            cld
            xor eax, eax
            cmp byte [os_NetEnabled], 0
            je os_ethernet_status_end

            mov ecx, 6
            mov rsi, os_NetMAC
    os_ethernet_status_loadMAC:
            shl rax, 8
            lodsb
            sub ecx, 1
            test ecx, ecx
            jnz os_ethernet_status_loadMAC

    os_ethernet_status_end:
            pop rcx
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_ethernet_tx -- Transmit a packet via Ethernet
    ;  IN:  RSI = Memory location where packet is stored
    ;       RCX = Length of packet
    ; OUT:  Nothing. All registers preserved
    os_ethernet_tx:
            push rsi
            push rdi
            push rcx
            push rax

            cmp byte [os_NetEnabled], 1             ; Check if networking is enabled
            jne os_ethernet_tx_fail
            cmp rcx, 64                             ; An Ethernet packet must be at least 64 bytes
            jge os_ethernet_tx_maxcheck
            mov rcx, 64                             ; If it was below 64 then set to 64
            ; FIXME - OS should pad the packet with 0's before sending if less than 64

    os_ethernet_tx_maxcheck:
            cmp rcx, 1522                           ; Fail if more than 1522 bytes
            jg os_ethernet_tx_fail

            mov rax, os_EthernetBusyLock            ; Lock the Ethernet so only one send can happen at a time
            call os_smp_lock

            add qword [os_net_TXPackets], 1
            add qword [os_net_TXBytes], rcx
            call qword [os_net_transmit]

            mov rax, os_EthernetBusyLock
            call os_smp_unlock

    os_ethernet_tx_fail:
            pop rax
            pop rcx
            pop rdi
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_ethernet_rx -- Polls the Ethernet card for received data
    ;  IN:  RDI = Memory location where packet will be stored
    ; OUT:  RCX = Length of packet, 0 if no data
    ;       All other registers preserved
    os_ethernet_rx:
            push rdi
            push rsi
            push rdx
            push rax

            xor ecx, ecx

            cmp byte [os_NetEnabled], 1
            jne os_ethernet_rx_fail

            mov rsi, os_EthernetBuffer
            mov ax, word [rsi]              ; Grab the packet length
            cmp ax, 0                       ; Anything there?
            je os_ethernet_rx_fail          ; If not, bail out
            mov word [rsi], cx              ; Clear the packet length
            mov cx, ax                      ; Save the count
            add rsi, 2                      ; Skip the packet length word
            push rcx
            rep movsb
            pop rcx

    os_ethernet_rx_fail:

            pop rax
            pop rdx
            pop rsi
            pop rdi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_ethernet_ack_int -- Acknowledge an interrupt within the NIC
    ;  IN:  Nothing
    ; OUT:  RAX = Type of interrupt trigger
    ;       All other registers preserved
    os_ethernet_ack_int:
            call qword [os_net_ack_int]

            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_ethernet_rx_from_interrupt -- Polls the Ethernet card for received data
    ;  IN:  RDI = Memory location where packet will be stored
    ; OUT:  RCX = Length of packet
    ;       All other registers preserved
    os_ethernet_rx_from_interrupt:
            push rdi
            push rsi
            push rdx
            push rax

            xor ecx, ecx

    ; Call the poll function of the Ethernet card driver
            call qword [os_net_poll]
            add qword [os_net_RXPackets], 1
            add qword [os_net_RXBytes], rcx

            pop rax
            pop rdx
            pop rsi
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    #+end_src
*** file
    #+begin_src fasm :tangle no
    ; =============================================================================
    ; File System Abstraction Layer
    ;
    ; The file system driver needs to support the following 6 commands:
    ;
    ; open, close, read, write, seek, query, create, delete
    ;
    ; =============================================================================

    ;align 16
    ;db 'DEBUG: FILESYS  '
    ;align 16


    ; -----------------------------------------------------------------------------
    ; os_file_open -- Open a file on disk
    ; IN:   RSI = File name (zero-terminated string)
    ; OUT:  RAX = File I/O handler number, 0 on error
    ;       All other registers preserved
    os_file_open:
            jmp os_bmfs_file_open
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_close -- Close an open file
    ; IN:   RAX = File I/O handler
    ; OUT:  All registers preserved
    os_file_close:
            jmp os_bmfs_file_close
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_read -- Read a number of bytes from a file
    ; IN:   RAX = File I/O handler
    ;       RCX = Number of bytes to read
    ;       RDI = Destination memory address
    ; OUT:  RCX = Number of bytes read
    ;       All other registers preserved
    os_file_read:
            jmp os_bmfs_file_read
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_write -- Write a number of bytes to a file
    ; IN:   RAX = File I/O handler
    ;       RCX = Number of bytes to write
    ;       RSI = Source memory address
    ; OUT:  RCX = Number of bytes written
    ;       All other registers preserved
    os_file_write:
            jmp os_bmfs_file_write
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_seek -- Seek to position in a file
    ; IN:   RAX = File I/O handler
    ;       RCX = Number of bytes to offset from origin.
    ;       RDX = Origin
    ; OUT:  All registers preserved
    os_file_seek:
            jmp os_bmfs_file_seek
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_query -- Query the existence of a file
    ; IN:   RSI = Address of file name string
    ; OUT:  RCX = Size in bytes
    ;       Carry is set if the file was not found or an error occurred
    os_file_query:
            jmp os_bmfs_file_query
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_create -- Create a file on disk
    ; IN:   RSI = Memory location of file name to create
    ;       RCX = Size in bytes of the space to reserve for this file (will be
    ;               rounded up to the nearest 2MiB)
    ; OUT:  Carry is set if the file already exists or an error occurred
    os_file_create:
            jmp os_bmfs_file_create
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_file_delete -- Delete a file from disk
    ; IN:   RSI = Memory location of file name to delete
    ; OUT:  Carry is set if the file was not found or an error occurred
    os_file_delete:
            jmp os_bmfs_file_delete
    ; -----------------------------------------------------------------------------
    #+end_src
*** memory
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_mem_allocate -- Allocates the requested number of 2 MiB pages
    ;  IN:  RCX = Number of pages to allocate
    ; OUT:  RAX = Starting address (Set to 0 on failure)
    ; This function will only allocate continuous pages
    os_mem_allocate:
            push rsi
            push rdx
            push rbx

            cmp rcx, 0
            je os_mem_allocate_fail         ; At least 1 page must be allocated

            ; Here, we'll load the last existing page of memory in RSI.
            ; RAX and RSI instructions are purposefully interleaved.

            xor rax, rax
            mov rsi, os_MemoryMap           ; First available memory block
            mov eax, [os_MemAmount]         ; Total memory in MiB from a double-word
            mov rdx, rsi                    ; Keep os_MemoryMap unmodified for later in RDX
            shr eax, 1                      ; Divide actual memory by 2

            sub rsi, 1
            std                             ; Set direction flag to backward
            add rsi, rax                    ; RSI now points to the last page

    os_mem_allocate_start:                  ; Find a free page of memory, from the end.
            mov rbx, rcx                    ; RBX is our temporary counter

    os_mem_allocate_nextpage:
            lodsb
            cmp rsi, rdx                    ; We have hit the start of the memory map, no more free pages
            je os_mem_allocate_fail

            cmp al, 1
            jne os_mem_allocate_start       ; Page is taken, start counting from scratch

            dec rbx                         ; We found a page! Any page left to find?
            jnz os_mem_allocate_nextpage

    os_mem_allocate_mark:                   ; We have a suitable free series of pages. Allocate them.
            cld                             ; Set direction flag to forward

            xor rdi, rsi                    ; We swap rdi and rsi to keep rdi contents.
            xor rsi, rdi
            xor rdi, rsi

            ; Instructions are purposefully swapped at some places here to avoid
            ; direct dependencies line after line.
            push rcx                        ; Keep RCX as is for the 'rep stosb' to come
            add rdi, 1
            mov al, 2
            mov rbx, rdi                    ; RBX points to the starting page
            rep stosb
            mov rdi, rsi                    ; Restoring RDI
            sub rbx, rdx                    ; RBX now contains the memory page number
            pop rcx                         ; Restore RCX

            ; Only dependency left is between the two next lines.
            shl rbx, 21                     ; Quick multiply by 2097152 (2 MiB) to get the starting memory address
            mov rax, rbx                    ; Return the starting address in RAX
            jmp os_mem_allocate_end

    os_mem_allocate_fail:
            cld                             ; Set direction flag to forward
            xor rax, rax                    ; Failure so set RAX to 0 (No pages allocated)

    os_mem_allocate_end:
            pop rbx
            pop rdx
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_mem_release -- Frees the requested number of 2 MiB pages
    ;  IN:  RAX = Starting address
    ;       RCX = Number of pages to free
    ; OUT:  RCX = Number of pages freed
    os_mem_release:
            push rdi
            push rcx
            push rax

            shr rax, 21                     ; Quick divide by 2097152 (2 MiB) to get the starting page number
            add rax, os_MemoryMap
            mov rdi, rax
            mov al, 1
            rep stosb

            pop rax
            pop rcx
            pop rdi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_mem_get_free -- Returns the number of 2 MiB pages that are available
    ;  IN:  Nothing
    ; OUT:  RCX = Number of free 2 MiB pages
    os_mem_get_free:
            push rsi
            push rbx
            push rax

            mov rsi, os_MemoryMap
            xor rcx, rcx
            xor rbx, rbx

    os_mem_get_free_next:
            lodsb
            inc rcx
            cmp rcx, 65536
            je os_mem_get_free_end
            cmp al, 1
            jne os_mem_get_free_next
            inc rbx
            jmp os_mem_get_free_next

    os_mem_get_free_end:
            mov rcx, rbx

            pop rax
            pop rbx
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_mem_copy -- Copy a number of bytes
    ;  IN:  RSI = Source address
    ;       RDI = Destination address
    ;       RCX = Number of bytes to copy
    ; OUT:  Nothing, all registers preserved
    os_mem_copy:
            push rdi
            push rsi
            push rcx

            rep movsb                       ; Optimize this!

            pop rcx
            pop rsi
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    #+end_src
*** misc
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_delay -- Delay by X eights of a second
    ; IN:   RAX = Time in eights of a second
    ; OUT:  All registers preserved
    ; A value of 8 in RAX will delay 1 second and a value of 1 will delay 1/8 of a second
    ; This function depends on the RTC (IRQ 8) so interrupts must be enabled.
    os_delay:
            push rcx
            push rax

            mov rcx, [os_ClockCounter]      ; Grab the initial timer counter. It increments 8 times a second
            add rax, rcx                    ; Add RCX so we get the end time we want
    os_delay_loop:
            cmp qword [os_ClockCounter], rax        ; Compare it against our end time
            jle os_delay_loop               ; Loop if RAX is still lower

            pop rax
            pop rcx
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_get_argv -- Get the value of an argument that was passed to the program
    ; IN:   RAX = Argument number
    ; OUT:  RAX = Start of numbered argument string
    os_get_argv:
            push rsi
            push rcx
            mov rsi, cli_temp_string
            cmp al, 0x00
            je os_get_argv_end
            mov cl, al

    os_get_argv_nextchar:
            lodsb
            cmp al, 0x00
            jne os_get_argv_nextchar
            dec cl
            cmp cl, 0
            jne os_get_argv_nextchar

    os_get_argv_end:
            mov rax, rsi
            pop rcx
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_system_config - View or modify system configuration options
    ; IN:   RDX = Function #
    ;       RAX = Variable
    ; OUT:  RAX = Result
    ;       All other registers preserved
    os_system_config:
            cmp rdx, 0
            je os_system_config_timecounter
            cmp rdx, 1
            je os_system_config_argc
            cmp rdx, 2
            je os_system_config_argv
            cmp rdx, 3
            je os_system_config_networkcallback_get
            cmp rdx, 4
            je os_system_config_networkcallback_set
            cmp rdx, 5
            je os_system_config_clockcallback_get
            cmp rdx, 6
            je os_system_config_clockcallback_set
            cmp rdx, 20
            je os_system_config_video_base
            cmp rdx, 21
            je os_system_config_video_x
            cmp rdx, 22
            je os_system_config_video_y
            cmp rdx, 23
            je os_system_config_video_bpp
            cmp rdx, 30
            je os_system_config_mac
            ret

    os_system_config_timecounter:
            mov rax, [os_ClockCounter]      ; Grab the timer counter value. It increments 8 times a second
            ret

    os_system_config_argc:
            xor eax, eax
            mov al, [app_argc]
            ret

    os_system_config_argv:
            call os_get_argv
            ret

    os_system_config_networkcallback_get:
            mov rax, [os_NetworkCallback]
            ret

    os_system_config_networkcallback_set:
            mov qword [os_NetworkCallback], rax
            ret

    os_system_config_clockcallback_get:
            mov rax, [os_ClockCallback]
            ret

    os_system_config_clockcallback_set:
            mov qword [os_ClockCallback], rax
            ret

    os_system_config_video_base:
            mov rax, [os_VideoBase]
            ret

    os_system_config_video_x:
            xor eax, eax
            mov ax, [os_VideoX]
            ret

    os_system_config_video_y:
            xor eax, eax
            mov ax, [os_VideoY]
            ret

    os_system_config_video_bpp:
            xor eax, eax
            mov al, [os_VideoDepth]
            ret

    os_system_config_mac:
            call os_ethernet_status
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_system_misc - Call misc OS sub-functions
    ; IN:   RDX = Function #
    ;       RAX = Variable 1
    ;       RCX = Variable 2
    ; OUT:  RAX = Result 1, dependant on system call
    ;       RCX = Result 2, dependant on system call
    os_system_misc:
    ;       cmp rdx, X
    ;       je os_system_misc_
            cmp rdx, 1
            je os_system_misc_smp_get_id
            cmp rdx, 2
            je os_system_misc_smp_lock
            cmp rdx, 3
            je os_system_misc_smp_unlock
            cmp rdx, 4
            je os_system_misc_debug_dump_mem
            cmp rdx, 5
            je os_system_misc_debug_dump_rax
            cmp rdx, 6
            je os_system_misc_delay
            cmp rdx, 7
            je os_system_misc_ethernet_status
            cmp rdx, 8
            je os_system_misc_mem_get_free
            cmp rdx, 9
            je os_system_misc_smp_numcores
            cmp rdx, 10
            je os_system_misc_smp_queuelen
            ret

    os_system_misc_smp_get_id:
            call os_smp_get_id
            ret

    os_system_misc_smp_lock:
            call os_smp_lock
            ret

    os_system_misc_smp_unlock:
            call os_smp_unlock
            ret

    os_system_misc_debug_dump_mem:
            push rsi
            mov rsi, rax
            call os_debug_dump_mem
            pop rsi
            ret

    os_system_misc_debug_dump_rax:
            call os_debug_dump_rax
            ret

    os_system_misc_delay:
            call os_delay
            ret

    os_system_misc_ethernet_status:
            call os_ethernet_status
            ret

    os_system_misc_mem_get_free:
            call os_mem_get_free
            ret

    os_system_misc_smp_numcores:
            call os_smp_numcores
            ret

    os_system_misc_smp_queuelen:
            call os_smp_queuelen
            ret
    ; -----------------------------------------------------------------------------
    #+end_src
*** smp
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_smp_reset -- Resets a CPU Core
    ;  IN:  AL = CPU #
    ; OUT:  Nothing. All registers preserved.
    ; Note: This code resets an AP
    ;       For set-up use only.
    os_smp_reset:
            push rdi
            push rax
    
            mov rdi, [os_LocalAPICAddress]
            shl eax, 24             ; AL holds the CPU #, shift left 24 bits to get it into 31:24, 23:0 are reserved
            mov [rdi+0x0310], eax   ; Write to the high bits first
            xor eax, eax            ; Clear EAX, namely bits 31:24
            mov al, 0x81            ; Execute interrupt 0x81
            mov [rdi+0x0300], eax   ; Then write to the low bits
    
            pop rax
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_wakeup -- Wake up a CPU Core
    ;  IN:  AL = CPU #
    ; OUT:  Nothing. All registers preserved.
    os_smp_wakeup:
            push rdi
            push rax
    
            mov rdi, [os_LocalAPICAddress]
            shl eax, 24             ; AL holds the CPU #, shift left 24 bits to get it into 31:24, 23:0 are reserved
            mov [rdi+0x0310], eax   ; Write to the high bits first
            xor eax, eax            ; Clear EAX, namely bits 31:24
            mov al, 0x80            ; Execute interrupt 0x80
            mov [rdi+0x0300], eax   ; Then write to the low bits
    
            pop rax
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_wakeup_all -- Wake up all CPU Cores
    ;  IN:  Nothing.
    ; OUT:  Nothing. All registers preserved.
    os_smp_wakeup_all:
            push rdi
            push rax
    
            mov rdi, [os_LocalAPICAddress]
            xor eax, eax
            mov [rdi+0x0310], eax   ; Write to the high bits first
            mov eax, 0x000C0080     ; Execute interrupt 0x80
            mov [rdi+0x0300], eax   ; Then write to the low bits
    
            pop rax
            pop rdi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_get_id -- Returns the APIC ID of the CPU that ran this function
    ;  IN:  Nothing
    ; OUT:  RAX = CPU's APIC ID number, All other registers preserved.
    os_smp_get_id:
            push rsi
    
            xor eax, eax
            mov rsi, [os_LocalAPICAddress]
            add rsi, 0x20           ; Add the offset for the APIC ID location
            lodsd                   ; APIC ID is stored in bits 31:24
            shr rax, 24             ; AL now holds the CPU's APIC ID (0 - 255)
    
            pop rsi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_enqueue -- Add a workload to the processing queue
    ;  IN:  RAX = Address of code to execute
    ;       RSI = Variable
    ; OUT:  Nothing
    os_smp_enqueue:
            push rdi
            push rsi
            push rcx
            push rax
    
    os_smp_enqueue_spin:
            bt word [os_QueueLock], 0       ; Check if the mutex is free
            jc os_smp_enqueue_spin          ; If not check it again
            lock bts word [os_QueueLock], 0 ; The mutex was free, lock the bus. Try to grab the mutex
            jc os_smp_enqueue_spin          ; Jump if we were unsuccessful
    
            cmp word [os_QueueLen], 256     ; aka cpuqueuemax
            je os_smp_enqueue_fail
    
            xor ecx, ecx
            mov rdi, cpuqueue
            mov cx, [cpuqueuefinish]
            shl rcx, 4                      ; Quickly multiply RCX by 16
            add rdi, rcx
    
            stosq                           ; Store the code address from RAX
            mov rax, rsi
            stosq                           ; Store the variable
    
            add word [os_QueueLen], 1
            shr rcx, 4                      ; Quickly divide RCX by 16
            add cx, 1
            cmp cx, [cpuqueuemax]
            jne os_smp_enqueue_end
            xor cx, cx                      ; We wrap around
    
    os_smp_enqueue_end:
            mov [cpuqueuefinish], cx
            pop rax
            pop rcx
            pop rsi
            pop rdi
            btr word [os_QueueLock], 0      ; Release the lock
            call os_smp_wakeup_all
            clc                             ; Carry clear for success
            ret
    
    os_smp_enqueue_fail:
            pop rax
            pop rcx
            pop rsi
            pop rdi
            btr word [os_QueueLock], 0      ; Release the lock
            stc                             ; Carry set for failure (Queue full)
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_dequeue -- Dequeue a workload from the processing queue
    ;  IN:  Nothing
    ; OUT:  RAX = Address of code to execute (Set to 0 if queue is empty)
    ;       RDI = Variable
    os_smp_dequeue:
            push rsi
            push rcx
    
    os_smp_dequeue_spin:
            bt word [os_QueueLock], 0       ; Check if the mutex is free
            jc os_smp_dequeue_spin          ; If not check it again
            lock bts word [os_QueueLock], 0 ; The mutex was free, lock the bus. Try to grab the mutex
            jc os_smp_dequeue_spin          ; Jump if we were unsuccessful
    
            cmp word [os_QueueLen], 0
            je os_smp_dequeue_fail
    
            xor ecx, ecx
            mov rsi, cpuqueue
            mov cx, [cpuqueuestart]
            shl rcx, 4                      ; Quickly multiply RCX by 16
            add rsi, rcx
    
            lodsq                           ; Load the code address into RAX
            push rax
            lodsq                           ; Load the variable
            mov rdi, rax
            pop rax
    
            sub word [os_QueueLen], 1
            shr rcx, 4                      ; Quickly divide RCX by 16
            add cx, 1
            cmp cx, [cpuqueuemax]
            jne os_smp_dequeue_end
            xor cx, cx                      ; We wrap around
    
    os_smp_dequeue_end:
            mov word [cpuqueuestart], cx
            pop rcx
            pop rsi
            btr word [os_QueueLock], 0      ; Release the lock
            clc                             ; If we got here then ok
            ret
    
    os_smp_dequeue_fail:
            xor rax, rax
            pop rcx
            pop rsi
            btr word [os_QueueLock], 0      ; Release the lock
            stc
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_run -- Call the code address stored in RAX
    ;  IN:  RAX = Address of code to execute
    ; OUT:  Nothing
    os_smp_run:
            call rax                        ; Run the code
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_queuelen -- Returns the number of items in the processing queue
    ;  IN:  Nothing
    ; OUT:  RAX = number of items in processing queue
    os_smp_queuelen:
            xor eax, eax
            mov ax, [os_QueueLen]
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_numcores -- Returns the number of cores in this computer
    ;  IN:  Nothing
    ; OUT:  RAX = number of cores in this computer
    os_smp_numcores:
            xor eax, eax
            mov ax, [os_NumCores]
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_wait -- Wait until all other CPU Cores are finished processing
    ;  IN:  Nothing
    ; OUT:  Nothing. All registers preserved.
    os_smp_wait:
            push rsi
            push rcx
            push rbx
            push rax
    
            call os_smp_get_id
            mov rbx, rax
    
            xor eax, eax
            xor ecx, ecx
            mov rsi, cpustatus
    
    checkit:
            lodsb
            cmp rbx, rcx            ; Check to see if it is looking at itself
            je skipit               ; If so then skip as it should be marked as busy
            bt ax, 0                ; Check the Present bit
            jnc skipit              ; If carry is not set then the CPU does not exist
            bt ax, 1                ; Check the Ready/Busy bit
            jnc skipit              ; If carry is not set then the CPU is Ready
            sub rsi, 1
            jmp checkit             ; Core is marked as Busy, check it again
    skipit:
            add rcx, 1
            cmp rcx, 256
            jne checkit
    
            pop rax
            pop rbx
            pop rcx
            pop rsi
            ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_lock -- Attempt to lock a mutex
    ;  IN:  RAX = Address of lock variable
    ; OUT:  Nothing. All registers preserved.
    os_smp_lock:
            bt word [rax], 0        ; Check if the mutex is free (Bit 0 cleared to 0)
            jc os_smp_lock          ; If not check it again
            lock bts word [rax], 0  ; The mutex was free, lock the bus. Try to grab the mutex
            jc os_smp_lock          ; Jump if we were unsuccessful
            ret                     ; Lock acquired. Return to the caller
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_smp_unlock -- Unlock a mutex
    ;  IN:  RAX = Address of lock variable
    ; OUT:  Nothing. All registers preserved.
    os_smp_unlock:
            btr word [rax], 0       ; Release the lock (Bit 0 cleared to 0)
            ret                     ; Lock released. Return to the caller
    ; -----------------------------------------------------------------------------
    #+end_src
*** string
    #+begin_src fasm :tangle no
    ; -----------------------------------------------------------------------------
    ; os_int_to_string -- Convert a binary integer into an string
    ;  IN:  RAX = binary integer
    ;       RDI = location to store string
    ; OUT:  RDI = points to end of string
    ;       All other registers preserved
    ; Min return value is 0 and max return value is 18446744073709551615 so the
    ; string needs to be able to store at least 21 characters (20 for the digits
    ; and 1 for the string terminator).
    ; Adapted from http://www.cs.usfca.edu/~cruse/cs210s09/rax2uint.s
    os_int_to_string:
            push rdx
            push rcx
            push rbx
            push rax

            mov rbx, 10                                     ; base of the decimal system
            xor ecx, ecx                                    ; number of digits generated
    os_int_to_string_next_divide:
            xor edx, edx                                    ; RAX extended to (RDX,RAX)
            div rbx                                         ; divide by the number-base
            push rdx                                        ; save remainder on the stack
            inc rcx                                         ; and count this remainder
            cmp rax, 0                                      ; was the quotient zero?
            jne os_int_to_string_next_divide                ; no, do another division

    os_int_to_string_next_digit:
            pop rax                                         ; else pop recent remainder
            add al, '0'                                     ; and convert to a numeral
            stosb                                           ; store to memory-buffer
            loop os_int_to_string_next_digit                ; again for other remainders
            xor al, al
            stosb                                           ; Store the null terminator at the end of the string

            pop rax
            pop rbx
            pop rcx
            pop rdx
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_string_to_int -- Convert a string into a binary integer
    ;  IN:  RSI = location of string
    ; OUT:  RAX = integer value
    ;       All other registers preserved
    ; Adapted from http://www.cs.usfca.edu/~cruse/cs210s09/uint2rax.s
    os_string_to_int:
            push rsi
            push rdx
            push rcx
            push rbx

            xor eax, eax                    ; initialize accumulator
            mov rbx, 10                     ; decimal-system's radix
    os_string_to_int_next_digit:
            mov cl, [rsi]                   ; fetch next character
            cmp cl, '0'                     ; char precedes '0'?
            jb os_string_to_int_invalid     ; yes, not a numeral
            cmp cl, '9'                     ; char follows '9'?
            ja os_string_to_int_invalid     ; yes, not a numeral
            mul rbx                         ; ten times prior sum
            and rcx, 0x0F                   ; convert char to int
            add rax, rcx                    ; add to prior total
            inc rsi                         ; advance source index
            jmp os_string_to_int_next_digit ; and check another char

    os_string_to_int_invalid:
            pop rbx
            pop rcx
            pop rdx
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_string_length -- Return length of a string
    ;  IN:  RSI = string location
    ; OUT:  RCX = length (not including the NULL terminator)
    ;       All other registers preserved
    os_string_length:
            push rdi
            push rax

            xor ecx, ecx
            xor eax, eax
            mov rdi, rsi
            not rcx
            cld
            repne scasb                     ; compare byte at RDI to value in AL
            not rcx
            dec rcx

            pop rax
            pop rdi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_string_copy -- Copy the contents of one string into another
    ;  IN:  RSI = source
    ;       RDI = destination
    ; OUT:  All registers preserved
    ; Note: It is up to the programmer to ensure that there is sufficient space in the destination
    os_string_copy:
            push rsi
            push rdi
            push rax

    os_string_copy_more:
            lodsb                           ; Load a character from the source string
            stosb
            cmp al, 0                       ; If source string is empty, quit out
            jne os_string_copy_more

            pop rax
            pop rdi
            pop rsi
            ret
    ; -----------------------------------------------------------------------------


    ; -----------------------------------------------------------------------------
    ; os_string_compare -- See if two strings match
    ;  IN:  RSI = string one
    ;       RDI = string two
    ; OUT:  Carry flag set if same
    os_string_compare:
            push rsi
            push rdi
            push rbx
            push rax

    os_string_compare_more:
            mov al, [rsi]                   ; Store string contents
            mov bl, [rdi]
            cmp al, 0                       ; End of first string?
            je os_string_compare_terminated
            cmp al, bl
            jne os_string_compare_not_same
            inc rsi
            inc rdi
            jmp os_string_compare_more

    os_string_compare_not_same:
            pop rax
            pop rbx
            pop rdi
            pop rsi
            clc
            ret

    os_string_compare_terminated:
            cmp bl, 0                       ; End of second string?
            jne os_string_compare_not_same

            pop rax
            pop rbx
            pop rdi
            pop rsi
            stc
            ret
    ; -----------------------------------------------------------------------------
    #+end_src
** drivers
*** pci
    #+begin_src fasm :tangle no
    ; http://wiki.osdev.org/PCI
    
    
    ; -----------------------------------------------------------------------------
    ; os_pci_read_reg -- Read a register from a PCI device
    ;  IN:  BL  = Bus number
    ;       CL  = Device/Slot/Function number
    ;       DL  = Register number
    ; OUT:  EAX = Register information
    ;       All other registers preserved
    os_pci_read_reg:
            push rdx
            push rcx
            push rbx
    
            shl ebx, 16                     ; Move Bus number to bits 23 - 16
            shl ecx, 8                      ; Move Device/Slot/Fuction number to bits 15 - 8
            mov bx, cx
            shl edx, 2
            mov bl, dl
            and ebx, 0x00ffffff             ; Clear bits 31 - 24
            or ebx, 0x80000000              ; Set bit 31
            mov eax, ebx
            mov dx, PCI_CONFIG_ADDRESS
            out dx, eax
            mov dx, PCI_CONFIG_DATA
            in eax, dx
    
            pop rbx
            pop rcx
            pop rdx
    ret
    ; -----------------------------------------------------------------------------
    
    
    ; -----------------------------------------------------------------------------
    ; os_pci_dump_devices -- Dump all Device and Vendor ID's to the screen
    ;  IN:  Nothing
    ; OUT:  Nothing, All registers preserved
    ; http://pci-ids.ucw.cz/read/PC/ - Online list of Device and Vendor ID's
    os_pci_dump_devices:
            push rdx
            push rcx
            push rbx
            push rax
    
            xor rcx, rcx
            xor rax, rax
    
            mov ecx, 0x80000000             ; Bit 31 must be set
    
    os_pci_dump_devices_check_next:
            mov eax, ecx
            mov dx, PCI_CONFIG_ADDRESS
            out dx, eax
            mov dx, PCI_CONFIG_DATA
            in eax, dx                      ; EAX now holds the Device and Vendor ID
            cmp eax, 0xffffffff             ; 0xFFFFFFFF means no device present on that Bus and Slot
            je os_pci_dump_devices_nothing_there
            call os_debug_dump_eax          ; Print the Device and Vendor ID (DDDDVVVV)
            call os_print_newline
    os_pci_dump_devices_nothing_there:
            add ecx, 0x800
            cmp ecx, 0x81000000             ; The end has been reached (already looked at 8192 devices)
            jne os_pci_dump_devices_check_next
    
    os_pci_dump_devices_end:
            pop rax
            pop rbx
            pop rcx
            pop rdx
    ret
    ; -----------------------------------------------------------------------------
    
    
    
    ;Configuration Mechanism One has two IO port rages associated with it.
    ;The address port (0xcf8-0xcfb) and the data port (0xcfc-0xcff).
    ;A configuration cycle consists of writing to the address port to specify which device and register you want to access and then reading or writing the data to the data port.
    
    PCI_CONFIG_ADDRESS      =   0x0CF8
    PCI_CONFIG_DATA         =   0x0CFC
    
    ;ddress dd 10000000000000000000000000000000b
    ;          /\     /\      /\   /\ /\    /\
    ;        E    Res    Bus    Dev  F  Reg   0
    ; Bits
    ; 31            Enable bit = set to 1
    ; 30 - 24       Reserved = set to 0
    ; 23 - 16       Bus number = 256 options
    ; 15 - 11       Device/Slot number = 32 options
    ; 10 - 8        Function number = will leave at 0 (8 options)
    ; 7 - 2         Register number = will leave at 0 (64 options) 64 x 4 bytes = 256 bytes worth of accessible registers
    ; 1 - 0         Set to 0
    #+end_src
*** pic
    #+begin_src fasm :tangle no
    ; http://wiki.osdev.org/PIC


    ; -----------------------------------------------------------------------------
    ; os_pic_mask_clear -- Clear a mask on the PIC
    ;  IN:  AL  = IRQ #
    ; OUT:  All registers preserved
    os_pic_mask_clear:
            push dx
            push bx
            push ax

            mov bl, al                      ; Save the IRQ value
            cmp bl, 8                       ; Less than 8
            jl os_pic_mask_clear_low        ; If so, only set Master PIC
            mov dx, 0xA1                    ; Slave PIC data address
            sub bl, 8
            jmp os_pic_mask_clear_write
    os_pic_mask_clear_low:
            mov dx, 0x21                    ; Mast PIC data address
    os_pic_mask_clear_write:
            in al, dx                       ; Read the current mask
            btr ax, bx
            out dx, al                      ; Write the new mask

            pop ax
            pop bx
            pop dx
    ret
    ; -----------------------------------------------------------------------------
    #+end_src
*** storage
**** ahci
     #+begin_src fasm :tangle no
     ; AHCI Driver
     
     
     ; -----------------------------------------------------------------------------
     init_ahci:
             mov rsi, diskmsg
             call os_output
     
     ; Probe for an AHCI hard drive controller
             xor ebx, ebx                    ; Clear the Bus number
             xor ecx, ecx                    ; Clear the Device/Slot number
             mov edx, 2                      ; Register 2 for Class code/Subclass
     
     init_ahci_probe_next:
             call os_pci_read_reg
             shr eax, 16                     ; Move the Class/Subclass code to AX
             cmp ax, 0x0106                  ; Mass Storage Controller (01) / SATA Controller (06)
             je init_ahci_found              ; Found a SATA Controller
             add ecx, 1
             cmp ecx, 256                    ; Maximum 256 devices/functions per bus
             je init_ahci_probe_next_bus
             jmp init_ahci_probe_next
     
     init_ahci_probe_next_bus:
             xor ecx, ecx
             add ebx, 1
             cmp ebx, 256                    ; Maximum 256 buses
             je init_ahci_err_noahci
             jmp init_ahci_probe_next
     
     init_ahci_found:
             mov dl, 9
             xor eax, eax
             call os_pci_read_reg            ; BAR5 (AHCI Base Address Register)
             mov [ahci_base], rax
     
     ; Basic config of the controller, port 0
             mov rsi, rax                    ; RSI holds the ABAR
             mov rdi, rsi
     
     ; Search the implemented ports for a drive
             mov eax, [rsi+0x0C]             ; PI  Ports Implemented
             mov edx, eax
             xor ecx, ecx
             mov ebx, 0x128                  ; Offset to Port 0 Serial ATA Status
     nextport:
             bt edx, 0                       ; Valid port?
             jnc nodrive
             mov eax, [rsi+rbx]
             cmp eax, 0
             je nodrive
             jmp founddrive
     
     nodrive:
             add ecx, 1
             shr edx, 1
             add ebx, 0x80                   ; Each port has a 128 byte memory space
             cmp ecx, 32
             je hdd_setup_err_nodisk
             jmp nextport
     
     ; Configure the first port found with a drive attached
     founddrive:
             mov [ahci_port], ecx
             mov rdi, rsi
             add rdi, 0x100                  ; Offset to port 0
             push rcx                        ; Save port number
             shl rcx, 7                      ; Quick multiply by 0x80
             add rdi, rcx
             pop rcx                         ; Restore port number
             mov rax, ahci_cmdlist           ; 1024 bytes per port
             stosd                           ; Offset 00h: PxCLB  Port x Command List Base Address
             xor eax, eax
             stosd                           ; Offset 04h: PxCLBU  Port x Command List Base Address Upper 32-bits
             mov rax, ahci_cmdlist + 0x1000  ; 256 or 4096 bytes per port
             stosd                           ; Offset 08h: PxFB  Port x FIS Base Address
             xor eax, eax
             stosd                           ; Offset 0Ch: PxFBU  Port x FIS Base Address Upper 32-bits
             stosd                           ; Offset 10h: PxIS  Port x Interrupt Status
             stosd                           ; Offset 14h: PxIE  Port x Interrupt Enable
     
             ; Query drive
             mov rdi, 0x200000
             call iddrive
             mov rsi, 0x200000
             mov eax, [rsi+200]              ; Max LBA Extended
             shr rax, 11                     ; rax = rax * 512 / 1048576     MiB
     ;       shr rax, 21                     ; rax = rax * 512 / 1073741824  GiB
             mov [hd1_size], eax             ; in mebibytes (MiB)
             mov rdi, os_temp_string
             mov rsi, rdi
             call os_int_to_string
             call os_output
             mov rsi, mibmsg
             call os_output
     
             ; Found a bootable drive
             mov byte [os_DiskEnabled], 0x01
     
             ret
     
     init_ahci_err_noahci:
     hdd_setup_err_nodisk:
             mov rsi, namsg
             call os_output
     
             ret
     ; -----------------------------------------------------------------------------
     
     
     ; -----------------------------------------------------------------------------
     ; iddrive -- Identify a SATA drive
     ; IN:   RCX = Port # to query
     ;       RDI = memory location to store details (512 bytes)
     ; OUT:  Nothing, all registers preserved
     iddrive:
             push rdi
             push rsi
             push rcx
             push rax
     
             shl rcx, 7                      ; Quick multiply by 0x80
             add rcx, 0x100                  ; Offset to port 0
     
             push rdi                        ; Save the destination memory address
     
             mov rsi, [ahci_base]
     
             mov rdi, ahci_cmdlist           ; command list (1K with 32 entries, 32 bytes each)
             xor eax, eax
             mov eax, 0x00010005 ;4          ; 1 PRDTL Entry, Command FIS Length = 16 bytes
             stosd                           ; DW 0 - Description Information
             xor eax, eax
             stosd                           ; DW 1 - Command Status
             mov eax, ahci_cmdtable
             stosd                           ; DW 2 - Command Table Base Address
             xor eax, eax
             stosd                           ; DW 3 - Command Table Base Address Upper
             stosd
             stosd
             stosd
             stosd
             ; DW 4 - 7 are reserved
     
             ; command table
             mov rdi, ahci_cmdtable          ; Build a command table for Port 0
             mov eax, 0x00EC8027             ; EC identify, bit 15 set, fis 27 H2D
             stosd                           ; feature 7:0, command, c, fis
             xor eax, eax
             stosd                           ; device, lba 23:16, lba 15:8, lba 7:0
             stosd                           ; feature 15:8, lba 47:40, lba 39:32, lba 31:24
             stosd                           ; control, ICC, count 15:8, count 7:0
     ;       stosd                           ; reserved
             mov rdi, ahci_cmdtable + 0x80
             pop rax                         ; Restore the destination memory address
             stosd                           ; Data Base Address
             shr rax, 32
             stosd                           ; Data Base Address Upper
             xor eax, eax
             stosd                           ; Reserved
             mov eax, 0x000001FF             ; 512 - 1
             stosd                           ; Description Information
     
             add rsi, rcx
     
             mov rdi, rsi
             add rdi, 0x10                   ; Port x Interrupt Status
             xor eax, eax
             stosd
     
             mov rdi, rsi
             add rdi, 0x18                   ; Offset to port 0 Command and Status
             mov eax, [rdi]
             bts eax, 4                      ; FRE
             bts eax, 0                      ; ST
             stosd
     
             mov rdi, rsi
             add rdi, 0x38                   ; Command Issue
             mov eax, 0x00000001             ; Execute Command Slot 0
             stosd
     
     iddrive_poll:
             mov eax, [rsi+0x38]
             cmp eax, 0
             jne iddrive_poll
     
             mov rdi, rsi
             add rdi, 0x18                   ; Offset to port 0
             mov eax, [rdi]
             btc eax, 4                      ; FRE
             btc eax, 0                      ; ST
             stosd
     
             pop rax
             pop rcx
             pop rsi
             pop rdi
     ret
     ; -----------------------------------------------------------------------------
     
     
     
     ;; ;; the following quick test about partition support was failed:
     
     PartitionSector = 0
     
     readsectors:
        add rax, PartitionSector
        call pre_readsectors
        sub rax, PartitionSector
        ret
     

     ; -----------------------------------------------------------------------------
     ; readsectors -- Read data from a SATA hard drive
     ; IN:   RAX = starting sector # to read
     ;       RCX = number of sectors to read (up to 8192 = 4MiB)
     ;       RDX = disk #
     ;       RDI = memory location to store sectors
     ; OUT:  RAX = RAX + number of sectors that were read
     ;       RCX = number of sectors that were read (0 on error)
     ;       RDI = RDI + (number of sectors read * 512)
     ;       All other registers preserved
     pre_readsectors:
             push rbx
             push rdi
             push rsi
             push rcx
             push rax
     
             push rcx                        ; Save the sector count
             push rdi                        ; Save the destination memory address
             push rax                        ; Save the block number
             push rax
     
             shl rdx, 7                      ; Quick multiply by 0x80
             add rdx, 0x100                  ; Offset to port 0
     
             mov rsi, [ahci_base]
     
             ; Command list setup
             mov rdi, ahci_cmdlist           ; command list (1K with 32 entries, 32 bytes each)
             xor eax, eax
             mov eax, 0x00010005             ; 1 PRDTL Entry, Command FIS Length = 20 bytes
             stosd                           ; DW 0 - Description Information
             xor eax, eax
             stosd                           ; DW 1 - Command Status
             mov eax, ahci_cmdtable
             stosd                           ; DW 2 - Command Table Base Address
             xor eax, eax
             stosd                           ; DW 3 - Command Table Base Address Upper
             stosd
             stosd
             stosd
             stosd
             ; DW 4 - 7 are reserved
     
             ; Command FIS setup
             mov rdi, ahci_cmdtable          ; Build a command table for Port 0
             mov eax, 0x00258027             ; 25 READ DMA EXT, bit 15 set, fis 27 H2D
             stosd                           ; feature 7:0, command, c, fis
             pop rax                         ; Restore the start sector number
             shl rax, 36
             shr rax, 36                     ; Upper 36 bits cleared
             bts rax, 30                     ; bit 30 set for LBA
             stosd                           ; device, lba 23:16, lba 15:8, lba 7:0
             pop rax                         ; Restore the start sector number
             shr rax, 24
             stosd                           ; feature 15:8, lba 47:40, lba 39:32, lba 31:24
             mov rax, rcx                    ; Read the number of sectors given in rcx
             stosd                           ; control, ICC, count 15:8, count 7:0
             mov rax, 0x00000000
             stosd                           ; reserved
     
             ; PRDT setup
             mov rdi, ahci_cmdtable + 0x80
             pop rax                         ; Restore the destination memory address
             stosd                           ; Data Base Address
             shr rax, 32
             stosd                           ; Data Base Address Upper
             stosd                           ; Reserved
             pop rax                         ; Restore the sector count
             shl rax, 9                      ; multiply by 512 for bytes
             sub rax, 1                      ; subtract 1 (4.2.3.3, DBC is number of bytes - 1)
             stosd                           ; Description Information
     
             add rsi, rdx
     
             mov rdi, rsi
             add rdi, 0x10                   ; Port x Interrupt Status
             xor eax, eax
             stosd
     
             mov rdi, rsi
             add rdi, 0x18                   ; Offset to port 0
             mov eax, [rdi]
             bts eax, 4                      ; FRE
             bts eax, 0                      ; ST
             stosd
     
             mov rdi, rsi
             add rdi, 0x38                   ; Command Issue
             mov eax, 0x00000001             ; Execute Command Slot 0
             stosd
     
     .poll:
             mov eax, [rsi+0x38]
             cmp eax, 0
             jne .poll
     
             mov rdi, rsi
             add rdi, 0x18                   ; Offset to port 0
             mov eax, [rdi]
             btc eax, 4                      ; FRE
             btc eax, 0                      ; ST
             stosd
     
             pop rax                         ; rax = start
             pop rcx                         ; rcx = number of sectors read
             add rax, rcx                    ; rax = start + number of sectors read
             pop rsi
             pop rdi
             mov rbx, rcx                    ; rdi = dest addr + number of bytes read
             shl rbx, 9
             add rdi, rbx
             pop rbx
     ret
     ; -----------------------------------------------------------------------------
     
     
     ; -----------------------------------------------------------------------------
     ; writesectors -- Write data to a SATA hard drive
     ; IN:   RAX = starting sector # to write
     ;       RCX = number of sectors to write (up to 8192 = 4MiB)
     ;       RDX = disk #
     ;       RSI = memory location of sectors
     ; OUT:  RAX = RAX + number of sectors that were written
     ;       RCX = number of sectors that were written (0 on error)
     ;       RSI = RSI + (number of sectors written * 512)
     ;       All other registers preserved
     writesectors:
             push rbx
             push rdi
             push rsi
             push rcx
             push rax
     
             push rcx                        ; Save the sector count
             push rsi                        ; Save the source memory address
             push rax                        ; Save the block number
             push rax
     
             shl rdx, 7                      ; Quick multiply by 0x80
             add rdx, 0x100                  ; Offset to port 0
     
             mov rsi, [ahci_base]
     
             ; Command list setup
             mov rdi, ahci_cmdlist           ; command list (1K with 32 entries, 32 bytes each)
             xor eax, eax
             mov eax, 0x00010045             ; 1 PRDTL Entry, write flag, Command FIS Length = 20 bytes
             stosd                           ; DW 0 - Description Information
             xor eax, eax
             stosd                           ; DW 1 - Command Status
             mov eax, ahci_cmdtable
             stosd                           ; DW 2 - Command Table Base Address
             xor eax, eax
             stosd                           ; DW 3 - Command Table Base Address Upper
             stosd
             stosd
             stosd
             stosd
             ; DW 4 - 7 are reserved
     
             ; Command FIS setup
             mov rdi, ahci_cmdtable          ; Build a command table for Port 0
             mov eax, 0x00358027             ; 35 WRITE DMA EXT, bit 15 set, fis 27 H2D
             stosd                           ; feature 7:0, command, c, fis
             pop rax                         ; Restore the start sector number
             shl rax, 36
             shr rax, 36                     ; Upper 36 bits cleared
             bts rax, 30                     ; bit 30 set for LBA
             stosd                           ; device, lba 23:16, lba 15:8, lba 7:0
             pop rax                         ; Restore the start sector number
             shr rax, 24
             stosd                           ; feature 15:8, lba 47:40, lba 39:32, lba 31:24
             mov rax, rcx                    ; Read the number of sectors given in rcx
             stosd                           ; control, ICC, count 15:8, count 7:0
             mov rax, 0x00000000
             stosd                           ; reserved
     
             ; PRDT setup
             mov rdi, ahci_cmdtable + 0x80
             pop rax                         ; Restore the source memory address
     
             stosd                           ; Data Base Address
             shr rax, 32
             stosd                           ; Data Base Address Upper
             stosd                           ; Reserved
             pop rax                         ; Restore the sector count
             shl rax, 9                      ; multiply by 512 for bytes
             add rax, -1                     ; subtract 1 (4.2.3.3, DBC is number of bytes - 1)
             stosd                           ; Description Information
     
             add rsi, rdx
     
             mov rdi, rsi
             add rdi, 0x10                   ; Port x Interrupt Status
             xor eax, eax
             stosd
     
             mov rdi, rsi
             add rdi, 0x18                   ; Offset to port 0
             mov eax, [rdi]
             bts eax, 4                      ; FRE
             bts eax, 0                      ; ST
             stosd
     
             mov rdi, rsi
             add rdi, 0x38                   ; Command Issue
             mov eax, 0x00000001             ; Execute Command Slot 0
             stosd
     
     .poll:
             mov eax, [rsi+0x38]
             cmp eax, 0
             jne .poll
     
             mov rdi, rsi
             add rdi, 0x18                   ; Offset to port 0
             mov eax, [rdi]
             btc eax, 4                      ; FRE
             btc eax, 0                      ; ST
             stosd
     
             pop rax                         ; rax = start
             pop rcx                         ; rcx = number of sectors read
             add rax, rcx                    ; rax = start + number of sectors written
             pop rsi
             pop rdi
             mov rbx, rcx                    ; rdi = dest addr + number of bytes written
             shl rbx, 9
             add rdi, rbx
             pop rbx
     ret
     ; -----------------------------------------------------------------------------
     #+end_src
*** filesystems
**** bmfs
     #+begin_src fasm :tangle no
     ; -----------------------------------------------------------------------------
     ; init_bmfs -- Initialize the BMFS driver
     init_bmfs:
             push rdi
             push rdx
             push rcx
             push rax

             mov byte [bmfs_directory], 0

             cmp byte [os_DiskEnabled], 0x01
             jne init_bmfs_nodisk

             ; Read directory to memory
             mov rax, 8                      ; Start to read from 4K in
             mov rcx, 8                      ; Read 8 sectors (4KiB)
             xor edx, edx                    ; Read from drive 0
             mov rdi, bmfs_directory
             call readsectors

             ; Get total blocks
             mov eax, [hd1_size]             ; in mebibytes (MiB)
             shr rax, 1
             mov [bmfs_TotalBlocks], rax

     init_bmfs_nodisk:

             pop rax
             pop rcx
             pop rdx
             pop rdi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_file_open -- Open a file on disk
     ; IN:   RSI = File name (zero-terminated string)
     ; OUT:  RAX = File I/O handler, 0 on error
     ;       All other registers preserved
     os_bmfs_file_open:
             push rsi
             push rdx
             push rcx
             push rbx

             ; Query the existence
             call os_bmfs_file_internal_query
             jc os_bmfs_file_open_error
             mov rax, rbx                    ; Slot #
             add rax, 10                     ; Files start at 10

             ; Is it already open? If not, mark as open
             mov rsi, os_filehandlers
             add rsi, rbx
             cmp byte [rsi], 0               ; 0 is closed
             jne os_bmfs_file_open_error
             mov byte [rsi], 1               ; Set to open

             ; Reset the seek
             mov rsi, os_filehandlers_seek
             shl rbx, 3                      ; Quick multiply by 8
             add rsi, rbx
             xor ebx, ebx                    ; SEEK_START
             mov qword [rsi], rbx

             jmp os_bmfs_file_open_done

     os_bmfs_file_open_error:
             xor eax, eax

     os_bmfs_file_open_done:
             pop rbx
             pop rcx
             pop rdx
             pop rsi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_file_close -- Close an open file
     ; IN:   RAX = File I/O handler
     ; OUT:  All registers preserved
     os_bmfs_file_close:
             push rsi
             push rax

             ; Is it in the valid file handler range?
             sub rax, 10                     ; Subtract the handler offset
             cmp rax, 64                     ; BMFS has up to 64 files
             jg os_bmfs_file_close_error

             ; Mark as closed
             mov rsi, os_filehandlers
             add rsi, rax
             mov byte [rsi], 0               ; Set to closed

     os_bmfs_file_close_error:

     os_bmfs_file_close_done:
             pop rax
             pop rsi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_read -- Read a number of bytes from a file
     ; IN:   RAX = File I/O handler
     ;       RCX = Number of bytes to read (automatically rounded up to next 2MiB)
     ;       RDI = Destination memory address
     ; OUT:  RCX = Number of bytes read
     ;       All other registers preserved
     os_bmfs_file_read:
             push rdi
             push rsi
             push rdx
             push rcx
             push rbx
             push rax

             ; Is it a valid read?
             cmp rcx, 0
             je os_bmfs_file_read_error

             ; Is it in the valid file handler range?
             sub rax, 10                     ; Subtract the handler offset
             mov rbx, rax                    ; Keep the file ID
             cmp rax, 64                     ; BMFS has up to 64 files
             jg os_bmfs_file_read_error

             ; Is this an open file?
             mov rsi, os_filehandlers
             add rsi, rax
             cmp byte [rsi], 0
             je os_bmfs_file_read_error

             ; Get the starting block
             mov rsi, bmfs_directory         ; Beginning of directory structure
             shl rax, 6                      ; Quickly multiply by 64 (size of BMFS record)
             add rsi, rax
             add rsi, 32                     ; Offset to starting block
             lodsq                           ; Load starting block in RAX

             ; Add the current offset
             ; Currently always starting from start

             ; Round up 'bytes to read' to the next 2MiB block
             add rcx, (200000h -1h)          ; 2MiB - 1 byte
             shr rcx, 21                     ; Quick divide by 2MiB

             call os_bmfs_block_read
             jmp os_bmfs_file_read_done

     os_bmfs_file_read_error:
             xor ecx, ecx

     os_bmfs_file_read_done:

             ; Increment the offset

             pop rax
             pop rbx
             pop rcx
             pop rdx
             pop rsi
             pop rdi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_write -- Write a number of bytes to a file
     ; IN:   RAX = File I/O handler
     ;       RCX = Number of bytes to write
     ;       RSI = Source memory address
     ; OUT:  RCX = Number of bytes written
     ;       All other registers preserved
     os_bmfs_file_write:
             push rdi
             push rsi
             push rdx
             push rcx
             push rbx
             push rax

             ; Is it a valid write?
             cmp rcx, 0
             je os_bmfs_file_write_error

             ; Is it in the valid file handler range?
             sub rax, 10                     ; Subtract the handler offset
             mov rbx, rax                    ; Keep the file ID
             cmp rax, 64                     ; BMFS has up to 64 files
             jg os_bmfs_file_write_error

             ; Is this an open file?
             mov rdi, os_filehandlers
             add rdi, rax
             cmp byte [rdi], 0
             je os_bmfs_file_write_error

             ; Flush directory to disk

     os_bmfs_file_write_error:
             xor ecx, ecx

     os_bmfs_file_write_done:

             pop rax
             pop rbx
             pop rcx
             pop rdx
             pop rsi
             pop rdi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_seek -- Seek to position in a file
     ; IN:   RAX = File I/O handler
     ;       RCX = Number of bytes to offset from origin
     ;       RDX = Origin
     ; OUT:  All registers preserved
     os_bmfs_file_seek:
             ; Is this an open file?

             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_internal_query -- Search for a file name and return information
     ; IN:   RSI = Pointer to file name
     ; OUT:  RAX = Staring block number
     ;       RBX = Offset to entry
     ;       RCX = File size in bytes
     ;       RDX = Reserved blocks
     ;       Carry set if not found. If carry is set then ignore returned values
     os_bmfs_file_internal_query:
             push rdi

             clc                             ; Clear carry
             mov rdi, bmfs_directory         ; Beginning of directory structure

     os_bmfs_file_internal_query_next:
             call os_string_compare
             jc os_bmfs_file_internal_query_found
             add rdi, 64                     ; Next record
             cmp rdi, bmfs_directory + 0x1000        ; End of directory
             jne os_bmfs_file_internal_query_next
             stc                             ; Set flag for file not found
             pop rdi
             ret

     os_bmfs_file_internal_query_found:
             clc                             ; Clear flag for file found
             mov rbx, rdi
             sub rbx, bmfs_directory
             shr rbx, 6                              ; Quick divide by 64 for offset (entry) number
             mov rdx, [rdi + BMFS_DirEnt.reserved]   ; Reserved blocks
             mov rcx, [rdi + BMFS_DirEnt.size]       ; Size in bytes
             mov rax, [rdi + BMFS_DirEnt.start]      ; Starting block number

             pop rdi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_query -- Search for a file name and return information
     ; IN:   RSI = Pointer to file name
     ; OUT:  RCX = File size in bytes
     ;       Carry set if not found. If carry is set then ignore returned values
     os_bmfs_file_query:
             push rdi

             clc                             ; Clear carry
             mov rdi, bmfs_directory         ; Beginning of directory structure

     os_bmfs_file_query_next:
             call os_string_compare
             jc os_bmfs_file_query_found
             add rdi, 64                     ; Next record
             cmp rdi, bmfs_directory + 0x1000        ; End of directory
             jne os_bmfs_file_query_next
             stc                             ; Set flag for file not found
             pop rdi
             ret

     os_bmfs_file_query_found:
             clc                             ; Clear flag for file found
             mov rcx, [rdi + BMFS_DirEnt.size]       ; Size in bytes

             pop rdi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_create -- Create a file on the hard disk
     ; IN:   RSI = Pointer to file name, must be <= 32 characters
     ;       RCX = File size to reserve (rounded up to the nearest 2MiB)
     ; OUT:  Carry clear on success, set on failure
     ; Note: This function pre-allocates all blocks required for the file
     os_bmfs_file_create:

             ; Flush directory to disk

             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_file_delete -- Delete a file from the hard disk
     ; IN:   RSI = File name to delete
     ; OUT:  Carry clear on success, set on failure
     os_bmfs_file_delete:
             push rdx
             push rcx
             push rbx
             push rax

             call os_bmfs_file_internal_query
             jc os_bmfs_file_delete_notfound

             mov byte [rbx + BMFS_DirEnt.filename], 0x01 ; Add deleted marker to file name

             ; Flush directory to disk

     os_bmfs_file_delete_notfound:
             pop rax
             pop rbx
             pop rcx
             pop rdx
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_bmfs_block_read -- Read a number of blocks into memory
     ; IN:   RAX = Starting block #
     ;       RCX = Number of blocks to read
     ;       RDI = Memory location to store blocks
     ; OUT:
     os_bmfs_block_read:
             cmp rcx, 0
             je os_bmfs_block_read_done      ; Bail out if instructed to read nothing

             ; Calculate the starting sector
             shl rax, 12                     ; Multiply block start count by 4096 to get sector start count
                                             ; 4096 = 2M / 0.5K,  0.5K = 1 sector

             ; Calculate sectors to read
             mov rbx, rcx
             shl rcx, 12                     ; Multiply block count by 4096 to get number of sectors to read

     os_bmfs_block_read_loop:
             mov rcx, 4096                   ; Read 2MiB at a time (4096 512-byte sectors = 2MiB)
             xor rdx, rdx                    ; Read from drive 0
             call readsectors
             dec rbx
             jnz os_bmfs_block_read_loop

     os_bmfs_block_read_done:
             ret
     ; -----------------------------------------------------------------------------


     ;; ; -----------------------------------------------------------------------------
     ;; ; os_bmfs_block_read -- Read a number of blocks into memory
     ;; ; IN:   RAX = Starting block #
     ;; ;       RCX = Number of blocks to read
     ;; ;       RDI = Memory location to store blocks
     ;; ; OUT:
     ;; os_bmfs_block_read:
     ;;         cmp rcx, 0
     ;;         je os_bmfs_block_read_done      ; Bail out if instructed to read nothing

     ;;         ; Calculate the starting sector
     ;;         shl rax, 12                     ; Multiply block start count by 4096 to get sector start count

     ;;         ; Calculate sectors to read
     ;;         shl rcx, 12                     ; Multiply block count by 4096 to get number of sectors to read
     ;;         mov rbx, rcx

     ;; os_bmfs_block_read_loop:
     ;;         mov rcx, 4096                   ; Read 2MiB at a time (4096 512-byte sectors = 2MiB)
     ;;         call readsectors
     ;;         sub rbx, 4096
     ;;         jnz os_bmfs_block_read_loop

     ;; os_bmfs_block_read_done:
     ;;         ret
     ;; ; -----------------------------------------------------------------------------



     ; -----------------------------------------------------------------------------
     ; os_bmfs_block_write -- Write a number of blocks to disk
     ; IN:   RAX = Starting block #
     ;       RCX = Number of blocks to write
     ;       RSI = Memory location of blocks to store
     ; OUT:
     os_bmfs_block_write:
             cmp rcx, 0
             je os_bmfs_block_write_done     ; Bail out if instructed to write nothing

             ; Calculate the starting sector
             shl rax, 12                     ; Multiply block start count by 4096 to get sector start count

             ; Calculate sectors to write
             shl rcx, 12                     ; Multiply block count by 4096 to get number of sectors to write
             mov rbx, rcx

     os_bmfs_block_write_loop:
             mov rcx, 4096                   ; Write 2MiB at a time (4096 512-byte sectors = 2MiB)
             call writesectors
             sub rbx, 4096
             jnz os_bmfs_block_write_loop

     os_bmfs_block_write_done:
             ret
     ; -----------------------------------------------------------------------------
     #+end_src
*** net
**** rtl8169
     #+begin_src fasm :tangle no
     ; Realtek 8169 NIC
     ; http://wiki.osdev.org/RTL8169


     ; -----------------------------------------------------------------------------
     ; Initialize a Realtek 8169 NIC
     ;  IN:  BL  = Bus number of the Realtek device
     ;       CL  = Device/Slot number of the Realtek device
     os_net_rtl8169_init:
             push rsi
             push rdx
             push rcx
             push rax

             ; Grab the Base I/O Address of the device
             mov dl, 0x04                            ; BAR0
             call os_pci_read_reg
             and eax, 0xFFFFFFFC                     ; EAX now holds the Base IO Address (clear the low 2 bits)
             mov word [os_NetIOAddress], ax

             ; Grab the IRQ of the device
             mov dl, 0x0F                            ; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)
             call os_pci_read_reg
             mov [os_NetIRQ], al                     ; AL holds the IRQ

             ; Grab the MAC address
             mov dx, word [os_NetIOAddress]
             in al, dx
             mov [os_NetMAC], al
             add dx, 1
             in al, dx
             mov [os_NetMAC+1], al
             add dx, 1
             in al, dx
             mov [os_NetMAC+2], al
             add dx, 1
             in al, dx
             mov [os_NetMAC+3], al
             add dx, 1
             in al, dx
             mov [os_NetMAC+4], al
             add dx, 1
             in al, dx
             mov [os_NetMAC+5], al

             ; Reset the device
             call os_net_rtl8169_reset

             pop rax
             pop rcx
             pop rdx
             pop rsi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_rtl8136_reset - Reset a Realtek 8169 NIC
     ;  IN:  Nothing
     ; OUT:  Nothing, all registers preserved
     os_net_rtl8169_reset:
             push rdx
             push rcx
             push rax

             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_COMMAND
             mov al, 0x10                            ; Bit 4 set for Reset
             out dx, al
             mov cx, 1000                            ; Wait no longer for the reset to complete
     wait_for_8169_reset:
             in al, dx
             test al, 0x10
             jz reset_8169_completed                 ; RST remains 1 during reset, Reset complete when 0
             dec cx
             jns wait_for_8169_reset
     reset_8169_completed:

             ; Unlock config registers
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_9346CR
             mov al, 0xC0                            ; Unlock
             out dx, al

             ; Set the C+ Command
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_CCR
             in ax, dx
             bts ax, 3                               ; Enable PCI Multiple Read/Write
             btc ax, 9                               ; Little-endian mode
             out dx, ax

             ; Power management?

             ; Recieve configuration
             mov dx, word [os_NetIOAddress]
             add edx, RTL8169_REG_RCR
             mov eax, 0x0000E70A                     ; Set bits 1 (APM), 3 (AB), 8-10 (Unlimited), 13-15 (No limit)
             out dx, eax

             ; Set up TCR
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_TCR
             mov eax, 0x03000700
             out dx, eax

             ; Setup max RX size
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_MAXRX
             mov ax, 0x3FFF                          ; 16384 - 1
             out dx, ax

             ; Setup max TX size
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_MAXTX
             mov al, 0x3B
             out dx, al

             ; Set the Transmit Normal Priority Descriptor Start Address
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_TNPDS
             mov rax, os_eth_tx_buffer
             out dx, eax                             ; Write the low bits
             shr rax, 32
             add dx, 4
             out dx, eax                             ; Write the high bits
             mov eax, 0x70000000                     ; Set bit 30 (End of Descriptor Ring), 29 (FS), and 28 (LS)
             mov [os_eth_tx_buffer], eax

             ; Set the Receive Descriptor Start Address
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_RDSAR
             mov rax, os_eth_rx_buffer
             out dx, eax                             ; Write the low bits
             shr rax, 32
             add dx, 4
             out dx, eax                             ; Write the high bits
             mov eax, 0x80001FF8                     ; Set bits 31 (Ownership), also buffer size (Max 0x1FF8)
             mov [os_eth_rx_buffer], eax
             mov rax, os_ethernet_rx_buffer
             mov [os_eth_rx_buffer+8], rax
             mov eax, 0xC0001FF8                     ; Set bits 31 (Ownership) and 30 (End of Descriptor Ring), also buffer size (Max 0x1FF8)
             mov [os_eth_rx_buffer+16], eax
             mov rax, os_ethernet_rx_buffer
             mov [os_eth_rx_buffer+24], rax

             ; Initialize multicast registers (no filtering)
             mov eax, 0xFFFFFFFF
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_MAR0
             out dx, eax
             add dx, 4                               ; MAR4
             out dx, eax

             ; Enable Rx/Tx in the Command register
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_COMMAND
             mov al, (1 shl RTL8169_BIT_RE) or (1 shl RTL8169_BIT_TE) ;0x0C                            ; Set bits 2 (TE) and 3 (RE)
             out dx, al

             ; Enable Receive and Transmit interrupts
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_IMR
             mov ax, 0x0005                          ; Set bits 0 (RX OK) and 2 (TX OK)
             out dx, ax

             ; Lock config register
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_9346CR
             mov al, 0x00                            ; Lock
             out dx, al

             pop rax
             pop rcx
             pop rdx
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_rtl8169_transmit - Transmit a packet via a Realtek 8169 NIC
     ;  IN:  RSI = Location of packet
     ;       RCX = Length of packet
     ; OUT:  Nothing
     ;       Uses RAX, RCX, RDX, RSI, RDI
     ; ToDo: Check for proper timeout
     os_net_rtl8169_transmit:
             mov rdi, os_eth_tx_buffer
             mov rax, rcx
             stosw                                   ; Store the frame length
             add rdi, 6                              ; Should the other data be cleared here?
             mov rax, rsi
             stosq                                   ; Store the packet location
             or dword [os_eth_tx_buffer], 0xF0000000 ; Set bit 31 (OWN), 30 (EOR), 29 (FS), and 28 (LS)
             mov dx, word [os_NetIOAddress]
             add dx, RTL8169_REG_TPPOLL
             mov al, 0x40
             out dx, al                              ; Set up TX Polling
     os_net_rtl8169_transmit_sendloop:
             mov eax, [os_eth_tx_buffer]
             and eax, 0x80000000                     ; Check the ownership bit (BT command instead?)
             cmp eax, 0x80000000                     ; If the ownership bit is clear then the NIC sent the packet
             je os_net_rtl8169_transmit_sendloop
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_rtl8169_poll - Polls the Realtek 8169 NIC for a received packet
     ;  IN:  RDI = Location to store packet
     ; OUT:  RCX = Length of packet
     ;       Uses RAX, RCX, RDX, RSI, RDI
     os_net_rtl8169_poll:
             xor ecx, ecx
             mov cx, [os_eth_rx_buffer]
             and cx, 0x3FFF                          ; Clear the two high bits as length is bits 13-0
             cmp cx, 0x1FF8
             jne os_net_rtl8169_poll_first_descriptor
             mov cx, [os_eth_rx_buffer+16]
             and cx, 0x3FFF                          ; Clear the two high bits as length is bits 13-0
     os_net_rtl8169_poll_first_descriptor:
             mov rsi, os_ethernet_rx_buffer
             push rcx
             rep movsb                               ; Copy the packet to the lacation stored in RDI
             pop rcx
             mov eax, 0x80001FF8                     ; Set bits 31 (Ownership), also buffer size (Max 0x1FF8)
             mov [os_eth_rx_buffer], eax
             mov rax, os_ethernet_rx_buffer
             mov [os_eth_rx_buffer+8], rax
             mov eax, 0xC0001FF8                     ; Set bits 31 (Ownership) and 30 (End of Descriptor Ring), also buffer size (Max 0x1FF8)
             mov [os_eth_rx_buffer+16], eax
             mov rax, os_ethernet_rx_buffer
             mov [os_eth_rx_buffer+24], rax
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_rtl8169_ack_int - Acknowledge an internal interrupt of the Realtek 8169 NIC
     ;  IN:  Nothing
     ; OUT:  RAX = Ethernet status
     ;       Uses RDI
     os_net_rtl8169_ack_int:
             push rdx
             mov dx, word [os_NetIOAddress]          ; Clear active interrupt sources
             add dx, RTL8169_REG_ISR
             in ax, dx
             out dx, ax
             shr eax, 2
             pop rdx
             ret
     ; -----------------------------------------------------------------------------


     ; Register Descriptors
             RTL8169_REG_IDR0        = 0x00        ; ID Register 0
             RTL8169_REG_IDR1        = 0x01        ; ID Register 1
             RTL8169_REG_IDR2        = 0x02        ; ID Register 2
             RTL8169_REG_IDR3        = 0x03        ; ID Register 3
             RTL8169_REG_IDR4        = 0x04        ; ID Register 4
             RTL8169_REG_IDR5        = 0x05        ; ID Register 5
             RTL8169_REG_MAR0        = 0x08        ; Multicast Register 0
             RTL8169_REG_MAR1        = 0x09        ; Multicast Register 1
             RTL8169_REG_MAR2        = 0x0A        ; Multicast Register 2
             RTL8169_REG_MAR3        = 0x0B        ; Multicast Register 3
             RTL8169_REG_MAR4        = 0x0C        ; Multicast Register 4
             RTL8169_REG_MAR5        = 0x0D        ; Multicast Register 5
             RTL8169_REG_MAR6        = 0x0E        ; Multicast Register 6
             RTL8169_REG_MAR7        = 0x0F        ; Multicast Register 7
             RTL8169_REG_TNPDS       = 0x20        ; Transmit Normal Priority Descriptors: Start address (64-bit). (256-byte alignment)
             RTL8169_REG_COMMAND     = 0x37        ; Command Register
             RTL8169_REG_TPPOLL      = 0x38        ; Transmit Priority Polling Register
             RTL8169_REG_IMR         = 0x3C        ; Interrupt Mask Register
             RTL8169_REG_ISR         = 0x3E        ; Interrupt Status Register
             RTL8169_REG_TCR         = 0x40        ; Transmit (Tx) Configuration Register
             RTL8169_REG_RCR         = 0x44        ; Receive (Rx) Configuration Register
             RTL8169_REG_9346CR      = 0x50        ; 93C46 (93C56) Command Register
             RTL8169_REG_CONFIG0     = 0x51        ; Configuration Register 0
             RTL8169_REG_CONFIG1     = 0x52        ; Configuration Register 1
             RTL8169_REG_CONFIG2     = 0x53        ; Configuration Register 2
             RTL8169_REG_CONFIG3     = 0x54        ; Configuration Register 3
             RTL8169_REG_CONFIG4     = 0x55        ; Configuration Register 4
             RTL8169_REG_CONFIG5     = 0x56        ; Configuration Register 5
             RTL8169_REG_PHYAR       = 0x60        ; PHY Access Register
             RTL8169_REG_PHYStatus   = 0x6C        ; PHY(GMII, MII, or TBI) Status Register
             RTL8169_REG_MAXRX       = 0xDA        ; Mac Receive Packet Size Register
             RTL8169_REG_CCR         = 0xE0        ; C+ Command Register
             RTL8169_REG_RDSAR       = 0xE4        ; Receive Descriptor Start Address Register (256-byte alignment)
             RTL8169_REG_MAXTX       = 0xEC        ; Max Transmit Packet Size Register

     ; Command Register (Offset 0037h, R/W)
             RTL8169_BIT_RST         = 4           ; Reset
             RTL8169_BIT_RE          = 3           ; Receiver Enable
             RTL8169_BIT_TE          = 2           ; Transmitter Enable

     ; Receive Configuration (Offset 0044h-0047h, R/W)
             RTL8169_BIT_AER         = 5           ; Accept Error
             RTL8169_BIT_AR          = 4           ; Accept Runt
             RTL8169_BIT_AB          = 3           ; Accept Broadcast Packets
             RTL8169_BIT_AM          = 2           ; Accept Multicast Packets
             RTL8169_BIT_APM         = 1           ; Accept Physical Match Packets
             RTL8169_BIT_AAP         = 0           ; Accept All Packets with Destination Address

     ; PHY Register Table
     ; BMCR (address 0x00)
             RTL8169_BIT_ANE         = 12          ; Auto-Negotiation Enable
     #+end_src
**** i8254x
     #+begin_src fasm :tangle no
     ; Intel i8254x NIC.

     ; -----------------------------------------------------------------------------
     ; Initialize an Intel 8254x NIC
     ;  IN:  BL  = Bus number of the Intel device
     ;       CL  = Device/Slot number of the Intel device
     os_net_i8254x_init:
             push rsi
             push rdx
             push rcx
             push rax

             ; Read BAR4, If BAR4 is all 0'z then we are using 32-bit addresses

             ; Grab the Base I/O Address of the device
             mov dl, 0x04                            ; BAR0
             call os_pci_read_reg
             and eax, 0xFFFFFFF0                     ; EAX now holds the Base Memory IO Address (clear the low 4 bits)
             mov dword [os_NetIOBaseMem], eax

             ; Grab the IRQ of the device
             mov dl, 0x0F                            ; Get device's IRQ number from PCI Register 15 (IRQ is bits 7-0)
             call os_pci_read_reg
             mov [os_NetIRQ], al                     ; AL holds the IRQ

             ; Grab the MAC address
             mov rsi, [os_NetIOBaseMem]
             mov eax, [rsi+0x5400]                           ; RAL
             cmp eax, 0x00000000
             je os_net_i8254x_init_get_MAC_via_EPROM
             mov [os_NetMAC], al
             shr eax, 8
             mov [os_NetMAC+1], al
             shr eax, 8
             mov [os_NetMAC+2], al
             shr eax, 8
             mov [os_NetMAC+3], al
             mov eax, [rsi+0x5404]                           ; RAH
             mov [os_NetMAC+4], al
             shr eax, 8
             mov [os_NetMAC+5], al
             jmp os_net_i8254x_init_done_MAC

     os_net_i8254x_init_get_MAC_via_EPROM:
             mov rsi, [os_NetIOBaseMem]
             mov eax, 0x00000001
             mov [rsi+0x14], eax
             mov eax, [rsi+0x14]
             shr eax, 16
             mov [os_NetMAC], al
             shr eax, 8
             mov [os_NetMAC+1], al
             mov eax, 0x00000101
             mov [rsi+0x14], eax
             mov eax, [rsi+0x14]
             shr eax, 16
             mov [os_NetMAC+2], al
             shr eax, 8
             mov [os_NetMAC+3], al
             mov eax, 0x00000201
             mov [rsi+0x14], eax
             mov eax, [rsi+0x14]
             shr eax, 16
             mov [os_NetMAC+4], al
             shr eax, 8
             mov [os_NetMAC+5], al
     os_net_i8254x_init_done_MAC:

             ; Reset the device
             call os_net_i8254x_reset

             pop rax
             pop rcx
             pop rdx
             pop rsi
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_i8254x_reset - Reset an Intel 8254x NIC
     ;  IN:  Nothing
     ; OUT:  Nothing, all registers preserved
     os_net_i8254x_reset:
             mov rsi, [os_NetIOBaseMem]
             mov rdi, rsi

             mov eax, 0xFFFFFFFF
             mov [rsi+I8254X_REG_IMC], eax           ; Disable all interrupt causes
             mov eax, [rsi+I8254X_REG_ICR]           ; Clear any pending interrupts
             xor eax, eax
             mov [rsi+I8254X_REG_ITR], eax           ; Disable interrupt throttling logic

             mov eax, 0x00000030
             mov [rsi+I8254X_REG_PBA], eax           ; PBA: set the RX buffer size to 48KB (TX buffer is calculated as 64-RX buffer)

             mov eax, 0x08008060
             mov [rsi+I8254X_REG_TXCW], eax          ; TXCW: set ANE, TxConfigWord (Half/Full duplex, Next Page Request)

             mov eax, [rsi+I8254X_REG_CTRL]
             btr eax, 3
             bts eax, 6
             bts eax, 5
             btr eax, 31
             btr eax, 30
             btr eax, 7
             mov [rsi+I8254X_REG_CTRL], eax          ; CTRL: clear LRST, set SLU and ASDE, clear RSTPHY, VME, and ILOS

             push rdi
             add rdi, 0x5200                         ; MTA: reset
             mov eax, 0xFFFFFFFF
             stosd
             stosd
             stosd
             stosd
             pop rdi

             mov rax, os_eth_rx_buffer
             mov [rsi+I8254X_REG_RDBAL], eax         ; Receive Descriptor Base Address Low
             shr rax, 32
             mov [rsi+I8254X_REG_RDBAH], eax         ; Receive Descriptor Base Address High
             mov eax, (32 * 16)
             mov [rsi+I8254X_REG_RDLEN], eax         ; Receive Descriptor Length
             xor eax, eax
             mov [rsi+I8254X_REG_RDH], eax           ; Receive Descriptor Head
             mov eax, 1
             mov [rsi+I8254X_REG_RDT], eax           ; Receive Descriptor Tail
             mov eax, 0x04008006                     ; Receiver Enable, Store Bad Packets, Broadcast Accept Mode, Strip Ethernet CRC from incoming packet
             mov [rsi+I8254X_REG_RCTL], eax          ; Receive Control Register

             push rdi
             mov rdi, os_eth_rx_buffer
             mov rax, 0x1c9000
             stosd
             pop rdi

             mov rax, os_eth_tx_buffer
             mov [rsi+I8254X_REG_TDBAL], eax         ; Transmit Descriptor Base Address Low
             shr rax, 32
             mov [rsi+I8254X_REG_TDBAH], eax         ; Transmit Descriptor Base Address High
             mov eax, (32 * 16)
             mov [rsi+I8254X_REG_TDLEN], eax         ; Transmit Descriptor Length
             xor eax, eax
             mov [rsi+I8254X_REG_TDH], eax           ; Transmit Descriptor Head
             mov [rsi+I8254X_REG_TDT], eax           ; Transmit Descriptor Tail
             mov eax, 0x010400FA                     ; Enabled, Pad Short Packets, 15 retries, 64-byte COLD, Re-transmit on Late Collision
             mov [rsi+I8254X_REG_TCTL], eax          ; Transmit Control Register
             mov eax, 0x0060200A                     ; IPGT 10, IPGR1 8, IPGR2 6
             mov [rsi+I8254X_REG_TIPG], eax          ; Transmit IPG Register

             xor eax, eax
             mov [rsi+I8254X_REG_RDTR], eax          ; Clear the Receive Delay Timer Register
             mov [rsi+I8254X_REG_RADV], eax          ; Clear the Receive Interrupt Absolute Delay Timer
             mov [rsi+I8254X_REG_RSRPD], eax         ; Clear the Receive Small Packet Detect Interrupt
             bts eax, 0                              ; TXDW
             bts eax, 7                              ; RXT0
             mov eax, 0x1FFFF                        ; Temp enable all interrupt types
             mov [rsi+I8254X_REG_IMS], eax           ; Enable interrupt types

             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_i8254x_transmit - Transmit a packet via an Intel 8254x NIC
     ;  IN:  RSI = Location of packet
     ;       RCX = Length of packet
     ; OUT:  Nothing
     ;       Uses RAX, RCX, RSI, RDI
     os_net_i8254x_transmit:
             mov rdi, os_eth_tx_buffer               ; Transmit Descriptor Base Address
             mov rax, rsi
             stosq                                   ; Store the data location
             mov rax, rcx                            ; The packet size is in CX
             bts rax, 24                             ; EOP
             bts rax, 25                             ; IFCS
             bts rax, 27                             ; RS
             stosq
             mov rdi, [os_NetIOBaseMem]
             xor eax, eax
             mov [rdi+I8254X_REG_TDH], eax           ; TDH - Transmit Descriptor Head
             add eax, 1
             mov [rdi+I8254X_REG_TDT], eax           ; TDL - Transmit Descriptor Tail
             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_i8254x_poll - Polls the Intel 8254x NIC for a received packet
     ;  IN:  RDI = Location to store packet
     ; OUT:  RCX = Length of packet
     ;       Uses RAX, RCX, RDX, RSI, RDI
     os_net_i8254x_poll:
             xor ecx, ecx

             mov cx, [os_eth_rx_buffer+8]            ; Get the packet length
             mov rsi, 0x1c9000
             push rcx
             rep movsb
             pop rcx
             mov rsi, [os_NetIOBaseMem]
             xor eax, eax
             mov [rsi+I8254X_REG_RDH], eax           ; Receive Descriptor Head
             mov eax, 1
             mov [rsi+I8254X_REG_RDT], eax           ; Receive Descriptor Tail

             push rdi
             mov rdi, os_eth_rx_buffer
             mov rax, 0x1c9000
             stosd
             pop rdi

             ret
     ; -----------------------------------------------------------------------------


     ; -----------------------------------------------------------------------------
     ; os_net_i8254x_ack_int - Acknowledge an internal interrupt of the Intel 8254x NIC
     ;  IN:  Nothing
     ; OUT:  RAX = Ethernet status
     ;       Uses RDI
     os_net_i8254x_ack_int:
             push rdi
             xor eax, eax
             mov rdi, [os_NetIOBaseMem]
             mov eax, [rdi+I8254X_REG_ICR]
             pop rdi
             ret
     ; -----------------------------------------------------------------------------


     ; Maximum packet size
     I8254X_MAX_PKT_SIZE     = 16384

     ; Register list
     I8254X_REG_CTRL         = 0x0000 ; Control Register
     I8254X_REG_STATUS       = 0x0008 ; Device Status Register
     I8254X_REG_CTRLEXT      = 0x0018 ; Extended Control Register
     I8254X_REG_MDIC         = 0x0020 ; MDI Control Register
     I8254X_REG_FCAL         = 0x0028 ; Flow Control Address Low
     I8254X_REG_FCAH         = 0x002C ; Flow Control Address High
     I8254X_REG_FCT          = 0x0030 ; Flow Control Type
     I8254X_REG_VET          = 0x0038 ; VLAN Ether Type
     I8254X_REG_ICR          = 0x00C0 ; Interrupt Cause Read
     I8254X_REG_ITR          = 0x00C4 ; Interrupt Throttling Register
     I8254X_REG_ICS          = 0x00C8 ; Interrupt Cause Set Register
     I8254X_REG_IMS          = 0x00D0 ; Interrupt Mask Set/Read Register
     I8254X_REG_IMC          = 0x00D8 ; Interrupt Mask Clear Register
     I8254X_REG_RCTL         = 0x0100 ; Receive Control Register
     I8254X_REG_FCTTV        = 0x0170 ; Flow Control Transmit Timer Value
     I8254X_REG_TXCW         = 0x0178 ; Transmit Configuration Word
     I8254X_REG_RXCW         = 0x0180 ; Receive Configuration Word
     I8254X_REG_TCTL         = 0x0400 ; Transmit Control Register
     I8254X_REG_TIPG         = 0x0410 ; Transmit Inter Packet Gap

     I8254X_REG_LEDCTL       = 0x0E00 ; LED Control
     I8254X_REG_PBA          = 0x1000 ; Packet Buffer Allocation

     I8254X_REG_RDBAL        = 0x2800 ; RX Descriptor Base Address Low
     I8254X_REG_RDBAH        = 0x2804 ; RX Descriptor Base Address High
     I8254X_REG_RDLEN        = 0x2808 ; RX Descriptor Length
     I8254X_REG_RDH          = 0x2810 ; RX Descriptor Head
     I8254X_REG_RDT          = 0x2818 ; RX Descriptor Tail
     I8254X_REG_RDTR         = 0x2820 ; RX Delay Timer Register
     I8254X_REG_RXDCTL       = 0x3828 ; RX Descriptor Control
     I8254X_REG_RADV         = 0x282C ; RX Int. Absolute Delay Timer
     I8254X_REG_RSRPD        = 0x2C00 ; RX Small Packet Detect Interrupt

     I8254X_REG_TXDMAC       = 0x3000 ; TX DMA Control
     I8254X_REG_TDBAL        = 0x3800 ; TX Descriptor Base Address Low
     I8254X_REG_TDBAH        = 0x3804 ; TX Descriptor Base Address High
     I8254X_REG_TDLEN        = 0x3808 ; TX Descriptor Length
     I8254X_REG_TDH          = 0x3810 ; TX Descriptor Head
     I8254X_REG_TDT          = 0x3818 ; TX Descriptor Tail
     I8254X_REG_TIDV         = 0x3820 ; TX Interrupt Delay Value
     I8254X_REG_TXDCTL       = 0x3828 ; TX Descriptor Control
     I8254X_REG_TADV         = 0x382C ; TX Absolute Interrupt Delay Value
     I8254X_REG_TSPMT        = 0x3830 ; TCP Segmentation Pad & Min Threshold

     I8254X_REG_RXCSUM       = 0x5000 ; RX Checksum Control

     ; Register list for i8254x
     I82542_REG_RDTR         = 0x0108 ; RX Delay Timer Register
     I82542_REG_RDBAL        = 0x0110 ; RX Descriptor Base Address Low
     I82542_REG_RDBAH        = 0x0114 ; RX Descriptor Base Address High
     I82542_REG_RDLEN        = 0x0118 ; RX Descriptor Length
     I82542_REG_RDH          = 0x0120 ; RDH for i82542
     I82542_REG_RDT          = 0x0128 ; RDT for i82542
     I82542_REG_TDBAL        = 0x0420 ; TX Descriptor Base Address Low
     I82542_REG_TDBAH        = 0x0424 ; TX Descriptor Base Address Low
     I82542_REG_TDLEN        = 0x0428 ; TX Descriptor Length
     I82542_REG_TDH          = 0x0430 ; TDH for i82542
     I82542_REG_TDT          = 0x0438 ; TDT for i82542

     ; CTRL - Control Register (0x0000)
     I8254X_CTRL_FD          = 0x00000001 ; Full Duplex
     I8254X_CTRL_LRST        = 0x00000008 ; Link Reset
     I8254X_CTRL_ASDE        = 0x00000020 ; Auto-speed detection
     I8254X_CTRL_SLU         = 0x00000040 ; Set Link Up
     I8254X_CTRL_ILOS        = 0x00000080 ; Invert Loss of Signal
     I8254X_CTRL_SPEED_MASK  = 0x00000300 ; Speed selection
     I8254X_CTRL_SPEED_SHIFT = 8
     I8254X_CTRL_FRCSPD      = 0x00000800 ; Force Speed
     I8254X_CTRL_FRCDPLX     = 0x00001000 ; Force Duplex
     I8254X_CTRL_SDP0_DATA   = 0x00040000 ; SDP0 data
     I8254X_CTRL_SDP1_DATA   = 0x00080000 ; SDP1 data
     I8254X_CTRL_SDP0_IODIR  = 0x00400000 ; SDP0 direction
     I8254X_CTRL_SDP1_IODIR  = 0x00800000 ; SDP1 direction
     I8254X_CTRL_RST         = 0x04000000 ; Device Reset
     I8254X_CTRL_RFCE        = 0x08000000 ; RX Flow Ctrl Enable
     I8254X_CTRL_TFCE        = 0x10000000 ; TX Flow Ctrl Enable
     I8254X_CTRL_VME         = 0x40000000 ; VLAN Mode Enable
     I8254X_CTRL_PHY_RST     = 0x80000000 ; PHY reset

     ; STATUS - Device Status Register (0x0008)
     I8254X_STATUS_FD                = 0x00000001 ; Full Duplex
     I8254X_STATUS_LU                = 0x00000002 ; Link Up
     I8254X_STATUS_TXOFF             = 0x00000010 ; Transmit paused
     I8254X_STATUS_TBIMODE           = 0x00000020 ; TBI Mode
     I8254X_STATUS_SPEED_MASK        = 0x000000C0 ; Link Speed setting
     I8254X_STATUS_SPEED_SHIFT       = 6
     I8254X_STATUS_ASDV_MASK         = 0x00000300 ; Auto Speed Detection
     I8254X_STATUS_ASDV_SHIFT        = 8
     I8254X_STATUS_PCI66             = 0x00000800 ; PCI bus speed
     I8254X_STATUS_BUS64             = 0x00001000 ; PCI bus width
     I8254X_STATUS_PCIX_MODE         = 0x00002000 ; PCI-X mode
     I8254X_STATUS_PCIXSPD_MASK      = 0x0000C000 ; PCI-X speed
     I8254X_STATUS_PCIXSPD_SHIFT     = 14

     ; CTRL_EXT - Extended Device Control Register (0x0018)
     I8254X_CTRLEXT_PHY_INT          = 0x00000020 ; PHY interrupt
     I8254X_CTRLEXT_SDP6_DATA        = 0x00000040 ; SDP6 data
     I8254X_CTRLEXT_SDP7_DATA        = 0x00000080 ; SDP7 data
     I8254X_CTRLEXT_SDP6_IODIR       = 0x00000400 ; SDP6 direction
     I8254X_CTRLEXT_SDP7_IODIR       = 0x00000800 ; SDP7 direction
     I8254X_CTRLEXT_ASDCHK           = 0x00001000 ; Auto-Speed Detect Chk
     I8254X_CTRLEXT_EE_RST           = 0x00002000 ; EEPROM reset
     I8254X_CTRLEXT_SPD_BYPS         = 0x00008000 ; Speed Select Bypass
     I8254X_CTRLEXT_RO_DIS           = 0x00020000 ; Relaxed Ordering Dis.
     I8254X_CTRLEXT_LNKMOD_MASK      = 0x00C00000 ; Link Mode
     I8254X_CTRLEXT_LNKMOD_SHIFT     = 22

     ; MDIC - MDI Control Register (0x0020)
     I8254X_MDIC_DATA_MASK   = 0x0000FFFF ; Data
     I8254X_MDIC_REG_MASK    = 0x001F0000 ; PHY Register
     I8254X_MDIC_REG_SHIFT   = 16
     I8254X_MDIC_PHY_MASK    = 0x03E00000 ; PHY Address
     I8254X_MDIC_PHY_SHIFT   = 21
     I8254X_MDIC_OP_MASK     = 0x0C000000 ; Opcode
     I8254X_MDIC_OP_SHIFT    = 26
     I8254X_MDIC_R           = 0x10000000 ; Ready
     I8254X_MDIC_I           = 0x20000000 ; Interrupt Enable
     I8254X_MDIC_E           = 0x40000000 ; Error

     ; ICR - Interrupt Cause Read (0x00c0)
     I8254X_ICR_TXDW         = 0x00000001 ; TX Desc Written back
     I8254X_ICR_TXQE         = 0x00000002 ; TX Queue Empty
     I8254X_ICR_LSC          = 0x00000004 ; Link Status Change
     I8254X_ICR_RXSEQ        = 0x00000008 ; RX Sequence Error
     I8254X_ICR_RXDMT0       = 0x00000010 ; RX Desc min threshold reached
     I8254X_ICR_RXO          = 0x00000040 ; RX Overrun
     I8254X_ICR_RXT0         = 0x00000080 ; RX Timer Interrupt
     I8254X_ICR_MDAC         = 0x00000200 ; MDIO Access Complete
     I8254X_ICR_RXCFG        = 0x00000400
     I8254X_ICR_PHY_INT      = 0x00001000 ; PHY Interrupt
     I8254X_ICR_GPI_SDP6     = 0x00002000 ; GPI on SDP6
     I8254X_ICR_GPI_SDP7     = 0x00004000 ; GPI on SDP7
     I8254X_ICR_TXD_LOW      = 0x00008000 ; TX Desc low threshold hit
     I8254X_ICR_SRPD         = 0x00010000 ; Small RX packet detected

     ; RCTL - Receive Control Register (0x0100)
     I8254X_RCTL_EN          = 0x00000002 ; Receiver Enable
     I8254X_RCTL_SBP         = 0x00000004 ; Store Bad Packets
     I8254X_RCTL_UPE         = 0x00000008 ; Unicast Promiscuous Enabled
     I8254X_RCTL_MPE         = 0x00000010 ; Xcast Promiscuous Enabled
     I8254X_RCTL_LPE         = 0x00000020 ; Long Packet Reception Enable
     I8254X_RCTL_LBM_MASK    = 0x000000C0 ; Loopback Mode
     I8254X_RCTL_LBM_SHIFT   = 6
     I8254X_RCTL_RDMTS_MASK  = 0x00000300 ; RX Desc Min Threshold Size
     I8254X_RCTL_RDMTS_SHIFT = 8
     I8254X_RCTL_MO_MASK     = 0x00003000 ; Multicast Offset
     I8254X_RCTL_MO_SHIFT    = 12
     I8254X_RCTL_BAM         = 0x00008000 ; Broadcast Accept Mode
     I8254X_RCTL_BSIZE_MASK  = 0x00030000 ; RX Buffer Size
     I8254X_RCTL_BSIZE_SHIFT = 16
     I8254X_RCTL_VFE         = 0x00040000 ; VLAN Filter Enable
     I8254X_RCTL_CFIEN       = 0x00080000 ; CFI Enable
     I8254X_RCTL_CFI         = 0x00100000 ; Canonical Form Indicator Bit
     I8254X_RCTL_DPF         = 0x00400000 ; Discard Pause Frames
     I8254X_RCTL_PMCF        = 0x00800000 ; Pass MAC Control Frames
     I8254X_RCTL_BSEX        = 0x02000000 ; Buffer Size Extension
     I8254X_RCTL_SECRC       = 0x04000000 ; Strip Ethernet CRC

     ; TCTL - Transmit Control Register (0x0400)
     I8254X_TCTL_EN          = 0x00000002 ; Transmit Enable
     I8254X_TCTL_PSP         = 0x00000008 ; Pad short packets
     I8254X_TCTL_SWXOFF      = 0x00400000 ; Software XOFF Transmission

     ; PBA - Packet Buffer Allocation (0x1000)
     I8254X_PBA_RXA_MASK     = 0x0000FFFF ; RX Packet Buffer
     I8254X_PBA_RXA_SHIFT    = 0
     I8254X_PBA_TXA_MASK     = 0xFFFF0000 ; TX Packet Buffer
     I8254X_PBA_TXA_SHIFT    = 16

     ; Flow Control Type
     I8254X_FCT_TYPE_DEFAULT = 0x8808

     ; === TX Descriptor fields ===

     ; TX Packet Length (word 2)
     I8254X_TXDESC_LEN_MASK  = 0x0000ffff

     ; TX Descriptor CMD field (word 2)
     I8254X_TXDESC_IDE       = 0x80000000 ; Interrupt Delay Enable
     I8254X_TXDESC_VLE       = 0x40000000 ; VLAN Packet Enable
     I8254X_TXDESC_DEXT      = 0x20000000 ; Extension
     I8254X_TXDESC_RPS       = 0x10000000 ; Report Packet Sent
     I8254X_TXDESC_RS        = 0x08000000 ; Report Status
     I8254X_TXDESC_IC        = 0x04000000 ; Insert Checksum
     I8254X_TXDESC_IFCS      = 0x02000000 ; Insert FCS
     I8254X_TXDESC_EOP       = 0x01000000 ; End Of Packet

     ; TX Descriptor STA field (word 3)
     I8254X_TXDESC_TU        = 0x00000008 ; Transmit Underrun
     I8254X_TXDESC_LC        = 0x00000004 ; Late Collision
     I8254X_TXDESC_EC        = 0x00000002 ; Excess Collisions
     I8254X_TXDESC_DD        = 0x00000001 ; Descriptor Done

     ; === RX Descriptor fields ===

     ; RX Packet Length (word 2)
     I8254X_RXDESC_LEN_MASK  = 0x0000ffff

     ; RX Descriptor STA field (word 3)
     I8254X_RXDESC_PIF       = 0x00000080 ; Passed In-exact Filter
     I8254X_RXDESC_IPCS      = 0x00000040 ; IP cksum calculated
     I8254X_RXDESC_TCPCS     = 0x00000020 ; TCP cksum calculated
     I8254X_RXDESC_VP        = 0x00000008 ; Packet is 802.1Q
     I8254X_RXDESC_IXSM      = 0x00000004 ; Ignore cksum indication
     I8254X_RXDESC_EOP       = 0x00000002 ; End Of Packet
     I8254X_RXDESC_DD        = 0x00000001 ; Descriptor Done
     #+end_src
**** NIC_DeviceVendor_ID
     #+begin_src fasm :tangle no
     NIC_DeviceVendor_ID:                    ; The supported list of NICs
     ; The ID's are Device/Vendor
     
     ; Realtek 816x/811x Gigabit Ethernet
     dd 0x8169FFFF
     dd 0x816710EC           ; 8110SC/8169SC
     dd 0x816810EC           ; 8111/8168B
     dd 0x816910EC           ; 8169
     
     ; Intel 8254x Gigabit Ethernet
     dd 0x8254FFFF
     dd 0x10008086           ; 82542 (Fiber)
     dd 0x10018086           ; 82543GC (Fiber)
     dd 0x10048086           ; 82543GC (Copper)
     dd 0x10088086           ; 82544EI (Copper)
     dd 0x10098086           ; 82544EI (Fiber)
     dd 0x100A8086           ; 82540EM
     dd 0x100C8086           ; 82544GC (Copper)
     dd 0x100D8086           ; 82544GC (LOM)
     dd 0x100E8086           ; 82540EM
     dd 0x100F8086           ; 82545EM (Copper)
     dd 0x10108086           ; 82546EB (Copper)
     dd 0x10118086           ; 82545EM (Fiber)
     dd 0x10128086           ; 82546EB (Fiber)
     dd 0x10138086           ; 82541EI
     dd 0x10148086           ; 82541ER
     dd 0x10158086           ; 82540EM (LOM)
     dd 0x10168086           ; 82540EP (Mobile)
     dd 0x10178086           ; 82540EP
     dd 0x10188086           ; 82541EI
     dd 0x10198086           ; 82547EI
     dd 0x101a8086           ; 82547EI (Mobile)
     dd 0x101d8086           ; 82546EB
     dd 0x101e8086           ; 82540EP (Mobile)
     dd 0x10268086           ; 82545GM
     dd 0x10278086           ; 82545GM
     dd 0x10288086           ; 82545GM
     dd 0x105b8086           ; 82546GB (Copper)
     dd 0x10758086           ; 82547GI
     dd 0x10768086           ; 82541GI
     dd 0x10778086           ; 82541GI
     dd 0x10788086           ; 82541ER
     dd 0x10798086           ; 82546GB
     dd 0x107a8086           ; 82546GB
     dd 0x107b8086           ; 82546GB
     dd 0x107c8086           ; 82541PI
     dd 0x10b58086           ; 82546GB (Copper)
     dd 0x11078086           ; 82544EI
     dd 0x11128086           ; 82544GC
     
     dq 0x0000000000000000   ; End of list
     #+end_src
** interrupt
   #+begin_src fasm :tangle no
   ; -----------------------------------------------------------------------------
   ; Default exception handler
   align 16
   exception_gate:
           mov rsi, int_string00
           call os_output
           mov rsi, exc_string
           call os_output
           jmp $                           ; Hang
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Default interrupt handler
   align 16
   interrupt_gate:                         ; handler for all other interrupts
           iretq                           ; It was an undefined interrupt so return to caller
   ; -----------------------------------------------------------------------------



   ; -----------------------------------------------------------------------------
   ; Keyboard interrupt. IRQ 0x01, INT 0x21
   ; This IRQ runs whenever there is input on the keyboard
   ; it saves keyboard scancode in some [key] (and maybe [key_shift])
   align 16
   keyboard:
           push rbx
           push rax
           pushfq


           xor eax, eax

           in al, 0x60                     ; Get the scan code from the keyboard

           cmp al, 0x01
           je keyboard_escape

           cmp al, 0x2A                    ; Left Shift Make
           je keyboard_shift

           cmp al, 0x36                    ; Right Shift Make
           je keyboard_shift

           cmp al, 0xAA                    ; Left Shift Break
           je keyboard_noshift

           cmp al, 0xB6                    ; Right Shift Break
           je keyboard_noshift

           test al, 0x80
           jz keydown

           jmp keyup

   keydown:
           cmp byte [key_shift], 0x00
           je keyboard_lowercase

   keyboard_uppercase:
           mov rbx, keylayoutupper
           jmp keyboard_processkey

   keyboard_lowercase:
           mov rbx, keylayoutlower

   keyboard_processkey:                    ; Convert the scan code
           add rbx, rax
           mov bl, [rbx]
           mov [key], bl
           jmp keyboard_done

   keyboard_escape:
           jmp keyboard_done

   keyup:
           jmp keyboard_done

   keyboard_shift:
           mov byte [key_shift], 0x01
           jmp keyboard_done

   keyboard_noshift:
           mov byte [key_shift], 0x00
           jmp keyboard_done


   keyboard_done:
           mov al, 0x20                    ; Acknowledge the IRQ
           out 0x20, al
           call os_smp_wakeup_all          ; A terrible hack

           popfq
           pop rax
           pop rbx

           iretq
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Cascade interrupt. IRQ 0x02, INT 0x22
   align 16
   cascade:
           push rax

           mov al, 0x20                    ; Acknowledge the IRQ
           out 0x20, al

           pop rax
           iretq
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Real-time clock interrupt. IRQ 0x08, INT 0x28
   ; Currently this IRQ runs 8 times per second (As defined in init_64.asm)
   ; The supervisor lives here
   align 16
   rtc:
           push rax
           pushfq

           add qword [os_ClockCounter], 1  ; 64-bit counter started at boot-up

           cmp qword [os_ClockCallback], 0 ; Is it valid?
           je rtc_end                      ; If not then bail out.

           ; We could do a 'call qword[os_ClockCallback]' here but that would not be ideal.
           ; A defective callback would hang the system if it never returned back to the
           ; interrupt handler. Instead, we modify the stack so that the callback is
           ; executed after the interrupt handler has finished. Once the callback has
           ; finished, the execution flow will pick up back in the program.
           push rdi
           push rsi
           push rcx
           mov rcx, clock_callback         ; RCX stores the callback function address
           mov rsi, rsp                    ; Copy the current stack pointer to RSI
           sub rsp, 8                      ; Subtract 8 since we add a 64-bit value to the stack
           mov rdi, rsp                    ; Copy the 'new' stack pointer to RDI
           movsq                           ; RCX
           movsq                           ; RSI
           movsq                           ; RDI
           movsq                           ; Flags
           movsq                           ; RAX
           lodsq                           ; RIP
           xchg rax, rcx
           stosq                           ; Callback address
           movsq                           ; CS
           movsq                           ; Flags
           lodsq                           ; RSP
           sub rax, 8
           stosq
           movsq                           ; SS
           mov [rax], rcx                  ; Original RIP
           pop rcx
           pop rsi
           pop rdi

   rtc_end:
           mov al, 0x0C                    ; Select RTC register C
           out 0x70, al                    ; Port 0x70 is the RTC index, and 0x71 is the RTC data
           in al, 0x71                     ; Read the value in register C

           mov al, 0x20                    ; Acknowledge the IRQ
           out 0xA0, al
           out 0x20, al

           popfq
           pop rax
           iretq
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Network interrupt.
   align 16
   network:
           push rdi
           push rsi
           push rcx
           push rax
           pushfq

           cld                             ; Clear direction flag
           call os_ethernet_ack_int        ; Call the driver function to acknowledge the interrupt internally

           bt ax, 0                        ; TX bit set (caused the IRQ?)
           jc network_tx                   ; If so then jump past RX section
           bt ax, 7                        ; RX bit set
           jnc network_end
   network_rx_as_well:
           mov byte [os_NetActivity_RX], 1
           mov rdi, os_EthernetBuffer      ; Raw packet is copied here
           push rdi
           add rdi, 2
           call os_ethernet_rx_from_interrupt
           pop rdi
           mov rax, rcx
           stosw                           ; Store the size of the packet
           cmp qword [os_NetworkCallback], 0       ; Is it valid?
           je network_end                  ; If not then bail out.

           ; We could do a 'call qword[os_NetworkCallback]' here but that would not be ideal.
           ; A defective callback would hang the system if it never returned back to the
           ; interrupt handler. Instead, we modify the stack so that the callback is
           ; executed after the interrupt handler has finished. Once the callback has
           ; finished, the execution flow will pick up back in the program.
           mov rcx, network_callback       ; RCX stores the callback function address
           mov rsi, rsp                    ; Copy the current stack pointer to RSI
           sub rsp, 8                      ; Subtract 8 since we add a 64-bit value to the stack
           mov rdi, rsp                    ; Copy the 'new' stack pointer to RDI
           movsq                           ; Flags
           movsq                           ; RAX
           movsq                           ; RCX
           movsq                           ; RSI
           movsq                           ; RDI
           lodsq                           ; RIP
           xchg rax, rcx
           stosq                           ; Callback address
           movsq                           ; CS
           movsq                           ; Flags
           lodsq                           ; RSP
           sub rax, 8
           stosq
           movsq                           ; SS
           mov [rax], rcx                  ; Original RIP
           jmp network_end

   network_tx:
           mov byte [os_NetActivity_TX], 1
           bt ax, 7
           jc network_rx_as_well

   network_end:
           mov al, 0x20                    ; Acknowledge the IRQ on the PIC(s)
           cmp byte [os_NetIRQ], 8
           jl network_ack_only_low         ; If the network IRQ is less than 8 then the other PIC does not need to be ack'ed
           out 0xA0, al
   network_ack_only_low:
           out 0x20, al

           popfq
           pop rax
           pop rcx
           pop rsi
           pop rdi
           iretq
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Network interrupt.
   align 16
   network_callback:
           pushfq
           call qword [os_NetworkCallback]
           popfq
           ret
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Network interrupt.
   align 16
   clock_callback:
           pushfq
           call qword [os_ClockCallback]
           popfq
           ret
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; A simple interrupt that just acknowledges an IPI. Useful for getting an AP past a 'hlt' in the code.
   align 16
   ap_wakeup:
           push rdi
           push rax

           mov rdi, [os_LocalAPICAddress]  ; Acknowledge the IPI
           add rdi, 0xB0
           xor eax, eax
           stosd

           pop rax
           pop rdi
           iretq                           ; Return from the IPI.
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; Resets a CPU to execute ap_clear
   align 16
   ap_reset:
           mov rax, ap_clear               ; Set RAX to the address of ap_clear
           mov [rsp], rax                  ; Overwrite the return address on the CPU's stack
           mov rdi, [os_LocalAPICAddress]  ; Acknowledge the IPI
           add rdi, 0xB0
           xor eax, eax
           stosd
           iretq                           ; Return from the IPI. CPU will execute code at ap_clear
   ; -----------------------------------------------------------------------------


   ; -----------------------------------------------------------------------------
   ; CPU Exception Gates
   align 16
   exception_gate_00:
           push rax
           mov al, 0x00
           jmp exception_gate_main

   align 16
   exception_gate_01:
           push rax
           mov al, 0x01
           jmp exception_gate_main

   align 16
   exception_gate_02:
           push rax
           mov al, 0x02
           jmp exception_gate_main

   align 16
   exception_gate_03:
           push rax
           mov al, 0x03
           jmp exception_gate_main

   align 16
   exception_gate_04:
           push rax
           mov al, 0x04
           jmp exception_gate_main

   align 16
   exception_gate_05:
           push rax
           mov al, 0x05
           jmp exception_gate_main

   align 16
   exception_gate_06:
           push rax
           mov al, 0x06
           jmp exception_gate_main

   align 16
   exception_gate_07:
           push rax
           mov al, 0x07
           jmp exception_gate_main

   align 16
   exception_gate_08:
           push rax
           mov al, 0x08
           jmp exception_gate_main

   align 16
   exception_gate_09:
           push rax
           mov al, 0x09
           jmp exception_gate_main

   align 16
   exception_gate_10:
           push rax
           mov al, 0x0A
           jmp exception_gate_main

   align 16
   exception_gate_11:
           push rax
           mov al, 0x0B
           jmp exception_gate_main

   align 16
   exception_gate_12:
           push rax
           mov al, 0x0C
           jmp exception_gate_main

   align 16
   exception_gate_13:
           push rax
           mov al, 0x0D
           jmp exception_gate_main

   align 16
   exception_gate_14:
           push rax
           mov al, 0x0E
           jmp exception_gate_main

   align 16
   exception_gate_15:
           push rax
           mov al, 0x0F
           jmp exception_gate_main

   align 16
   exception_gate_16:
           push rax
           mov al, 0x10
           jmp exception_gate_main

   align 16
   exception_gate_17:
           push rax
           mov al, 0x11
           jmp exception_gate_main

   align 16
   exception_gate_18:
           push rax
           mov al, 0x12
           jmp exception_gate_main

   align 16
   exception_gate_19:
           push rax
           mov al, 0x13
           jmp exception_gate_main

   align 16
   exception_gate_main:
           mov qword [os_NetworkCallback], 0       ; Reset the network callback
           push rbx
           push rdi
           push rsi
           push rax                        ; Save RAX since os_smp_get_id clobbers it
           call os_print_newline
           mov rsi, int_string00
           call os_output
           call os_smp_get_id              ; Get the local CPU ID and print it
           mov rdi, os_temp_string
           mov rsi, rdi
           call os_int_to_string
           call os_output
           mov rsi, int_string01
           call os_output
           mov rsi, exc_string00
           pop rax
           and rax, 0x00000000000000FF     ; Clear out everything in RAX except for AL
           push rax
           mov bl, 32                      ; Length of each message
           mul bl                          ; AX = AL x BL
           add rsi, rax                    ; Use the value in RAX as an offset to get to the right message
           pop rax
           mov bl, 0x0F
           call os_output
           call os_print_newline
           pop rsi
           pop rdi
           pop rbx
           pop rax
           call os_print_newline
           call os_debug_dump_reg
           mov rsi, rip_string
           call os_output
           push rax
           mov rax, [rsp+0x08]             ; RIP of caller
           call os_debug_dump_rax
           pop rax
           call os_print_newline
           push rax
           push rcx
           push rsi
           mov rsi, stack_string
           call os_output
           mov rsi, rsp
           add rsi, 0x18
           mov rcx, 4
   next_stack:
           lodsq
           call os_debug_dump_rax
           mov al, ' '
           call os_output_char
           loop next_stack
           call os_print_newline
           pop rsi
           pop rcx
           pop rax
   ;       jmp $                           ; For debugging
           call init_memory_map
           jmp ap_clear                    ; jump to AP clear code


   int_string00 db 'BareMetal OS - CPU ', 0
   int_string01 db ' - Interrupt ', 0
   ; Strings for the error messages
   exc_string db 'Unknown Fatal Exception!', 0
   exc_string00 db '00 - Divide Error (#DE)        ', 0
   exc_string01 db '01 - Debug (#DB)               ', 0
   exc_string02 db '02 - NMI Interrupt             ', 0
   exc_string03 db '03 - Breakpoint (#BP)          ', 0
   exc_string04 db '04 - Overflow (#OF)            ', 0
   exc_string05 db '05 - BOUND Range Exceeded (#BR)', 0
   exc_string06 db '06 - Invalid Opcode (#UD)      ', 0
   exc_string07 db '07 - Device Not Available (#NM)', 0
   exc_string08 db '08 - Double Fault (#DF)        ', 0
   exc_string09 db '09 - Coprocessor Segment Over  ', 0    ; No longer generated on new CPU's
   exc_string10 db '10 - Invalid TSS (#TS)         ', 0
   exc_string11 db '11 - Segment Not Present (#NP) ', 0
   exc_string12 db '12 - Stack Fault (#SS)         ', 0
   exc_string13 db '13 - General Protection (#GP)  ', 0
   exc_string14 db '14 - Page-Fault (#PF)          ', 0
   exc_string15 db '15 - Undefined                 ', 0
   exc_string16 db '16 - x87 FPU Error (#MF)       ', 0
   exc_string17 db '17 - Alignment Check (#AC)     ', 0
   exc_string18 db '18 - Machine-Check (#MC)       ', 0
   exc_string19 db '19 - SIMD Floating-Point (#XM) ', 0
   rip_string db ' IP:', 0
   stack_string db ' ST:', 0
   #+end_src
** cli
   #+begin_src fasm :tangle no
   os_command_line:                                   	       
	   mov rsi, prompt                 ; Prompt for input
	   mov ebx, 0x00FF0000             ; Red prompt in graphics mode
	   mov [os_Font_Color], ebx
	   call os_output
	   mov ebx, 0x00FFFFFF             ; White text in graphics mode
	   mov [os_Font_Color], ebx
   
	   mov rdi, cli_temp_string
	   mov rcx, 250                    ; Limit the input to 250 characters
	   call os_input
	   call os_print_newline           ; The user hit enter so print a new line
	   jrcxz os_command_line           ; os_input_string stores the number of characters received in RCX
   
	   mov rsi, rdi
	   call os_string_parse            ; Remove extra spaces
	   jrcxz os_command_line           ; os_string_parse stores the number of words in RCX
	   mov byte [app_argc], cl         ; Store the number of words in the string
   
	   ; Break the contents of cli_temp_string into individual strings
	   mov al, 0x20
	   mov bl, 0x00
	   call os_string_change_char
   
	   mov rdi, cls_string             ; 'CLS' entered?
	   call os_string_compare
	   jc near clear_screen
   
	   mov rdi, dir_string             ; 'DIR' entered?
	   call os_string_compare
	   jc near dir
   
	   mov rdi, l_string               ; 'l' entered?
	   call os_string_compare
	   jc near dir
   
	   mov rdi, ver_string             ; 'VER' entered?
	   call os_string_compare
	   jc near print_ver
   
	   mov rdi, exit_string            ; 'EXIT' entered?
	   call os_string_compare
	   jc near exit
   
	   mov rdi, help_string            ; 'HELP' entered?
	   call os_string_compare
	   jc near print_help
   
	   mov rdi, debug_string           ; 'DEBUG' entered?
	   call os_string_compare
	   jc near debug
   
   
	   mov rdi, testzone_string        ; 'TESTZONE' entered?
	   call os_string_compare
	   jc near testzone
   
	   ;; At this point it is not one of the built-in CLI functions. Prepare to check the file system.
	   call os_file_open
	   cmp rax, 0
	   je fail
	   call os_file_query              ; Returns the file size in RCX
	   mov rdi, programlocation
	   call os_file_read
	   call os_file_close
   
	   call programlocation            ; Call the program just loaded
	   jmp os_command_line             ; Jump back to the CLI on program completion
   
   
   fail:                                   ; We didn't get a valid command or program name
	   mov rsi, not_found_msg
	   call os_output
	   jmp os_command_line
   
   print_help:
	   mov rsi, help_text
	   call os_output
	   jmp os_command_line
   
   clear_screen:
	   call os_screen_clear
   ;       mov ax, 0x0018
   ;       call os_move_cursor
	   jmp os_command_line
   
   print_ver:
	   mov rsi, version_msg
	   call os_output
	   jmp os_command_line
   
   dir:
	   mov rdi, cli_temp_string
	   mov rsi, rdi
	   call os_bmfs_file_list
	   call os_output
	   jmp os_command_line
   
   
   testzone:
	   xchg bx, bx                     ; Bochs Magic Breakpoint
   
	   mov qword [os_ClockCallback], 1
   ;       ud2
   
   ;       xor rax, rax
   ;       xor rbx, rcx
   ;       xor rcx, rcx
   ;       xor rdx, rdx
   ;       div rax
   
	   jmp os_command_line
   
   debug:
	   mov rdx, 1                      ; argc
	   call os_system_config
	   cmp al, 1
	   je debug_dump_reg               ; If it is only one then do a register dump
	   mov rcx, 16
	   cmp al, 3                       ; Did we get at least 3?
	   jl noamount                     ; If not no amount was specified
	   mov al, 2
	   call os_get_argv                ; Get the amount of bytes to display
	   mov rsi, rax
	   call os_string_to_int           ; Convert to an integer
	   mov rcx, rax
   noamount:
	   mov al, 1
	   call os_get_argv                ; Get the starting memory address
	   mov rsi, rax
	   call os_hex_string_to_int
	   mov rsi, rax
   debug_default:
	   call os_debug_dump_mem
	   call os_print_newline
   
	   jmp os_command_line
   
   debug_dump_reg:
	   call os_debug_dump_reg
	   jmp os_command_line
   
   exit:
	   call os_screen_clear
	   ret
   
   ; Strings
	   help_text               db 'Built-in commands: cls, debug, l, dir, help, ver', 13, 0
	   not_found_msg           db 'Command or program not found', 13, 0
	   version_msg             db 'BareMetal OS :: Hacking Version', 13, 0
   
	   cls_string              db 'cls', 0
	   dir_string              db 'dir', 0
	   l_string                db 'l', 0
	   ver_string              db 'ver', 0
	   exit_string             db 'exit', 0
	   help_string             db 'help', 0
	   debug_string            db 'debug', 0
	   testzone_string         db 'testzone', 0
   
	   appextension:           db '.app', 0
	   prompt:                 db '> ', 0
   
   ; -----------------------------------------------------------------------------
   ; os_string_find_char -- Find first location of character in a string
   ;  IN:  RSI = string location
   ;       AL  = character to find
   ; OUT:  RAX = location in string, or 0 if char not present
   ;       All other registers preserved
   os_string_find_char:
	   push rsi
	   push rcx
   
	   mov rcx, 1              ; Counter -- start at first char
   os_string_find_char_more:
	   cmp byte [rsi], al
	   je os_string_find_char_done
	   cmp byte [rsi], 0
	   je os_string_find_char_not_found
	   inc rsi
	   inc rcx
	   jmp os_string_find_char_more
   
   os_string_find_char_done:
	   mov rax, rcx
   
	   pop rcx
	   pop rsi
	   ret
   
   os_string_find_char_not_found:
	   pop rcx
	   pop rsi
	   xor eax, eax    ; not found, set RAX to 0
	   ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_string_change_char -- Change all instances of a character in a string
   ;  IN:  RSI = string location
   ;       AL  = character to replace
   ;       BL  = replacement character
   ; OUT:  All registers preserved
   os_string_change_char:
	   push rsi
	   push rcx
	   push rbx
	   push rax
   
	   mov cl, al
   os_string_change_char_loop:
	   mov byte al, [rsi]
	   cmp al, 0
	   je os_string_change_char_done
	   cmp al, cl
	   jne os_string_change_char_no_change
	   mov byte [rsi], bl
   
   os_string_change_char_no_change:
	   inc rsi
	   jmp os_string_change_char_loop
   
   os_string_change_char_done:
	   pop rax
	   pop rbx
	   pop rcx
	   pop rsi
	   ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_string_chomp -- Strip leading and trailing spaces from a string
   ;  IN:  RSI = string location
   ; OUT:  All registers preserved
   os_string_chomp:
	   push rsi
	   push rdi
	   push rcx
	   push rax
   
	   call os_string_length           ; Quick check to see if there are any characters in the string
	   jrcxz os_string_chomp_done      ; No need to work on it if there is no data
   
	   mov rdi, rsi                    ; RDI will point to the start of the string...
	   push rdi                        ; ...while RSI will point to the "actual" start (without the spaces)
	   add rdi, rcx                    ; os_string_length stored the length in RCX
   
   os_string_chomp_findend:                ; we start at the end of the string and move backwards until we don't find a space
	   dec rdi
	   cmp rsi, rdi                    ; Check to make sure we are not reading backward past the string start
	   jg os_string_chomp_fail         ; If so then fail (string only contained spaces)
	   cmp byte [rdi], ' '
	   je os_string_chomp_findend
   
	   inc rdi                         ; we found the real end of the string so null terminate it
	   mov byte [rdi], 0x00
	   pop rdi
   
   os_string_chomp_start_count:            ; read through string until we find a non-space character
	   cmp byte [rsi], ' '
	   jne os_string_chomp_copy
	   inc rsi
	   jmp os_string_chomp_start_count
   
   os_string_chomp_fail:                   ; In this situation the string is all spaces
	   pop rdi                         ; We are about to bail out so make sure the stack is sane
	   mov al, 0x00
	   stosb
	   jmp os_string_chomp_done
   
   ; At this point RSI points to the actual start of the string (minus the leading spaces, if any)
   ; And RDI point to the start of the string
   
   os_string_chomp_copy:           ; Copy a byte from RSI to RDI one byte at a time until we find a NULL
	   lodsb
	   stosb
	   cmp al, 0x00
	   jne os_string_chomp_copy
   
   os_string_chomp_done:
	   pop rax
	   pop rcx
	   pop rdi
	   pop rsi
	   ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_string_parse -- Parse a string into individual words
   ;  IN:  RSI = Address of string
   ; OUT:  RCX = word count
   ; Note: This function will remove "extra" white-space in the source string
   ;       "This is  a test. " will update to "This is a test."
   os_string_parse:
	   push rsi
	   push rdi
	   push rax
   
	   xor ecx, ecx                    ; RCX is our word counter
	   mov rdi, rsi
   
	   call os_string_chomp            ; Remove leading and trailing spaces
   
	   cmp byte [rsi], 0x00            ; Check the first byte
	   je os_string_parse_done         ; If it is a null then bail out
	   inc rcx                         ; At this point we know we have at least one word
   
   os_string_parse_next_char:
	   lodsb
	   stosb
	   cmp al, 0x00                    ; Check if we are at the end
	   je os_string_parse_done         ; If so then bail out
	   cmp al, ' '                     ; Is it a space?
	   je os_string_parse_found_a_space
	   jmp os_string_parse_next_char   ; If not then grab the next char
   
   os_string_parse_found_a_space:
	   lodsb                           ; We found a space.. grab the next char
	   cmp al, ' '                     ; Is it a space as well?
	   jne os_string_parse_no_more_spaces
	   jmp os_string_parse_found_a_space
   
   os_string_parse_no_more_spaces:
	   dec rsi                         ; Decrement so the next lodsb will read in the non-space
	   inc rcx
	   jmp os_string_parse_next_char
   
   os_string_parse_done:
	   pop rax
	   pop rdi
	   pop rsi
	   ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_string_append -- Append a string to an existing string
   ;  IN:  RSI = String to be appended
   ;       RDI = Destination string
   ; OUT:  All registers preserved
   ; Note: It is up to the programmer to ensure that there is sufficient space in the destination
   os_string_append:
	   push rsi
	   push rdi
	   push rcx
   
	   xchg rsi, rdi
	   call os_string_length
	   xchg rsi, rdi
	   add rdi, rcx
	   call os_string_copy
   
	   pop rcx
	   pop rdi
	   pop rsi
	   ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_hex_string_to_int -- Convert up to 8 hexascii to bin
   ;  IN:  RSI = Location of hex asciiz string
   ; OUT:  RAX = binary value of hex string
   ;       All other registers preserved
   os_hex_string_to_int:
	   push rsi
	   push rcx
	   push rbx
   
	   cld
	   xor ebx, ebx
   os_hex_string_to_int_loop:
	   lodsb
	   mov cl, 4
	   cmp al, 'a'
	   jb os_hex_string_to_int_ok
	   sub al, 0x20                            ; convert to upper case if alpha
   os_hex_string_to_int_ok:
	   sub al, '0'                             ; check if legal
	   jc os_hex_string_to_int_exit            ; jump if out of range
	   cmp al, 9
	   jle os_hex_string_to_int_got            ; jump if number is 0-9
	   sub al, 7                               ; convert to number from A-F or 10-15
	   cmp al, 15                              ; check if legal
	   ja os_hex_string_to_int_exit            ; jump if illegal hex char
   os_hex_string_to_int_got:
	   shl rbx, cl
	   or bl, al
	   jmp os_hex_string_to_int_loop
   os_hex_string_to_int_exit:
	   mov rax, rbx                            ; integer value stored in RBX, move to RAX
   
	   pop rbx
	   pop rcx
	   pop rsi
	   ret
   ; -----------------------------------------------------------------------------
   
   
   ; -----------------------------------------------------------------------------
   ; os_bmfs_file_list -- Generate a list of files on disk
   ; IN:   RDI = location to store list
   ; OUT:  RDI = pointer to end of list
   os_bmfs_file_list:
	   push rdi
	   push rsi
	   push rcx
	   push rbx
	   push rax
   
	   mov rsi, Disk_Size_MSG
	   call os_string_length
	   call os_string_copy
	   add rdi, rcx
   
	   mov eax, [hd1_size]
	   call os_int_to_string
	   dec rdi
	   mov al, 0
   
	   mov rsi, MiB_MSG
	   call os_string_length
	   call os_string_copy
	   add rdi, rcx
   
	   mov rsi, List_MSG
	   call os_string_length
	   call os_string_copy
	   add rdi, rcx
   
	   mov rsi, bmfs_directory
	   mov rbx, rsi
   
   os_bmfs_list_next:
	   cmp byte [rbx], 0x00
	   je os_bmfs_list_done
   
	   cmp byte [rbx], 0x01
	   jle os_bmfs_list_skip
   
	   mov rsi, rbx
	   call os_string_length
	   call os_string_copy
	   add rdi, rcx
   
	   sub rcx, 34
	   neg rcx
	   mov al, ' '
	   rep stosb
   
	   mov rax, [rbx + BMFS_DirEnt.size]
	   call os_int_to_string
	   dec rdi
   
	   sub rcx, 20             ; 20 ?
	   neg rcx
	   mov al, ' '
	   rep stosb
   
	   mov rax, [rbx + BMFS_DirEnt.reserved]
	   add rax, rax
	   call os_int_to_string
	   dec rdi
	   mov al, 13
	   stosb
   
   os_bmfs_list_skip:
	   add rbx, 64
	   cmp rbx, bmfs_directory + 0x1000
	   jne os_bmfs_list_next
   
   os_bmfs_list_done:
	   mov al, 0x00
	   stosb
   
	   pop rax
	   pop rbx
	   pop rcx
	   pop rsi
	   pop rdi
   
	   ret
   
   Disk_Size_MSG: db 'Disk Size: ', 0
   MiB_MSG: db ' MiB', 13, 0
   List_MSG: db 'Name                            | Size (Byte)        | Reserved (MiB)', 13, \
	       	'==========================================================================', 13, 0
   #+end_src
** set the size & the magic number
   #+begin_src fasm :tangle no
   times (SizeOfKernel * 1024) - ($-$$) - 4 db 0
   dd MagicNumberOfKernel    ;; 4 bytes 
   #+end_src
* ==================================================
