#+TITLE:  basic common-lisp lib
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* TODO
** argument type check for the following functions
   * dup#string
   * edit#line-list
** dup
   * uses make-string to re-define dup#string
   * define dup for other datatype
* ===================================
* note
** respect
   * you should respect the function
     * when a calculation is done
       it is not respectful
       to not return all of the hard work the function had done
     * so I return multi-value
       to capture almost the whole calculation
   * function should return its audience
     * function should be defined in the way that
       1. the structure of the data applied to the function
          is as regular as possible
          [this will make the function easy to write and easy to read]
       2. when ill-structured data is applied to the function
          the function cry out loud that it is an error
       3. well defined predicate is created
          to test if the data is regular or not
       4. when call the function
          the caller should use the predicate
          to make sure that
          the structure of data is regular
          [this will make the intention of code clear]
** naming convention
   * to use "#" to introduce symbol prefix and postfix
   * a "#" denotes an word such as
     "of" "'s" "is" "are" "for" "to" "from" and so on
     in Chinese
     this kind of words are called unfilled-word
     i.e. word which is not filled by a precise meaning
     the meaning of it should be infered from context
   * when wish to stress that a symbol is used as a bounded-variable
     use "." as its prefix
* -----------------------------------
* (in-package :cicada-vm)
** basic.lisp
   #+begin_src lisp :tangle basic.lisp
   (in-package :cicada-vm)
   #+end_src
** basic.test.lisp
   #+begin_src lisp :tangle basic.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* bool
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun nil? (x)
     (null x))

   (defun ture? (x)
     (eq t x))

   (defun false? (x)
     (eq nil x))
   #+end_src
** equal
   #+begin_src lisp :tangle basic.lisp
   (defun eq? (x y)
     (eq x y))

   (defun equal? (x y)
     (equal x y))
   #+end_src
* fixmun
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun zero? (x)
     (and (integerp x)
          (zerop x)))

   (defun integer? (x)
     (integerp x))

   (defun natural-number? (x)
     (and (integerp x)
          (<= 0 x)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest natural-number?
       (basic)
     (ensure
         (list (natural-number? 0)
               (natural-number? 1)
               (natural-number? -1)
               (natural-number? 1.1))
         ==>
         (list t
               t
               nil
               nil)))
   #+end_src
** add1 & sub1
   #+begin_src lisp :tangle basic.lisp
   (defun add1 (x)
     (+ x 1))

   (defun sub1 (x)
     (- x 1))
   #+end_src
** shift#[left|right]
   #+begin_src lisp :tangle basic.lisp
   (defun shift#left (&key
                        (step 1)
                        number)
     (* number
        (expt 2 step)))


   (defun shift#right (&key
                         (step 1)
                         number)
     (/ number
        (expt 2 step)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest shift#left
       (basic)
     (ensure
         (list (shift#left :number 10)
               (shift#left :step 2
                           :number 10))
         ==>
         (list 20
               40)))

   (deftest shift#right
       (basic)
     (ensure
         (list (shift#right :number 64)
               (shift#right :step 2
                            :number 64))
         ==>
         (list 32
               16)))
   #+end_src
* bit
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#bits (&key
                        bits
                        (size 1)
                        index)
     (ldb (byte size index) bits))

   (defun save#bits (&key
                       value
                       bits
                       (size 1)
                       index)
     (setf (ldb (byte size index) bits) value)
     (values bits
             value))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#bits
       (basic)
     (ensure
         (fetch#bits :bits #b0010
                     :size 1
                     :index 1)
         ==>
         1))
   #+end_src
* byte
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#bytes (&key
                         bytes
                         (size 1)
                         index)
     (fetch#bits :bits bytes
                 :size (* 8 size)
                 :index (* 8 index)))

   (defun save#bytes (&key
                        value
                        bytes
                        (size 1)
                        index)
     (save#bits :value value
                :bits bytes
                :size (* 8 size)
                :index (* 8 index)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#bytes
       (basic)
     (ensure
         (list (fetch#bytes :bytes #xff  :index 0)
               (fetch#bytes :bytes #xff  :index 1)
               (fetch#bytes :bytes #x100 :index 0)
               (fetch#bytes :bytes #x100 :index 1))
         ==>
         `(255
           0
           0
           1)))
   #+end_src
* array
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun array? (x)
     (arrayp x))
   #+end_src
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#array (&key
                         array
                         index-vector)
     (let ((index-list (vector->list index-vector)))
       (apply (function aref)
              array index-list)))



   (defun save#array (&key
                        value
                        array
                        index-vector)
     (let ((index-list (vector->list index-vector)))
       (setf
        (apply #'aref array index-list) value)
       (values array
               value)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#array
       (basic)
     (ensure
         (fetch#array
          :array (make-array '(1 1 1) :initial-element 666)
          :index-vector '#(0 0 0))
         ==>
         666))

   (deftest save#array
       (basic)
     (ensure
         (fetch#array
          :array (save#array
                  :value 258
                  :array (make-array '(1 1 1) :initial-element 666)
                  :index-vector '#(0 0 0))
          :index-vector '#(0 0 0))
         ==>
         258))
          #+end_src
* vector
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun vector? (x)
     (vectorp x))
   #+end_src
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#vector (&key
                          vector
                          index)
     (fetch#array :array vector
                  :index-vector `#(,index)))



   (defun save#vector (&key
                         value
                         vector
                         index)
     (save#array :value value
                 :array vector
                 :index-vector `#(,index)))



   (defun copy-vector (vector)
     (if (not (vector? vector))
         (error "the argument of copy-vector must be a vector")
         (copy-seq vector)))
   #+end_src
** list->vector & vector->list
   #+begin_src lisp :tangle basic.lisp
   (defun list->vector (list)
     (if (not (list? list))
         (error "the argument of (list->vector) must be a list")
         (coerce list 'vector)))


   (defun vector->list (vector)
     (if (not (vector? vector))
         (error "the argument of (vector->list) must be a vector")
         (coerce vector 'list)))
   #+end_src
* byte-array
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#byte-array
       (&key
          byte-array
          (size 1)
          index-vector
          (endian 'little))

     (cond
       ((not (<= (+ (fetch#vector :vector index-vector
                                  :index (sub1 (array-rank byte-array)))
                    size)
                 (array-dimension byte-array
                                  (sub1 (array-rank byte-array)))))
        (error "the size of the value you wish to fetch is out of the index of the byte-array"))

       ((equal? endian 'little)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#little-endian#fetch#byte-array
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       ((equal? endian 'big)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#big-endian#fetch#byte-array
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       (:else
        (error "the argument :endian of (fetch#byte-array) must be 'little or 'big"))
       ))


   (defun help#little-endian#fetch#byte-array
       (&key
          byte-array
          size
          index-vector
          (counter 0)
          (sum 0))
     (cond
       ((not (< counter
                size))
        sum)

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               (value-for-shift (fetch#array
                                 :array byte-array
                                 :index-vector index-vector))
               (value-for-sum (shift#left
                               :step (* 8 counter)
                               :number value-for-shift)))
          ;; update index-vector
          (save#vector :value (add1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#little-endian#fetch#byte-array
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter)
           :sum (+ sum value-for-sum))))
       ))




   ;; (add1) change to (sub1)
   ;; new index-vector-for-fetch
   (defun help#big-endian#fetch#byte-array
       (&key
          byte-array
          size
          index-vector
          (counter 0)
          (sum 0))
     (cond
       ((not (< counter
                size))
        sum)

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               ;; new index-vector-for-fetch
               (index-vector-for-fetch (save#vector
                                        :value (+ last-index
                                                  (sub1 size))
                                        :vector (copy-vector index-vector)
                                        :index (sub1 (array-rank byte-array))))
               (value-for-shift (fetch#array
                                 :array byte-array
                                 :index-vector index-vector-for-fetch))
               (value-for-sum (shift#left
                               :step (* 8 counter)
                               :number value-for-shift)))
          ;; update index-vector
          ;; (add1) change to (sub1)
          (save#vector :value (sub1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#big-endian#fetch#byte-array
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter)
           :sum (+ sum value-for-sum))))
       ))





   (defun save#byte-array
       (&key
          value
          byte-array
          (size 1)
          index-vector
          (endian 'little))
     (cond
       ((not (<= (+ (fetch#vector :vector index-vector
                                  :index (sub1 (array-rank byte-array)))
                    size)
                 (array-dimension byte-array
                                  (sub1 (array-rank byte-array)))))
        (error "the size of the value you wish to save is out of the index of the byte-array"))

       ((equal? endian 'little)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#little-endian#save#byte-array
         :value value
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       ((equal? endian 'big)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#big-endian#save#byte-array
         :value value
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       (:else
        (error "the argument :endian of (save#byte-array) must be 'little or 'big"))
       ))


   (defun help#little-endian#save#byte-array
       (&key
          value
          byte-array
          size
          index-vector
          (counter 0))
     (cond
       ((not (< counter
                size))
        (values byte-array
                value))

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array)))))
          ;; save to byte-array
          (save#array :value (fetch#bytes :bytes value
                                          :size 1
                                          :index counter)
                      :array byte-array
                      :index-vector index-vector)
          ;; update index-vector
          (save#vector :value (add1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#little-endian#save#byte-array
           :value value
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter))))
       ))





   ;; (add1) change to (sub1)
   ;; new index-vector-for-save
   (defun help#big-endian#save#byte-array
       (&key
          value
          byte-array
          size
          index-vector
          (counter 0))
     (cond
       ((not (< counter
                size))
        (values byte-array
                value))

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               ;; new index-vector-for-save
               (index-vector-for-save (save#vector
                                       :value (+ last-index
                                                 (sub1 size))
                                       :vector (copy-vector index-vector)
                                       :index (sub1 (array-rank byte-array)))))
          ;; save to byte-array
          (save#array :value (fetch#bytes :bytes value
                                          :size 1
                                          :index counter)
                      :array byte-array
                      :index-vector index-vector-for-save)
          ;; update index-vector
          ;; (add1) change to (sub1)
          (save#vector :value (sub1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#big-endian#save#byte-array
           :value value
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter))))
       ))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#byte-array
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector #(0)))
         ==>
         257))

   (deftest fetch#byte-array--big-endian
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector #(0)
                             :endian 'big))
         ==>
         257))

   (deftest save#byte-array
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (save#byte-array :value 1234
                            :byte-array k
                            :size 2
                            :index-vector '#(0))
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector '#(0)))
         ==>
         1234))

   (deftest save#byte-array--big-endian
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (save#byte-array :value 1234
                            :byte-array k
                            :size 2
                            :index-vector #(0)
                            :endian 'big)
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector #(0)
                             :endian 'big))
         ==>
         1234))
   #+end_src
* byte-vector
** fetch & save & copy
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#byte-vector (&key
                               byte-vector
                               (size 1)
                               index
                               (endian 'little))
     (fetch#byte-array :byte-array byte-vector
                       :size size
                       :index-vector `#(,index)
                       :endian endian))



   (defun save#byte-vector (&key
                              value
                              byte-vector
                              (size 1)
                              index
                              (endian 'little))
     (save#byte-array :value value
                      :byte-array byte-vector
                      :size size
                      :index-vector `#(,index)
                      :endian endian))


   (defun copy#byte-vector (&key
                              from
                              from-index
                              to
                              to-index
                              size
                              (counter 0))
     (cond
       ((not (< counter
                size))
        (values to
                from
                counter))

       (:else
        (save#byte-vector
         :value (fetch#byte-vector
                 :byte-vector from
                 :size 1
                 :index from-index)
         :byte-vector to
         :size 1
         :index to-index)
        (copy#byte-vector :from from
                          :from-index (add1 from-index)
                          :to to
                          :to-index (add1 to-index)
                          :size size
                          :counter (add1 counter)))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#byte-vector
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (fetch#byte-vector :byte-vector k
                              :size 2
                              :index 0))
         ==>
         257))

   (deftest save#byte-vector
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (save#byte-vector :value 1234
                             :byte-vector k
                             :size 2
                             :index 0)
           (fetch#byte-vector :byte-vector k
                              :size 2
                              :index 0))
         ==>
         1234))
   #+end_src
* stream
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun stream? (x)
     (streamp x))
   #+end_src
** read#char & read#line
   #+begin_src lisp :tangle basic.lisp
   (defun read#char (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-char from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))

   (defun read#line (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-line from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))

   #+end_src
** cat
   #+begin_src lisp :tangle basic.lisp
   ;; (cat (:to *standard-output*)
   ;;   ("~A" 123)
   ;;   ("~A" 456))
   ;; ==>
   ;; (concatenate
   ;;  'string
   ;;  (format *standard-output* "~A" 123)
   ;;  (format *standard-output* "~A" 456))

   ;; (defmacro cat
   ;;     ((&key (to nil))
   ;;      &body form#list-of-list)
   ;;   (let* ((form#list-of-list#2
   ;;           (mapcar (lambda (list) (append `(format ,to) list))
   ;;                   form#list-of-list))
   ;;          (form#final (append '(concatenate (quote string))
   ;;                              form#list-of-list#2)))
   ;;     form#final))



   (defmacro cat
       ((&key (to nil)
              (trim '())
              prefix
              postfix)
        &body form#list-of-list)
     (let* ((form#list-of-list#2
             (apply (function append)
                    (mapcar (lambda (list)
                              (list prefix
                                    (list 'string-trim trim
                                          (append '(format nil) list))
                                    postfix))
                            form#list-of-list)))
            (form#final (append '(concatenate (quote string))
                                form#list-of-list#2)))
       `(let ((string-for-return ,form#final))
          (format ,to "~A" string-for-return)
          string-for-return)))

   ;; (cat (:to *standard-output*
   ;;           :trim '(#\Space)
   ;;           :prefix "* "
   ;;           :postfix (cat () ("~%")))
   ;;   ("~A" "      123   ")
   ;;   ("~A" "   456   "))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest cat
       (basic)
     (ensure
         (cat ()
           ("~A" 123)
           ("~A" 456))
         ==>
         "123456"))

   ;; (cat ()
   ;;   ("~A" 123)
   ;;   ("~A" 456))

   ;; (cat (:to *standard-output*)
   ;;   ("~%")
   ;;   ("~A~%" 123)
   ;;   ("~A~%" 456))

   ;; (let ((x 123))
   ;;   (cat (:to *standard-output*)
   ;;     ("~A~%" x)))
   #+end_src
** newline
   #+begin_src lisp :tangle basic.lisp
   (defmacro newline ()
     (cat () ("~%")))

   ;; (newline)

   ;; (cat ()
   ;;   ((newline)))

   ;; (defun newline (&key (many 1))
   ;;   (cond ((= 0 many) :nothing)
   ;;         ((= 1 many) (format t "~%"))
   ;;         ((< 1 many) (format t "~%")
   ;;          (newline :many (sub1 many)))
   ;;         (:else :nothing)))
   #+end_src
* reader
  #+begin_src lisp :tangle basic.lisp
  (defun bind-char-to-reader (char reader)
    (set-macro-character char reader))

  (defun find-reader-from-char (char)
    (get-macro-character char))
  #+end_src
* char
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun char? (x)
     (characterp x))

   (defun char#space? (char)
     (if (not (char? char))
         (error "the argument of (char#space?) must be a char")
         (let ((code (char->code char)))
           (cond ((= code 32) t)
                 ((= code 10) t)
                 (:else nil)))))
   #+end_src
** char->code & code->char
   #+begin_src lisp :tangle basic.lisp
   (defun char->code (char)
     (char-code char))

   (defun code->char (code)
     (code-char code))
   #+end_src
* symbol
** string->symbol & symbol->string
   #+begin_src lisp :tangle basic.lisp
   (defun symbol->string (symbol)
     (symbol-name symbol))

   (defun string->symbol (string)
     (intern string))
   #+end_src
* string
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun string? (x)
     (stringp x))

   (defun string#empty? (string)
     (equal? string ""))

   (defun string#space? (string)
     (if (not (string? string))
         (error "the argument of (string#space?) must be a string")
         (not (position-if
               (lambda (char) (not (char#space? char)))
               string))))
   #+end_src
** dup#string
   #+begin_src lisp :tangle basic.lisp
   (defun dup#string (&key
                        (time 1)
                        string)
     (cond ((= 1 time)
            string)
           (:else
            (concatenate
             'string
             string
             (dup#string :time (sub1 time)
                         :string string)))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest char#space?
       (basic)
     (ensure
         (list (char#space? #\newline)
               (char#space? #\space))
         ==>
         (list t
               t)))

   (deftest string#space?
       (basic)
     (ensure
         (list (string#space? " 123 ")
               (string#space? "  ")
               (string#space? ""))
         ==>
         (list nil
               t
               t)))
   #+end_src
** string->[head|tail|list]#word
   #+begin_src lisp :tangle basic.lisp
   ;; interface:
   ;; (multiple-value-bind
   ;;       (head#word
   ;;        index-end-or-nil
   ;;        index-start
   ;;        string)
   ;;     (string->head#word string)
   ;;   ><><><)

   (defun string->head#word (string)
     (let* ((index-start
             (position-if (lambda (char) (not (char#space? char)))
                          string))
            (index-end-or-nil
             (position-if (lambda (char) (char#space? char))
                          string
                          :start index-start)))
       (values (subseq string
                       index-start
                       index-end-or-nil)
               index-end-or-nil
               index-start
               string)))


   (defun string->tail#word (string)
     (multiple-value-bind
           (head#word
            index-end-or-nil
            index-start
            string)
         (string->head#word string)
       (if (nil? index-end-or-nil)
           nil
           (subseq string index-end-or-nil))))


   (defun string->list#word (string &key (base-list '()))
     (cond
       ((nil? string) base-list)
       ((string#space? string) base-list)
       (:else
        (cons (string->head#word string)
              (string->list#word (string->tail#word string))))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest string->head#word
       (basic)
     (and (ensure
              (list (multiple-value-list (string->head#word " kkk took my baby away! "))
                    (multiple-value-list (string->head#word "k"))
                    (multiple-value-list (string->head#word " k"))
                    (multiple-value-list (string->head#word "k ")))
              ==>
              (list `("kkk" 4 1 " kkk took my baby away! ")
                    `("k" nil 0 "k")
                    `("k" nil 1 " k")
                    `("k" 1 0 "k ")))

          ;; the argument applied to string->head#word
          ;; must not be space-string
          ;; one should use string#space? to ensure this

          ;; just do not handle the error
          ;; let the debuger do its job
          (ensure
              (string->head#word " ")
              signals
              type-error)
          ))


   (deftest string->tail#word
       (basic)
     (ensure
         (list (string->tail#word " kkk took my baby away! ")
               (string->tail#word "just-kkk"))
         ==>
         (list " took my baby away! "
               nil)))


   (deftest string->list#word
       (basic)
     (ensure
         (list (string->list#word " kkk took my baby away! ")
               (string->list#word " kkk")
               (string->list#word "kkk ")
               (string->list#word " ")
               (string->list#word ""))
         ==>
         (list `("kkk" "took" "my" "baby" "away!")
               `("kkk")
               `("kkk")
               `nil
               `nil)))
   #+end_src
** string->[head|tail|list]#line
   #+begin_src lisp :tangle basic.lisp
   ;; interface:
   ;; (multiple-value-bind
   ;;       (head#line
   ;;        index-end-or-nil
   ;;        string)
   ;;     (string->head#line string)
   ;;   ><><><)

   (defun string->head#line (string)
     (let* ((index-end-or-nil
             (position-if (lambda (char) (equal? #\Newline char))
                          string)))
       (values (subseq string
                       0
                       index-end-or-nil)
               index-end-or-nil
               string)))


   (defun string->tail#line (string)
     (multiple-value-bind
           (head#line
            index-end-or-nil
            string)
         (string->head#line string)
       (if (nil? index-end-or-nil)
           nil
           (subseq string (add1 index-end-or-nil)))))


   (defun string->list#line (string &key (base-list '()))
     (cond
       ((nil? string) base-list)
       (:else
        (cons (string->head#line string)
              (string->list#line (string->tail#line string))))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest string->head#line
       (basic)
     (ensure
         (list (string->head#line "123")
               (string->head#line (format nil "~%123"))
               (string->head#line (format nil "123~%")))
         ==>
         `("123"
           ""
           "123")))


   (deftest string->tail#line
       (basic)
     (ensure
         (list (string->tail#line "123")
               (string->tail#line (format nil "~%123"))
               (string->tail#line (format nil "123~%")))
         ==>
         `(nil
           "123"
           "")))


   (deftest string->list#line
       (basic)
     (ensure
         (string->list#line
          (cat (:postfix (cat () ("~%")))
            ("kkk")
            ("took")
            ("")
            ("my baby")
            ("")
            ("away!")
            ("")))
         ==>
         `("kkk"
           "took"
           ""
           "my baby"
           ""
           "away!"
           ""
           "")))
   #+end_src
** string->[head|tail|list]#char
   #+begin_src lisp :tangle basic.lisp
   ;; interface:
   ;; (multiple-value-bind
   ;;       (head#char
   ;;        tail#char
   ;;        string)
   ;;     (string->head#char string)
   ;;   ><><><)

   (defun string->head#char (string)
     (values (char string 0)
             (subseq string
                     1)
             string))


   (defun string->tail#char (string)
     (multiple-value-bind
           (head#char
            tail#char
            string)
         (string->head#char string)
       tail#char))


   (defun string->list#char (string &key (base-list '()))
     (cond
       ((string#empty? string) base-list)
       (:else
        (cons (string->head#char string)
              (string->list#char (string->tail#char string))))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest string->head#char
       (basic)
     (and (ensure
              (list (multiple-value-list (string->head#char " kkk took my baby away! "))
                    (multiple-value-list (string->head#char "k"))
                    (multiple-value-list (string->head#char " k"))
                    (multiple-value-list (string->head#char "k ")))
              ==>
              (list `(#\  "kkk took my baby away! " " kkk took my baby away! ")
                    `(#\k "" "k")
                    `(#\  "k" " k")
                    `(#\k " " "k ")))

          ;; the argument applied to string->head#char
          ;; must not be ""
          ;; one should use string#empty? to ensure this

          ;; just do not handle the error
          ;; let the debuger do its job
          (ensure
              (string->head#char "")
              signals
              type-error)
          ))

   (deftest string->tail#char
       (basic)
     (and (ensure
              (string->tail#char " kkk took my baby away! ")
              ==>
              "kkk took my baby away! ")

          ;; just do not handle the error
          ;; let the debuger do its job
          (ensure
              (string->tail#char "")
              signals
              type-error)
          ))

   (deftest string->list#char
       (basic)
     (ensure
         (list (string->list#char " kkk took my baby away! ")
               (string->list#char " kkk")
               (string->list#char "kkk ")
               (string->list#char " ")
               (string->list#char ""))
         ==>
         (list `(#\  #\k #\k #\k #\  #\t #\o #\o #\k #\  #\m #\y #\  #\b #\a #\b #\y #\  #\a
                     #\w #\a #\y #\! #\ )
               `(#\  #\k #\k #\k)
               `(#\k #\k #\k #\ )
               `(#\ )
               `nil)))
   #+end_src
* list
** predicate
   #+begin_src lisp :tangle basic.test.lisp
   (defun pair? (x)
     (consp x))

   (defun list? (x)
     (listp x))
   #+end_src
** end-of-list
   #+begin_src lisp :tangle basic.lisp
   (defun end-of-list (list)
     (cond
       ((not (pair? list))
        (error "the argument of (end-of-list) must be a list"))
       (:else
        (help#loop#end-of-list list))
       ))

   (defun help#loop#end-of-list (list)
     (let ((cdr#list (cdr list)))
       (cond
         ((nil? cdr#list)
          (car list))
         ((not (pair? cdr#list))
          (error (concatenate
                  'string
                  "the argument of (end-of-list) must be not only a list~%"
                  "but also a proper-list")))
         (:else
          (help#loop#end-of-list cdr#list))
         )))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest end-of-list
       (basic)
     (and (ensure
              (end-of-list '(1 2 3))
              ==>
              3)
          (ensure
              (end-of-list '(1 2 . 3))
              signals
              simple-error)
          (ensure
              (end-of-list 3)
              signals
              simple-error)))
   #+end_src
** group
   #+begin_src lisp :tangle basic.lisp
   (defun group (list
                 &key
                   (number 2)
                   ;; (pattern '())
                   (base-list '()))
     (cond ((< (length list) 2) base-list)
           (:else
            (cons (list (first list) (second list))
                  (group (cddr list)
                         :number number)))))
   #+end_src
** cons-many
   #+begin_src lisp :tangle basic.lisp
   ;; (cons-many 1 2 '(3 4))
   ;; ==>
   ;; (cons 1
   ;;       (cons 2
   ;;             '(3 4)))

   (defmacro cons-many (&body form)
     (cond
       ((null (cdr form))
        (car form))
       (:else
        `(cons ,(car form)
               (cons-many . ,(cdr form))))))

   ;; (cons-many 1 2 (list 3 4))
   ;; (cons-many (car '(1 2)) (list 3 4))
   ;; (cons-many (list 3 4))

   ;; on error
   ;; (cons-many 1)
   #+end_src
* function
** map-composite-function
   #+begin_src lisp :tangle basic.lisp
   (defun map-composite-function (function-list list)
     (help#reverse#map-composite-function
      (reverse function-list)
      list))

   (defun help#reverse#map-composite-function
       (reversed-function-list
        list)
     (cond
       ((nil? reversed-function-list)
        list)
       (:else
        (mapcar (car reversed-function-list)
                (help#reverse#map-composite-function
                 (cdr reversed-function-list)
                 list)))))
   #+end_src
** multi return value
   #+begin_src lisp :tangle basic.lisp
   (defun return-zero-value ()
     (values))
   #+end_src
* line-list
** edit#line-list
   #+begin_src lisp :tangle basic.lisp
   ;; note the order
   (defun edit#line-list
       (&key
          line-list
          (print-to nil)
          (prefix "")
          (postfix "")
          (indent 0)
          (function-list '()))
     (let* ((line-list-for-return
             (map-composite-function function-list
                                     line-list))
            (line-list-for-return
             (mapcar (lambda (line) (concatenate 'string prefix line))
                     line-list-for-return))
            (line-list-for-return
             (mapcar (lambda (line) (concatenate 'string line postfix))
                     line-list-for-return))
            (line-list-for-return
             (cond ((zero? indent)
                    line-list-for-return)
                   (:else
                    (mapcar (lambda (line) (concatenate 'string (dup#string :time indent :string " ") line))
                            line-list-for-return)))))
       (cond ((nil? print-to)
              line-list-for-return)
             ((stream? print-to)
              (mapcar (lambda (line) (format print-to "~A~%" line))
                      line-list-for-return))
             (:else
              (error "the argument :print-to of (edit#line-list) must be a output stream")))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest edit#line-list
       (basic)
     (ensure
         (edit#line-list
          :indent 2
          :prefix "* "
          :postfix "|^-^"
          :function-list
          `(,(lambda (string) (string-trim '(#\space) string)))
          :line-list
          `("  123"
            "456  "))
         ==>
         `("  * 123|^-^"
           "  * 456|^-^")))

   ;; (edit#line-list
   ;;  :indent 2
   ;;  :print-to *standard-output*
   ;;  :prefix "* "
   ;;  :postfix "|^-^"
   ;;  :function-list
   ;;  `(,(lambda (string) (string-trim '(#\space) string)))
   ;;  :line-list
   ;;  `("  123"
   ;;    "456  "))
   #+end_src
* -----------------------------------
* *little-tester*
** test-group & test
   #+begin_src lisp :tangle basic.lisp
   (defstruct (test-group
                (:constructor make-test-group (name &key
                                                    pre
                                                    post
                                                    docstring))
                (:print-function %print-test-group))
     (name (required-argument) :type symbol :read-only t)
     (docstring nil :type (or null simple-base-string) :read-only t)
     (tests (make-hash-table) :type hash-table :read-only t)
     (pre nil :type (or null function))
     (post nil :type (or null function)))

   (defun %print-test-group (group stream depth)
     (declare (ignore depth))
     (print-unreadable-object (group stream :type t :identity t)
       (format stream "~S, ~D tests" (test-group-name group)
               (hash-table-count (test-group-tests group)))))


   (defstruct (test
                (:constructor make-test (name fn
                                              &key
                                              after
                                              after-pass
                                              after-fail
                                              when
                                              unless
                                              priority
                                              docstring))
                (:print-function %print-test))
     (name (required-argument) :type symbol :read-only t)
     (docstring nil :type (or null simple-base-string) :read-only t)
     (fn (required-argument) :type function :read-only t)
     (priority 0 :type fixnum)
     (after '() :type list)
     (after-pass '() :type list)
     (after-fail '() :type list)
     (when nil :type (or null function))
     (unless nil :type (or null function)))

   (defun %print-test (test stream depth)
     (declare (ignore depth))
     (print-unreadable-object (test stream :type t :identity t)
       (princ (test-name test) stream)))

   (defun required-argument ()
     (error "A required argument was not supplied."))
   #+end_src
** find-test-group & define-test-group
   #+begin_src lisp :tangle basic.lisp
   (defun find-test-group (name &optional create)
     (if (test-group-p name)
         name
         (let ((group (get name 'tests)))
           (cond (group group)
                 (create (setf (get name 'tests) (make-test-group name)))))))

   (defmacro define-test-group (name &optional opts docstring)
     (let ((tmp (gensym "GROUP"))
           (pre (gensym))
           (post (gensym)))
       `(let ((,tmp (find-test-group ',name))
              (,pre ,(getf opts :before))
              (,post ,(getf opts :after)))
          (if (null ,tmp)
              (setf (get ',name 'tests) (make-test-group ',name
                                                         :pre ,pre
                                                         :post ,post
                                                         :docstring ',docstring))
              (progn
                (when ,pre (setf (test-group-pre ,tmp) ,pre))
                (when ,post (setf (test-group-post ,tmp) ,post))
                ,tmp)))))
   #+end_src
** doc
   * syntax:
     #+begin_src lisp
     (define-test-group name &optional opts docstring)
     ;; => group
     #+end_src
   * arguments:
     | name      | a symbol        |
     | opts      | a property list |
     | docstring | a string        |
   * description:
     * Defines a group of tests with the given name.
       OPTS may contain the keys :before and :after,
       whose values should be functions (or lambda expressions)
       to be called before and after all tests in the group have been run.
     * If the group already exists,
       the :before and :after functions are updated;
       the docstring
       and any tests already defined in the group
       are left unchanged.
** deftest
   #+begin_src lisp :tangle basic.lisp
   (defmacro deftest
       (test-name
        (group &key
               after
               after-pass
               after-fail
               when unless
               priority)
        &body body)

     (multiple-value-bind
           (body
            decls
            doc)
         (help#parse-body#deftest body nil t)

       (let* ((test-function-name
               (intern (concatenate 'string
                                    #.(string '#:test-)
                                    (string test-name)
                                    "/"
                                    (string group))))
              (hash (gensym "HASH"))
              (keys (append
                     ;; symbol or list of symbol
                     (cond ((consp after)      `(:after       (quote ,after)))
                           (after              `(:after       (quote (,after)))))
                     (cond ((consp after-pass) `(:after-pass  (quote ,after-pass)))
                           (after-pass         `(:after-pass  (quote (,after-pass)))))
                     (cond ((consp after-fail) `(:after-fail  (quote ,after-fail)))
                           (after-fail         `(:after-fail  (quote (,after-fail)))))

                     (when when   `(:when   (lambda () ,when)))
                     (when unless `(:unless (lambda () ,unless)))
                     (when doc `(:docstring ,doc))
                     (if priority
                         `(:priority ,priority)
                         `(:priority (if (gethash (quote ,test-name) ,hash)
                                         (test-priority
                                          (gethash (quote ,test-name) ,hash))
                                         (hash-table-count ,hash)))))))



         `(progn
            (defun ,test-function-name ()
              ,doc
              ,@decls
              (block ,test-name
               ;; test-block ,test-name
                ,@body))

            (let ((,hash (test-group-tests
                          (find-test-group (quote ,group) t))))
              (when (gethash (quote ,test-name) ,hash) (warn "Redefining test ~A." (quote ,test-name)))
              (setf (gethash (quote ,test-name) ,hash)
                    (make-test (quote ,test-name)
                               (function ,test-function-name)
                               ,@keys)))

            (quote ,test-name)
            ))))


   (defun help#parse-body#deftest (body env &optional doc-p)
     (declare (ignore env))
     (let ((decls '())
           (doc nil))
       (loop (cond
               ((and (consp (first body))
                     (eq (first (first body))
                         'declare))
                (push (pop body) decls))

               ((and doc-p
                     (null doc)
                     (stringp (first body)))
                (setq doc (pop body)))

               (:else
                (return (values body
                                (nreverse decls)
                                doc))
                )))))
   #+end_src
** doc
   * syntax:
     #+begin_src lisp
     (deftest name
         (group :after
                :after-pass
                :after-fail
                :when
                :unless
                :priority )
       body)
     ;; => name
     #+end_src
   * arguments:
     | name       | a symbol                                 |
     | group      | a symbol                                 |
     | after      | a symbol or a list                       |
     | after-pass | a symbol or a list                       |
     | after-fail | a symbol or a list                       |
     | when       | a Lisp form                              |
     | unless     | a Lisp form                              |
     | priority   | a fixnum                                 |
     | body       | Lisp forms;                              |
     |            | may include declarations and a docstring |
   * description:
     * Defines a test with the given name
       to be a member of the named group.
       If the group isn't yet defined,
       this defines it.
     * The body should perform the test
       and return
       T if it succeeds
       NIL if it fails.
       Signalling an error is also a failure.
     * The keyword arguments control the order and conditions
       under which the test is run:
       * after
       * after-pass
       * after-fail
       may be either the name of an individual test
       or a list of names.
       This test will run after the test(s) named;
       tests named in the after-pass argument must pass
       before this test will be allowed to run,
       and tests named in the after-fail argument must fail
       before this test will be allowed to run.
     * The when and unless arguments
       are forms to be evaluated,
       which return a true value if the test is to be
       performed (for when)
       or skipped (for unless),
       and NIL otherwise.
     * The priority argument is a number;
       tests with lower priority values
       run earlier than tests with higher priority values,
       subject to the after, after-pass and after-fail constraints.
       If priority is not supplied,
       and a test with the given name already exists,
       the priority is left unchanged;
       if the test does not already exist
       the priority defaults to the number of tests defined so far,
       so tests tend to run in the order they're defined.
     * DEFTEST defines a function named TEST-name/group,
       which can be called manually
       to run an individual test.
       RUN-TESTS is used to run all tests in a group.
** help#==>#ensure
   #+begin_src lisp :tangle basic.lisp
   (defmacro help#==>#ensure
       (&key
          actual-form
          expect-form)

     `(handler-case (values (multiple-value-list ,actual-form)
                            (multiple-value-list ,expect-form))

        ;; if a condition occur
        ;; :actual-form or :expect-form
        ;; match the condition's type to the following cases

        (simple-error (condition)
          (values nil
                  (cat (:trim (cat () ("~%")))
                    ((cat (:postfix (cat () ("~%")))
                       ("#+begin_src lisp")
                       (";; [ACTUAL-FORM]")
                       ("~S" (quote ,actual-form))
                       ("")
                       (";; [EXPECT-FORM]")
                       ("~S" (quote ,expect-form))
                       ("")
                       (";; [ACTUAL-CONDITION when evaluating the forms]")
                       ("~A" (apply (function format) nil
                                    (simple-condition-format-control condition)
                                    (simple-condition-format-arguments condition)))
                       ("#+end_src"))))))

        (error (condition)
          (values nil
                  (cat (:trim (cat () ("~%")))
                    ((cat (:postfix (cat () ("~%")))
                       ("#+begin_src lisp")
                       (";; [ACTUAL-FORM]")
                       ("~S" (quote ,actual-form))
                       ("")
                       (";; [EXPECT-FORM]")
                       ("~S" (quote ,expect-form))
                       ("")
                       (";; [ACTUAL-CONDITION when evaluating the forms]")
                       ("~A" condition)
                       ("#+end_src"))))))

        ;; the following names are bound by VALUES
        (:no-error (actual-value-list
                    expect-value-list)
          (cond ((not (and (= (length actual-value-list)
                              (length expect-value-list))
                           (every (function equalp)
                                  actual-value-list
                                  expect-value-list)))
                 (values nil
                         (cat (:trim (cat () ("~%")))
                           ((cat (:postfix (cat () ("~%")))
                              ("#+begin_src lisp")
                              (";; [ACTUAL-FORM]")
                              ("~S" (quote ,actual-form))
                              ("")
                              (";; [EXPECT-VALUE]")
                              ("~{~S~^~%~17T~}" expect-value-list)
                              ("")
                              (";; [ACTUAL-VALUE]")
                              ("~{~S~^~%~15T~}" actual-value-list)
                              ("#+end_src"))))))
                (:else
                 (values t
                         "ensure successed ^-^"))
                ))))

   ;; (ensure
   ;;     (values 1 2 3 4 5)
   ;;     ==>
   ;;     (values 1 2 3 4 5))

   ;; ><><><
   ;; (ensure
   ;;     (values 1 2 3 4 5)
   ;;     ==>
   ;;     (values 5 4 3 2 1))

   ;; (ensure
   ;;     (list (be :name (string->name "kkk")
   ;;               :as (string->name "took")
   ;;               :mean "my baby away!")
   ;;           (multiple-value-list
   ;;            (be :name (string->name "kkk")
   ;;                :as (string->name "took")
   ;;                :mean "my baby away!"))
   ;;           (multiple-value-list
   ;;            (explain :name (string->name "kkk")
   ;;                     :as (string->name "took"))))
   ;;     ==>
   ;;     (list 1
   ;;           `(2
   ;;             :UPDATED!!!
   ;;             "my baby away!")
   ;;           `("my baby away!"
   ;;             :found!!!)))

   ;; (ensure
   ;;     (string->head#char "")
   ;;     ==>
   ;;     '><><><)

   ;; (ensure
   ;;     (error "testing (ensure)")
   ;;     ==>
   ;;     '><><><)
   #+end_src
** help#signals#ensure
   #+begin_src lisp :tangle basic.lisp
   (defmacro help#signals#ensure
       (&key
          actual-form
          expect-condition)

     `(handler-case (multiple-value-list ,actual-form)

        (,expect-condition () t)

        (simple-error (condition)
          (cat (:trim (cat () ("~%")))
            ((cat (:postfix (cat () ("~%")))
               ("#+begin_src lisp")
               (";; [ACTUAL-FORM]")
               ("~S" (quote ,actual-form))
               ("")
               (";; [EXPECT-CONDITION]")
               ("~S" (quote ,expect-condition))
               ("")
               (";; [ACTUAL-CONDITION]")
               ("~A" (apply (function format) nil
                            (simple-condition-format-control condition)
                            (simple-condition-format-arguments condition)))
               ("#+end_src")))))

        (error (condition)
          (cat (:trim (cat () ("~%")))
            ((cat (:postfix (cat () ("~%")))
               ("#+begin_src lisp")
               (";; [ACTUAL-FORM]")
               ("~S" (quote ,actual-form))
               ("")
               (";; [EXPECT-CONDITION]")
               ("~S" (quote ,expect-condition))
               ("")
               (";; [ACTUAL-CONDITION]")
               ("~A" condition)
               ("#+end_src")))))

        (:no-error (actual-value-list)
          (cat (:trim (cat () ("~%")))
            ((cat (:postfix (cat () ("~%")))
               ("#+begin_src lisp")
               (";; [ACTUAL-FORM]")
               ("~S" (quote ,actual-form))
               ("")
               (";; [EXPECT-CONDITION]")
               ("~S" (quote ,expect-condition))
               ("")
               (";; [ACTUAL-VALUE]")
               ("~{~S~^~%~10T~}" actual-value-list)
               ("#+end_src")))))))

   ;; (ensure
   ;;     (string->head#char "")
   ;;     signals
   ;;     type-error)

   ;; (ensure
   ;;     (string->head#char "")
   ;;     signals
   ;;     error)

   ;; (ensure
   ;;     (string->head#char "")
   ;;     signals
   ;;     simple-error)
   #+end_src
** ensure
   #+begin_src lisp :tangle basic.lisp
   ;; (multiple-value-bind
   ;;       (success?
   ;;        report-string)
   ;;     (ensure string)
   ;;   '><><><)

   (defmacro ensure (left-expression
                     infix-notation
                     right-expression)
     (cond
       ((string-equal infix-notation '==>)
        `(help#==>#ensure :actual-form ,left-expression
                          :expect-form ,right-expression))

       ((string-equal infix-notation 'signals)
        `(help#signals#ensure :actual-form ,left-expression
                              :expect-condition ,right-expression))

       (:else
        (error "unknown infix-notation of the macro (ensure)"))
       ))
   #+end_src
** doc
   * syntax:
     #+begin_src lisp
     (ensure
         form
         =>
         value)
     ;; => boolean

     (ensure
         form
         signals
         condition)
     ;; => boolean
     #+end_src
   * arguments:
     | form    | a Lisp form              |
     | =>      | a symbol named "=>"      |
     | signals | a symbol named "SIGNALS" |
     | value   | a Lisp form              |
   * description:
     * The first form ensures that form evaluates to value,
       printing a short report if the test fails.
       The test is done using EQUALP.
       The number of values returned is also checked.
     * The second form ensures that the form signals the named condition,
       printing a short report if the test fails.
     * The ENSURE macro is only available in the body of a DEFTEST form.
** all-tests
   #+begin_src lisp :tangle basic.lisp
   (defun all-tests (group)
     (let* ((group (find-test-group group))
            (tests (loop for x being the hash-values of (test-group-tests group)
                      collecting x))
            (constraints '()))
       (dolist (test tests)
         (dolist (val (test-after test))
           (push (cons val (test-name test)) constraints))
         (dolist (val (test-after-pass test))
           (push (cons val (test-name test)) constraints))
         (dolist (val (test-after-fail test))
           (push (cons val (test-name test)) constraints)))
       (help#topological-sort#all-tests (map-into tests #'test-name tests) constraints
                         (lambda (x y)
                           (declare (ignore y))
                           (first (stable-sort (copy-seq x) #'<
                                               :key (lambda (name)
                                                      (test-priority
                                                       (gethash name (test-group-tests group))))))))))

   (defun help#topological-sort#all-tests (elements constraints tie-breaker)
     (let ((result '()))
       (loop
          (let* ((rhs (mapcar #'cdr constraints))
                 (elts (remove-if (lambda (x) (member x rhs)) elements)))
            (when (null elts)
              (if elements
                  (error "Inconsistent constraints in ~S" 'help#topological-sort#all-tests)
                  (unless elements (return (nreverse result)))))
            (let ((elt
                   (if (cdr elts) (funcall tie-breaker elts result) (car elts))))
              (push elt result)
              (setq elements (delete elt elements))
              (setq constraints (delete-if (lambda (x)
                                             (or (eq (car x) elt)
                                                 (eq (cdr x) elt)))
                                           constraints)))))))
   #+end_src
** doc
   * syntax:
     #+begin_src lisp
     (all-tests group)

     ;; => list
     #+end_src
   * arguments:
     | group | a symbol naming a group of tests |
   * description:
     * Retrieve a list of the (names of) tests in the group,
       in the order in which they will run.
** *break-on-fail*
   #+begin_src lisp :tangle basic.lisp
   (defvar *break-on-fail* nil)
   #+end_src
** doc
   * value type:
     a (generalized) boolean
   * initial value:
     nil
   * description:
     The default value for the break-on-fail argument to RUN-TESTS.
** run-tests
   #+begin_src lisp :tangle basic.lisp
   (defun run-tests
       (group &key
                (skip nil)
                (break-on-fail *break-on-fail*))
     (let ((group (find-test-group group))
           (passed '())
           (failed '()))
       (when (test-group-pre group)
         (funcall (test-group-pre group)))
       (unwind-protect
            (dolist (name (all-tests group))
              (tagbody
               try-again
                 (let ((test (gethash name (test-group-tests group))))
                   (unless (or (member name skip)
                               (and (test-when test)
                                    (not (funcall (test-when test))))
                               (and (test-unless test)
                                    (funcall (test-unless test)))
                               (set-difference (test-after-pass test) passed)
                               (set-difference (test-after-fail test) failed))

                     (multiple-value-bind
                           (pass?
                            report-string
                            time)
                         (do-test test)

                       ;; about break-on-fail
                       (when (and break-on-fail (not pass?))
                         (restart-case
                             (break "Test ~A failed with BREAK-ON-FAIL set."
                                    name)
                           (try-again ()
                             :report "Try the test again."
                             (go try-again))))

                       ;; main report
                       (cond ((not pass?)
                              (push name failed)
                              (cat (:to *standard-output*
                                        :postfix (cat () ("~%")))
                                ("* >< ~A" name)
                                ("  * failed"))
                              (edit#line-list
                               :print-to *standard-output*
                               :indent 4
                               :line-list
                               (string->list#line (cat () ("~A" report-string)))))
                             (:else
                              (push name passed)
                              (cat (:to *standard-output*
                                        :postfix (cat () ("~%")))
                                ("* ~A" name))))

                       ;; about time used
                       ;; (multiple-value-bind (hours time) (floor time 3600)
                       ;;   (multiple-value-bind (minutes seconds) (floor time 60)
                       ;;     (format t "~47T[~2,'0D:~2,'0D:~5,2,,,'0F]~%"
                       ;;             hours minutes seconds)))

                       )))))

         (when (test-group-post group)
           (funcall (test-group-post group))))

       (let ((pass (length passed))
             (fail (length failed))
             (total (hash-table-count (test-group-tests group))))
         (format t "~2&Ran ~D of ~D test~:P in group ~S~%" (+ pass fail) total
                 (test-group-name group))
         (when failed
           (format t "~&The following tests failed:~%  ~S~%" failed))
         (format t "~2&Totals -- Passed: ~D~25T~3D%~&~10TFailed: ~D~25T~3D%~%"
                 pass (round (* 100 pass) total)
                 fail (round (* 100 fail) total)))

       (null failed)
       ))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (pass?
   ;;        report-string
   ;;        time)
   ;;     (do-test test)
   ;;   '><><><)
   (defun do-test (test)
     (let ((time (get-internal-run-time)))
       (multiple-value-bind
             (success?
              report-string)
           (ignore-errors
             (funcall (test-fn test)))
         (values success?
                 report-string
                 (/ (float (- (get-internal-run-time) time) 1f0)
                    (float internal-time-units-per-second 1f0))))))
   #+end_src
** doc
   * syntax:
     #+begin_src lisp
     (run-tests group
                :skip
                :break-on-fail )
     ;; => boolean
     #+end_src
   * arguments:
     | group         | a symbol naming a group of tests |
     | skip          | a list                           |
     | break-on-fail | a (generalized) boolean          |
   * description:
     * Runs all of the runnable tests in the group,
       printing a pass or fail message for each test,
       and the processor time used.
     * A list of tests to be skipped
       can be supplied in the SKIP argument
       (any tests which depend on those tests will also be skipped)
     * If the BREAK-ON-FAIL argument is supplied non-NIL,
       the failure of any test will cause a break,
       with restarts named TRY-AGAIN to retry the test
       and CONTINUE to accept the failure and continue with the next test.
       The default value for BREAK-ON-FAIL
       is given by the special variable *BREAK-ON-FAIL*.
     * The return value is
       NIL if any test failed,
       T otherwise.
       This allows test groups to be nested
       by simply writing a DEFTEST
       whose body runs the nested test group.
* ===================================
