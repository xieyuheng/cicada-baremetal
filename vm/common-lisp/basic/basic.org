#+TITLE:  basic lib for common-lisp
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** maybe need a better fixnum?
** argument type check for the following functions
   * dup#string
   * edit#line-list
** dup
   * uses make-string to re-define dup#string
   * define dup for other datatype
* ===================================
* note
** respect
   * you should respect the function
     * when a calculation is done
       it is not respectful
       to not return all of the hard work the function had done
     * so I return multi-value
       to capture almost the whole calculation
   * function should return its audience
     * function should be defined in the way that
       1. the structure of the data applied to the function
          is as regular as possible
          [this will make the function easy to write and easy to read]
       2. when ill-structured data is applied to the function
          the function cry out loud that it is an error
       3. well defined predicate is created
          to test if the data is regular or not
       4. when call the function
          the caller should use the predicate
          to make sure that
          the structure of data is regular
          [this will make the intention of code clear]
** naming convention
   * to use "#" to introduce symbol prefix and postfix
   * a "#" denotes an word such as
     "of" "'s" "is" "are" "for" "to" "from" and so on
     in Chinese
     this kind of words are called unfilled-word
     i.e. word which is not filled by a precise meaning
     the meaning of it should be infered from context
   * when wish to stress that a symbol is used as a bounded-variable
     use "." as its prefix
* -----------------------------------
* (in-package :cicada-vm)
** basic.lisp
   #+begin_src lisp :tangle basic.lisp
   (in-package :cicada-vm)
   #+end_src
** basic.test.lisp
   #+begin_src lisp :tangle basic.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* bool
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun nil? (x)
     (null x))

   (defun ture? (x)
     (eq t x))

   (defun false? (x)
     (eq nil x))
   #+end_src
** ----------------------------------
** equal
   #+begin_src lisp :tangle basic.lisp
   (defun eq? (x y)
     (eq x y))

   (defun equal? (x y)
     (equal x y))
   #+end_src
** ----------------------------------
* fixmun
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defparameter *size#fixnum* 32) ;; unit bit

   (defun fixnum? (x)
     (and (natural-number? x)
          (< x
             (expt 2 *size#fixnum*))))


   (defun zero? (x)
     (and (integerp x)
          (zerop x)))

   (defun integer? (x)
     (integerp x))

   (defun natural-number? (x)
     (and (integerp x)
          (<= 0 x)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest natural-number?
       (basic)
     (ensure
         (list (natural-number? 0)
               (natural-number? 1)
               (natural-number? -1)
               (natural-number? 1.1))
         ==>
         (list t
               t
               nil
               nil)))
   #+end_src
** ----------------------------------
** add & sub & mul & div
   #+begin_src lisp :tangle basic.lisp
   (defun add (x y) (+ x y))
   (defun sub (x y) (- x y))
   (defun mul (x y) (* x y))
   (defun div (x y) (/ x y))

   (defun add1 (x) (+ x 1))
   (defun sub1 (x) (- x 1))

   (defmacro add1! (x) `(setf ,x (add1 ,x)))
   (defmacro sub1! (x) `(setf ,x (sub1 ,x)))
   #+end_src
** ----------------------------------
** shift#[left|right]
   #+begin_src lisp :tangle basic.lisp
   (defun shift#left (&key
                        (step 1)
                        number)
     (* number
        (expt 2 step)))


   (defun shift#right (&key
                         (step 1)
                         number)
     (/ number
        (expt 2 step)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest shift#left
       (basic)
     (ensure
         (list (shift#left :number 10)
               (shift#left :step 2
                           :number 10))
         ==>
         (list 20
               40)))

   (deftest shift#right
       (basic)
     (ensure
         (list (shift#right :number 64)
               (shift#right :step 2
                            :number 64))
         ==>
         (list 32
               16)))
   #+end_src
** ----------------------------------
* bit
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#bits (&key
                        bits
                        (size 1)
                        index)
     (ldb (byte size index) bits))

   (defun save#bits (&key
                       value
                       bits
                       (size 1)
                       index)
     (setf (ldb (byte size index) bits) value)
     (values bits
             value))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#bits
       (basic)
     (ensure
         (fetch#bits :bits #b0010
                     :size 1
                     :index 1)
         ==>
         1))
   #+end_src
** ----------------------------------
* byte
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#bytes (&key
                         bytes
                         (size 1)
                         index)
     (fetch#bits :bits bytes
                 :size (* 8 size)
                 :index (* 8 index)))

   (defun save#bytes (&key
                        value
                        bytes
                        (size 1)
                        index)
     (save#bits :value value
                :bits bytes
                :size (* 8 size)
                :index (* 8 index)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#bytes
       (basic)
     (ensure
         (list (fetch#bytes :bytes #xff  :index 0)
               (fetch#bytes :bytes #xff  :index 1)
               (fetch#bytes :bytes #x100 :index 0)
               (fetch#bytes :bytes #x100 :index 1))
         ==>
         `(255
           0
           0
           1)))
   #+end_src
** ----------------------------------
* array
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun array? (x)
     (arrayp x))
   #+end_src
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#array (&key
                         array
                         index-vector)
     (let ((index-list (vector->list index-vector)))
       (apply (function aref)
              array index-list)))



   (defun save#array (&key
                        value
                        array
                        index-vector)
     (let ((index-list (vector->list index-vector)))
       (setf
        (apply #'aref array index-list) value)
       (values array
               value)))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#array
       (basic)
     (ensure
         (fetch#array
          :array (make-array '(1 1 1) :initial-element 666)
          :index-vector '#(0 0 0))
         ==>
         666))

   (deftest save#array
       (basic)
     (ensure
         (fetch#array
          :array (save#array
                  :value 258
                  :array (make-array '(1 1 1) :initial-element 666)
                  :index-vector '#(0 0 0))
          :index-vector '#(0 0 0))
         ==>
         258))
          #+end_src
** ----------------------------------
* vector
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun vector? (x)
     (vectorp x))
   #+end_src
** ----------------------------------
** make-vector
   #+begin_src lisp :tangle basic.lisp
   (defun make-vector
       (&key
          length
          element-type
          initial-element
          adjustable
          fill-pointer
          displaced-to
          displaced-index-offset)
     (make-array `(,length)
                 :element-type element-type
                 :initial-element initial-element
                 :adjustable adjustable
                 :fill-pointer fill-pointer
                 :displaced-to displaced-to
                 :displaced-index-offset displaced-index-offset))
   #+end_src
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#vector (&key
                          vector
                          index)
     (fetch#array :array vector
                  :index-vector `#(,index)))



   (defun save#vector (&key
                         value
                         vector
                         index)
     (save#array :value value
                 :array vector
                 :index-vector `#(,index)))



   (defun copy-vector (vector)
     (if (not (vector? vector))
         (error "the argument of copy-vector must be a vector")
         (copy-seq vector)))
   #+end_src
** ----------------------------------
** list->vector & vector->list
   #+begin_src lisp :tangle basic.lisp
   (defun list->vector (list)
     (if (not (list? list))
         (error "the argument of (list->vector) must be a list")
         (coerce list 'vector)))


   (defun vector->list (vector)
     (if (not (vector? vector))
         (error "the argument of (vector->list) must be a vector")
         (coerce vector 'list)))
   #+end_src
** ----------------------------------
* byte-array
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#byte-array
       (&key
          byte-array
          (size 1)
          index-vector
          (endian 'little))

     (cond
       ((not (<= (+ (fetch#vector :vector index-vector
                                  :index (sub1 (array-rank byte-array)))
                    size)
                 (array-dimension byte-array
                                  (sub1 (array-rank byte-array)))))
        (error "the size of the value you wish to fetch is out of the index of the byte-array"))

       ((equal? endian 'little)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#little-endian#fetch#byte-array
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       ((equal? endian 'big)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#big-endian#fetch#byte-array
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       (:else
        (error "the argument :endian of (fetch#byte-array) must be 'little or 'big"))
       ))


   (defun help#little-endian#fetch#byte-array
       (&key
          byte-array
          size
          index-vector
          (counter 0)
          (sum 0))
     (cond
       ((not (< counter
                size))
        sum)

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               (value-for-shift (fetch#array
                                 :array byte-array
                                 :index-vector index-vector))
               (value-for-sum (shift#left
                               :step (* 8 counter)
                               :number value-for-shift)))
          ;; update index-vector
          (save#vector :value (add1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#little-endian#fetch#byte-array
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter)
           :sum (+ sum value-for-sum))))
       ))




   ;; (add1) change to (sub1)
   ;; new index-vector-for-fetch
   (defun help#big-endian#fetch#byte-array
       (&key
          byte-array
          size
          index-vector
          (counter 0)
          (sum 0))
     (cond
       ((not (< counter
                size))
        sum)

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               ;; new index-vector-for-fetch
               (index-vector-for-fetch (save#vector
                                        :value (+ last-index
                                                  (sub1 size))
                                        :vector (copy-vector index-vector)
                                        :index (sub1 (array-rank byte-array))))
               (value-for-shift (fetch#array
                                 :array byte-array
                                 :index-vector index-vector-for-fetch))
               (value-for-sum (shift#left
                               :step (* 8 counter)
                               :number value-for-shift)))
          ;; update index-vector
          ;; (add1) change to (sub1)
          (save#vector :value (sub1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#big-endian#fetch#byte-array
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter)
           :sum (+ sum value-for-sum))))
       ))





   (defun save#byte-array
       (&key
          value
          byte-array
          (size 1)
          index-vector
          (endian 'little))
     (cond
       ((not (<= (+ (fetch#vector :vector index-vector
                                  :index (sub1 (array-rank byte-array)))
                    size)
                 (array-dimension byte-array
                                  (sub1 (array-rank byte-array)))))
        (error "the size of the value you wish to save is out of the index of the byte-array"))

       ((equal? endian 'little)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#little-endian#save#byte-array
         :value value
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       ((equal? endian 'big)
        ;; helper function will do side-effect on argument :index-vector
        ;; so copy it first
        (setf index-vector (copy-vector index-vector))
        (help#big-endian#save#byte-array
         :value value
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       (:else
        (error "the argument :endian of (save#byte-array) must be 'little or 'big"))
       ))


   (defun help#little-endian#save#byte-array
       (&key
          value
          byte-array
          size
          index-vector
          (counter 0))
     (cond
       ((not (< counter
                size))
        (values byte-array
                value))

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array)))))
          ;; save to byte-array
          (save#array :value (fetch#bytes :bytes value
                                          :size 1
                                          :index counter)
                      :array byte-array
                      :index-vector index-vector)
          ;; update index-vector
          (save#vector :value (add1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#little-endian#save#byte-array
           :value value
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter))))
       ))





   ;; (add1) change to (sub1)
   ;; new index-vector-for-save
   (defun help#big-endian#save#byte-array
       (&key
          value
          byte-array
          size
          index-vector
          (counter 0))
     (cond
       ((not (< counter
                size))
        (values byte-array
                value))

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               ;; new index-vector-for-save
               (index-vector-for-save (save#vector
                                       :value (+ last-index
                                                 (sub1 size))
                                       :vector (copy-vector index-vector)
                                       :index (sub1 (array-rank byte-array)))))
          ;; save to byte-array
          (save#array :value (fetch#bytes :bytes value
                                          :size 1
                                          :index counter)
                      :array byte-array
                      :index-vector index-vector-for-save)
          ;; update index-vector
          ;; (add1) change to (sub1)
          (save#vector :value (sub1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#big-endian#save#byte-array
           :value value
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter))))
       ))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#byte-array
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector #(0)))
         ==>
         257))

   (deftest fetch#byte-array--big-endian
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector #(0)
                             :endian 'big))
         ==>
         257))

   (deftest save#byte-array
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (save#byte-array :value 1234
                            :byte-array k
                            :size 2
                            :index-vector '#(0))
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector '#(0)))
         ==>
         1234))

   (deftest save#byte-array--big-endian
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (save#byte-array :value 1234
                            :byte-array k
                            :size 2
                            :index-vector #(0)
                            :endian 'big)
           (fetch#byte-array :byte-array k
                             :size 2
                             :index-vector #(0)
                             :endian 'big))
         ==>
         1234))
   #+end_src
** ----------------------------------
* byte-vector
** ----------------------------------
** byte-vector?
   #+begin_src lisp :tangle basic.lisp
   (defun byte-vector? (x)
     (typep x '(vector (unsigned-byte 8))))
   #+end_src
** ----------------------------------
** fetch & save & copy
   #+begin_src lisp :tangle basic.lisp
   (defun fetch#byte-vector (&key
                               byte-vector
                               (size 1)
                               index
                               (endian 'little))
     (fetch#byte-array :byte-array byte-vector
                       :size size
                       :index-vector `#(,index)
                       :endian endian))



   (defun save#byte-vector (&key
                              value
                              byte-vector
                              (size 1)
                              index
                              (endian 'little))
     (save#byte-array :value value
                      :byte-array byte-vector
                      :size size
                      :index-vector `#(,index)
                      :endian endian))


   (defun copy#byte-vector (&key
                              from
                              from-index
                              to
                              to-index
                              size
                              (counter 0))
     (cond
       ((not (< counter
                size))
        (values to
                from
                counter))

       (:else
        (save#byte-vector
         :value (fetch#byte-vector
                 :byte-vector from
                 :size 1
                 :index from-index)
         :byte-vector to
         :size 1
         :index to-index)
        (copy#byte-vector :from from
                          :from-index (add1 from-index)
                          :to to
                          :to-index (add1 to-index)
                          :size size
                          :counter (add1 counter)))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest fetch#byte-vector
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (fetch#byte-vector :byte-vector k
                              :size 2
                              :index 0))
         ==>
         257))

   (deftest save#byte-vector
       (basic)
     (ensure
         (let ((k (make-array `(4)
                              :element-type '(unsigned-byte 8)
                              :initial-element 1)))
           (save#byte-vector :value 1234
                             :byte-vector k
                             :size 2
                             :index 0)
           (fetch#byte-vector :byte-vector k
                              :size 2
                              :index 0))
         ==>
         1234))
   #+end_src
** ----------------------------------
* stream
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun stream? (x)
     (streamp x))
   #+end_src
** ----------------------------------
** read#char & read#line
   #+begin_src lisp :tangle basic.lisp
   (defun read#char (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-char from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))

   (defun read#line (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-line from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))

   #+end_src
** ----------------------------------
** cat
   #+begin_src lisp :tangle basic.lisp
   ;; (cat (:to *standard-output*)
   ;;   ("~A" 123)
   ;;   ("~A" 456))
   ;; ==>
   ;; (concatenate
   ;;  'string
   ;;  (format *standard-output* "~A" 123)
   ;;  (format *standard-output* "~A" 456))

   ;; (defmacro cat
   ;;     ((&key (to nil))
   ;;      &body form#list-of-list)
   ;;   (let* ((form#list-of-list#2
   ;;           (mapcar (lambda (list) (append `(format ,to) list))
   ;;                   form#list-of-list))
   ;;          (form#final (append '(concatenate (quote string))
   ;;                              form#list-of-list#2)))
   ;;     form#final))



   (defmacro cat
       ((&key (to nil)
              (trim '())
              prefix
              postfix
              letter)
        &body form#list-of-list)
     (let* ((form#list-of-list#2
             (apply (function append)
                    (mapcar (lambda (list)
                              (list prefix
                                    (list 'string-trim trim
                                          (append '(format nil) list))
                                    postfix))
                            form#list-of-list)))
            (form#list-of-list#3
             (append '(concatenate (quote string))
                     form#list-of-list#2))
            (form#final
             (cond ((equal letter :big)
                    (list 'string-upcase form#list-of-list#3))
                   ((equal letter :small)
                    (list 'string-downcase form#list-of-list#3))
                   (:else form#list-of-list#3))))
       `(let ((string-for-return ,form#final))
          (format ,to "~A" string-for-return)
          string-for-return)))

   ;; (cat (:to *standard-output*
   ;;           :trim '(#\Space)
   ;;           :prefix "* "
   ;;           :postfix (cat () ("~%")))
   ;;   ("~A" "      123   ")
   ;;   ("~A" "   456   "))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest cat
       (basic)
     (ensure
         (cat ()
           ("~A" 123)
           ("~A" 456))
         ==>
         "123456"))

   ;; (cat ()
   ;;   ("~A" 123)
   ;;   ("~A" 456))

   ;; (cat (:to *standard-output*)
   ;;   ("~%")
   ;;   ("~A~%" 123)
   ;;   ("~A~%" 456))

   ;; (let ((x 123))
   ;;   (cat (:to *standard-output*)
   ;;     ("~A~%" x)))
   #+end_src
** ----------------------------------
* char
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun char? (x)
     (characterp x))

   (defun char#space? (char)
     (if (not (char? char))
         (error "the argument of (char#space?) must be a char")
         (let ((code (char->code char)))
           (cond ((= code 32) t)
                 ((= code 10) t)
                 (:else nil)))))
   #+end_src
** ----------------------------------
** char->code & code->char
   #+begin_src lisp :tangle basic.lisp
   (defun char->code (char)
     (char-code char))

   (defun code->char (code)
     (code-char code))
   #+end_src
** ----------------------------------
* symbol
** ----------------------------------
** string->symbol & symbol->string
   #+begin_src lisp :tangle basic.lisp
   (defun symbol->string (symbol)
     (symbol-name symbol))

   (defun string->symbol (string)
     (intern string))
   #+end_src
** ----------------------------------
* string
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun string? (x)
     (stringp x))

   (defun string#empty? (string)
     (equal? string ""))

   (defun string#space? (string)
     (if (not (string? string))
         (error "the argument of (string#space?) must be a string")
         (not (position-if
               (lambda (char) (not (char#space? char)))
               string))))
   #+end_src
** ----------------------------------
** dup#string
   #+begin_src lisp :tangle basic.lisp
   (defun dup#string (&key
                        (time 1)
                        string)
     (cond ((= 1 time)
            string)
           (:else
            (concatenate
             'string
             string
             (dup#string :time (sub1 time)
                         :string string)))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest char#space?
       (basic)
     (ensure
         (list (char#space? #\newline)
               (char#space? #\space))
         ==>
         (list t
               t)))

   (deftest string#space?
       (basic)
     (ensure
         (list (string#space? " 123 ")
               (string#space? "  ")
               (string#space? ""))
         ==>
         (list nil
               t
               t)))
   #+end_src
** ----------------------------------
** string->[head|tail|list]#word
   #+begin_src lisp :tangle basic.lisp
   ;; interface:
   ;; (multiple-value-bind
   ;;       (head#word
   ;;        index-end-or-nil
   ;;        index-start
   ;;        string)
   ;;     (string->head#word string)
   ;;   ><><><)

   (defun string->head#word (string)
     (let* ((index-start
             (position-if (lambda (char) (not (char#space? char)))
                          string))
            (index-end-or-nil
             (position-if (lambda (char) (char#space? char))
                          string
                          :start index-start)))
       (values (subseq string
                       index-start
                       index-end-or-nil)
               index-end-or-nil
               index-start
               string)))


   (defun string->tail#word (string)
     (multiple-value-bind
           (head#word
            index-end-or-nil
            index-start
            string)
         (string->head#word string)
       (if (nil? index-end-or-nil)
           nil
           (subseq string index-end-or-nil))))


   (defun string->list#word (string &key (base-list '()))
     (cond
       ((nil? string) base-list)
       ((string#space? string) base-list)
       (:else
        (cons (string->head#word string)
              (string->list#word (string->tail#word string))))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest string->head#word
       (basic)
     (and (ensure
              (list (multiple-value-list (string->head#word " kkk took my baby away! "))
                    (multiple-value-list (string->head#word "k"))
                    (multiple-value-list (string->head#word " k"))
                    (multiple-value-list (string->head#word "k ")))
              ==>
              (list `("kkk" 4 1 " kkk took my baby away! ")
                    `("k" nil 0 "k")
                    `("k" nil 1 " k")
                    `("k" 1 0 "k ")))

          ;; the argument applied to string->head#word
          ;; must not be space-string
          ;; one should use string#space? to ensure this

          ;; just do not handle the error
          ;; let the debuger do its job
          (ensure
              (string->head#word " ")
              signals
              type-error)
          ))


   (deftest string->tail#word
       (basic)
     (ensure
         (list (string->tail#word " kkk took my baby away! ")
               (string->tail#word "just-kkk"))
         ==>
         (list " took my baby away! "
               nil)))


   (deftest string->list#word
       (basic)
     (ensure
         (list (string->list#word " kkk took my baby away! ")
               (string->list#word " kkk")
               (string->list#word "kkk ")
               (string->list#word " ")
               (string->list#word ""))
         ==>
         (list `("kkk" "took" "my" "baby" "away!")
               `("kkk")
               `("kkk")
               `nil
               `nil)))
   #+end_src
** ----------------------------------
** string->[head|tail|list]#line
   #+begin_src lisp :tangle basic.lisp
   ;; interface:
   ;; (multiple-value-bind
   ;;       (head#line
   ;;        index-end-or-nil
   ;;        string)
   ;;     (string->head#line string)
   ;;   ><><><)

   (defun string->head#line (string)
     (let* ((index-end-or-nil
             (position-if (lambda (char) (equal? #\Newline char))
                          string)))
       (values (subseq string
                       0
                       index-end-or-nil)
               index-end-or-nil
               string)))


   (defun string->tail#line (string)
     (multiple-value-bind
           (head#line
            index-end-or-nil
            string)
         (string->head#line string)
       (if (nil? index-end-or-nil)
           nil
           (subseq string (add1 index-end-or-nil)))))


   (defun string->list#line (string &key (base-list '()))
     (cond
       ((nil? string) base-list)
       (:else
        (cons (string->head#line string)
              (string->list#line (string->tail#line string))))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest string->head#line
       (basic)
     (ensure
         (list (string->head#line "123")
               (string->head#line (format nil "~%123"))
               (string->head#line (format nil "123~%")))
         ==>
         `("123"
           ""
           "123")))


   (deftest string->tail#line
       (basic)
     (ensure
         (list (string->tail#line "123")
               (string->tail#line (format nil "~%123"))
               (string->tail#line (format nil "123~%")))
         ==>
         `(nil
           "123"
           "")))


   (deftest string->list#line
       (basic)
     (ensure
         (string->list#line
          (cat (:postfix (cat () ("~%")))
            ("kkk")
            ("took")
            ("")
            ("my baby")
            ("")
            ("away!")
            ("")))
         ==>
         `("kkk"
           "took"
           ""
           "my baby"
           ""
           "away!"
           ""
           "")))
   #+end_src
** ----------------------------------
** string->[head|tail|list]#char
   #+begin_src lisp :tangle basic.lisp
   ;; interface:
   ;; (multiple-value-bind
   ;;       (head#char
   ;;        tail#char
   ;;        string)
   ;;     (string->head#char string)
   ;;   ><><><)

   (defun string->head#char (string)
     (values (char string 0)
             (subseq string
                     1)
             string))


   (defun string->tail#char (string)
     (multiple-value-bind
           (head#char
            tail#char
            string)
         (string->head#char string)
       tail#char))


   (defun string->list#char (string &key (base-list '()))
     (cond
       ((string#empty? string) base-list)
       (:else
        (cons (string->head#char string)
              (string->list#char (string->tail#char string))))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest string->head#char
       (basic)
     (and (ensure
              (list (multiple-value-list (string->head#char " kkk took my baby away! "))
                    (multiple-value-list (string->head#char "k"))
                    (multiple-value-list (string->head#char " k"))
                    (multiple-value-list (string->head#char "k ")))
              ==>
              (list `(#\  "kkk took my baby away! " " kkk took my baby away! ")
                    `(#\k "" "k")
                    `(#\  "k" " k")
                    `(#\k " " "k ")))

          ;; the argument applied to string->head#char
          ;; must not be ""
          ;; one should use string#empty? to ensure this

          ;; just do not handle the error
          ;; let the debuger do its job
          (ensure
              (string->head#char "")
              signals
              type-error)
          ))

   (deftest string->tail#char
       (basic)
     (and (ensure
              (string->tail#char " kkk took my baby away! ")
              ==>
              "kkk took my baby away! ")

          ;; just do not handle the error
          ;; let the debuger do its job
          (ensure
              (string->tail#char "")
              signals
              type-error)
          ))

   (deftest string->list#char
       (basic)
     (ensure
         (list (string->list#char " kkk took my baby away! ")
               (string->list#char " kkk")
               (string->list#char "kkk ")
               (string->list#char " ")
               (string->list#char ""))
         ==>
         (list `(#\  #\k #\k #\k #\  #\t #\o #\o #\k #\  #\m #\y #\  #\b #\a #\b #\y #\  #\a
                     #\w #\a #\y #\! #\ )
               `(#\  #\k #\k #\k)
               `(#\k #\k #\k #\ )
               `(#\ )
               `nil)))
   #+end_src
** ----------------------------------
* pathname
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.lisp
   (defun pathname? (x)
     (pathnamep x))
   #+end_src
** ----------------------------------
** pathname->string & string->pathname
   #+begin_src lisp :tangle basic.lisp
   (defun pathname->string (pathname)
     (if (not (pathname? pathname))
         (error "the argument of (pathname->string) must be a pathname")
         (namestring pathname)))

   (defun string->pathname (string)
     (if (not (string? string))
         (error "the argument of (string->pathname) must be a string")
         (pathname string)))
   #+end_src
** ----------------------------------
* list
** ----------------------------------
** predicate
   #+begin_src lisp :tangle basic.test.lisp
   (defun pair? (x)
     (consp x))

   (defun list? (x)
     (listp x))
   #+end_src
** ----------------------------------
** end-of-list
   #+begin_src lisp :tangle basic.lisp
   (defun end-of-list (list)
     (cond
       ((not (pair? list))
        (error "the argument of (end-of-list) must be a list"))
       (:else
        (help#loop#end-of-list list))
       ))

   (defun help#loop#end-of-list (list)
     (let ((cdr#list (cdr list)))
       (cond
         ((nil? cdr#list)
          (car list))
         ((not (pair? cdr#list))
          (error (concatenate
                  'string
                  "the argument of (end-of-list) must be not only a list~%"
                  "but also a proper-list")))
         (:else
          (help#loop#end-of-list cdr#list))
         )))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest end-of-list
       (basic)
     (and (ensure
              (end-of-list '(1 2 3))
              ==>
              3)
          (ensure
              (end-of-list '(1 2 . 3))
              signals
              simple-error)
          (ensure
              (end-of-list 3)
              signals
              simple-error)))
   #+end_src
** ----------------------------------
** group
   #+begin_src lisp :tangle basic.lisp
   (defun group (list
                 &key
                   (number 2)
                   ;; (pattern '())
                   (base-list '()))
     (cond ((< (length list) 2) base-list)
           (:else
            (cons (list (first list) (second list))
                  (group (cddr list)
                         :number number)))))
   #+end_src
** ----------------------------------
** cons-many
   #+begin_src lisp :tangle basic.lisp
   ;; (cons-many 1 2 '(3 4))
   ;; ==>
   ;; (cons 1
   ;;       (cons 2
   ;;             '(3 4)))

   (defmacro cons-many (&body form)
     (cond
       ((null (cdr form))
        (car form))
       (:else
        `(cons ,(car form)
               (cons-many . ,(cdr form))))))

   ;; (cons-many 1 2 (list 3 4))
   ;; (cons-many (car '(1 2)) (list 3 4))
   ;; (cons-many (list 3 4))

   ;; on error
   ;; (cons-many 1)
   #+end_src
** ----------------------------------
* function
** ----------------------------------
** map-composite-function
   #+begin_src lisp :tangle basic.lisp
   (defun map-composite-function (function-list list)
     (help#reverse#map-composite-function
      (reverse function-list)
      list))

   (defun help#reverse#map-composite-function
       (reversed-function-list
        list)
     (cond
       ((nil? reversed-function-list)
        list)
       (:else
        (mapcar (car reversed-function-list)
                (help#reverse#map-composite-function
                 (cdr reversed-function-list)
                 list)))))
   #+end_src
** ----------------------------------
** multi return value
   #+begin_src lisp :tangle basic.lisp
   (defun return-zero-value ()
     (values))
   #+end_src
** ----------------------------------
* line-list
** ----------------------------------
** edit#line-list
   #+begin_src lisp :tangle basic.lisp
   ;; note the order
   (defun edit#line-list
       (&key
          line-list
          (print-to nil)
          (prefix "")
          (postfix "")
          (indent 0)
          (function-list '()))
     (let* ((line-list-for-return
             (map-composite-function function-list
                                     line-list))
            (line-list-for-return
             (mapcar (lambda (line) (concatenate 'string prefix line))
                     line-list-for-return))
            (line-list-for-return
             (mapcar (lambda (line) (concatenate 'string line postfix))
                     line-list-for-return))
            (line-list-for-return
             (cond ((zero? indent)
                    line-list-for-return)
                   (:else
                    (mapcar (lambda (line) (concatenate 'string (dup#string :time indent :string " ") line))
                            line-list-for-return)))))
       (cond ((nil? print-to)
              line-list-for-return)
             ((stream? print-to)
              (mapcar (lambda (line) (format print-to "~A~%" line))
                      line-list-for-return))
             (:else
              (error "the argument :print-to of (edit#line-list) must be a output stream")))))
   #+end_src
** test
   #+begin_src lisp :tangle basic.test.lisp
   (deftest edit#line-list
       (basic)
     (ensure
         (edit#line-list
          :indent 2
          :prefix "* "
          :postfix "|^-^"
          :function-list
          `(,(lambda (string) (string-trim '(#\space) string)))
          :line-list
          `("  123"
            "456  "))
         ==>
         `("  * 123|^-^"
           "  * 456|^-^")))

   ;; (edit#line-list
   ;;  :indent 2
   ;;  :print-to *standard-output*
   ;;  :prefix "* "
   ;;  :postfix "|^-^"
   ;;  :function-list
   ;;  `(,(lambda (string) (string-trim '(#\space) string)))
   ;;  :line-list
   ;;  `("  123"
   ;;    "456  "))
   #+end_src
** ----------------------------------
* ===================================
