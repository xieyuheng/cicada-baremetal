#+TITLE:  compiler
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* ===================================
* note
** usage in common-lisp
   * [ (: cicada :) ]
** 臨時性
   * 這裏的編譯器是將要被重新實現於蟬語中的
     所以
     其代碼風格趨向蟬語
   * 注意所處理的都是字符串 而不是 stream
   * 難點在於
     在這裏就要形成 所謂的 語境 概念
     所定義的是一個語境而已
     這個語境中 保留了 forth 的語法的傳統
     但是這裏不能使用虛擬機中的 姓名 機制來實現 語境
     也沒有必要這樣做
     因爲這裏的語境是單一的
   * 使用一個解釋器
     而不把解釋器實現爲 編譯後執行
* -----------------------------------
* file header
** compiler.lisp
   #+begin_src lisp :tangle compiler.lisp
   (in-package :cicada-vm)
   #+end_src
** compiler.test.lisp
   #+begin_src lisp :tangle compiler.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* cicada-compiler
** 記 cicada-compiler 的受限語法
   * 解釋器的語法是受限制的
     爲了實現起來簡單
   * ":" ";" 這兩個語法關鍵詞 作爲 bar-ket
     期間的字符串會被 (define-function) (define-variable) 這類函數處理
** cicada-compiler
   #+begin_src lisp :tangle compiler.lisp
   (defparameter *string#cicada-compiler* "")
   (defparameter *cursor#cicada-compiler* 0)


   (defparameter *string#define-function* "")
   (defparameter *cursor#define-function* 0)


   ;; the following function is to be used in (: cicada :)
   (defun cicada-compiler (string)
     (set! *string#cicada-compiler* string)
     (set! *cursor#cicada-compiler* 0)
     (help#cicada-compiler))

   (defun help#cicada-compiler ()
     (let ((next-word (next-word!
                       :string *string#cicada-compiler*
                       :cursor *cursor#cicada-compiler*)))
       (cond ((equal? ":" next-word)
              (let* ((start-index *cursor#cicada-compiler*)
                     (end-index (let ((find-cursor
                                       (find-word!
                                        :word ";"
                                        :string *string#cicada-compiler*
                                        :cursor *cursor#cicada-compiler*)))
                                  (if (nil? find-cursor)
                                      (orz ()
                                        ("when calling (cicada-compiler)~%")
                                        (": and ; as bar-ket must be balance~%")))))
                     (string (subseq string
                                     start-index
                                     end-index))
                     (next-word (progn (next-word!
                                        ;; over ";"
                                        :string *string#cicada-compiler*
                                        :cursor *cursor#cicada-compiler*)
                                       (next-word!
                                        ;; the next-word to return
                                        :string *string#cicada-compiler*
                                        :cursor *cursor#cicada-compiler*))))
                (cond ((equal? "(define-function)" next-word)
                       (define-function string))
                      (:else
                       (orz ()
                         ("when calling (cicada-compiler)~%")
                         ("the word after ; must be (define-function) but not ~A ~%" next-word)))))
              (help#cicada-compiler))
             ((equal? :no-more-word next-word)
              :ok)
             (:else
              (orz ()
                ("when calling (cicada-compiler)~%")
                ("the first word must be : but not ~A ~%" next-word))))))
   #+end_src
** 記 define-function 的工作方式
   * 一詞一詞 或 一字一字 而向前移動光標
     移動光標的函數會返回所經過的詞或字
     由相關的謂詞進行判斷
   * compile to buffer (instead of compile to "dictionary")
     write buffer to file
     when needed load file to vector-function-heap
** define-function
   #+begin_src lisp :tangle compiler.lisp
   (defparameter *buffer#define-function*
     (make#vector :length (mul 1024 1024)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   (defparameter *current-free-address#buffer#define-function* 0)

   (defun define-function (string)
     (set! *string#define-function* string)
     (set! *cursor#define-function* 0)
     (help#define-function))

   (defun help#define-function ()
     (let ((next-word (next-word!
                       :string *string#define-function*
                       :cursor *cursor#define-function*)))
       (cond ((function-call?#word next-word)
              (let ((function-name
                     (function-call->function-name#word next-word)))
                ()))
             ((equal? :no-more-word next-word)
              :ok)
             (:else
              (orz ()
                ("when calling (define-function)~%")
                ("the word in the body must be a function call but not ~A ~%" next-word))))))

   (defun function-call?#word (word)
     (and (equal? "(" (string->head#char word))
          (equal? ")" (string->end#char word))))

   (defun function-call->function-name#word (word)
     (subseq word 1 (sub1 (length word))))
   #+end_src
** test
   #+begin_src cicada
   [ (: cicada :)

   : string->char
     (* string[address, length] -- char *)
     (* drop fetch-byte *)
     get-char
     xx|swap|x drop2
     Exit
   ; define-verb

   : <string> (->char)
     (@ <string> -- <char> @)
     (char) (* drop fetch-byte *)
     (xx|swap|x) (drop 2)
   ; (define-verb)

   : <string> ->char
     (@ <string> -- <char> @)
     char (* drop fetch-byte *)
     xx|swap|x drop2
   ; define-verb

   ]
   #+end_src
* -----------------------------------
* vector-function-heap
** note
   * vector-function-heap is a data-section
     one address is always relative to one data-section
* vector-function
** 記
   * 函數體 中所保存的是線串碼[threaded-code][一串珠]
     也可以說一個函數體就是被線穿起來的一串珠子[bead]
     每個珠子是兩個物 一爲指令 二爲指令之參數
     不同的指令的參數個數可以不同 也就是說珠子有大有小
   * 函數頭 中保存約束變元的信息
     還有返回值的信息
     還關於副作用類型的信息
** fetch & save
   #+begin_src lisp :tangle compiler.lisp
   (defun fetch#vector-function-body ())
   (defun save#vector-function-body ())
   #+end_src
* -----------------------------------
* ===================================
