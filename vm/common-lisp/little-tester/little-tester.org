#+TITLE:  little-tester for common-lisp
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
  * 整理數據結構
* ===================================
* note
* -----------------------------------
* (in-package :cicada-vm)
** little-tester.lisp
   #+begin_src lisp :tangle little-tester.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* note
  * syntax:
    #+begin_src lisp
    (define-test-group name &optional opts docstring)
    ;; => group
    #+end_src
  * arguments:
    | name      | a symbol        |
    | opts      | a property list |
    | docstring | a string        |
  * description:
    * Defines a group of tests with the given name.
      OPTS may contain the keys :before and :after,
      whose values should be functions (or lambda expressions)
      to be called before and after all tests in the group have been test.
    * If the group already exists,
      the :before and :after functions are updated;
      the docstring
      and any tests already defined in the group
      are left unchanged.
* the test-group
  #+begin_src lisp :tangle little-tester.lisp
  (defun required-argument ()
    (error "A required argument was not supplied."))

  (defstruct (test-group (:constructor make-test-group
                                       (name &key
                                             pre
                                             post
                                             docstring))
                         (:print-function %print-test-group))
    (name (required-argument)
          :type symbol
          :read-only t)
    (docstring nil
               :type (or null simple-base-string)
               :read-only t)
    (tests (make-hash-table)
           :type hash-table
           :read-only t)
    (pre nil
         :type (or null function))
    (post nil
          :type (or null function)))

  (defun %print-test-group (group stream depth)
    (declare (ignore depth))
    (print-unreadable-object (group stream :type t :identity t)
      (format stream "~S, ~D tests" (test-group-name group)
              (hash-table-count (test-group-tests group)))))
  #+end_src
* find-test-group & define-test-group
  #+begin_src lisp :tangle little-tester.lisp
  (defun find-test-group (name &optional create)
    (if (test-group-p name)
        name
        (let ((group (get name 'tests)))
          (cond (group group)
                (create
                 (setf (get name 'tests)
                       (make-test-group name)))))))

  (defmacro define-test-group (name &optional opts docstring)
    (let ((tmp (gensym "GROUP"))
          (pre (gensym))
          (post (gensym)))
      `(let ((,tmp (find-test-group ',name))
             (,pre ,(getf opts :before))
             (,post ,(getf opts :after)))
         (if (null ,tmp)
             (setf (get ',name 'tests) (make-test-group ',name
                                                        :pre ,pre
                                                        :post ,post
                                                        :docstring ',docstring))
             (progn
               (when ,pre (setf (test-group-pre ,tmp) ,pre))
               (when ,post (setf (test-group-post ,tmp) ,post))
               ,tmp)))))
  #+end_src
* -----------------------------------
* note
  * syntax:
    #+begin_src lisp
    (deftest name
        (group :after
               :after-pass
               :after-fail
               :when
               :unless
               :priority )
      body)
    ;; => name
    #+end_src
  * arguments:
    | name       | a symbol                                 |
    | group      | a symbol                                 |
    | after      | a symbol or a list                       |
    | after-pass | a symbol or a list                       |
    | after-fail | a symbol or a list                       |
    | when       | a Lisp form                              |
    | unless     | a Lisp form                              |
    | priority   | a fixnum                                 |
    | body       | Lisp forms;                              |
    |            | may include declarations and a docstring |
  * description:
    * Defines a test with the given name
      to be a member of the named group.
      If the group isn't yet defined,
      this defines it.
    * The body should perform the test
      and return
      T if it succeeds
      NIL if it fails.
      Signalling an error is also a failure.
    * The keyword arguments control the order and conditions
      under which the test is test:
      * after
      * after-pass
      * after-fail
      may be either the name of an individual test
      or a list of names.
      This test will run after the test(s) named;
      tests named in the after-pass argument must pass
      before this test will be allowed to run,
      and tests named in the after-fail argument must fail
      before this test will be allowed to run.
    * The when and unless arguments
      are forms to be evaluated,
      which return a true value if the test is to be
      performed (for when)
      or skipped (for unless),
      and NIL otherwise.
    * The priority argument is a number;
      tests with lower priority values
      run earlier than tests with higher priority values,
      subject to the after, after-pass and after-fail constraints.
      If priority is not supplied,
      and a test with the given name already exists,
      the priority is left unchanged;
      if the test does not already exist
      the priority defaults to the number of tests defined so far,
      so tests tend to run in the order they're defined.
    * DEFTEST defines a function named TEST-name/group,
      which can be called manually
* the test
  #+begin_src lisp :tangle little-tester.lisp
  (defstruct (test (:constructor
                    make-test
                    (name fn
                          &key
                          after
                          after-pass
                          after-fail
                          when
                          unless
                          priority
                          docstring))
                   (:print-function %print-test))
    (name (required-argument)
          :type symbol
          :read-only t)
    (docstring nil
               :type (or null simple-base-string)
               :read-only t)
    (fn (required-argument)
        :type function
        :read-only t)
    (priority 0
              :type fixnum)
    (after '()
           :type list)
    (after-pass '()
                :type list)
    (after-fail '()
                :type list)
    (when  nil  :type (or null function))
    (unless nil :type (or null function))
    )

  (defun %print-test (test stream depth)
    (declare (ignore depth))
    (print-unreadable-object (test stream :type t :identity t)
      (princ (test-name test) stream)))
  #+end_src
* deftest
  #+begin_src lisp :tangle little-tester.lisp
  (defmacro deftest
      (test-name
       (group &key
              after
              after-pass
              after-fail
              when unless
              priority)
       &body body)
    (multiple-value-bind
          (body
           decls
           doc)
        (help#parse-body#deftest body nil t)
      (let* ((test-function-name
              (intern (concatenate 'string
                                   #.(string '#:test-)
                                   (string test-name)
                                   "/"
                                   (string group))))
             (hash (gensym "HASH"))
             (keys (append
                    ;; symbol or list of symbol
                    (cond ((consp after)      `(:after       (quote ,after)))
                          (after              `(:after       (quote (,after)))))
                    (cond ((consp after-pass) `(:after-pass  (quote ,after-pass)))
                          (after-pass         `(:after-pass  (quote (,after-pass)))))
                    (cond ((consp after-fail) `(:after-fail  (quote ,after-fail)))
                          (after-fail         `(:after-fail  (quote (,after-fail)))))

                    (when when   `(:when   (lambda () ,when)))
                    (when unless `(:unless (lambda () ,unless)))
                    (when doc `(:docstring ,doc))
                    (if priority
                        `(:priority ,priority)
                        `(:priority (if (gethash (quote ,test-name) ,hash)
                                        (test-priority
                                         (gethash (quote ,test-name) ,hash))
                                        (hash-table-count ,hash)))))))
        `(progn
           (defun ,test-function-name ()
             ,doc
             ,@decls
             (block ,test-name
               ,@body))
           (let ((,hash (test-group-tests (find-test-group (quote ,group) t))))
             (when (gethash (quote ,test-name) ,hash) (warn "Redefining test ~A." (quote ,test-name)))
             (setf (gethash (quote ,test-name) ,hash)
                   (make-test (quote ,test-name)
                              (function ,test-function-name)
                              ,@keys)))
           (quote ,test-name)))))


  (defun help#parse-body#deftest (body env &optional doc-p)
    (declare (ignore env))
    (let ((decls '())
          (doc nil))
      (loop (cond
              ((and (consp (first body))
                    (eq (first (first body))
                        'declare))
               (push (pop body) decls))

              ((and doc-p
                    (null doc)
                    (stringp (first body)))
               (setq doc (pop body)))

              (:else
               (return (values body
                               (nreverse decls)
                               doc))
               )))))
  #+end_src
* -----------------------------------
* note
  * syntax:
    #+begin_src lisp
    (ensure
        form
        =>
        value)
    ;; => boolean

    (ensure
        form
        signals
        condition)
    ;; => boolean
    #+end_src
  * arguments:
    | form    | a Lisp form              |
    | =>      | a symbol named "=>"      |
    | signals | a symbol named "SIGNALS" |
    | value   | a Lisp form              |
  * description:
    * The first form ensures that form evaluates to value,
      printing a short report if the test fails.
      The test is done using EQUALP.
      The number of values returned is also checked.
    * The second form ensures that the form signals the named condition,
      printing a short report if the test fails.
* help#==>#ensure
  #+begin_src lisp :tangle little-tester.lisp
  (defmacro help#==>#ensure
      (&key
         actual-form
         expect-form)

    `(handler-case (values (multiple-value-list ,actual-form)
                           (multiple-value-list ,expect-form))

       ;; if a condition occur
       ;; :actual-form or :expect-form
       ;; match the condition's type to the following cases

       (simple-error (condition)
         (values nil
                 (cat (:trim (cat () ("~%")))
                   ((cat (:postfix (cat () ("~%")))
                      ("#+begin_src lisp")
                      (";; [ACTUAL-FORM]")
                      ("~S" (quote ,actual-form))
                      ("")
                      (";; [EXPECT-FORM]")
                      ("~S" (quote ,expect-form))
                      ("")
                      (";; [ACTUAL-CONDITION when evaluating the forms]")
                      ("~A" (apply (function format) nil
                                   (simple-condition-format-control condition)
                                   (simple-condition-format-arguments condition)))
                      ("#+end_src"))))))

       (error (condition)
         (values nil
                 (cat (:trim (cat () ("~%")))
                   ((cat (:postfix (cat () ("~%")))
                      ("#+begin_src lisp")
                      (";; [ACTUAL-FORM]")
                      ("~S" (quote ,actual-form))
                      ("")
                      (";; [EXPECT-FORM]")
                      ("~S" (quote ,expect-form))
                      ("")
                      (";; [ACTUAL-CONDITION when evaluating the forms]")
                      ("~A" condition)
                      ("#+end_src"))))))

       ;; the following names are bound by VALUES
       (:no-error (actual-value-list
                   expect-value-list)
         (cond ((not (and (= (length actual-value-list)
                             (length expect-value-list))
                          (every (function equalp)
                                 actual-value-list
                                 expect-value-list)))
                (values nil
                        (cat (:trim (cat () ("~%")))
                          ((cat (:postfix (cat () ("~%")))
                             ("#+begin_src lisp")
                             (";; [ACTUAL-FORM]")
                             ("~S" (quote ,actual-form))
                             ("")
                             (";; [EXPECT-VALUE]")
                             ("~{~S~^~%~17T~}" expect-value-list)
                             ("")
                             (";; [ACTUAL-VALUE]")
                             ("~{~S~^~%~15T~}" actual-value-list)
                             ("#+end_src"))))))
               (:else
                (values t
                        "ensure successed ^-^"))
               ))))

  ;; (ensure
  ;;     (values 1 2 3 4 5)
  ;;     ==>
  ;;     (values 1 2 3 4 5))

  ;; ><><><
  ;; (ensure
  ;;     (values 1 2 3 4 5)
  ;;     ==>
  ;;     (values 5 4 3 2 1))

  ;; (ensure
  ;;     (list (be :name (string->name "kkk")
  ;;               :as (string->name "took")
  ;;               :mean "my baby away!")
  ;;           (multiple-value-list
  ;;            (be :name (string->name "kkk")
  ;;                :as (string->name "took")
  ;;                :mean "my baby away!"))
  ;;           (multiple-value-list
  ;;            (explain :name (string->name "kkk")
  ;;                     :as (string->name "took"))))
  ;;     ==>
  ;;     (list 1
  ;;           `(2
  ;;             :UPDATED!!!
  ;;             "my baby away!")
  ;;           `("my baby away!"
  ;;             :found!!!)))

  ;; (ensure
  ;;     (string->head#char "")
  ;;     ==>
  ;;     '><><><)

  ;; (ensure
  ;;     (error "testing (ensure)")
  ;;     ==>
  ;;     '><><><)
  #+end_src
* help#signals#ensure
  #+begin_src lisp :tangle little-tester.lisp
  (defmacro help#signals#ensure
      (&key
         actual-form
         expect-condition)

    `(handler-case (multiple-value-list ,actual-form)

       (,expect-condition () t)

       (simple-error (condition)
         (cat (:trim (cat () ("~%")))
           ((cat (:postfix (cat () ("~%")))
              ("#+begin_src lisp")
              (";; [ACTUAL-FORM]")
              ("~S" (quote ,actual-form))
              ("")
              (";; [EXPECT-CONDITION]")
              ("~S" (quote ,expect-condition))
              ("")
              (";; [ACTUAL-CONDITION]")
              ("~A" (apply (function format) nil
                           (simple-condition-format-control condition)
                           (simple-condition-format-arguments condition)))
              ("#+end_src")))))

       (error (condition)
         (cat (:trim (cat () ("~%")))
           ((cat (:postfix (cat () ("~%")))
              ("#+begin_src lisp")
              (";; [ACTUAL-FORM]")
              ("~S" (quote ,actual-form))
              ("")
              (";; [EXPECT-CONDITION]")
              ("~S" (quote ,expect-condition))
              ("")
              (";; [ACTUAL-CONDITION]")
              ("~A" condition)
              ("#+end_src")))))

       (:no-error (actual-value-list)
         (cat (:trim (cat () ("~%")))
           ((cat (:postfix (cat () ("~%")))
              ("#+begin_src lisp")
              (";; [ACTUAL-FORM]")
              ("~S" (quote ,actual-form))
              ("")
              (";; [EXPECT-CONDITION]")
              ("~S" (quote ,expect-condition))
              ("")
              (";; [ACTUAL-VALUE]")
              ("~{~S~^~%~10T~}" actual-value-list)
              ("#+end_src")))))))

  ;; (ensure
  ;;     (string->head#char "")
  ;;     signals
  ;;     type-error)

  ;; (ensure
  ;;     (string->head#char "")
  ;;     signals
  ;;     error)

  ;; (ensure
  ;;     (string->head#char "")
  ;;     signals
  ;;     simple-error)
  #+end_src
* ensure
  #+begin_src lisp :tangle little-tester.lisp
  ;; (multiple-value-bind
  ;;       (success?
  ;;        report-string)
  ;;     (ensure string)
  ;;   '><><><)

  (defmacro ensure (left-expression
                    infix-notation
                    right-expression)
    (cond
      ((string-equal infix-notation '==>)
       `(help#==>#ensure :actual-form ,left-expression
                         :expect-form ,right-expression))

      ((string-equal infix-notation 'signals)
       `(help#signals#ensure :actual-form ,left-expression
                             :expect-condition ,right-expression))

      (:else
       (error "unknown infix-notation of the macro (ensure)"))
      ))
  #+end_src
* -----------------------------------
* note
  * syntax:
    #+begin_src lisp
    (all-tests group)

    ;; => list
    #+end_src
  * arguments:
    | group | a symbol naming a group of tests |
  * description:
    * Retrieve a list of the (names of) tests in the group,
      in the order in which they will be run.
* all-tests
  #+begin_src lisp :tangle little-tester.lisp
  (defun all-tests (group)
    (let* ((group (find-test-group group))
           (tests (loop for x being the hash-values of (test-group-tests group)
                     collecting x))
           (constraints '()))
      (dolist (test tests)
        (dolist (val (test-after test))
          (push (cons val (test-name test)) constraints))
        (dolist (val (test-after-pass test))
          (push (cons val (test-name test)) constraints))
        (dolist (val (test-after-fail test))
          (push (cons val (test-name test)) constraints)))
      (help#topological-sort#all-tests (map-into tests #'test-name tests) constraints
                        (lambda (x y)
                          (declare (ignore y))
                          (first (stable-sort (copy-seq x) #'<
                                              :key (lambda (name)
                                                     (test-priority
                                                      (gethash name (test-group-tests group))))))))))

  (defun help#topological-sort#all-tests (elements constraints tie-breaker)
    (let ((result '()))
      (loop
         (let* ((rhs (mapcar #'cdr constraints))
                (elts (remove-if (lambda (x) (member x rhs)) elements)))
           (when (null elts)
             (if elements
                 (error "Inconsistent constraints in ~S" 'help#topological-sort#all-tests)
                 (unless elements (return (nreverse result)))))
           (let ((elt
                  (if (cdr elts) (funcall tie-breaker elts result) (car elts))))
             (push elt result)
             (setq elements (delete elt elements))
             (setq constraints (delete-if (lambda (x)
                                            (or (eq (car x) elt)
                                                (eq (cdr x) elt)))
                                          constraints)))))))
  #+end_src
* -----------------------------------
* note
  * syntax:
    #+begin_src lisp
    (run group
         :skip
         :break-on-fail )
    ;; => boolean
    #+end_src
  * arguments:
    | group         | a symbol naming a group of tests |
    | skip          | a list                           |
    | break-on-fail | a (generalized) boolean          |
  * description:
    * Runs all of the runnable tests in the group,
      printing a pass or fail message for each test,
      and the processor time used.
    * A list of tests to be skipped
      can be supplied in the SKIP argument
      (any tests which depend on those tests will also be skipped)
    * The return value is
      NIL if any test failed,
      T otherwise.
      This allows test groups to be nested
      by simply writing a DEFTEST
      whose body runs the nested test group.
* run-unit
  #+begin_src lisp :tangle little-tester.lisp
  (defparameter *report-time?* nil)

  (defun run-unit
      (group &key
               (skip nil))
    (let* ((group (find-test-group group))
           (passed '())
           (failed '())
           (report-pathname
            (merge-pathnames (make-pathname
                              :directory ".unit-test-report-center"
                              :name (cat (:letter :small)
                                      ("~A" (test-group-name group))
                                      (".unit-test-report.org")))
                             (user-homedir-pathname)))
           (report-stream (open report-pathname
                                :direction :output
                                :if-exists :supersede)))

      (when (test-group-pre group)
        (funcall (test-group-pre group)))

      (unwind-protect
           (dolist (name (all-tests group))
             (tagbody
              try-again
                (let ((test (gethash name (test-group-tests group))))
                  (unless (or (member name skip)
                              (and (test-when test)
                                   (not (funcall (test-when test))))
                              (and (test-unless test)
                                   (funcall (test-unless test)))
                              (set-difference (test-after-pass test) passed)
                              (set-difference (test-after-fail test) failed))
                    (multiple-value-bind
                          (pass?
                           report-string
                           time)
                        (help#do-test#run-unit test)

                      ;; about time used
                      (let ((test-time-string
                             (if (not *report-time?*)
                                 ""
                                 (multiple-value-bind (hours time) (floor time 3600)
                                   (multiple-value-bind (minutes seconds) (floor time 60)
                                     (cat ()
                                       ("[~2,'0D:~2,'0D:~5,2,,,'0F]"
                                        hours minutes seconds)))))))                      
                        ;; main report
                        (cond ((not pass?)
                               (push name failed)
                               (cat (:to report-stream
                                         :postfix (cat () ("~%")))
                                 ("* >< ~A  ~A" name test-time-string)
                                 ("  * failed"))
                               (edit#line-list
                                :print-to report-stream
                                :indent 4
                                :line-list
                                (string->list#line (cat () ("~A" report-string)))))
                              (:else
                               (push name passed)
                               (cat (:to report-stream
                                         :postfix (cat () ("~%")))
                                 ("* ~A  ~A" name test-time-string)))))                  
                      )))))

        (when (test-group-post group)
          (funcall (test-group-post group))))

      (let ((pass (length passed))
            (fail (length failed))
            (total (hash-table-count (test-group-tests group))))

        (cat (:to *standard-output*)
          ("~%")
          ("in unit ~S~%"
           (test-group-name group)))
        (when failed
          (cat (:to *standard-output*)
            ("The following tests failed:~%")
            ("~S~%" failed)))
        (cat (:to *standard-output*)
          ("Totals -- Passed: ~D~25T~3D%~&~10TFailed: ~D~25T~3D%~%"
           pass
           (round (* 100 pass) total)
           fail
           (round (* 100 fail) total))
          ("report write to: ~A~%" report-pathname)))

      (close report-stream)

      (null failed)
      ))



  ;; interface:
  ;; (multiple-value-bind
  ;;       (pass?
  ;;        report-string
  ;;        time)
  ;;     (help#do-test#run-unit test)
  ;;   '><><><)
  (defun help#do-test#run-unit (test)
    (let ((time (get-internal-run-time)))
      (multiple-value-bind
            (success?
             report-string)
          (ignore-errors
            (funcall (test-fn test)))
        (values success?
                report-string
                (/ (float (- (get-internal-run-time) time) 1f0)
                   (float internal-time-units-per-second 1f0))))))
  #+end_src
* ===================================
