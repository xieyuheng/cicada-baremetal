#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** refine the interface of primitive-function-table & primitive-instruction-table
** interface to cicada image buffer
** primitive-function-table 的合理性
   * 我想 以 primitive 爲名的數據類型中
     還有很多東西要被 table 來實現
** type check of function
   * load-file
     the argument :file should be of path type
** about io
   * 總應該使用 record 來記錄 io
     record 是可以被作爲一等公民處理的
   * record 應該可以被過濾
     設計數據結構的時候需要考慮這一點
   * 並且 record 的順序是極端重要的
   * 輸入設備所產生的 record
     將被作爲 消息 傳遞給 一個 底層的 loop
     這在於 repl 並應該在回車的時候執行代碼
     而應該有一個特殊的按鍵來控制代碼的執行
     如果以 每次鍵盤的擊鍵爲輸入的話
     repl 其實就是一個小型的文本編輯器了
** write image file
** vector-function
** the funciton (next)
** parsing image file
** cicada-rhapsody
** first version
   * without database of symbol usage
   * without resolving symbols
   * move let modules become packages
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  (defsystem #:cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module #:package-header
              :components
              ((:file "package-header")))
     (:module #:basic
              :components
              ((:file "basic")))
     (:module #:little-tester
              :components
              ((:file "little-tester")))
     (:module #:basic.test :pathname "basic"
              :components
              ((:file "basic.test"
                      :if-feature :with-little-test)))
     (:module #:cicada-rhapsody
              :components
              ((:file "cicada-rhapsody")
               (:file "cicada-rhapsody.test"
                      :if-feature :with-little-test)))
     ;; (:module #:ghost-in-shell
     ;;          :components
     ;;          ((:file "ghost-in-shell")
     ;;           (:file "ghost-in-shell.test"
     ;;                  :if-feature :with-little-test)))
     (:file "cicada-vm")
     (:file "cicada-vm.test"
            :if-feature :with-little-test)
     ))
  #+end_src
* ===================================
* note
** cicada vm
   * cicada vm is
     a threaded-code interpreter
     with a hash-table of string which is called name-table
   * the way used to implement
     a forth inner interpreter in assembly language
     is used to design this vm
   * it will be easy to implement this vm in both
     low-level language as assembly
     and high-level language as common-lisp
   * an image file is as an executable [linkable] format
   * when a image file is loaded to *cicada-image-buffer*
     host language can provide many run-time supports
     but run-time independent compile must be supported too
   * when compiling to cicada language to image file
     the compiler maintains a database of symbol-address binding
     the database records all the use of every symbol
     the database helps one to
     NOT care about the encoding of instruction and title
   * value of symbol
     need to be updated
     address of primitive-function and primitive-instruction
     need to be updated
   * when vm interpreting image file
     it reads the database first
     and resolves the symbol in the image file
     meanwhile updating the database
     only after then
     the vm can begin interpreting the image file
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
* -----------------------------------
* file header
** cicada-vm.lisp
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package :cicada-vm)
   #+end_src
** cicada-vm.test.lisp
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* cicada-object
** ----------------------------------
** note cicada-object
   * cicada-object only exist in cicada-object-vector
     for example *return-stack*
** cell-unit
   * a cell is of *cell-unit* many bytes
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* (/ *size#fixnum* 8)) ;; unit byte
   #+end_src
** ----------------------------------
** cicada-object-vector?
   * an object is two cell
     one for title (an index into title-table)
     one for value (of which the meaning is depended on its title)
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))

   (defun cicada-object-vector? (cicada-object-vector)
     (and (equal? '(unsigned-byte 8)
                  (array-element-type cicada-object-vector))
          (zero? (mod (length cicada-object-vector)
                      ,*cicada-object-size*))))
   #+end_src
** ----------------------------------
** [save|fetch]#[title|value]#cicada-object-vector
   * index
     into byte-vector
     element size *cicada-object-size*
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun save#title#cicada-object-vector
       (&key
          title
          cicada-object-vector
          index)
     (save#byte-vector :value title
                       :byte-vector cicada-object-vector
                       :size *cell-unit*
                       :index (mul *cicada-object-size*
                                   index)))

   (defun save#value#cicada-object-vector
       (&key
          value
          cicada-object-vector
          index)
     (save#byte-vector :value value
                       :byte-vector cicada-object-vector
                       :size *cell-unit*
                       :index (add *cell-unit*
                                   (mul *cicada-object-size*
                                        index))))


   (defun fetch#title#cicada-object-vector
       (&key
          cicada-object-vector
          index)
     (fetch#byte-vector :byte-vector cicada-object-vector
                        :size *cell-unit*
                        :index (mul *cicada-object-size*
                                    index)))

   (defun fetch#value#cicada-object-vector
       (&key
          cicada-object-vector
          index)
     (fetch#byte-vector :byte-vector cicada-object-vector
                        :size *cell-unit*
                        :index (add *cell-unit*
                                    (mul *cicada-object-size*
                                         index))))
   #+end_src
** ----------------------------------
** cicada-object-pointer?
** ----------------------------------
* title.name-table
** ----------------------------------
** note title
   * every object have a title
     title is the way I used to manage nameing of things
     a title could be viewed as
     a type
     a module
     a structure
   * a title is a index into title.name-table
     the index is used as the encoding of that title
     there is only one title.name-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (be)
       <field
       <update?
     * <title
       <name
       (ask)
       <object
       <find?
** ----------------------------------
** title-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title.name-table* 1000)

   (defparameter *size#entry#title.name-table* 100)

   (defparameter *title.name-table*
     ;; should be a byte-vector in assembly version
     (make-array
      `(,*size#title.name-table* ,*size#entry#title.name-table*)
      ;; note that
      ;; this table's element can be of any type
      ;; but actually
      ;; (i 0) must be an name[index] to name-hash-table
      ;; (i n) must be a vector of
      ;; #( name[index] title[index] value )
      :initial-element 0))

   ;; the first entry of *title.name-table* reserved
   ;; for *name-hash-table*
   ;; to test if a name in *name-hash-table*
   ;; is used as title or not
   (defparameter *pointer#title.name-table* 1)
   #+end_src
** title?
   * index-within-title.name-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (index)
     (and (natural-number? index)
          (< index *size#title.name-table*)))
   #+end_src
** ----------------------------------
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let* ((name (string->name string))
            (index-for-title
             (fetch#vector :vector *name-hash-table#index-for-title*
                           :index name)))
       (cond
         ((not (zero? index-for-title))
          index-for-title)

         ((< *pointer#title.name-table*
             ,*size#title.name-table*)
          ;; now
          ;; *pointer#title.name-table* is pointing to
          ;; the next free to use index
          ;; in the *title.name-table*

          ;; save title[index] to *name-hash-table#index-for-title*
          (save#vector :value *pointer#title.name-table*
                       :vector *name-hash-table#index-for-title*
                       :index name)

          ;; save name[index] to *title.name-table*
          (save#array :value name
                      :array *title.name-table*
                      :index-vector (vector *pointer#title.name-table* 0))

          ;; to update *pointer#title.name-table*
          ;; is to allocate a new index in the *title.name-table*
          (add1! *pointer#title.name-table*)

          ;; return value
          (sub1 *pointer#title.name-table*))

         (:else
          (error (cat ()
                   ("title.name-table is filled~%")
                   ("(string->title) can not make new title~%")))))))
   #+end_src
** title->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->name (title)
     (if (not (title? title))
         (error "the argument of (title->name) must be a title")
         (fetch#array
          :array *title.name-table*
          :index-vector
          (vector title 0))))
   #+end_src
** title->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->string (title)
     (if (not (title? title))
         (error "the argument of (title->string) must be a title")
         (name->string (title->name title))))
   #+end_src
** print-title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-title (title &key (stream t))
     (if (not (title? title))
         (error "the argument of (print-title) must be a title")
         (print-name (title->name title)
                     :stream stream)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print-title
       (cicada-vm)
     (ensure
         (print-title (string->title "kkk")
                      :stream nil)
         ==>
         "[kkk]"))
   #+end_src
** ----------------------------------
** be
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin be
     .field ;; index
     .update?)
   (defun be
       (&key
          title
          name
          title#object
          value#object)
     (cond
       ((not (title? title))
        (error "the argument :title of (be) must be a title"))
       ((not (name? name))
        (error "the argument :name of (be) must be a name"))
       ((not (title? title#object))
        (error "the argument :title#object of (be) must be a title"))
       (:else
        (help#be
         :title title
         :name name
         :title#object title#object
         :value#object value#object))))


   (defun help#be
       (&key
          title
          name
          title#object
          value#object
          (field 1))
     (let ((content-of-field
            (fetch#array
             :array *title.name-table*
             :index-vector `#(,title ,field))))
       (cond
         ;; creat new
         ((zero? content-of-field)
          (save#array
           :value (vector name
                          title#object
                          value#object)
           :array *title.name-table*
           :index-vector `#(,title ,field))
          (values field
                  nil))
         ;; update
         ((equal? name
                  (fetch#vector
                   :vector content-of-field
                   :index 0))
          (save#array
           :value (vector name
                          title#object
                          value#object)
           :array *title.name-table*
           :index-vector `#(,title ,field))
          (values field
                  :updated!!!))
         ;; next
         ((< field *size#entry#title.name-table*)
          (help#be :title title
                   :name name
                   :title#object title#object
                   :value#object value#object
                   :field (add1 field)))
         ;; filled
         (:else
          (error "the names under this title is too filled (be) can not do")))))
   #+end_src
** ask
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin ask
     .title
     .value
     .found?)
   (defun ask
       (&key
          title
          name)
     (cond ((not (title? title))
            (error "the argument :title of (ask) must be a title"))
           ((not (name? name))
            (error "the argument :name of (ask) must be a name"))
           (:else
            (help#ask :title title
                      :name name))))

   (defun help#ask
       (&key
          title
          name
          (field 1))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title ,field))))
       (cond
         ;; not found
         ((zero? content-of-field)
          (values 0
                  0
                  nil))
         ;; found
         ((equal? name
                  (fetch#vector :vector content-of-field
                                :index 0))
          (let ((vector#name-title-value
                 (fetch#array :array *title.name-table*
                              :index-vector `#(,title ,field))))
            (values (fetch#vector :vector vector#name-title-value
                                  :index 1)
                    (fetch#vector :vector vector#name-title-value
                                  :index 2)
                    :found!!!)))
         ;; next
         ((< field *size#entry#title.name-table*)
          (help#ask :title title
                    :name name
                    :field (add1 field)))
         ;; filled
         (:else
          (error (cat ()
                   ("can not ask for the object under the name as you wish~%")
                   ("and the names under this title is too filled")))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest be--and--ask
       (cicada-vm)
     (ensure
         (list (be :title (string->title "kkk")
                   :name (string->name "took")
                   :title#object (string->title "my")
                   :value#object 666)
               (with (be :title (string->title "kkk")
                         :name (string->name "took")
                         :title#object (string->title "my")
                         :value#object 666)
                 (list .field .update?))
               (with (ask :title (string->title "kkk")
                          :name (string->name "took"))
                 (list .title .value .found?)))
         ==>
         `(1

           (1
            :UPDATED!!!)

           (,(string->title "my")
             666
             :FOUND!!!)

           )))
    #+end_src
** ----------------------------------
* name-hash-table
** ----------------------------------
** note name
   * not name value binding in name-hash-table
     name-hash-table is used to
     1. provide the name datatype
     2. implement title.name-table
   * binding will be done in title.name-table
     an object [value with title]
     will be bound to a title name pair
** ----------------------------------
** name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-hash-table* 100333)

   (defparameter *name-hash-table#string*
     (make#vector
      :length *size#name-hash-table*
      :initial-element 0))

   ;; to reverse index 0
   ;; the first entry of *name-hash-table* is reserved
   ;; for *title.name-table*
   ;; to test if a title name pair in *title.name-table*
   ;; is bound to any object or not
   (save#vector :value ""
                :vector *name-hash-table#string*
                :index 0)

   (defparameter *name-hash-table#index-for-title*
     (make#vector
      :length *size#name-hash-table*
      :element-type `(integer 0 ,*size#title.name-table*)
      :initial-element 0))
   #+end_src
** name?
   * index-within-name-hash-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (index)
     (and (natural-number? index)
          (< index *size#name-hash-table*)))
   #+end_src
** ----------------------------------
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest string->natural-number
       (cicada-vm)
     (ensure
         (list (string->natural-number "")
               (string->natural-number "@")
               (string->natural-number "@@@"))
         ==>
         (list 0
               64
               448)))
   #+end_src
** ----------------------------------
** string->name
   * in the following functions
     the fact tha name is an index is stressed
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (help#string->name#find-old-or-creat-new
      :string string
      :index (mod (string->natural-number string)
                  ,*size#name-hash-table*)))

   (defun help#string->name#find-old-or-creat-new
       (&key
          string
          index)
     (cond
       ((not (name-hash-table-index#used? index))
        (help#string->name#creat-new
         :string string
         :index index)
        index)

       ((equal?
         string
         (fetch#vector
          :vector *name-hash-table#string*
          :index index))
        index)

       (:else
        (help#string->name#find-old-or-creat-new
         :string string
         :index (name-hash-table-index#next :index index)))
       ))

   (defun name-hash-table-index#used? (index)
     (not (zero? (fetch#vector
                  :vector *name-hash-table#string*
                  :index index))))

   (defun help#string->name#creat-new
       (&key
          string
          index)
     (save#vector
      :value string
      :vector *name-hash-table#string*
      :index index))

   (defun name-hash-table-index#next
       (&key index)
     (if (= index *size#name-hash-table*)
         0
         (add1 index)))
   #+end_src
** name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->string (name)
     (if (not (name? name))
         (error "the argument of (name->string) must be a name")
         (cond ((not (name-hash-table-index#used? name))
                (error "this name does not have a string"))
               (:else
                (fetch#vector :vector *name-hash-table#string*
                              :index name))
               )))
   #+end_src
** print-name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-name (name
                      &key (stream t))
     (format stream
             "[~A]"
             (name->string name)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name->string
       (cicada-vm)
     (ensure
         (name->string (string->name "kkk took my baby away!"))
         ==>
         "kkk took my baby away!"))

   (deftest print-name
       (cicada-vm)
     (ensure
         (print-name (string->name "kkk took my baby away!")
                     :stream nil)
         ==>
         "[kkk took my baby away!]"))
   #+end_src
** ----------------------------------
* cicada-image
** ----------------------------------
** note
   * 這裏的設計可以非常豐富
** ----------------------------------
** the cicada-image
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#cicada-image-buffer* 16)
   (defparameter *cicada-image-filename* "test.image.iaa~")

   (defparameter *cicada-image*
     (make#vector :length (mul *size#cicada-image-buffer* *cicada-object-size*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   (defparameter *pointer#cicada-image-buffer* 0)
   #+end_src
** fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch-byte#cicada-image (&key address)
     (fetch#byte-vector :byte-vector *cicada-image*
                        :size 1
                        :index address))

   (defun save-byte#cicada-image (&key address byte)
     (save#byte-vector :value byte
                       :byte-vector *cicada-image*
                       :size 1
                       :index address))

   (defin fetch#cicada-image
     .title .value)
   (defun fetch#cicada-image (&key address)
     (values (fetch#byte-vector :byte-vector *cicada-image*
                                :size *cell-unit*
                                :index address)
             (fetch#byte-vector :byte-vector *cicada-image*
                                :size *cell-unit*
                                :index (add *cell-unit*
                                            address))))

   (defun save#cicada-image (&key address title value)
     (save#byte-vector :value title
                       :byte-vector *cicada-image*
                       :size *cell-unit*
                       :index address)
     (save#byte-vector :value value
                       :byte-vector *cicada-image*
                       :size *cell-unit*
                       :index (add *cell-unit*
                                   address)))
   #+end_src
** ----------------------------------
** load cicada-image
   #+begin_src lisp :tangle cicada-vm.lisp
   (progn
     (setf stream
           (open (make-pathname :name *cicada-image-filename*)
                 :direction :output
                 :if-exists :supersede))
     (format stream "cicada test~%")
     (close stream))


   (file->buffer :filename *cicada-image-filename*
                 :buffer *cicada-image*)
   #+end_src
** ----------------------------------
* >< vector-function
** ----------------------------------
** note
** ----------------------------------
** >< fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#vector-function-body ())
   (defun save#vector-function-body ())
   #+end_src
** ----------------------------------
* return-stack
** ----------------------------------
** note
   * return-stack is a stack of pointers
     a pointer points into a (one type of) function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers
     that are moving the pointer
     which on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers
     that are pushing or popping the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 vector-function-body-pointer 這個 title
     的數據
     的函數
     而 vector-function-body-pointer 這個 title 下
     有處理這個數據類型
     的函數
** ----------------------------------
** the return-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make#vector :length (mul *cicada-object-size* *size#return-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *return-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#return-stack* 0)
   #+end_src
** push#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#return-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the argument :title of (push#return-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#return-stack*
                     ,*cicada-object-size*)
                ,*size#return-stack*))
        (error "can not push anymore *return-stack* is filled"))
       ;; side-effect
       ;; *pointer#return-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *return-stack*
               :index *pointer#return-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *return-stack*
               :index *pointer#return-stack*)
              (add1! *pointer#return-stack*)
              ;; return current-pointer
              ,*pointer#return-stack*)))
   #+end_src
** pop#return-stack & tos#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#return-stack
     .title
     .value
     .current-pointer)
   (defun pop#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error (cat ()
                 ("when calling (pop#return-stack)~%")
                 ("the *return-stack* must NOT be empty"))))
       (:else
        (sub1! *pointer#return-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index *pointer#return-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index *pointer#return-stack*)
                ,*pointer#return-stack*))))


   ;; TOS denotes top of stack
   (defin tos#return-stack
     .title
     .value
     .current-pointer)
   (defun tos#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error (cat ()
                 ("when calling (tos#return-stack)~%")
                 ("the *return-stack* must NOT be empty"))))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index (sub1 *pointer#return-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index (sub1 *pointer#return-stack*))
                (sub1 *pointer#return-stack*)))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest return-stack
       (cicada-vm)
     (ensure
         (list (push#return-stack
                :title (string->title "return-stack--push--test#1")
                :value 147)

               (push#return-stack
                :title (string->title "return-stack--push--test#2")
                :value 258)

               (push#return-stack
                :title (string->title "return-stack--push--test#3")
                :value 369)

               (with (tos#return-stack)
                 .value)
               (with (pop#return-stack)
                 .value)

               (with (tos#return-stack)
                 .value)
               (with (pop#return-stack)
                 .value)

               (with (tos#return-stack)
                 .value)
               (with (pop#return-stack)
                 .value))
         ==>
         (list 1
               2
               3

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
** execute-next-instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; note that:
   ;; this function defines the interface of primitive-instruction
   ;; as:
   ;; 1. (<primitive-instruction> :title :value )
   ;;    the return-stack will likely be updated by primitive-instruction
   ;; 2. at the end of <primitive-instruction>
   ;;    the (execute-next-instruction) will likely be called again
   ;; [compare this to real CPU to understand it]

   (defun execute-next-instruction ()
     (let* ((address#vector-function-body
             (with (tos#return-stack)
               .value))
            (primitive-instruction
             ;; this means only primitive-instruction is handled now
             (with (fetch#cicada-image
                    :address address#vector-function-body)
               .value)))
       (with (fetch#cicada-image
              :address (add *cicada-object-size*
                            address#vector-function-body))
         (funcall (primitive-instruction->host-function primitive-instruction)
                  :title .title
                  :value .value))))
   #+end_src
** ----------------------------------
** >< [maybe] address#in-vector-function-body
** ----------------------------------
* primitive-instruction
** ----------------------------------
** note
   * 用 table 來實現
     primitive-instruction 這個數據結構
     除了找到 primitive-instruction 本身在 host language 中的位置以外
     我還可以增加別的數據域
   * primitive-instruction 的製作
     與 用 (be) 給它命名是分開的
     單單在 host-language 中製作一個 primitive-instruction
     會在 *primitive-instruction-table* 中申請一個位置
     [接口函數是 make-primitive-instruction]
     所申請的位置的 index 就被爲是 primitive-instruction 的值
     而需要的時候 (be) 會給這個 index 一個名字
** the primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-instruction-table* 1000)

   (defparameter *primitive-instruction-table*
     (make#vector
      :length *size#primitive-instruction-table*
      :initial-element 'function))
   #+end_src
** primitive-instruction?
   * index-within-primitive-instruction-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-instruction? (index)
     (and (natural-number? index)
          (< index *size#primitive-instruction-table*)))

   (defparameter *pointer#primitive-instruction-table* 1)
   #+end_src
** make-primitive-instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun make-primitive-instruction (host-funciton)
     (cond ((not (function? host-funciton))
            (error "the argument of (make-primitive-instruction) must be a function"))
           ((< *pointer#primitive-instruction-table*
               ,*size#primitive-instruction-table*)
            (save#vector :value host-funciton
                         :vector *primitive-instruction-table*
                         :index *pointer#primitive-instruction-table*)
            (add1! *pointer#primitive-instruction-table*)
            ;; return the old pointer [the index]
            (sub1 *pointer#primitive-instruction-table*))
           (:else
            (error (cat ()
                     ("when calling (make-primitive-instruction)~%")
                     ("the *primitive-instruction-table* must NOT be filled"))))))
   #+end_src
** primitive-instruction->host-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-instruction->host-function (primitive-instruction)
     (let ((host-function
            (fetch#vector :vector *primitive-instruction-table*
                          :index primitive-instruction)))
       (if (not (function? host-function))
           (error (cat ()
                    ("from an instruction[index]~%")
                    ("(primitive-instruction->host-function) can not find any host-function")))
           host-function)))

   ;; (defun primitive-instruction->host-function (primitive-instruction)
   ;;   (fetch#vector :vector *primitive-instruction-table*
   ;;                 :index primitive-instruction))
   #+end_src
** ----------------------------------
** &call-primitive-function
   * this is the first primitive-instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun &call-primitive-function (&key title value)
     ;; ><><>< should do title check ???
     (funcall (primitive-function->host-function value)))
   #+end_src
** ----------------------------------
* primitive-function
** ----------------------------------
** the primitive-function-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-function-table* 1000)

   (defparameter *primitive-function-table*
     (make#vector
      :length *size#primitive-function-table*
      :initial-element 'function))
   #+end_src
** primitive-function?
   * index-within-primitive-function-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-function? (index)
     (and (natural-number? index)
          (< index *size#primitive-function-table*)))

   (defparameter *pointer#primitive-function-table* 1)
   #+end_src
** make-primitive-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun make-primitive-function (host-funciton)
     (cond ((not (function? host-funciton))
            (error "the argument of (make-primitive-function) must be a function"))
           ((< *pointer#primitive-function-table*
               ,*size#primitive-function-table*)
            (save#vector :value host-funciton
                         :vector *primitive-function-table*
                         :index *pointer#primitive-function-table*)
            (add1! *pointer#primitive-function-table*)
            ;; return the old pointer [the index]
            (sub1 *pointer#primitive-function-table*))
           (:else
            (error (cat ()
                     ("when calling (make-primitive-function)~%")
                     ("the *primitive-function-table* must NOT be filled"))))))
   #+end_src
** primitive-function->host-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-function->host-function (primitive-function)
     (let ((host-function
            (fetch#vector :vector *primitive-function-table*
                          :index primitive-function)))
       (if (not (function? host-function))
           (error (cat ()
                    ("from an function[index]~%")
                    ("(primitive-function->host-function) can not find any host-function")))
           host-function)))

   ;; (defun primitive-function->host-function (primitive-function)
   ;;   (fetch#vector :vector *primitive-function-table*
   ;;                 :index primitive-function))
   #+end_src
** ----------------------------------
** >< some primitive-function for to test
   * the argument of a primitive-function
     should be fetched from the *argument-stack*
   * in the lisp's sense
     the primitive-functions are all about side-effect
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun &kkk ()
     (cat (:to *standard-output*)
       ("kkk took what away?")))
   #+end_src
** ----------------------------------
* argument-stack
** ----------------------------------
** the argument-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#argument-stack* 1024)

   (defparameter *argument-stack*
     (make#vector :length (mul *cicada-object-size* *size#argument-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *argument-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#argument-stack* 0)
   #+end_src
** push#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#argument-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the argument :title of (push#argument-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#argument-stack*
                     ,*cicada-object-size*)
                ,*size#argument-stack*))
        (error "can not push anymore *argument-stack* is filled"))
       ;; side-effect
       ;; *pointer#argument-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *argument-stack*
               :index *pointer#argument-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *argument-stack*
               :index *pointer#argument-stack*)
              (add1! *pointer#argument-stack*)
              ;; argument current-pointer
              ,*pointer#argument-stack*)))
   #+end_src
** pop#argument-stack & tos#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#argument-stack
     .title
     .value
     .current-pointer)
   (defun pop#argument-stack ()
     (cond
       ((zero? *pointer#argument-stack*)
        (error (cat ()
                 ("when calling (pop#argument-stack)~%")
                 ("the *argument-stack* must NOT be empty"))))
       (:else
        (sub1! *pointer#argument-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index *pointer#argument-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index *pointer#argument-stack*)
                ,*pointer#argument-stack*))))


   ;; TOS denotes top of stack
   (defin tos#argument-stack
     .title
     .value
     .current-pointer)
   (defun tos#argument-stack ()
     (cond
       ((zero? *pointer#argument-stack*)
        (error (cat ()
                 ("when calling (tos#argument-stack)~%")
                 ("the *argument-stack* must NOT be empty"))))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index (sub1 *pointer#argument-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index (sub1 *pointer#argument-stack*))
                (sub1 *pointer#argument-stack*)))))
   #+end_src
** ----------------------------------
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest argument-stack
       (cicada-vm)
     (ensure
         (list (push#argument-stack
                :title (string->title "argument-stack--push--test#1")
                :value 147)

               (push#argument-stack
                :title (string->title "argument-stack--push--test#2")
                :value 258)

               (push#argument-stack
                :title (string->title "argument-stack--push--test#3")
                :value 369)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value))
         ==>
         (list 1
               2
               3

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
* >< frame-stack
* >< [maybe] instruction-return-stack
** note
   * in cicada language
     you can extend the instruction set of the vm
   * in the body of the definition of your instruction
     when you call a cicada function
     it will not use the return-stack to record the return point
     but to use instruction-return-stack
* -----------------------------------
* >< let it be
  #+begin_src lisp :tangle cicada-vm.lisp

  #+end_src
* >< the story begin
* ===================================
* test
  #+begin_src lisp
  (asdf:load-system "cicada-vm")
  (in-package :cicada-vm)
  (setf *print-pretty* t)
  (run-unit 'basic)
  (run-unit 'cicada-rhapsody)
  (run-unit 'cicada-vm)


  (save#cicada-image :address 0
                     :title (string->title "nevermind")
                     :value (make-primitive-instruction (function &call-primitive-function)))

  (save#cicada-image :address *cicada-object-size*
                     :title (string->title "nevermind")
                     :value (make-primitive-function (function &kkk)))



  (primitive-instruction->host-function (make-primitive-instruction (function &call-primitive-function)))

  (save#vector :value (function &call-primitive-function)
               :vector *primitive-instruction-table*
               :index *pointer#primitive-instruction-table*)

  (push#return-stack
   :title (string->title "nevermind")
   :value 0)

  (execute-next-instruction)
  #+end_src
* ===================================
