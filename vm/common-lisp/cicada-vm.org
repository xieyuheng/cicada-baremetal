#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* get the basic forth-style quick-test
  * the vm (the inner interpreter) is really working now
* [compiler] function-header and the use of them
* [compiler] instruction for vector-function call
* [compiler] the first version of the compiler
** for to write the compiler
   * 这个编译器 在代码演化到某个阶段时 会被抛弃
** 象棋比喻
   * 关于 vector-function 与 primitive-function 的接口
     * 此二者的实现方式不同
       但是它们的接口都将被编译器用到
     * 所以先写编译器
       看看需要什么样的接口
   * 我发现 就像下棋[象棋]一样
     你能同时考虑的步数越多
     你的棋艺就越精湛
     比如
     之列 vector-function 与 primitive-function 的接口函数
     就应该与使用这些接口的编译器一起被考虑
     也就是说我同时能考虑到的 "步数" 仅仅是 两步 而已
* [instruction-set] a set (very first group) of primitive-[function|instruction]
  * as instruction-set
  * primitive-[function|instruction]
    应该写在能够用来测试它们的编译器之后
  * instruction-set will grow as needed
* ===================================
* todo regular-common-lisp
** [maybe] optimize fixnum
** [maybe] big number
** dup
   * uses make-string to re-define dup#string
   * define dup for other datatype
* todo architecture
** to use instruction-return-stack
** refine printers
** [how?] reduce dup code by better abstraction
** [maybe] to find a better hash function
** interface to cicada image buffer
** type check of load-file
   * the argument :file should be of path type
** about io
   * 總應該使用 record 來記錄 io
     record 是可以被作爲一等公民處理的
   * record 應該可以被過濾
     設計數據結構的時候需要考慮這一點
   * 並且 record 的順序是極端重要的
   * io 要從鍵盤的輸入開始 而不使用舊的標準
   * 輸入設備所產生的 record
     將被作爲 消息 傳遞給 一個 底層的 loop
     這在於 repl 並應該在回車的時候執行代碼
     而應該有一個特殊的按鍵來控制代碼的執行
     如果以 每次鍵盤的擊鍵爲輸入的話
     repl 其實就是一個小型的文本編輯器了
** write image file
** parsing image file
* todo instruction-set
** 重新設計跟謂詞有關的語義
   * 在之前的版本中我沒有發現這個錯誤真是太愚蠢了
     但是現在我卻發現
     有使用局部有名變元時
     和不使用局部有名變元時
     對謂詞的語義要求不同
     前者要求吃掉棧中的值
     而後者要求不吃
   * 是否可以給謂詞設立一個專門的棧 ?
   * 其實
     是 if 被特殊處理了 而不是 各個謂詞
     可能想到的方法有
     1) 在編譯期計算 if-part 所消耗的值的個數
        然後複製這些個數的值
        這樣就要求 if-part 必須具有簡單性
        這樣 與有名局部變元的語義衝突就解決了
* todo compiler
* todo cicada-vm
** [maybe] let modules be packages
** first version
   * without database of symbol usage
   * without resolving symbols
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  ;; new common-lisp hacker
  ;; please view module as directory
  ;;   which you can override by :pathname
  ;; and system as top-level directory
  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module "package-header"
              :components
              ((:file "package-header")))
     (:module "ytool"
              :components
              ((:file "ytool")))
     (:module "regular-common-lisp"
              :components
              ((:file "regular-common-lisp")))
     (:module "little-tester"
              :components
              ((:file "little-tester")))
     (:module "ytool.test" :pathname "ytool"
              :components
              ((:file "ytool.test"
                      :if-feature :with-little-test)))
     (:module "regular-common-lisp.test" :pathname "regular-common-lisp"
              :components
              ((:file "regular-common-lisp.test"
                      :if-feature :with-little-test)))
     ;; (:module "cicada-rhapsody"
     ;;          :components
     ;;          ((:file "cicada-rhapsody")
     ;;           (:file "cicada-rhapsody.test"
     ;;                  :if-feature :with-little-test)))
     (:module "architecture"
              :components
              ((:file "architecture")
               (:file "architecture.test"
                      :if-feature :with-little-test)))
     (:module "instruction-set"
              :components
              ((:file "instruction-set")
               (:file "instruction-set.test"
                      :if-feature :with-little-test)))
     (:module "compiler"
              :components
              ((:file "compiler")
               (:file "compiler.test"
                      :if-feature :with-little-test)))
     ;; (:module ghost-in-shell
     ;;          :components
     ;;          ((:file "ghost-in-shell")
     ;;           (:file "ghost-in-shell.test"
     ;;                  :if-feature :with-little-test)))
     ))
  #+end_src
* -----------------------------------
* note
* -----------------------------------
* test
  #+begin_src lisp
  (let ()
    (asdf:load-system :cicada-vm)

    (in-package :cicada-vm)
    (setf *print-pretty* t))

  (let ()
    (run-unit 'ytool)
    (run-unit 'regular-common-lisp)
    (run-unit 'architecture))

  (let ()
    (print#primitive-instruction-table)
    (print#primitive-function-table)
    (print#name-hash-table)
    (print#title.name-table)
    (values :ok))
  #+end_src
* ===================================
