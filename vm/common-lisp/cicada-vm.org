#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* TODO
** type check of function
   * load-file
     the argument :file should be of path type
** about io
   * 總應該使用 record 來記錄 io
     record 是可以被作爲一等公民處理的
   * record 應該可以被過濾
     設計數據結構的時候需要考慮這一點
   * 並且 record 的順序是極端重要的
   * 輸入設備所產生的 record
     將被作爲 消息 傳遞給 一個 底層的 loop
     這在於 repl 並應該在回車的時候執行代碼
     而應該有一個特殊的按鍵來控制代碼的執行
     如果以 每次鍵盤的擊鍵爲輸入的話
     repl 其實就是一個小型的文本編輯器了
** note
   * write image file
   * vector-function
   * the funciton (next)
   * first version
     without database of symbol usage
     without resolving system
   * parsing image file
   * cicada-rhapsody
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module :package-header
              :components
              ((:file "package-header")))
     (:module :basic
              :components
              ((:file "basic")
               (:file "basic.test"
                      :if-feature :with-little-test)))
     (:module :ghost-in-shell
              :components
              ((:file "ghost-in-shell")
               (:file "ghost-in-shell.test"
                      :if-feature :with-little-test)))
     (:file "cicada-vm")
     (:file "cicada-vm.test"
            :if-feature :with-little-test)))
  #+end_src
* ===================================
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the way used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
  * when a image file is loaded to *cicada-image-buffer*
    host language can provide many run-time supports
    but run-time independent compile must be supported too
  * when compiling to cicada language to image file
    the compiler maintains a database of symbol-address binding
    the database records all the use of every symbol
    the database helps one to
    NOT care about the encoding of instruction and title
  * value of symbol
    need to be updateed
    address of primitive-function and primitive-instruction
    need to be updateed
  * when vm interpreting image file
    it reads the database first
    and resolves the symbol in the image file
    meanwhile updating the database
    only after then
    the vm can begin interpreting the image file
* -----------------------------------
* (in-package :cicada-vm)
** cicada-vm.lisp
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package :cicada-vm)
   #+end_src
** cicada-vm.test.lisp
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* cicada-object
** cell-unit
   * a cell is of *cell-unit* many bytes
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* (/ *size#fixnum* 8)) ;; unit byte
   #+end_src
** cicada-object?
   * an object is two cell
     one for title (an index into title-table)
     one for value (of which the meaning is depended on its title)
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))

   (defun cicada-object? (x)
     (and (vector? x)
          (equal? '(unsigned-byte 8) (array-element-type x))
          (fixnum? (fetch#byte-vector :byte-vector x
                                      :size *cell-unit*
                                      :index 2))
          (= *cicada-object-size*
             (array-dimension x 0))
          (not
           (nil?
            (fetch#array
             :array *title-table*
             :index-vector (vector (fetch#byte-vector
                                    :byte-vector x
                                    :size *cell-unit*
                                    :index 0)
                                   0))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest cicada-object?
       (cicada-vm)
     (ensure
         (cicada-object?
          (make-cicada-object :title (string->title "kkk")
                              :value 666))
         ==>
         t))
   #+end_src
** make-cicada-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun make-cicada-object (&key
                                title
                                value)
     (if (not (title? title))
         (error "the agument :title of (make-cicada-object) must be checked by title?")
         (let ((cicada-object (make-array `(,*cicada-object-size*)
                                          :element-type '(unsigned-byte 8)
                                          :initial-element 0)))
           (save#byte-vector :value (title->index title)
                             :byte-vector cicada-object
                             :size *cell-unit*
                             :index 0)
           (save#byte-vector :value value
                             :byte-vector cicada-object
                             :size *cell-unit*
                             :index *cell-unit*))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest make-cicada-object
       (cicada-vm)
     (ensure
         (list (fetch#byte-vector
                :byte-vector (make-cicada-object :title (string->title "kkk")
                                                 :value 666)
                :size *cell-unit*
                :index *cell-unit*)
               (equal? (array-element-type
                        (make-cicada-object :title (string->title "kkk")
                                            :value 666))
                       '(unsigned-byte 8)))
         ==>
         (list 666
               t)))
   #+end_src
** cicada-object->title & cicada-object->value
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; these two funcitons return values to be use in host-language

   (defun cicada-object->title (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->title) must be cicada-object"))
           (:else
            (fetch#byte-vector :byte-vector cicada-object
                               :size *cell-unit*
                               :index 0))))

   (defun cicada-object->value (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->value) must be cicada-object"))
           (:else
            (fetch#byte-vector :byte-vector cicada-object
                               :size *cell-unit*
                               :index *cell-unit*))))
   #+end_src
* host-object
** host-object?
   * in host language
     only three user defined datatypes should be provided
   * I simply use a symbol in the host language as type-tag
   * the three types are
     <object>
     <name>
     <title>
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun host-object? (x)
     (and (vector? x)
          (= 3 (array-dimension x
                                0))
          (equal? '<host-object>
                  (fetch#vector :vector x
                                :index 0))
          (title? (fetch#vector :vector x
                                :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest host-object?
       (cicada-vm)
     (ensure
         (host-object? #(<host-object>
                         #(<title> 0)
                         #(<name> 0)))
         ==>
         T))
   #+end_src
** host-object->cicada-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun host-object->cicada-object (host-object)
     (if (not (host-object? host-object))
         (error "the argument of (host-object->cicada-object) must be host-object")
         (make-cicada-object :title (fetch#vector :vector host-object
                                                  :index 1)
                             :value (fetch#vector :vector host-object
                                                  :index 2))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest host-object->cicada-object
       (cicada-vm)
     (ensure
         (multiple-value-list
          (host-object->cicada-object
           `#(<host-object>
              ,(string->title "testing#host-object->cicada-object")
              #b10000000)))
         ==>
         (list `#(,(title->index
                    (string->title
                     "testing#host-object->cicada-object"))
                  0 0 0
                  128 0 0 0)
               `128)))
   #+end_src
** cicada-object->host-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->host-object (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->host-object) must be cicada-object"))
           (:else
            `#(<host-object>
               ,(vector '<title>
                        (cicada-object->title cicada-object))
               ,(cicada-object->value cicada-object)))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest cicada-object->host-object
       (cicada-vm)
     (ensure
         (cicada-object->host-object
          (host-object->cicada-object
           `#(<host-object>
              ,(string->title "testing#host-object->cicada-object")
              #b10000000)))
         ==>
         `#(<HOST-OBJECT>
            ,(string->title "testing#host-object->cicada-object")
            128)))
   #+end_src
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     * <name
       <as
       <mean
       (be)
     * <name
       <as
       (explain)
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-table* 100333)

   (defparameter *size#entry#name-table* 100)

   (defparameter *name-table*
     (make-array
      `(,*size#name-table* ,*size#entry#name-table*)
      ;; note that
      ;; this table's element can be of any type
      :initial-element nil))

   (defun index-within-name-table? (index)
     (and (natural-number? index)
          (< index *size#name-table*)))
   #+end_src
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest string->natural-number
       (cicada-vm)
     (ensure
         (list (string->natural-number "")
               (string->natural-number "@")
               (string->natural-number "@@@"))
         ==>
         (list 0
               64
               448)))
   #+end_src
** natural-number->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-table*)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest natural-number->index
       (cicada-vm)
     (ensure
         (list (natural-number->index 0)
               (natural-number->index 123)
               (natural-number->index *size#name-table*))
         ==>
         (list 0
               123
               0)))
   #+end_src
** name?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (x)
     (and (vector? x)
          (= 2 (array-dimension x
                                0))
          (equal? '<name>
                  (fetch#vector :vector x
                                :index 0))
          (index-within-name-table?
           (fetch#vector :vector x
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name?
       (cicada-vm)
     (ensure
         (name? #(<name> 0))
         ==>
         t))
   #+end_src
** name->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->index (name)
     (cond ((not (name? name))
            (error "argument of name->index must be a name"))
           (:else
            (fetch#vector :vector name
                          :index 1))))
   #+end_src
** string->name & name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (let ((index
            (natural-number->index
             (string->natural-number string))))
       (help#string->name#find-old-or-creat-new string
                                                index)))

   (defun help#string->name#find-old-or-creat-new (string index)
     (cond
       ((not (name-table-index#used? index))
        (help#string->name#creat-new string
                                     index)
        `#(<name> ,index))

       ((equal? string
                (fetch#array :array *name-table*
                             :index-vector `#(,index 0)))
        `#(<name> ,index))

       (:else
        (help#string->name#find-old-or-creat-new
         string
         (name-table-index#next index)))
       ))


   (defun help#string->name#creat-new (string index)
    (save#array :value string
                :array *name-table*
                :index-vector `#(,index 0)))


   (defun name-table-index#used? (index)
     (string? (fetch#array :array *name-table*
                           :index-vector `#(,index 0))))

   (defun name-table-index#next (index)
     (if (= index *size#name-table*)
         0
         (add1 index)))



   (defun name->string (name)
     (cond ((not (name? name))
            (error "argument of name->string must be a name"))
           (:else
            (let ((index (name->index name)))
              (cond ((not (name-table-index#used? index))
                     (error "this name does not have a string"))
                    (:else
                     (fetch#array :array *name-table*
                                  :index-vector `#(,index 0)))
                    )))
           ))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name->string
       (cicada-vm)
     (ensure
         (name->string (string->name "kkk took my baby away!"))
         ==>
         "kkk took my baby away!"))
   #+end_src
** print-name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-name (name
                      &key (stream t))
     (format stream
             "[~A]"
             (name->string name)))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print-name
       (cicada-vm)
     (ensure
         ;; (let ((test-stream (make-string-output-stream)))
         ;;   (print-name (string->name "kkk took my baby away!")
         ;;               :stream test-stream)
         ;;   (get-output-stream-string test-stream))
         (print-name (string->name "kkk took my baby away!")
                     :stream nil)
         ==>
         "[kkk took my baby away!]"))
   #+end_src
** be & explain
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; <name
   ;; <as
   ;; <mean
   ;; (be)

   ;; <name
   ;; <as
   ;; (explain)



   ;; interface:
   ;; (multiple-value-bind
   ;;       (field
   ;;        update?
   ;;        old-mean)
   ;;     (be :name
   ;;         :as
   ;;         :mean )
   ;;   ><><><)

   (defun be (&key
                name
                as
                mean)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (be) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#be :name-index name-index
                    :as-index as-index
                    :mean mean))))



   (defun help#be (&key
                     name-index
                     as-index
                     mean
                     (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-vector `#(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-vector `#(,name-index ,field))
          (values field
                  nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-vector `#(,name-index ,field))
          (values field
                  :updated!!!
                  (cdr content-of-field)))

         ((< field *size#entry#name-table*)
          (help#be :name-index name-index
                   :as-index as-index
                   :mean mean
                   :field (add1 field)))

         (:else
          (error "the meaning of this name is too filled"))
         )))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (mean
   ;;        find?)
   ;;     (explain :name
   ;;              :as )
   ;;   ><><><)

   (defun explain (&key
                     name
                     as)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (explain) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#explain :name-index name-index
                         :as-index as-index))))



   (defun help#explain (&key
                          name-index
                          as-index
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-vector `#(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  :found!!!))

         ((< field *size#entry#name-table*)
          (help#explain :name-index name-index
                        :as-index as-index
                        :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not explain the name as the way you wish~%"
                  "and the meaning of this name is too filled")))
         )))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest be--and--explain
       (cicada-vm)
     (ensure
         (list (be :name (string->name "kkk")
                   :as (string->name "took")
                   :mean "my baby away!")
               (multiple-value-list
                (be :name (string->name "kkk")
                    :as (string->name "took")
                    :mean "my baby away!"))
               (multiple-value-list
                (explain :name (string->name "kkk")
                         :as (string->name "took"))))
         ==>
         (list 2
               `(2
                 :UPDATED!!!
                 "my baby away!")
               `("my baby away!"
                 :found!!!))
       ))
   #+end_src
** meaningful?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun meaningful? (&key
                         name
                         as)
       (multiple-value-bind
             (mean
              find?)
           (explain :name name
                    :as as)
         find?))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest meaningful?
       (cicada-vm)
     (ensure
         (meaningful? :name (string->name "kkk")
                      :as (string->name "took"))
         ==>
         :found!!!))
   #+end_src
* title-table
** note
   * title is the way I used to manage name of things
     a title can be viewed as
     a type
     a module
     a structure
   * a title is a index into title-table
     the index is used as the encoding of that title
     there is only one title-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (entitle)
     * <title
       <name
       (ask)
   * every object have a title
** title-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title-table* 1000)

   (defparameter *size#entry#title-table* 100)

   (defparameter *title-table*
     (make-array
      `(,*size#title-table* ,*size#entry#title-table*)
      ;; note that
      ;; this table's element can be of any type
      :initial-element nil))

   (defun index-within-title-table? (index)
     (and (natural-number? index)
          (< index *size#title-table*)))

   (defparameter *pointer#title-table* 0)
   #+end_src
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let ((name (string->name string))
           (name#title (string->name "title")))
       (cond
         ((meaningful? :name name
                       :as name#title)
          `#(<title>
             ,(explain :name name
                       :as name#title)))

         ((< *pointer#title-table*
             ,*size#title-table*)
          ;; to create a new title is
          ;; to allocate a new index in the title-table
          ;; and save the name#title to the field number 0 of the entry
          (be :name name
              :as name#title
              :mean *pointer#title-table*)
          (save#array :value name#title
                      :array *title-table*
                      :index-vector (vector *pointer#title-table* 0))
          ;; update *pointer#title-table*
          (setf *pointer#title-table*
                (add1 *pointer#title-table*))
          `#(<title>
             ,(sub1 *pointer#title-table*)))

         (:else
          (error "title-table is filled, can not make new title")))))
   #+end_src
** title?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (x)
     (and (vector? x)
          (= 2 (array-dimension x
                                0))
          (equal? '<title>
                  (fetch#vector :vector x
                                :index 0))
          (index-within-title-table?
           (fetch#vector :vector x
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest title?
       (cicada-vm)
     (ensure
         (list (title? #(<title> 0))

               (title? (string->title "testing#title?")))
         ==>
         (list t
               t)))
   #+end_src
** title->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->index (title)
     (cond ((not (title? title))
            (error "argument of title->index must be a title"))
           (:else
            (fetch#vector :vector title
                          :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest title->index
       (cicada-vm)
     (ensure
         (let ((test1 (title->index (string->title "testing#1#title->index")))
               (test2 (title->index (string->title "testing#2#title->index"))))
           (- test2 test1))
         ==>
         1))
   #+end_src
** entitle & ask
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; <title
   ;; <name
   ;; <object
   ;; (entitle)

   ;; <title
   ;; <name
   ;; (ask)



   ;; interface:
   ;; (multiple-value-bind
   ;;       (field
   ;;        update?
   ;;        old-object)
   ;;     (entitle :title
   ;;              :name
   ;;              :object )
   ;;   ><><><)

   (defun entitle (&key
                     title
                     name
                     object)
     (if (or (not (title? title))
             (not (name? name))
             (not (host-object? object)))
         (error "one or more the arguments of (entitle) is of wrong type")
         (let ((title-index (title->index title))
               (name-index (name->index name)))
           (help#entitle :title-index title-index
                         :name-index name-index
                         :object object))))



   (defun help#entitle (&key
                          title-index
                          name-index
                          object
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *title-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons name-index object)
                      :array *title-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  nil
                  nil))

         ((equal? name-index
                  (car content-of-field))
          (save#array :value (cons name-index object)
                      :array *title-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  :updated!!!
                  (cdr content-of-field)))

         ((< field *size#entry#title-table*)
          (help#entitle :title-index title-index
                        :name-index name-index
                        :object object
                        :field (add1 field)))

         (:else
          (error "the names under this title is too filled"))
         )))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (object
   ;;        find?)
   ;;     (ask :title
   ;;          :name )
   ;;   ><><><)


   (defun ask (&key
                 title
                 name)
     (if (or (not (title? title))
             (not (name? name)))
         (error "one or more the arguments of (ask) is of wrong type")
         (let ((title-index (title->index title))
               (name-index (name->index name)))
           (help#ask :title-index title-index
                     :name-index name-index))))



   (defun help#ask (&key
                      title-index
                      name-index
                      (field 1))
     (let ((content-of-field
            (fetch#array :array *title-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? name-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  :found!!!))

         ((< field *size#entry#title-table*)
          (help#ask :title-index title-index
                    :name-index name-index
                    :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not ask for the object under the name as you wish~%"
                  "and the names under this title is too filled")))
         )))


   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest entitle--and--ask
       (cicada-vm)
     (ensure
         (list (entitle :title (string->title "kkk")
                        :name (string->name "took")
                        :object `#(<host-object>
                                   ,(string->title "my")
                                   "baby away!"))
               (multiple-value-list
                (entitle :title (string->title "kkk")
                         :name (string->name "took")
                         :object `#(<host-object>
                                    ,(string->title "my")
                                    "baby away!")))
               (multiple-value-list
                (ask :title (string->title "kkk")
                     :name (string->name "took"))))
         ==>
         (list `1
               `(1
                 :updated!!!
                 #(<host-object> ,(string->title "my") "baby away!"))
               `(#(<host-object> ,(string->title "my") "baby away!")
                  :found!!!))))
    #+end_src
** entitled?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun entitled? (&key
                       title
                       name)
     (multiple-value-bind
           (object
            find?)
         (ask :title title
              :name name)
       find?))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest entitled?
       (cicada-vm)
     (ensure
         (entitled? :title (string->title "kkk")
                    :name (string->name "took"))
         ==>
         :found!!!))
   #+end_src
** print-title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-title (title &key (stream t))
     (if (not (title? title))
         (error "the argument of (print-title) must be checked by title?")
         (print-name (fetch#array :array *title-table*
                                  :index-vector `#(,(title->index title) 0))
                     :stream stream)))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print-title
       (cicada-vm)
     (ensure
         ;; (let ((test-stream (make-string-output-stream)))
         ;;   (print-title (string->title "kkk")
         ;;                :stream test-stream)
         ;;   (get-output-stream-string test-stream))
         (print-title (string->title "kkk")
                      :stream nil)
         ==>
         "[title]"))
   #+end_src
** (string->title "title")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "title")
   #+end_src
* return-stack
** note
   * return-stack is a stack of pointers
     a pointer points into a (one type of) function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers
     that are moving the pointer
     which on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers
     that are pushing or popping the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 body-pointer#vector-function 這個 title
     的數據
     的函數
     而 body-pointer#vector-function 這個 title 下
     有處理這個數據類型
     的函數
** (string->title "return-stack")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "return-stack")
   #+end_src
** return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make-array `(,(*  *cicada-object-size*
                        ,*size#return-stack*))
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))

   ;; pointer is an index into *return-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#return-stack* 0)

   ;; explicitly change value to cicada-object before push
   (defun push#return-stack (cicada-object)
     (cond
       ((not (cicada-object? cicada-object))
        (error "the argument of (push#return-stack) must be checked by cicada-object?"))

       ((not (<  (*  *pointer#return-stack*
                     ,*cicada-object-size*)
                 ,*size#return-stack*))
        (error "can not push anymore *return-stack* is filled"))

       (:else
        (copy#byte-vector :from cicada-object
                          :from-index 0
                          :to *return-stack*
                          :to-index (*  *pointer#return-stack*
                                        ,*cicada-object-size*)
                          :size *cicada-object-size*)
        (setf *pointer#return-stack*
              (add1 *pointer#return-stack*))
        (values *pointer#return-stack*
                cicada-object))))

   (defun pop#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error "can not pop anymore *return-stack* is empty"))
       (:else
        (let ((cicada-object
               (make-cicada-object
                :title (string->title
                        "pop#return-stack--make-cicada-object--to-return")
                :value 0)))
          (setf *pointer#return-stack*
                (sub1 *pointer#return-stack*))
          (copy#byte-vector :to cicada-object
                            :to-index 0
                            :from *return-stack*
                            :from-index (*  *pointer#return-stack*
                                            ,*cicada-object-size*)
                            :size *cicada-object-size*)
          (values cicada-object
                  ,*pointer#return-stack*)))))


   ;; TOS denotes top of stack
   (defun tos#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error "can not pop anymore *return-stack* is empty"))
       (:else
        (let ((cicada-object
               (make-cicada-object
                :title (string->title
                        "pop#return-stack--make-cicada-object--to-return")
                :value 0)))
          (copy#byte-vector :to cicada-object
                            :to-index 0
                            :from *return-stack*
                            :from-index (*  (sub1 *pointer#return-stack*)
                                            ,*cicada-object-size*)
                            :size *cicada-object-size*)
          (values cicada-object
                  (sub1 *pointer#return-stack*))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest push#return-stack
       (cicada-vm)
     (ensure
         (multiple-value-bind
               (pointer-index#1
                cicada-object#1)
             (push#return-stack
              (make-cicada-object :title (string->title "kkk")
                                  :value 666))
           (multiple-value-bind
                 (pointer-index#2
                  cicada-object#2)
               (push#return-stack
                (make-cicada-object :title (string->title "kkk")
                                    :value 666))
             (list (- pointer-index#2
                      pointer-index#1)
                   (every (function equal?)
                          cicada-object#1
                          cicada-object#2)
                   (every (function equal?)
                          cicada-object#1
                          (make-cicada-object :title (string->title "kkk")
                                              :value 666))
                   (equal? (car (cdr (multiple-value-list (pop#return-stack)))) (sub1 pointer-index#2))
                   (equal? (car (cdr (multiple-value-list (tos#return-stack)))) (sub1 pointer-index#1))
                   (every (function equal?)
                          (pop#return-stack)
                          (make-cicada-object :title (string->title "kkk")
                                              :value 666))
                   )))
         ==>
         (list 1
               t
               t
               t
               t
               t)))
   #+end_src
** next & execute-instruction
   #+begin_src lisp :tangle cicada-vm.test.lisp
   ;; the following two address#cicada-object can be index

   (defun next ()
     (let* ((body-pointer (toc#return-stack))
            ;; (title#body-pointer (cicada-object->title body-pointer))
            (address#body-pointer (cicada-object->value body-pointer)))
       (execute-instruction :instruction instruction
                            :cicada-object cicada-object)))


   ;; note that:
   ;; this function defines the interface of primitive-instruction
   ;; as:
   ;; 1. (primitive-instruction host-object)
   ;;    the return-stack will likely be updated by primitive-instruction
   ;; 2. at the end of primitive-instruction 
   ;;    the next will likely be called again
   ;; compare this to really CPU to understand it

   (defun execute-instruction
       (&key
          instruction
          cicada-object)
     (let (;; (title#instruction (cicada-object->title instruction))
           (address#instruction (cicada-object->value instruction)))
       (funcall (address->instruction address#instruction)
                (cicada-object->host-object cicada-object))))
   #+end_src
** address->instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun address->instruction (address)
     ;; ><><>< maybe not only the function in the table's entry
     (fetch#vector :vector *primitive-instruction-table*
                   :index address))
   #+end_src
* >< argument-stack
* >< frame-stack
* primitive-instruction
** note
   * instruction 都是在 title 下的
     但是
     在函數體中
     所保存在 instruction 位置的 cicada-object
     卻是 一個 instruction 的類型標籤
     再加上其 address
   * 函數體中
     保存函數的位置也同樣如此
     所保存的並不是名而是值
     即 function 的 address
   * 要注意 address 可以是 index
     尤其是對於 instruction 而言
     除非在匯編中用絕對地址
     否則都只能使用 index
     因爲 host-language 中
     函數的絕對地址
     不好保存在 cicada-object cell 中
     因爲其絕對地址通常被認爲是用戶不可知的值
** (string->title "primitive-instruction")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "primitive-instruction")
   #+end_src
** primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-instruction-table* 1000)

   (defparameter *primitive-instruction-table*
     (make-vector
      :length *size#primitive-instruction-table*
      ;; note that
      ;; this table's element can be of any type
      :initial-element nil))

   (defun index-within-primitive-instruction-table? (index)
     (and (natural-number? index)
          (< index *size#primitive-instruction-table*)))

   (defparameter *pointer#primitive-instruction-table* 0)
   #+end_src
* load image
** note
   * in the first few test versions
     the image file will just be a vector-function-body
** *cicada-image-file* & *cicada-image-buffer*
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#cicada-image-buffer* 16)
   (defparameter *cicada-image-file* "test.image.iaa~")

   (defparameter *cicada-image-buffer*
     (make-array `(,(*  *size#cicada-image-buffer*
                        ,*cicada-object-size*))
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))
   #+end_src
** load-file
   #+begin_src lisp :tangle cicada-vm.lisp
   (progn
     (setf stream (open (make-pathname :name *cicada-image-file*)
                        :direction ':output
                        :if-exists ':supersede))
     (format stream "cicada test~%")
     (close stream))

   (defun load-file (&key
                       file
                       buffer
                       (buffer-boundary#lower 0)
                       (buffer-boundary#uper nil))
     (cond ((not (string? file))
            (error "the argument :file of (load-file) must be a string"))
           ((not (byte-vector? buffer))
            (error "the argument :buffer of (load-file) must be a byte-vector"))
           (:else
            ;; return the index of the first byte of the buffer that was not updated
            (read-sequence buffer
                           (open (make-pathname :name file)
                                 :element-type '(unsigned-byte 8)
                                 :direction ':input)
                           :start buffer-boundary#lower
                           :end buffer-boundary#uper))))

   (load-file :file *cicada-image-file*
              :buffer *cicada-image-buffer*)
   #+end_src
* >< vector-function
* >< body-pointer#vector-function
** note
   * with the title system
     no (not much) global addresses will be used
     the title of a poniter helps to make the poniter
     become from an address to an index
** (string->title "body-pointer#vector-function")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "body-pointer#vector-function")
   #+end_src
* primitive-function
** note
   * 函數的調用 和 函數的返回值
     argument-stack 和 return-stack 和 frame-stack
     這裏就涉及到了不同模塊的東西之間的依賴關係
** create title
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (string->title "primitive-function")
   #+end_src
** instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; call#primitive-function
   ;; tail-call#primitive-function
   #+end_src
* >< instruction-return-stack
  * in cicada language
    you can extend the instruction set of the vm
  * in the body of the definition of your instruction
    when you call a cicada function
    it will not use the return-stack to record the return point
    but to use instruction-return-stack
* >< threaded-code interpreter
** >< test
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; push#return-stack
   #+end_src
* ===================================
* test
  #+begin_src lisp
  (asdf:load-system "cicada-vm")
  (in-package :cicada-vm)
  (run-unit 'basic)
  (run-unit 'cicada-vm)
  #+end_src
* ===================================
