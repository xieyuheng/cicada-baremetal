#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* TODO
  * first version
    without parsing the image file
  * parse image file
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the method used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
* -----------------------------------
* header
** system declaration
   #+begin_src lisp :tangle threaded-code-interpreter.asd
   (defsystem #:threaded-code-interpreter
     :description "threaded-code interpreter of cicada language"
     :author "XIE Yuheng <xyheme@gmail.com>"
     :depends-on ()
     :serial t
     :components ((:file "threaded-code-interpreter--package-header")
                  (:file "threaded-code-interpreter")))
   #+end_src
** threaded-code-interpreter--package-header
   #+begin_src lisp :tangle threaded-code-interpreter--package-header.lisp
   (defpackage #:threaded-code-interpreter
     (:use #:common-lisp)
     (:nicknames #:cicada-vm)
     (:export

      ))
   #+end_src
** (in-package #:threaded-code-interpreter)
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (in-package #:threaded-code-interpreter)
   #+end_src
* basic
** note
   * a subset of syntax
   * naming convention
     * rename functions
     * to use "#"
       to introduce symbol
       as prefix and postfix of other symbol
     * a "#" denotes an word such as
       "of" "'s" "is" "are" "for" "to" "from" and so on
       in Chinese
       this kind of words are called unfilled-word
       i.e. word which is not filled by a precise meaning
       the meaning of it should be infered from context
     * when wish to stress that a symbol is used as a bounded-variable
       use "." as its prefix
   * you should respect the function
     * when a calculation is done
       it is not respectful
       to not return all of the hard work the function had done
     * so I return multi-value
       to capture almost the whole calculation
   * function should return its audience
     * function should be defined in the way that
       1. the structure of the data applied to the function
          is as regular as possible
          [this will make the function easy to write and easy to read]
       2. when ill-structured data is applied to the function
          the function cry out loud that it is an error
       3. well defined predicate is created
          to test if the data is regular or not
       4. when call the function
          the caller should use the predicate
          to make sure that
          the structure of data is regular
          [this will make the intention of code clear]
** predicate
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun nil? (x)
     (null x))

   (defun integer? (x)
     (integerp x))

   (defun natural-number? (x)
     (and (integerp x)
          (<= 0 x)))

   ;; (natural-number? 0)
   ;; (natural-number? 1)
   ;; (natural-number? -1)
   ;; (natural-number? 1.1)


   (defun array? (x)
     (arrayp x))
   #+end_src
** add1 sub1
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun add1 (x)
     (+ x 1))

   (defun sub1 (x)
     (- x 1))
   #+end_src
** >< array
   #+begin_src lisp
   (make-array '(2 3 4) :initial-element nil)

   (array-dimension
    (make-array '(2 3 4) :initial-element nil)
    0)

   (array-rank
    (make-array '(2 3 4) :initial-element nil))

   (aref (make-array '(2 3 4) :initial-element nil)
         0 0 0)
   #+end_src
** io
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun read#line (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof))
     (read-line from eof-as-error? read-eof-as))

   (defun read#char (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof))
     (read-char from eof-as-error? read-eof-as))

   (defun newline (&key (many 1))
     (cond ((= 0 many) :nothing)
           ((= 1 many) (format t "~%"))
           ((< 1 many) (format t "~%")
            (newline :many (sub1 many)))
           (:else :nothing)))
   #+end_src
** char->code code->char
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun char->code (char)
     (char-code char))

   (defun code->char (code)
     (code-char code))
   #+end_src
** [char|string]#space? string#empty?
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun char#space? (char)
     (let ((code (char->code char)))
       (cond ((= code 32) t)
             ((= code 10) t)
             (:else nil))))

   ;; (char#space? #\newline)
   ;; (char#space? #\space)

   (defun string#empty? (string)
     (equal string ""))

   (defun string#space? (string)
     (not (position-if
           (lambda (char) (not (char#space? char)))
           string)))

   ;; (string#space? " 123 ")
   ;; (string#space? "  ")
   ;; (string#space? "")
   #+end_src
** string->[head|tail|list]#word
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun string->head#word (string)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (head#word
     ;;        index-end
     ;;        index-start
     ;;        string)
     ;;     (string->head#word string)
     ;;   ><><><)
     (let* ((index-start (position-if
                          (lambda (char) (not (char#space? char)))
                          string))
            (index-end (position-if
                        (lambda (char) (char#space? char))
                        string
                        :start index-start)))
       (values (subseq string
                       index-start
                       index-end)
               index-end
               index-start
               string)))

   ;; (string->head#word " kkk took my baby away! ")
   ;; (string->head#word "k")
   ;; (string->head#word " k")
   ;; (string->head#word "k ")

   ;; the argument applied to string->head#word
   ;; must not be space-string
   ;; one should use string#space? to ensure this

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#word " ")



   (defun string->tail#word (string)
     (multiple-value-bind
           (head#word
            index-end
            index-start
            string)
         (string->head#word string)
       (if (nil? index-end)
           ""
           (subseq string index-end))))

   ;; (string->tail#word " kkk took my baby away! ")




   (defun string->list#word (string &key (base-list '()))
     (cond
       ((string#space? string) base-list)
       (:else
        (cons (string->head#word string)
              (string->list#word (string->tail#word string))))))

   ;; (string->list#word " kkk took my baby away! ")
   ;; (string->list#word " kkk")
   ;; (string->list#word "kkk ")
   ;; (string->list#word " ")
   ;; (string->list#word "")
   #+end_src
** string->[head|tail|list]#char
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun string->head#char (string)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (head#char
     ;;        tail#char
     ;;        string)
     ;;     (string->head#char string)
     ;;   ><><><)
     (values (char string 0)
             (subseq string
                     1)
             string))

   ;; (string->head#char " kkk took my baby away! ")
   ;; (string->head#char "k")
   ;; (string->head#char " k")
   ;; (string->head#char "k ")

   ;; the argument applied to string->head#char
   ;; must not be ""
   ;; one should use string#empty? to ensure this

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#char "")



   (defun string->tail#char (string)
     (multiple-value-bind
           (head#char
            tail#char
            string)
         (string->head#char string)
       tail#char))

   ;; (string->tail#char " kkk took my baby away! ")
   ;; (string->tail#char "")



   (defun string->list#char (string &key (base-list '()))
     (cond
       ((string#empty? string) base-list)
       (:else
        (cons (string->head#char string)
              (string->list#char (string->tail#char string))))))

   ;; (string->list#char " kkk took my baby away! ")
   ;; (string->list#char " kkk")
   ;; (string->list#char "kkk ")
   ;; (string->list#char " ")
   ;; (string->list#char "")
   #+end_src
** shift#[left|right]
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun shift#left (&key
                        (step 1)
                        number)
     (* number
        (expt 2 step)))

   ;; (shift#left
   ;;  :step 2
   ;;  :number 10)
   ;; (shift#left
   ;;  :number 10)


   (defun shift#right (&key
                         (step 1)
                         number)
     (/ number
        (expt 2 step)))

   ;; (shift#right
   ;;  :step 2
   ;;  :number 64)
   ;; (shift#right
   ;;  :number 64)
   #+end_src
** group
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun group (list
                 &key
                   (number 2)
                   ;; (pattern '())
                   (base-list '()))
     (cond ((< (length list) 2) base-list)
           (:else
            (cons (list (first list) (second list))
                  (group (cddr list)
                         :number number)))))
   ;; (defun help#group ())
   #+end_src
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     symbol <name
     symbol <as
     (explain)
     for example
     one can explain a symbol as
     * type
     * string
     * instruction
   * 需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** the table
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-table*
     100333)

   (defparameter *size#entry#name-table*
     100)

   (defparameter *name-table*
     (make-array
      (list *size#name-table* *size#entry#name-table*)
      :initial-element nil))
   #+end_src
** string->natural-number
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))

   ;; (string->natural-number "")
   ;; (string->natural-number "@")
   ;; (string->natural-number "@@@")
   #+end_src
** natural-number->index
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-table*)))

   ;; (natural-number->index 0)
   ;; (natural-number->index 123)
   ;; (natural-number->index 123.123)
   #+end_src
** string->name name->string
   #+begin_src lisp :tangle threaded-code-interpreter.lisp
   (defun name? (x)
     (and (array? x)
          (= 1 (array-rank x))
          (= 2 (array-dimension x
                                0))
          (equal :<name>
                 (aref x
                       0))))

   (name? #(:<name> "123"))

   (defun print-name (name
                      &key (stream t))
     (format stream
             "#name: ~A"
             '><))


   (defun help#string->symbol#find-old-or-creat-new
       ())

   (defun string->name (string)
     (let ((index
            (natural-number->index
             (string->natural-number string))))
       ()
       ))


   (defun symbol->string (index)
     ())
   #+end_src
* threaded-code interpreter
** note
   * 只有 對 threaded-code 的解釋 內置在虛擬機中的
     也就是說
     這裏需要處理的 structure 有
     1. primitive-function
     2. vector-function
     3. return-stack
     4. argument-stack
     5. frame-stack
        也就是說專門有一個 stack
        專注於約束變元
        而 argument-stack 還是以 古典的 forth 的方式工作
   * 其實這些 stack 是爲了 完成函數調用語義 而設計的
     那麼這裏就遇到了
     用 小的 structure
     組成 大的 structure 的問題
     但是 在實現 threaded-code interpreter 的時候
     還不能使用 structure 的機制
     因爲這個機制還沒實現呢
     儘管
     之後
     這些處理函數都會被暴露出來
** ><
   #+begin_src lisp :tangle threaded-code-interpreter.lisp

   #+end_src
* -----------------------------------
* test
  #+begin_src lisp
  (progn

    (asdf:load-system 'threaded-code-interpreter)
    (in-package :threaded-code-interpreter)

    )
  #+end_src
