#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* todo
** primitive-function#table 的合理性
   * 我想 以 primitive 爲名的數據類型中
     還有很多東西要被 table 來實現
** type check of function
   * load-file
     the argument :file should be of path type
** about io
   * 總應該使用 record 來記錄 io
     record 是可以被作爲一等公民處理的
   * record 應該可以被過濾
     設計數據結構的時候需要考慮這一點
   * 並且 record 的順序是極端重要的
   * 輸入設備所產生的 record
     將被作爲 消息 傳遞給 一個 底層的 loop
     這在於 repl 並應該在回車的時候執行代碼
     而應該有一個特殊的按鍵來控制代碼的執行
     如果以 每次鍵盤的擊鍵爲輸入的話
     repl 其實就是一個小型的文本編輯器了
** write image file
** vector-function
** the funciton (next)
** parsing image file
** cicada-rhapsody
** first version
   * without database of symbol usage
   * without resolving symbols
   * move let modules become packages
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module #:package-header
              :components
              ((:file "package-header")))
     (:module #:basic
              :components
              ((:file "basic")))
     (:module #:little-tester
              :components
              ((:file "little-tester")))
     (:module #:basic.test :pathname "basic"
              :components
              ((:file "basic.test"
                      :if-feature :with-little-test)))
     (:module #:ghost-in-shell
              :components
              ((:file "ghost-in-shell")
               (:file "ghost-in-shell.test"
                      :if-feature :with-little-test)))
     (:file "cicada-vm")
     (:file "cicada-vm.test"
            :if-feature :with-little-test)))
  #+end_src
* ===================================
* note
** cicada vm
   * cicada vm is
     a threaded-code interpreter
     with a hash-table of string which is called name-table
   * the way used to implement
     a forth inner interpreter in assembly language
     is used to design this vm
   * it will be easy to implement this vm in both
     low-level language as assembly
     and high-level language as common-lisp
   * an image file is as an executable [linkable] format
   * when a image file is loaded to *cicada-image-buffer*
     host language can provide many run-time supports
     but run-time independent compile must be supported too
   * when compiling to cicada language to image file
     the compiler maintains a database of symbol-address binding
     the database records all the use of every symbol
     the database helps one to
     NOT care about the encoding of instruction and title
   * value of symbol
     need to be updateed
     address of primitive-function and primitive-instruction
     need to be updateed
   * when vm interpreting image file
     it reads the database first
     and resolves the symbol in the image file
     meanwhile updating the database
     only after then
     the vm can begin interpreting the image file
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
* -----------------------------------
* (in-package :cicada-vm)
** cicada-vm.lisp
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package :cicada-vm)
   #+end_src
** cicada-vm.test.lisp
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* title.name-table
** ----------------------------------
** note title
   * every object have a title
     title is the way I used to manage nameing of things
     a title could be viewed as
     a type
     a module
     a structure
   * a title is a index into title.name-table
     the index is used as the encoding of that title
     there is only one title.name-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (be)
       <field
       <update?
     * <title
       <name
       (ask)
       <object
       <find?
** ----------------------------------
** title-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title.name-table* 1000)

   (defparameter *size#entry#title.name-table* 100)

   (defparameter *title.name-table*
     ;; should be a byte-vector in assembly version
     (make-array
      `(,*size#title.name-table* ,*size#entry#title.name-table*)
      ;; note that
      ;; this table's element can be of any type
      ;; but actually
      ;; (i 0) must be an name[index] to name-hash-table
      ;; (i n) must be a vector of
      ;; #( name[index] title[index] value )
      :initial-element 0))

   ;; the first entry of *title.name-table* reserved
   ;; for *name-hash-table*
   ;; to test if a name in *name-hash-table*
   ;; is used as title or not
   (defparameter *pointer#title.name-table* 1)
   #+end_src
** index-within-title.name-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun index-within-title.name-table? (index)
     (and (natural-number? index)
          (< index *size#title.name-table*)))
   #+end_src
** title?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (vector)
     (and (vector? vector)
          (= 2 (length vector))
          (equal? '<title>
                  (fetch#vector :vector vector
                                :index 0))
          (index-within-title.name-table?
           (fetch#vector :vector vector
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest title?
       (cicada-vm)
     (ensure
         (list (title? #(<title> 0))

               (title? (string->title "testing#title?")))
         ==>
         (list t
               t)))
   #+end_src
** ----------------------------------
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let* ((name-index
             (name->index (string->name string)))
            (index-for-title
             (fetch#vector :vector *name-hash-table#index-for-title*
                           :index name-index)))
       (cond
         ((not (zero? index-for-title))
          `#(<title> ,index-for-title))

         ((< *pointer#title.name-table*
             ,*size#title.name-table*)
          ;; now
          ;; *pointer#title.name-table* is pointing to
          ;; the next free to use index
          ;; in the *title.name-table*

          ;; save title[index] to *name-hash-table#index-for-title*
          (save#vector :value *pointer#title.name-table*
                       :vector *name-hash-table#index-for-title*
                       :index name-index)

          ;; save name[index] to *title.name-table*
          (save#array :value name-index
                      :array *title.name-table*
                      :index-vector (vector *pointer#title.name-table* 0))

          ;; to update *pointer#title.name-table*
          ;; is to allocate a new index in the *title.name-table*
          (setf *pointer#title.name-table*
                (add1 *pointer#title.name-table*))

          ;; return value
          `#(<title>
             ,(sub1 *pointer#title.name-table*)))

         (:else
          (error "title.name-table is filled, (string->title) can not make new title")))))
   #+end_src
** title->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->index (title)
     (if (not (title? title))
         (error "argument of (title->index) must be a title")
         (fetch#vector :vector title
                       :index 1)))
   #+end_src
** title->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->name (title)
     (if (not (title? title))
         (error "argument of (title->name) must be a title")
         `#(<name>
            ,(fetch#array
              :array *title.name-table*
              :index-vector
              (vector (title->index title) 0)))))
   #+end_src
** title->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->string (title)
     (if (not (title? title))
         (error "argument of (title->string) must be a title")
         (name->string (title->name title))))
   #+end_src
** print-title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-title (title &key (stream t))
     (if (not (title? title))
         (error "the argument of (print-title) must be checked by title?")
         (print-name (title->name title)
                     :stream stream)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest title->index
       (cicada-vm)
     (ensure
         (let ((test1 (title->index (string->title "testing#1#title->index")))
               (test2 (title->index (string->title "testing#2#title->index"))))
           (- test2 test1))
         ==>
         1))

   (deftest print-title
       (cicada-vm)
     (ensure
         (print-title (string->title "kkk")
                      :stream nil)
         ==>
         "[kkk]"))
   #+end_src
** ----------------------------------
** be
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun be (&key
                title
                name
                cicada-object)
     (cond
       ((not (title? title))
        (error "the argument :title of (be) must be a title"))
       ((not (name? name))
        (error "the argument :name of (be) must be a name"))
       ((not (cicada-object? cicada-object))
        (error "the argument :cicada-object of (be) must be a cicada-object?"))
       (:else
        (let ((title-index (title->index title))
              (name-index (name->index name)))
          (be#low-level :title-index title-index
                        :name-index name-index
                        :cicada-byte-vector (cicada-object->cicada-byte-vector
                                             cicada-object))))))


   (defun be#low-level (&key
                          title-index
                          name-index
                          cicada-byte-vector
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ;; creat new
         ((zero? content-of-field)
          (save#array :value (vector name-index
                                     (cicada-byte-vector->title-index cicada-byte-vector)
                                     (cicada-byte-vector->value cicada-byte-vector))
                      :array *title.name-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  nil))
         ;; update
         ((equal? name-index
                  (fetch#vector :vector content-of-field
                                :index 0))
          (save#array :value (vector name-index
                                     (cicada-byte-vector->title-index cicada-byte-vector)
                                     (cicada-byte-vector->value cicada-byte-vector))
                      :array *title.name-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  :updated!!!))
         ;; next
         ((< field *size#entry#title.name-table*)
          (be#low-level :title-index title-index
                        :name-index name-index
                        :cicada-byte-vector cicada-byte-vector
                        :field (add1 field)))
         ;; filled
         (:else
          (error "the names under this title is too filled (be) can not do")))))
   #+end_src
** ask
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun ask (&key
                 title
                 name)
     (cond ((not (title? title))
            (error "the argument :title of (ask) must be a title"))
           ((not (name? name))
            (error "the argument :name of (ask) must be a name"))
           (:else
            (let ((title-index (title->index title))
                  (name-index (name->index name)))
              (multiple-value-bind
                    (cicada-byte-vector
                     found?)
                  (ask#low-level :title-index title-index
                                 :name-index name-index)
                (values (cicada-byte-vector->cicada-object
                         cicada-byte-vector)
                        found?))))))


   (defun ask#low-level (&key
                           title-index
                           name-index
                           (field 1))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ;; not found
         ((zero? content-of-field)
          (values nil
                  nil))
         ;; found
         ((equal? name-index
                  (fetch#vector :vector content-of-field
                                :index 0))
          (let ((vector-of-name-title-value
                 (fetch#array :array *title.name-table*
                              :index-vector `#(,title-index ,field))))
            (values (make-cicada-byte-vector-with#title-index&value
                     :title-index (fetch#vector :vector vector-of-name-title-value
                                                :index 1)
                     :value (fetch#vector :vector vector-of-name-title-value
                                          :index 2)
                     ) ;; this bar-ket is to stress that the next key-word values
                    :found!!!)))
         ;; next
         ((< field *size#entry#title.name-table*)
          (ask#low-level :title-index title-index
                         :name-index name-index
                         :field (add1 field)))
         ;; filled
         (:else
          (error (cat ()
                   ("can not ask for the object under the name as you wish~%")
                   ("and the names under this title is too filled")))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest be--and--ask
       (cicada-vm)
     (ensure
         (list (be :title (string->title "kkk")
                   :name (string->name "took")
                   :cicada-object (make-cicada-object
                                   :title (string->title "my")
                                   :value 666))
               (multiple-value-list
                (be :title (string->title "kkk")
                    :name (string->name "took")
                    :cicada-object (make-cicada-object
                                    :title (string->title "my")
                                    :value 666)))
               (multiple-value-list
                (ask :title (string->title "kkk")
                     :name (string->name "took"))))
         ==>
         (list `1
               `(1
                 :updated!!!)
               `(,(vector '<cicada-object>
                         (cicada-object->cicada-byte-vector
                          (make-cicada-object
                           :title (string->title "my")
                           :value 666)))
                 :found!!!))))
    #+end_src
** ----------------------------------
* name-hash-table
** ----------------------------------
** note name
   * not name value binding in name-hash-table
     name-hash-table is used to
     1. provide the name datatype
     2. implement title.name-table
   * binding will be done in title.name-table
     an object [value with title]
     will be bound to a title name pair
** ----------------------------------
** name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-hash-table* 100333)

   (defparameter *name-hash-table#string*
     (make-vector
      :length *size#name-hash-table*
      :initial-element 0))

   (defparameter *name-hash-table#index-for-title*
     (make-vector
      :length *size#name-hash-table*
      :element-type `(integer 0 ,*size#title.name-table*)
      :initial-element 0))
   #+end_src
** index-within-name-hash-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun index-within-name-hash-table? (index)
     (and (natural-number? index)
          (< index *size#name-hash-table*)))
   #+end_src
** name?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (vector)
     (and (vector? vector)
          (= 2 (length vector))
          (equal? '<name>
                  (fetch#vector :vector vector
                                :index 0))
          (index-within-name-hash-table?
           (fetch#vector :vector vector
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name?
       (cicada-vm)
     (ensure
         (name? #(<name> 0))
         ==>
         t))
   #+end_src
** ----------------------------------
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))
   #+end_src
** natural-number->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-hash-table*)))
   #+end_src
** string->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->index (string)
     (natural-number->index
      (string->natural-number string)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest string->natural-number
       (cicada-vm)
     (ensure
         (list (string->natural-number "")
               (string->natural-number "@")
               (string->natural-number "@@@"))
         ==>
         (list 0
               64
               448)))

   (deftest natural-number->index
       (cicada-vm)
     (ensure
         (list (natural-number->index 0)
               (natural-number->index 123)
               (natural-number->index *size#name-hash-table*))
         ==>
         (list 0
               123
               0)))
   #+end_src
** ----------------------------------
** note
   * name is not only a index
     but also have a type-tag
** string->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (help#string->name#find-old-or-creat-new
      string
      (string->index string)))

   (defun help#string->name#find-old-or-creat-new (string index)
     (cond
       ((not (name-hash-table-index#used? index))
        (help#string->name#creat-new string
                                     index)
        `#(<name> ,index))

       ((equal? string
                (fetch#vector :vector *name-hash-table#string*
                              :index index))
        `#(<name> ,index))

       (:else
        (help#string->name#find-old-or-creat-new
         string
         (name-hash-table-index#next index)))
       ))

   (defun name-hash-table-index#used? (index)
     (not (equal? 0
                  (fetch#vector :vector *name-hash-table#string*
                                :index index))))

   (defun help#string->name#creat-new (string index)
     (save#vector :value string
                  :vector *name-hash-table#string*
                  :index index))

   (defun name-hash-table-index#next (index)
     (if (= index *size#name-hash-table*)
         0
         (add1 index)))
   #+end_src
** to reverse index 0
   * the first entry of *name-hash-table* is reserved
     for *title.name-table*
     to test if a title name pair in *title.name-table*
     is bound to any object or not
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (string->name "")
   #+end_src
** name->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->index (name)
     (cond ((not (name? name))
            (error "argument of (name->index) must be a name"))
           (:else
            (fetch#vector :vector name
                          :index 1))))
   #+end_src
** name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->string (name)
     (if (not (name? name))
         (error "argument of name->string must be a name")
         (let ((index (name->index name)))
           (cond ((not (name-hash-table-index#used? index))
                  (error "this name does not have a string"))
                 (:else
                  (fetch#vector :vector *name-hash-table#string*
                                :index index))
                 ))))
   #+end_src
** print-name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-name (name
                      &key (stream t))
     (format stream
             "[~A]"
             (name->string name)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name->string
       (cicada-vm)
     (ensure
         (name->string (string->name "kkk took my baby away!"))
         ==>
         "kkk took my baby away!"))

   (deftest print-name
       (cicada-vm)
     (ensure
         (print-name (string->name "kkk took my baby away!")
                     :stream nil)
         ==>
         "[kkk took my baby away!]"))
   #+end_src
** ----------------------------------
* cicada-byte-vector
** ----------------------------------
** note
   * this is low-level interface
** ----------------------------------
** cell-unit
   * a cell is of *cell-unit* many bytes
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* (/ *size#fixnum* 8)) ;; unit byte
   #+end_src
** ----------------------------------
** cicada-byte-vector?
   * an object is two cell
     one for title (an index into title-table)
     one for value (of which the meaning is depended on its title)
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))

   (defun cicada-byte-vector? (byte-vector)
     (and (equal? '(unsigned-byte 8)
                  (array-element-type byte-vector))
          (fixnum? (fetch#byte-vector :byte-vector byte-vector
                                      :size *cell-unit*
                                      :index 2))
          (= *cicada-object-size*
             ;; (array-dimension byte-vector 0)
             (length byte-vector))
          (not (zero? (fetch#array
                       :array *title.name-table*
                       :index-vector `#(,(fetch#byte-vector
                                          :byte-vector byte-vector
                                          :size *cell-unit*
                                          :index 0)
                                        0))))))
   #+end_src
** ----------------------------------
** make-cicada-byte-vector-with#title-index&value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun make-cicada-byte-vector-with#title-index&value
       (&key
          title-index
          value)
     (if (not (index-within-title.name-table? title-index))
         (error (cat ()
                  ("the agument :title-index of~%")
                  ("  (make-cicada-byte-vector-with#title-index&value)~%")
                  ("must be an index-within-title.name-table")))
         (let ((cicada-object#byte-vector
                (make-vector :length *cicada-object-size*
                             :element-type '(unsigned-byte 8)
                             :initial-element 0)))
           (save#byte-vector :value title-index
                             :byte-vector cicada-object#byte-vector
                             :size *cell-unit*
                             :index 0)
           ;; save#byte-vector returns the byte-vector
           (save#byte-vector :value value
                             :byte-vector cicada-object#byte-vector
                             :size *cell-unit*
                             :index *cell-unit*))))
   #+end_src
** ----------------------------------
** cicada-byte-vector->title-index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-byte-vector->title-index (cicada-byte-vector)
     (cond ((not (cicada-byte-vector? cicada-byte-vector))
            (error "the argument of (cicada-byte-vector->title-index) must be cicada-byte-vector"))
           (:else
            (fetch#byte-vector :byte-vector cicada-byte-vector
                               :size *cell-unit*
                               :index 0))))
   #+end_src
** cicada-byte-vector->value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-byte-vector->value (cicada-byte-vector)
     (cond ((not (cicada-byte-vector? cicada-byte-vector))
            (error "the argument of (cicada-byte-vector->value) must be cicada-byte-vector"))
           (:else
            (fetch#byte-vector :byte-vector cicada-byte-vector
                               :size *cell-unit*
                               :index *cell-unit*))))
   #+end_src
** ----------------------------------
* cicada-object
** ----------------------------------
** cicada-object?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object? (vector)
     (and (vector? vector)
          (equal? 2 (length vector))
          (equal? '<cicada-object>
                  (fetch#vector :vector vector
                                :index 0))
          (cicada-byte-vector?
           (fetch#vector :vector vector
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest cicada-object?
       (cicada-vm)
     (ensure
         (cicada-object?
          (make-cicada-object :title (string->title "kkk")
                              :value 666))
         ==>
         t))
   #+end_src
** ----------------------------------
** cicada-byte-vector->cicada-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-byte-vector->cicada-object (cicada-byte-vector)
     (if (not (cicada-byte-vector? cicada-byte-vector))
         (error "argument of (cicada-byte-vector->cicada-object) must be a cicada-byte-vector")
         `#(<cicada-object>
            ,cicada-byte-vector)))
   #+end_src
** make-cicada-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun make-cicada-object
       (&key
          title
          value)
     (if (not (title? title))
         (error (cat ()
                  ("the agument :title of~%")
                  ("  (make-cicada-object)~%")
                  ("must be an title")))
         `#(<cicada-object>
            ,(make-cicada-byte-vector-with#title-index&value
              :title-index (title->index title)
              :value value))))
   #+end_src
** cicada-object->cicada-byte-vector
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->cicada-byte-vector (cicada-object)
     (if (not (cicada-object? cicada-object))
         (error "argument of (cicada-object->cicada-byte-vector) must be a cicada-object")
         (fetch#vector :vector cicada-object
                       :index 1)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest make-cicada-object
       (cicada-vm)
     (ensure
         (list (fetch#byte-vector
                :byte-vector
                (cicada-object->cicada-byte-vector
                 (make-cicada-object :title (string->title "kkk")
                                     :value 666))
                :size *cell-unit*
                :index *cell-unit*)
               (equal? (array-element-type
                        (cicada-object->cicada-byte-vector
                         (make-cicada-object :title (string->title "kkk")
                                             :value 666)))
                       '(unsigned-byte 8)))
         ==>
         (list 666
               t)))
   #+end_src
** ----------------------------------
** cicada-object->cicada-byte-vector
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->cicada-byte-vector (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->cicada-byte-vector) must be cicada-object"))
           (:else
            (fetch#vector :vector cicada-object
                          :index 1))))
   #+end_src
** cicada-object->title-index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->title-index (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->title-index) must be cicada-object"))
           (:else
            (cicada-byte-vector->title-index
              (cicada-object->cicada-byte-vector cicada-object)))))
   #+end_src
** cicada-object->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->title (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->title) must be cicada-object"))
           (:else
            `#(<title>
               ,(cicada-object->title-index cicada-object)))))
   #+end_src
** cicada-object->value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->value (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->value) must be cicada-object"))
           (:else
            (cicada-byte-vector->value
             (cicada-object->cicada-byte-vector cicada-object)))))
   #+end_src
** ----------------------------------
* return-stack
** ----------------------------------
** note
   * return-stack is a stack of pointers
     a pointer points into a (one type of) function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers
     that are moving the pointer
     which on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers
     that are pushing or popping the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 body-pointer#vector-function 這個 title
     的數據
     的函數
     而 body-pointer#vector-function 這個 title 下
     有處理這個數據類型
     的函數
** ----------------------------------
** (string->title "return-stack")
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (string->title "return-stack")
   #+end_src
** ----------------------------------
** return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make-vector :length (* *cicada-object-size* *size#return-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *return-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#return-stack* 0)

   ;; explicitly change value to cicada-byte-vector before push
   (defun push#return-stack (cicada-byte-vector)
     (cond
       ((not (cicada-byte-vector? cicada-byte-vector))
        (error "the argument of (push#return-stack) must cicada-byte-vector?"))

       ((not (<  (*  *pointer#return-stack*
                     ,*cicada-object-size*)
                 ,*size#return-stack*))
        (error "can not push anymore *return-stack* is filled"))

       (:else
        (copy#byte-vector :from cicada-byte-vector
                          :from-index 0
                          :to *return-stack*
                          :to-index (*  *pointer#return-stack*
                                        ,*cicada-object-size*)
                          :size *cicada-object-size*)
        (setf *pointer#return-stack*
              (add1 *pointer#return-stack*))
        (values *pointer#return-stack*
                cicada-byte-vector))))

   (defun pop#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error "can not pop anymore *return-stack* is empty"))
       (:else
       (let ((cicada-byte-vector
               (make-cicada-byte-vector-with#title-index&value
                :title-index 0 ;; place holder
                :value 0)))
          (setf *pointer#return-stack*
                (sub1 *pointer#return-stack*))
          (copy#byte-vector :to cicada-byte-vector
                            :to-index 0
                            :from *return-stack*
                            :from-index (*  *pointer#return-stack*
                                            ,*cicada-object-size*)
                            :size *cicada-object-size*)
          (values cicada-byte-vector
                  ,*pointer#return-stack*)))))


   ;; TOS denotes top of stack
   (defun tos#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error "can not pop anymore *return-stack* is empty"))
       (:else
        (let ((cicada-byte-vector
               (make-cicada-byte-vector-with#title-index&value
                :title-index 0 ;; place holder
                :value 0)))
          (copy#byte-vector :to cicada-byte-vector
                            :to-index 0
                            :from *return-stack*
                            :from-index (*  (sub1 *pointer#return-stack*)
                                            ,*cicada-object-size*)
                            :size *cicada-object-size*)
          (values cicada-byte-vector
                  (sub1 *pointer#return-stack*))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest push#return-stack
       (cicada-vm)
     (ensure
         (multiple-value-bind
               (pointer-index#1
                cicada-object#1)
             (push#return-stack
              (cicada-object->cicada-byte-vector
               (make-cicada-object :title (string->title "kkk")
                                   :value 666)))
           (multiple-value-bind
                 (pointer-index#2
                  cicada-object#2)
               (push#return-stack
                (cicada-object->cicada-byte-vector
                 (make-cicada-object :title (string->title "kkk")
                                     :value 666)))
             (list (- pointer-index#2
                      pointer-index#1)
                   (every (function equal?)
                          cicada-object#1
                          cicada-object#2)
                   (every (function equal?)
                          cicada-object#1
                          (cicada-object->cicada-byte-vector
                           (make-cicada-object :title (string->title "kkk")
                                               :value 666)))
                   (equal? (car (cdr (multiple-value-list (pop#return-stack)))) (sub1 pointer-index#2))
                   (equal? (car (cdr (multiple-value-list (tos#return-stack)))) (sub1 pointer-index#1))
                   (every (function equal?)
                          (pop#return-stack)
                          (cicada-object->cicada-byte-vector
                           (make-cicada-object :title (string->title "kkk")
                                               :value 666)))
                   )))
         ==>
         (list 1
               t
               t
               t
               t
               t)))
   #+end_src
** ----------------------------------
** >< next & execute-instruction
   #+begin_src lisp
   ;; the following two address#cicada-object can be index

   (defun next ()
     (let* ((body-pointer (toc#return-stack))
            ;; (title#body-pointer (cicada-object->title body-pointer))
            (address#body-pointer (cicada-object->value body-pointer)))
       (execute-instruction :instruction instruction
                            :cicada-object cicada-object)))


   ;; note that:
   ;; this function defines the interface of primitive-instruction
   ;; as:
   ;; ><><><
   ;; 1. (primitive-instruction host-object)
   ;;    the return-stack will likely be updated by primitive-instruction
   ;; 2. at the end of primitive-instruction
   ;;    the next will likely be called again
   ;; compare this to really CPU to understand it

   (defun execute-instruction
       (&key
          instruction
          cicada-object)
     (let (;; (title#instruction (cicada-object->title instruction))
           (address#instruction (cicada-object->value instruction)))
       (funcall (address->instruction address#instruction)
                (><><>< cicada-object))))
   #+end_src
** ----------------------------------
** address->instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun address->instruction (address)
     ;; ><><>< maybe not only the function in the table's entry
     (fetch#vector :vector *primitive-instruction-table*
                   :index address))
   #+end_src
** ----------------------------------
* primitive-instruction-table
** ----------------------------------
** note
   * 必須用 table 來實現
     primitive-instruction 這個數據結構
     因爲否則就難以把它轉碼爲 cicada-object
     或者說 只有這樣 我才能給 這個數據結構更豐富的性質
     因爲
     除了找到那個 primitive-instruction 本身
     在 host language 中的位置以外
     我還可以增加別的數據域
   * instruction 都是在 title 下的
     但是
     在函數體中
     所保存在 instruction 位置的 cicada-object
     卻是 一個 instruction 的類型標籤
     再加上其 address
   * 函數體中
     保存函數的位置也同樣如此
     所保存的並不是名而是值
     即 function 的 address
   * 要注意 address 可以是 index
     尤其是對於 instruction 而言
     除非在匯編中用絕對地址
     否則都只能使用 index
     因爲 host-language 中
     函數的絕對地址
     不好保存在 cicada-object cell 中
     因爲其絕對地址通常被認爲是用戶不可知的值
** ----------------------------------
** (string->title "primitive-instruction")
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (string->title "primitive-instruction")
   #+end_src
** ----------------------------------
** primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-instruction-table* 1000)

   (defparameter *primitive-instruction-table*
     (make-vector
      :length *size#primitive-instruction-table*
      ;; note that
      ;; this table's element can be of any type
      :initial-element nil))

   (defun index-within-primitive-instruction-table? (index)
     (and (natural-number? index)
          (< index *size#primitive-instruction-table*)))

   (defparameter *pointer#primitive-instruction-table* 0)
   #+end_src
** ----------------------------------
* >< primitive-function-table
* >< argument-stack
* >< frame-stack
* load image
** ----------------------------------
** note
   * in the first few test versions
     the image file will just be a vector-function-body
** ----------------------------------
** *cicada-image-file* & *cicada-image-buffer*
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#cicada-image-buffer* 16)
   (defparameter *cicada-image-file* "test.image.iaa~")

   (defparameter *cicada-image-buffer*
     (make-array `(,(*  *size#cicada-image-buffer*
                        ,*cicada-object-size*))
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))
   #+end_src
** ----------------------------------
** load-file
   #+begin_src lisp :tangle cicada-vm.lisp
   (progn
     (setf stream (open (make-pathname :name *cicada-image-file*)
                        :direction ':output
                        :if-exists ':supersede))
     (format stream "cicada test~%")
     (close stream))


   (defun load-file (&key
                       file
                       buffer
                       (buffer-boundary#lower 0)
                       (buffer-boundary#uper nil))
     (cond ((not (string? file))
            (error "the argument :file of (load-file) must be a string"))
           ((not (byte-vector? buffer))
            (error "the argument :buffer of (load-file) must be a byte-vector"))
           (:else
            ;; return the index of the first byte of the buffer that was not updated
            (read-sequence buffer
                           (open (make-pathname :name file)
                                 :element-type '(unsigned-byte 8)
                                 :direction ':input)
                           :start buffer-boundary#lower
                           :end buffer-boundary#uper))))

   (load-file :file *cicada-image-file*
              :buffer *cicada-image-buffer*)
   #+end_src
** ----------------------------------
* >< vector-function
* >< body-pointer#vector-function
** note
   * with the title system
     no (not much) global addresses will be used
     the title of a poniter helps to make the poniter
     become from an address to an index
* >< instruction-return-stack
** note
   * in cicada language
     you can extend the instruction set of the vm
   * in the body of the definition of your instruction
     when you call a cicada function
     it will not use the return-stack to record the return point
     but to use instruction-return-stack
* >< threaded-code interpreter
** test
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; push#return-stack
   #+end_src
* ===================================
* test
  #+begin_src lisp
  (asdf:load-system "cicada-vm")
  (in-package :cicada-vm)
  (setf *print-pretty* t)
  (run-unit 'basic)
  (run-unit 'cicada-vm)
  #+end_src
* ===================================
