#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* TODO
  * parse image file
  * first version complete
  * cicada-rhapsody
* -----------------------------------
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the way used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
* -----------------------------------
* header
** system declaration
   #+begin_src lisp :tangle cicada-vm.asd
   (defsystem #:cicada-vm
     :description "virtual machine of cicada language"
     :author "XIE Yuheng <xyheme@gmail.com>"
     :depends-on ()
     :serial t
     :components ((:file "cicada-vm--package-header")
                  (:file "cicada-vm")))
   #+end_src
** cicada-vm--package-header
   #+begin_src lisp :tangle cicada-vm--package-header.lisp
   (defpackage #:cicada-vm
     (:use #:common-lisp)
     (:export

      ))
   #+end_src
** (in-package #:cicada-vm)
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package #:cicada-vm)
   #+end_src
* basic
** note
   * you should respect the function
     * when a calculation is done
       it is not respectful
       to not return all of the hard work the function had done
     * so I return multi-value
       to capture almost the whole calculation
   * function should return its audience
     * function should be defined in the way that
       1. the structure of the data applied to the function
          is as regular as possible
          [this will make the function easy to write and easy to read]
       2. when ill-structured data is applied to the function
          the function cry out loud that it is an error
       3. well defined predicate is created
          to test if the data is regular or not
       4. when call the function
          the caller should use the predicate
          to make sure that
          the structure of data is regular
          [this will make the intention of code clear]
** naming convention
   * to use "#" to introduce symbol prefix and postfix
   * a "#" denotes an word such as
     "of" "'s" "is" "are" "for" "to" "from" and so on
     in Chinese
     this kind of words are called unfilled-word
     i.e. word which is not filled by a precise meaning
     the meaning of it should be infered from context
   * when wish to stress that a symbol is used as a bounded-variable
     use "." as its prefix
** predicate
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun nil? (x)
     (null x))

   (defun ture? (x)
     (eq t x))

   (defun false? (x)
     (eq nil x))

   (defun eq? (x y)
     (eq x y))

   (defun equal? (x y)
     (equal x y))

   (defun integer? (x)
     (integerp x))

   (defun natural-number? (x)
     (and (integerp x)
          (<= 0 x)))

   ;; (natural-number? 0)
   ;; (natural-number? 1)
   ;; (natural-number? -1)
   ;; (natural-number? 1.1)


   (defun array? (x)
     (arrayp x))

   (defun string? (x)
     (stringp x))
   #+end_src
** math
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun add1 (x)
     (+ x 1))

   (defun sub1 (x)
     (- x 1))
   #+end_src
** array
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (make-array '(2 3 4) :initial-element nil)

   ;; (array-dimension
   ;;  (make-array '(2 3 4) :initial-element nil)
   ;;  0)

   ;; (array-rank
   ;;  (make-array '(2 3 4) :initial-element nil))

   ;; (aref (make-array '(2 3 4) :initial-element nil)
   ;;       0 0 0)



   (defun fetch#array (&key array index-list)
     (apply (function aref)
            (cons array index-list)))

   ;; (fetch#array :array (make-array '(2 3 4) :initial-element nil)
   ;;              :index-list '(0 0 0))



   (defun save#array (&key value array index-list)
     (setf
      (apply #'aref array index-list) value))

   ;; (save#array :value 1
   ;;             :array (make-array '(2 3 4) :initial-element nil)
   ;;             :index-list '(0 0 0))
   #+end_src
** multi reture value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun reture-zero-value ()
     (values))
   #+end_src
** io
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun read#line (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-line from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))


   (defun read#char (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-char from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))


   (defun newline (&key (many 1))
     (cond ((= 0 many) :nothing)
           ((= 1 many) (format t "~%"))
           ((< 1 many) (format t "~%")
            (newline :many (sub1 many)))
           (:else :nothing)))
   #+end_src
** reader
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun bind-char-to-reader (char reader)
     (set-macro-character char reader))

   (defun find-reader-from-char (char)
     (get-macro-character char))
   #+end_src
** character
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (character "1")
   ;; (character "中")

   ;; error, length of string must be 1
   ;; (character "12")
   #+end_src
** char->code & code->char
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun char->code (char)
     (char-code char))

   (defun code->char (code)
     (code-char code))
   #+end_src
** string#empty?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string#empty? (string)
     (equal? string ""))
   #+end_src
** [char|string]#space? & string#empty?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun char#space? (char)
     (let ((code (char->code char)))
       (cond ((= code 32) t)
             ((= code 10) t)
             (:else nil))))

   ;; (char#space? #\newline)
   ;; (char#space? #\space)


   (defun string#space? (string)
     (not (position-if
           (lambda (char) (not (char#space? char)))
           string)))

   ;; (string#space? " 123 ")
   ;; (string#space? "  ")
   ;; (string#space? "")
   #+end_src
** string->[head|tail|list]#word
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->head#word (string)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (head#word
     ;;        index-end
     ;;        index-start
     ;;        string)
     ;;     (string->head#word string)
     ;;   ><><><)
     (let* ((index-start (position-if
                          (lambda (char) (not (char#space? char)))
                          string))
            (index-end (position-if
                        (lambda (char) (char#space? char))
                        string
                        :start index-start)))
       (values (subseq string
                       index-start
                       index-end)
               index-end
               index-start
               string)))

   ;; (string->head#word " kkk took my baby away! ")
   ;; (string->head#word "k")
   ;; (string->head#word " k")
   ;; (string->head#word "k ")

   ;; the argument applied to string->head#word
   ;; must not be space-string
   ;; one should use string#space? to ensure this

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#word " ")



   (defun string->tail#word (string)
     (multiple-value-bind
           (head#word
            index-end
            index-start
            string)
         (string->head#word string)
       (if (nil? index-end)
           ""
           (subseq string index-end))))

   ;; (string->tail#word " kkk took my baby away! ")




   (defun string->list#word (string &key (base-list '()))
     (cond
       ((string#space? string) base-list)
       (:else
        (cons (string->head#word string)
              (string->list#word (string->tail#word string))))))

   ;; (string->list#word " kkk took my baby away! ")
   ;; (string->list#word " kkk")
   ;; (string->list#word "kkk ")
   ;; (string->list#word " ")
   ;; (string->list#word "")
   #+end_src
** string->[head|tail|list]#char
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->head#char (string)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (head#char
     ;;        tail#char
     ;;        string)
     ;;     (string->head#char string)
     ;;   ><><><)
     (values (char string 0)
             (subseq string
                     1)
             string))

   ;; (string->head#char " kkk took my baby away! ")
   ;; (string->head#char "k")
   ;; (string->head#char " k")
   ;; (string->head#char "k ")

   ;; the argument applied to string->head#char
   ;; must not be ""
   ;; one should use string#empty? to ensure this

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#char "")



   (defun string->tail#char (string)
     (multiple-value-bind
           (head#char
            tail#char
            string)
         (string->head#char string)
       tail#char))

   ;; (string->tail#char " kkk took my baby away! ")
   ;; (string->tail#char "")



   (defun string->list#char (string &key (base-list '()))
     (cond
       ((string#empty? string) base-list)
       (:else
        (cons (string->head#char string)
              (string->list#char (string->tail#char string))))))

   ;; (string->list#char " kkk took my baby away! ")
   ;; (string->list#char " kkk")
   ;; (string->list#char "kkk ")
   ;; (string->list#char " ")
   ;; (string->list#char "")
   #+end_src
** shift#[left|right]
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun shift#left (&key
                        (step 1)
                        number)
     (* number
        (expt 2 step)))

   ;; (shift#left
   ;;  :step 2
   ;;  :number 10)
   ;; (shift#left
   ;;  :number 10)


   (defun shift#right (&key
                         (step 1)
                         number)
     (/ number
        (expt 2 step)))

   ;; (shift#right
   ;;  :step 2
   ;;  :number 64)
   ;; (shift#right
   ;;  :number 64)
   #+end_src
** string->symbol & symbol->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun symbol->string (symbol)
     (symbol-name symbol))

   (defun string->symbol (string)
     (intern string))
   #+end_src
** group
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun group (list
                 &key
                   (number 2)
                   ;; (pattern '())
                   (base-list '()))
     (cond ((< (length list) 2) base-list)
           (:else
            (cons (list (first list) (second list))
                  (group (cddr list)
                         :number number)))))
   ;; (defun help#group ())
   #+end_src
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     symbol <name
     symbol <as
     (explain)
     for example
     one can explain a symbol as
     * type
     * string
     * instruction
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** the table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-table*
     100333)

   (defparameter *size#entry#name-table*
     100)

   (defparameter *name-table*
     (make-array
      (list *size#name-table* *size#entry#name-table*)
      :initial-element nil))

   (defun index-within-name-table? (index)
     (and (natural-number? index)
          (< index *size#name-table*)))
   #+end_src
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))

   ;; (string->natural-number "")
   ;; (string->natural-number "@")
   ;; (string->natural-number "@@@")
   #+end_src
** natural-number->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-table*)))

   ;; (natural-number->index 0)
   ;; (natural-number->index 123)
   ;; (natural-number->index 123.123)
   #+end_src
** name?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (x)
     (and (array? x)
          (= 1 (array-rank x))
          (= 2 (array-dimension x
                                0))
          (equal? '<name>
                  (fetch#array :array x
                               :index-list '(0)))
          (index-within-name-table?
           (fetch#array :array x
                        :index-list '(1)))))

   ;; (name? #(<name> 0))
   #+end_src
** string->name & name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (let ((index
            (natural-number->index
             (string->natural-number string))))
       (help#string->name#find-old-or-creat-new string
                                                index)))


   (defun help#string->name#find-old-or-creat-new (string index)
     (cond
       ((not (name-table-index#used? index))
        (help#string->name#creat-new string
                                     index)
        `#(<name> ,index))

       ((equal? string
                (fetch#array :array *name-table*
                             :index-list `(,index 0)))
        `#(<name> ,index))

       (:else
        (help#string->name#find-old-or-creat-new
         string
         (name-table-index#next index)))
       ))


   (defun help#string->name#creat-new (string index)
    (save#array :value string
                :array *name-table*
                :index-list `(,index 0)))


   (defun name-table-index#used? (index)
     (string? (fetch#array :array *name-table*
                           :index-list `(,index 0))))

   (defun name-table-index#next (index)
     (if (= index *size#name-table*)
         0
         (add1 index)))


   (defun name->index (name)
     (cond ((not (name? name))
            (error "argument of name->index must be a name"))
           (:else
            (fetch#array :array name
                         :index-list '(1)))))

   (defun name->string (name)
     (cond ((not (name? name))
            (error "argument of name->string must be a name"))
           (:else
            (let ((index (name->index name)))
              (cond ((not (name-table-index#used? index))
                     (error "this name does not have a string"))
                    (:else
                     (fetch#array :array *name-table*
                                  :index-list `(,index 0)))
                    )))
           ))


   ;; (name->string (string->name "kkk took my baby away!"))
   #+end_src
** print-name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-name (name
                      &key (stream t))
     (format stream
             "[~A]"
             (name->string name)))

   ;; (print-name (string->name "kkk took my baby away!"))
   #+end_src
** be & explain
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun be (&key
                name
                as
                mean)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (field
     ;;        update?
     ;;        old-mean)
     ;;     (be :name name
     ;;         :as as
     ;;         :mean mean)
     ;;   ><><><)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (be) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#be :name-index name-index
                    :as-index as-index
                    :mean mean))))



   (defun help#be (&key
                     name-index
                     as-index
                     mean
                     (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-list `(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-list `(,name-index ,field))
          (values field
                  nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-list `(,name-index ,field))
          (values field
                  t
                  (cdr content-of-field)))

         ((< field *size#entry#name-table*)
          (help#be :name-index name-index
                   :as-index as-index
                   :mean mean
                   :field (add1 field)))

         (:else
          (error "the meaning of this name is too filled"))
         )))





   (defun explain (&key
                     name
                     as)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (mean
     ;;        find?)
     ;;     (explain :name name
     ;;              :as as)
     ;;   ><><><)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (explain) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#explain :name-index name-index
                         :as-index as-index))))



   (defun help#explain (&key
                          name-index
                          as-index
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-list `(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  t))

         ((< field *size#entry#name-table*)
          (help#explain :name-index name-index
                        :as-index as-index
                        :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not explain the name in the way you wish~%"
                  "and the meaning of this name is too filled")))
         )))



   ;; (be :name (string->name "kkk")
   ;;     :as (string->name "took")
   ;;     :mean "my baby away!")

   ;; (explain :name (string->name "kkk")
   ;;          :as (string->name "took"))
   #+end_src
* threaded-code interpreter
** note
   * primitive-function set
     instruction set
   * return-stack
     argument-stack
     frame-stack
   * 也就是說專門有一個 stack
     專注於約束變元
     而 argument-stack 還是以 古典的 forth 的方式工作
** ><
   #+begin_src lisp
   (progn
    ;; form a (file . buffer) pair
    (setf stream (open (make-pathname :name "cicada-image-file-test~")
                       :direction ':output
                       :if-exists ':supersede))
    ;; edit the buffer
    (format stream "cicada ~%")
    ;; save-buffer-to-file
    (close stream))

   (defparameter *cicada-image-stream*
     (open (make-pathname :name "cicada-image-file-test~")
           :element-type '(unsigned-byte 8)
           :direction ':input))

   (defparameter *cicada-image-buffer*
     (make-array '(100)
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))

   (values
    (read-sequence *cicada-image-buffer*
                   ,*cicada-image-stream*)
    ,*cicada-image-buffer*)
   #+end_src
* >< cicada-rhapsody
  #+begin_src lisp
  (defun name-reader (stream char-bound-with-this-function)
    (read#char :from stream
               :recursive-call-to-reader? nil))

  (bind-char-to-reader
   (character "[")
   (function name-reader))

  ;; (find-reader-from-char (character "["))
  (values [123])


  (readtablep *readtable*)
  (setq zvar 123)
  (set-syntax-from-char
   #\z #\'
   (setq table2 (copy-readtable)))

  (setq *readtable* table2)
  ;; zvar =>  VAR
  (setq *readtable* (copy-readtable nil))
  ;; zvar =>  123

  [ (cicada)

  ]

  ## cicada
  ## end cicada

  cicada.cicada
  cicada.iaa
  #+end_src
* -----------------------------------
* test
  #+begin_src lisp
  (progn
    (asdf:load-system 'cicada-vm)
    (in-package :cicada-vm))
  #+end_src
