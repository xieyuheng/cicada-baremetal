#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* ===================================
* TODO
  * reading & writing image file
  * interface between host and cicada
  * vector-function
  * the funciton (next)
  * first version
    without database of symbol usage
    without resolving system
  * parsing image file
  * cicada-rhapsody
* -----------------------------------
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the way used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
  * when a image file is loaded to *cicada-image-buffer*
    host language can provide many run-time supports
    but run-time independent compile must be supported too
  * when compiling to cicada language to image file
    the compiler maintains a database of symbol-address binding
    the database records all the use of every symbol
    the database helps one to
    NOT care about the encoding of instruction and title
  * value of symbol
    need to be updateed
    address of primitive-function and primitive-instruction
    need to be updateed
  * when vm interpreting image file
    it reads the database first
    and resolves the symbol in the image file
    meanwhile updating the database
    only after then
    the vm can begin interpreting the image file
* -----------------------------------
* header
** system declaration
   #+begin_src lisp :tangle cicada-vm.asd
   (defsystem #:cicada-vm
     :description "virtual machine of cicada language"
     :author "XIE Yuheng <xyheme@gmail.com>"
     :depends-on ()
     :serial t
     :components ((:file "cicada-vm--package-header")
                  (:file "cicada-vm")))
   #+end_src
** cicada-vm--package-header
   #+begin_src lisp :tangle cicada-vm--package-header.lisp
   (defpackage #:cicada-vm
     (:use #:common-lisp)
     (:export

      ))
   #+end_src
** (in-package #:cicada-vm)
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package #:cicada-vm)
   #+end_src
* -----------------------------------
* basic
** note
   * you should respect the function
     * when a calculation is done
       it is not respectful
       to not return all of the hard work the function had done
     * so I return multi-value
       to capture almost the whole calculation
   * function should return its audience
     * function should be defined in the way that
       1. the structure of the data applied to the function
          is as regular as possible
          [this will make the function easy to write and easy to read]
       2. when ill-structured data is applied to the function
          the function cry out loud that it is an error
       3. well defined predicate is created
          to test if the data is regular or not
       4. when call the function
          the caller should use the predicate
          to make sure that
          the structure of data is regular
          [this will make the intention of code clear]
** naming convention
   * to use "#" to introduce symbol prefix and postfix
   * a "#" denotes an word such as
     "of" "'s" "is" "are" "for" "to" "from" and so on
     in Chinese
     this kind of words are called unfilled-word
     i.e. word which is not filled by a precise meaning
     the meaning of it should be infered from context
   * when wish to stress that a symbol is used as a bounded-variable
     use "." as its prefix
** predicate
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun nil? (x)
     (null x))


   (defun ture? (x)
     (eq t x))

   (defun false? (x)
     (eq nil x))


   (defun eq? (x y)
     (eq x y))

   (defun equal? (x y)
     (equal x y))


   (defun zero? (x)
     (and (integerp x)
          (zerop x)))

   (defun integer? (x)
     (integerp x))

   (defun natural-number? (x)
     (and (integerp x)
          (<= 0 x)))

   ;; (natural-number? 0)
   ;; (natural-number? 1)
   ;; (natural-number? -1)
   ;; (natural-number? 1.1)


   (defun list? (x)
     (listp x))

   (defun array? (x)
     (arrayp x))

   (defun vector? (x)
     (vectorp x))


   (defun string? (x)
     (stringp x))

   (defun pair? (x)
     (consp x))
   #+end_src
** math
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun add1 (x)
     (+ x 1))

   (defun sub1 (x)
     (- x 1))
   #+end_src
** bit
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#bits (&key
                        bits
                        (size 1)
                        index)
     (ldb (byte size index) bits))

   (defun save#bits (&key
                       value
                       bits
                       (size 1)
                       index)
     (setf (ldb (byte size index) bits) value)
     (values bits
             value))


   ;; (fetch#bits :bits #b0010
   ;;             :size 1
   ;;             :index 1)
   ;; ==> 1
   #+end_src
** byte
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#bytes (&key
                         bytes
                         (size 1)
                         index)
     (fetch#bits :bits bytes
                 :size (* 8 size)
                 :index (* 8 index)))

   ;; (fetch#byte :number #xff  :index 0) ;; 255
   ;; (fetch#byte :number #xff  :index 1) ;; 0
   ;; (fetch#byte :number #x100 :index 0) ;; 0
   ;; (fetch#byte :number #x100 :index 1) ;; 1


   (defun save#bytes (&key
                        value
                        bytes
                        (size 1)
                        index)
     (save#bits :value value
                :bits bytes
                :size (* 8 size)
                :index (* 8 index)))
   #+end_src
** list->vector & vector->list
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun list->vector (list)
     (if (not (list? list))
         (error "the argument of (list->vector) must be a list")
         (coerce list 'vector)))


   (defun vector->list (vector)
     (if (not (vector? vector))
         (error "the argument of (vector->list) must be a vector")
         (coerce vector 'list)))
   #+end_src
** array
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (make-array '(2 3 4) :initial-element nil)

   ;; (array-dimension
   ;;  (make-array '(2 3 4) :initial-element nil)
   ;;  2)

   ;; (array-rank
   ;;  (make-array '(2 3 4) :initial-element nil))

   ;; (aref (make-array '(2 3 4) :initial-element nil)
   ;;       0 0 0)



   (defun fetch#array (&key
                         array
                         index-vector)
     (let ((index-list (vector->list index-vector)))
       (apply (function aref)
              array index-list)))


   ;; (fetch#array :array (make-array '(2 3 4) :initial-element nil)
   ;;              :index-vector '#(0 0 0))



   (defun save#array (&key
                        value
                        array
                        index-vector)
     (let ((index-list (vector->list index-vector)))
       (setf
        (apply #'aref array index-list) value)
       (values array
               value)))

   ;; (save#array :value 1
   ;;             :array (make-array '(2 3 4) :initial-element nil)
   ;;             :index-vector '#(0 0 0))
   #+end_src
** vector
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#vector (&key
                          vector
                          index)
     (fetch#array :array vector
                  :index-vector `#(,index)))



   (defun save#vector (&key
                         value
                         vector
                         index)
     (save#array :value value
                 :array vector
                 :index-vector `#(,index)))



   (defun copy-vector (vector)
     (if (not (vector? vector))
         (error "the argument of copy-vector must be a vector")
         (copy-seq vector)))
   #+end_src
** byte-array
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#byte-array
       (&key
          byte-array
          (size 1)
          index-vector
          (endian 'little))
     (cond
       ((not (<= (+ (fetch#vector :vector index-vector
                                  :index (sub1 (array-rank byte-array)))
                    size)
                 (array-dimension byte-array
                                  (sub1 (array-rank byte-array)))))
        (error "the size of the value you wish to fetch is out of the index of the byte-array"))

       ((equal? endian 'little)
        (help#little-endian#fetch#byte-array
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       ((equal? endian 'big)
        (help#big-endian#fetch#byte-array
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       (:else
        (error "the argument :endian of (fetch#byte-array) must be 'little or 'big"))
       ))


   (defun help#little-endian#fetch#byte-array
       (&key
          byte-array
          size
          index-vector
          (counter 0)
          (sum 0))
     (cond
       ((not (< counter
                size))
        sum)

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               (value-for-shift (fetch#array
                                 :array byte-array
                                 :index-vector index-vector))
               (value-for-sum (shift#left
                               :step (* 8 counter)
                               :number value-for-shift)))
          ;; update index-vector
          (save#vector :value (add1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#little-endian#fetch#byte-array
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter)
           :sum (+ sum value-for-sum))))
       ))

   ;; (let ((k (make-array `(,*cicada-object-size*)
   ;;                      :element-type '(unsigned-byte 8)
   ;;                      :initial-element 1)))
   ;;   (fetch#byte-array :byte-array k
   ;;                     :size 2
   ;;                     :index-vector #(0)))
   ;; ==> 257



   ;; (add1) change to (sub1)
   ;; new index-vector-for-fetch
   (defun help#big-endian#fetch#byte-array
       (&key
          byte-array
          size
          index-vector
          (counter 0)
          (sum 0))
     (cond
       ((not (< counter
                size))
        sum)

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               ;; new index-vector-for-fetch
               (index-vector-for-fetch (save#vector
                                        :value (+ last-index
                                                  (sub1 size))
                                        :vector (copy-vector index-vector)
                                        :index (sub1 (array-rank byte-array))))
               (value-for-shift (fetch#array
                                 :array byte-array
                                 :index-vector index-vector-for-fetch))
               (value-for-sum (shift#left
                               :step (* 8 counter)
                               :number value-for-shift)))
          ;; update index-vector
          ;; (add1) change to (sub1)
          (save#vector :value (sub1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#big-endian#fetch#byte-array
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter)
           :sum (+ sum value-for-sum))))
       ))

   ;; (let ((k (make-array `(,*cicada-object-size*)
   ;;                      :element-type '(unsigned-byte 8)
   ;;                      :initial-element 1)))
   ;;   (fetch#byte-array :byte-array k
   ;;                     :size 2
   ;;                     :index-vector #(0)
   ;;                     :endian 'big))
   ;; ==> 257




   (defun save#byte-array
       (&key
          value
          byte-array
          (size 1)
          index-vector
          (endian 'little))
     (cond
       ((not (<= (+ (fetch#vector :vector index-vector
                                  :index (sub1 (array-rank byte-array)))
                    size)
                 (array-dimension byte-array
                                  (sub1 (array-rank byte-array)))))
        (error "the size of the value you wish to save is out of the index of the byte-array"))

       ((equal? endian 'little)
        (help#little-endian#save#byte-array
         :value value
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       ((equal? endian 'big)
        (help#big-endian#save#byte-array
         :value value
         :byte-array byte-array
         :size size
         :index-vector index-vector))

       (:else
        (error "the argument :endian of (save#byte-array) must be 'little or 'big"))
       ))


   (defun help#little-endian#save#byte-array
       (&key
          value
          byte-array
          size
          index-vector
          (counter 0))
     (cond
       ((not (< counter
                size))
        (values byte-array
                value))

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array)))))
          ;; save to byte-array
          (save#array :value (fetch#bytes :bytes value
                                          :size 1
                                          :index counter)
                      :array byte-array
                      :index-vector index-vector)
          ;; update index-vector
          (save#vector :value (add1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#little-endian#save#byte-array
           :value value
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter))))
       ))



   ;; (let ((k (make-array `(,*cicada-object-size*)
   ;;                      :element-type '(unsigned-byte 8)
   ;;                      :initial-element 1)))
   ;;   (save#byte-array :value 1234
   ;;                    :byte-array k
   ;;                    :size 2
   ;;                    :index-vector #(0))
   ;;   (fetch#byte-array :byte-array k
   ;;                     :size 2
   ;;                     :index-vector #(0)))
   ;; ==> 1234



   ;; (add1) change to (sub1)
   ;; new index-vector-for-save
   (defun help#big-endian#save#byte-array
       (&key
          value
          byte-array
          size
          index-vector
          (counter 0))
     (cond
       ((not (< counter
                size))
        (values byte-array
                value))

       (:else
        (let* ((last-index (fetch#vector
                            :vector index-vector
                            :index (sub1 (array-rank byte-array))))
               ;; new index-vector-for-save
               (index-vector-for-save (save#vector
                                       :value (+ last-index
                                                 (sub1 size))
                                       :vector (copy-vector index-vector)
                                       :index (sub1 (array-rank byte-array)))))
          ;; save to byte-array
          (save#array :value (fetch#bytes :bytes value
                                          :size 1
                                          :index counter)
                      :array byte-array
                      :index-vector index-vector-for-save)
          ;; update index-vector
          ;; (add1) change to (sub1)
          (save#vector :value (sub1 last-index)
                       :vector index-vector
                       :index (sub1 (array-rank byte-array)))
          ;; loop
          (help#big-endian#save#byte-array
           :value value
           :byte-array byte-array
           :size size
           :index-vector index-vector
           :counter (add1 counter))))
       ))



   ;; (let ((k (make-array `(,*cicada-object-size*)
   ;;                      :element-type '(unsigned-byte 8)
   ;;                      :initial-element 1)))
   ;;   (save#byte-array :value 1234
   ;;                    :byte-array k
   ;;                    :size 2
   ;;                    :index-vector #(0)
   ;;                    :endian 'big)
   ;;   (fetch#byte-array :byte-array k
   ;;                     :size 2
   ;;                     :index-vector #(0)
   ;;                     :endian 'big))
   ;; ==> 1234
   #+end_src
** byte-vector
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#byte-vector (&key
                               byte-vector
                               (size 1)
                               index
                               (endian 'little))
     (fetch#byte-array :byte-array byte-vector
                       :size size
                       :index-vector `#(,index)
                       :endian endian))

   ;; (let ((k (make-array `(,*cicada-object-size*)
   ;;                      :element-type '(unsigned-byte 8)
   ;;                      :initial-element 1)))
   ;;   (fetch#byte-vector :byte-vector k
   ;;                      :size 2
   ;;                      :index 0))
   ;; ==> 257


   (defun save#byte-vector (&key
                              value
                              byte-vector
                              (size 1)
                              index
                              (endian 'little))
     (save#byte-array :value value
                      :byte-array byte-vector
                      :size size
                      :index-vector `#(,index)
                      :endian endian))

   ;; (let ((k (make-array `(,*cicada-object-size*)
   ;;                      :element-type '(unsigned-byte 8)
   ;;                      :initial-element 1)))
   ;;   (save#byte-vector :value 1234
   ;;                     :byte-vector k
   ;;                     :size 2
   ;;                     :index 0)
   ;;   (fetch#byte-vector :byte-vector k
   ;;                      :size 2
   ;;                      :index 0))
   ;; ==> 1234
   #+end_src
** multi return value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun return-zero-value ()
     (values))
   #+end_src
** io
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun read#line (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-line from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))


   (defun read#char (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof)
                       (recursive-call-to-reader? nil))
     (read-char from
                eof-as-error?
                read-eof-as
                recursive-call-to-reader?))


   (defun newline (&key (many 1))
     (cond ((= 0 many) :nothing)
           ((= 1 many) (format t "~%"))
           ((< 1 many) (format t "~%")
            (newline :many (sub1 many)))
           (:else :nothing)))
   #+end_src
** reader
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun bind-char-to-reader (char reader)
     (set-macro-character char reader))

   (defun find-reader-from-char (char)
     (get-macro-character char))
   #+end_src
** character
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (character "1")
   ;; (character "中")

   ;; error, length of string must be 1
   ;; (character "12")
   #+end_src
** char->code & code->char
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun char->code (char)
     (char-code char))

   (defun code->char (code)
     (code-char code))
   #+end_src
** string#empty?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string#empty? (string)
     (equal? string ""))
   #+end_src
** [char|string]#space? & string#empty?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun char#space? (char)
     (let ((code (char->code char)))
       (cond ((= code 32) t)
             ((= code 10) t)
             (:else nil))))

   ;; (char#space? #\newline)
   ;; (char#space? #\space)


   (defun string#space? (string)
     (not (position-if
           (lambda (char) (not (char#space? char)))
           string)))

   ;; (string#space? " 123 ")
   ;; (string#space? "  ")
   ;; (string#space? "")
   #+end_src
** string->[head|tail|list]#word
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->head#word (string)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (head#word
     ;;        index-end
     ;;        index-start
     ;;        string)
     ;;     (string->head#word string)
     ;;   ><><><)
     (let* ((index-start (position-if
                          (lambda (char) (not (char#space? char)))
                          string))
            (index-end (position-if
                        (lambda (char) (char#space? char))
                        string
                        :start index-start)))
       (values (subseq string
                       index-start
                       index-end)
               index-end
               index-start
               string)))

   ;; (string->head#word " kkk took my baby away! ")
   ;; (string->head#word "k")
   ;; (string->head#word " k")
   ;; (string->head#word "k ")

   ;; the argument applied to string->head#word
   ;; must not be space-string
   ;; one should use string#space? to ensure this

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#word " ")



   (defun string->tail#word (string)
     (multiple-value-bind
           (head#word
            index-end
            index-start
            string)
         (string->head#word string)
       (if (nil? index-end)
           ""
           (subseq string index-end))))

   ;; (string->tail#word " kkk took my baby away! ")




   (defun string->list#word (string &key (base-list '()))
     (cond
       ((string#space? string) base-list)
       (:else
        (cons (string->head#word string)
              (string->list#word (string->tail#word string))))))

   ;; (string->list#word " kkk took my baby away! ")
   ;; (string->list#word " kkk")
   ;; (string->list#word "kkk ")
   ;; (string->list#word " ")
   ;; (string->list#word "")
   #+end_src
** string->[head|tail|list]#char
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->head#char (string)
     ;; interface:
     ;; (multiple-value-bind
     ;;       (head#char
     ;;        tail#char
     ;;        string)
     ;;     (string->head#char string)
     ;;   ><><><)
     (values (char string 0)
             (subseq string
                     1)
             string))

   ;; (string->head#char " kkk took my baby away! ")
   ;; (string->head#char "k")
   ;; (string->head#char " k")
   ;; (string->head#char "k ")

   ;; the argument applied to string->head#char
   ;; must not be ""
   ;; one should use string#empty? to ensure this

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#char "")



   (defun string->tail#char (string)
     (multiple-value-bind
           (head#char
            tail#char
            string)
         (string->head#char string)
       tail#char))

   ;; (string->tail#char " kkk took my baby away! ")
   ;; (string->tail#char "")



   (defun string->list#char (string &key (base-list '()))
     (cond
       ((string#empty? string) base-list)
       (:else
        (cons (string->head#char string)
              (string->list#char (string->tail#char string))))))

   ;; (string->list#char " kkk took my baby away! ")
   ;; (string->list#char " kkk")
   ;; (string->list#char "kkk ")
   ;; (string->list#char " ")
   ;; (string->list#char "")
   #+end_src
** shift#[left|right]
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun shift#left (&key
                        (step 1)
                        number)
     (* number
        (expt 2 step)))

   ;; (shift#left
   ;;  :step 2
   ;;  :number 10)
   ;; (shift#left
   ;;  :number 10)


   (defun shift#right (&key
                         (step 1)
                         number)
     (/ number
        (expt 2 step)))

   ;; (shift#right
   ;;  :step 2
   ;;  :number 64)
   ;; (shift#right
   ;;  :number 64)
   #+end_src
** string->symbol & symbol->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun symbol->string (symbol)
     (symbol-name symbol))

   (defun string->symbol (string)
     (intern string))
   #+end_src
** group
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun group (list
                 &key
                   (number 2)
                   ;; (pattern '())
                   (base-list '()))
     (cond ((< (length list) 2) base-list)
           (:else
            (cons (list (first list) (second list))
                  (group (cddr list)
                         :number number)))))
   ;; (defun help#group ())
   #+end_src
** list
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun end-of-list (list)
     (cond
       ((not (pair? list))
        (error "the argument of (end-of-list) must be a list"))
       (:else
        (help#loop#end-of-list list))
       ))

   (defun help#loop#end-of-list (list)
     (let ((cdr#list (cdr list)))
       (cond
         ((nil? cdr#list)
          (car list))
         ((not (pair? cdr#list))
          (error (concatenate
                  'string
                  "the argument of (end-of-list) must be not only a list~%"
                  "but also a proper-list")))
         (:else
          (help#loop#end-of-list cdr#list))
         )))

   ;; (end-of-list '(1 2 3))
   ;; (end-of-list '(1 2 . 3))
   ;; (end-of-list 3)
   #+end_src
* cell
** note
   * in cicada
     an object is two cell
     one for title
     one for value
   * a cell is *cell-unit* many bytes
     the title cell is just a index into title-table
     the maening of the value cell is depends on its title
   * in the host language of cicada
     functions
     (host-object->cicada-object)
     (cicada-object->host-object)
     are provided
** cell-unit
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* 4) ;; 4 bytes
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))
   #+end_src
* object
** object?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun object? (x)
     (and (array? x)
          (= 1 (array-rank x))
          (= 3 (array-dimension x
                                0))
          (equal? '<object>
                  (fetch#vector :vector x
                                :index 0))
          (title? (fetch#vector :vector x
                                :index 1))))

   ;; (object? #(<object>
   ;;            #(<title> 0)
   ;;            #(<name> 0)))
   ;; ==> T
   #+end_src
* interface between host and cicada
** note
   * 可能需要重新用 vector-of-byte
     來重新實現 common-lisp 的所有數據結構
     比如 stack
   * 這相當於改變
     數據轉碼的位置
     1. 比如可以在 stack 之間相互轉移數據時 轉碼
     2. 也可以把 stack 用同一的方式實現
        然後用在每個 primitive-function 接收參數時 轉碼
** host-object->cicada-object
   #+begin_src lisp
   (defun host-object->cicada-object (host-object)
     (if (not (object? host-object))
         (error "the argument of host-object->cicada-object must be checked by object?")
         (let ((cicada-object (make-array `(,*cicada-object-size*)
                                          :element-type '(unsigned-byte 8)
                                          :initial-element 0)))

           cicada-object)))




   (let ((kkk (make-array `(,*cicada-object-size*)
                          :element-type '(unsigned-byte 8)
                          :initial-element 0)))
     (save#array :value 123
                 :array kkk
                 :index-vector `#(2))
     kkk)
   #+end_src
** cicada-object->host-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->host-object (cicada-object)
     ())
   #+end_src
* load image
** note
   * in the first few test versions
     the image file will just be a vector-function-body
** ><
   #+begin_src lisp
   (progn
    ;; form a (file . buffer) pair
    (setf stream (open (make-pathname :name "cicada-image-file-test~")
                       :direction ':output
                       :if-exists ':supersede))
    ;; edit the buffer
    (format stream "cicada ~%")
    ;; save-buffer-to-file
    (close stream))

   (defparameter *cicada-image-stream*
     (open (make-pathname :name "cicada-image-file-test~")
           :element-type '(unsigned-byte 8)
           :direction ':input))

   (defparameter *cicada-image-buffer*
     (make-array '(100)
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))

   (values
    (read-sequence *cicada-image-buffer*
                   ,*cicada-image-stream*)
    ,*cicada-image-buffer*)
   #+end_src
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     * <name
       <as
       <mean
       (be)
     * <name
       <as
       (explain)
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** the name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-table*
     100333)

   (defparameter *size#entry#name-table*
     100)

   (defparameter *name-table*
     (make-array
      (list *size#name-table* *size#entry#name-table*)
      :initial-element nil))

   (defun index-within-name-table? (index)
     (and (natural-number? index)
          (< index *size#name-table*)))
   #+end_src
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))

   ;; (string->natural-number "")
   ;; (string->natural-number "@")
   ;; (string->natural-number "@@@")
   #+end_src
** natural-number->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-table*)))

   ;; (natural-number->index 0)
   ;; (natural-number->index 123)
   ;; (natural-number->index 123.123)
   #+end_src
** name?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (x)
     (and (array? x)
          (= 1 (array-rank x))
          (= 2 (array-dimension x
                                0))
          (equal? '<name>
                  (fetch#vector :vector x
                                :index 0))
          (index-within-name-table?
           (fetch#vector :vector x
                         :index 1))))

   ;; (name? #(<name> 0))
   ;; ==> T
   #+end_src
** name->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->index (name)
     (cond ((not (name? name))
            (error "argument of name->index must be a name"))
           (:else
            (fetch#vector :vector name
                          :index 1))))
   #+end_src
** string->name & name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (let ((index
            (natural-number->index
             (string->natural-number string))))
       (help#string->name#find-old-or-creat-new string
                                                index)))

   (defun help#string->name#find-old-or-creat-new (string index)
     (cond
       ((not (name-table-index#used? index))
        (help#string->name#creat-new string
                                     index)
        `#(<name> ,index))

       ((equal? string
                (fetch#array :array *name-table*
                             :index-vector `#(,index 0)))
        `#(<name> ,index))

       (:else
        (help#string->name#find-old-or-creat-new
         string
         (name-table-index#next index)))
       ))


   (defun help#string->name#creat-new (string index)
    (save#array :value string
                :array *name-table*
                :index-vector `#(,index 0)))


   (defun name-table-index#used? (index)
     (string? (fetch#array :array *name-table*
                           :index-vector `#(,index 0))))

   (defun name-table-index#next (index)
     (if (= index *size#name-table*)
         0
         (add1 index)))



   (defun name->string (name)
     (cond ((not (name? name))
            (error "argument of name->string must be a name"))
           (:else
            (let ((index (name->index name)))
              (cond ((not (name-table-index#used? index))
                     (error "this name does not have a string"))
                    (:else
                     (fetch#array :array *name-table*
                                  :index-vector `#(,index 0)))
                    )))
           ))


   ;; (name->string (string->name "kkk took my baby away!"))
   #+end_src
** print-name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-name (name
                      &key (stream t))
     (format stream
             "[~A]"
             (name->string name)))

   ;; (print-name (string->name "kkk took my baby away!"))
   #+end_src
** be & explain
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; <name
   ;; <as
   ;; <mean
   ;; (be)

   ;; <name
   ;; <as
   ;; (explain)



   ;; interface:
   ;; (multiple-value-bind
   ;;       (field
   ;;        update?
   ;;        old-mean)
   ;;     (be :name
   ;;         :as
   ;;         :mean )
   ;;   ><><><)

   (defun be (&key
                name
                as
                mean)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (be) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#be :name-index name-index
                    :as-index as-index
                    :mean mean))))



   (defun help#be (&key
                     name-index
                     as-index
                     mean
                     (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-vector `#(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-vector `#(,name-index ,field))
          (values field
                  nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-vector `#(,name-index ,field))
          (values field
                  :updated!!!
                  (cdr content-of-field)))

         ((< field *size#entry#name-table*)
          (help#be :name-index name-index
                   :as-index as-index
                   :mean mean
                   :field (add1 field)))

         (:else
          (error "the meaning of this name is too filled"))
         )))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (mean
   ;;        find?)
   ;;     (explain :name
   ;;              :as )
   ;;   ><><><)

   (defun explain (&key
                     name
                     as)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (explain) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#explain :name-index name-index
                         :as-index as-index))))



   (defun help#explain (&key
                          name-index
                          as-index
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-vector `#(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  :found!!!))

         ((< field *size#entry#name-table*)
          (help#explain :name-index name-index
                        :as-index as-index
                        :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not explain the name as the way you wish~%"
                  "and the meaning of this name is too filled")))
         )))



   ;; (be :name (string->name "kkk")
   ;;     :as (string->name "took")
   ;;     :mean "my baby away!")

   ;; (explain :name (string->name "kkk")
   ;;          :as (string->name "took"))



   (defun meaningful? (&key
                         name
                         as)
       (multiple-value-bind
             (mean
              find?)
           (explain :name name
                    :as as)
         find?))

   ;; (meaningful? :name (string->name "kkk")
   ;;              :as (string->name "took"))
   #+end_src
* title-table
** note
   * title is the way I used to manage name of things
     a title can be viewed as
     a type
     a module
     a structure
   * a title is a index into title-table
     the index is used as the encoding of that title
     there is only one title-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (entitle)
     * <title
       <name
       (ask)
   * every object have a title
** the title-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title-table*
     1000)

   (defparameter *size#entry#title-table*
     100)

   (defparameter *title-table*
     (make-array
      (list *size#title-table* *size#entry#title-table*)
      :initial-element nil))

   (defun index-within-title-table? (index)
     (and (natural-number? index)
          (< index *size#title-table*)))

   (defparameter *pointer#title-table* 0)
   #+end_src
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let ((name (string->name string))
           (name#title (string->name "title")))
       (cond
         ((meaningful? :name name
                       :as name#title)
          `#(<title>
             ,(explain :name name
                       :as name#title)))

         ((< *pointer#title-table*
             ,*size#title-table*)
          ;; to create a new title is
          ;; to allocate a new index in the title-table
          (be :name name
              :as name#title
              :mean *pointer#title-table*)
          (setf *pointer#title-table*
                (add1 *pointer#title-table*))
          `#(<title>
             ,(sub1 *pointer#title-table*)))

         (:else
          (error "title-table is filled, can not make new title")))))
   #+end_src
** title?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (x)
     (and (array? x)
          (= 1 (array-rank x))
          (= 2 (array-dimension x
                                0))
          (equal? '<title>
                  (fetch#vector :vector x
                                :index 0))
          (index-within-title-table?
           (fetch#vector :vector x
                         :index 1))))

   ;; (title? #(<title> 0))
   ;; ==> T
   ;; (title? (string->title "testing#title?"))
   ;; ==> T
   #+end_src
** title->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->index (title)
     (cond ((not (title? title))
            (error "argument of title->index must be a title"))
           (:else
            (fetch#vector :vector title
                          :index 1))))

   ;; (title->index (string->title "testing#1#title->index"))
   ;; (title->index (string->title "testing#2#title->index"))
   #+end_src
** entitle & ask
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; <title
   ;; <name
   ;; <object
   ;; (entitle)

   ;; <title
   ;; <name
   ;; (ask)



   ;; interface:
   ;; (multiple-value-bind
   ;;       (field
   ;;        update?
   ;;        old-object)
   ;;     (entitle :title
   ;;              :name
   ;;              :object )
   ;;   ><><><)

   (defun entitle (&key
                     title
                     name
                     object)
     (if (or (not (title? title))
             (not (name? name))
             (not (object? object)))
         (error "one or more the arguments of (entitle) is of wrong type")
         (let ((title-index (title->index title))
               (name-index (name->index name)))
           (help#entitle :title-index title-index
                         :name-index name-index
                         :object object))))



   (defun help#entitle (&key
                          title-index
                          name-index
                          object
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *title-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons name-index object)
                      :array *title-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  nil
                  nil))

         ((equal? name-index
                  (car content-of-field))
          (save#array :value (cons name-index object)
                      :array *title-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  :updated!!!
                  (cdr content-of-field)))

         ((< field *size#entry#title-table*)
          (help#entitle :title-index title-index
                        :name-index name-index
                        :object object
                        :field (add1 field)))

         (:else
          (error "the names under this title is too filled"))
         )))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (object
   ;;        find?)
   ;;     (ask :title
   ;;          :name )
   ;;   ><><><)


   (defun ask (&key
                 title
                 name)
     (if (or (not (title? title))
             (not (name? name)))
         (error "one or more the arguments of (ask) is of wrong type")
         (let ((title-index (title->index title))
               (name-index (name->index name)))
           (help#ask :title-index title-index
                     :name-index name-index))))



   (defun help#ask (&key
                      title-index
                      name-index
                      (field 1))
     (let ((content-of-field
            (fetch#array :array *title-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? name-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  :found!!!))

         ((< field *size#entry#title-table*)
          (help#ask :title-index title-index
                    :name-index name-index
                    :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not ask for the object under the name as you wish~%"
                  "and the names under this title is too filled")))
         )))



   ;; (entitle :title (string->title "kkk")
   ;;          :name (string->name "took")
   ;;          :object `#(<object>
   ;;                    ,(string->title "my")
   ;;                    "baby away!"))

   ;; (ask :title (string->title "kkk")
   ;;      :name (string->name "took"))



   (defun entitled? (&key
                       title
                       name)
     (multiple-value-bind
           (object
            find?)
         (ask :title title
              :name name)
       find?))

   ;; (entitled? :title (string->title "kkk")
   ;;            :name (string->name "took"))
   #+end_src
** (string->title "title")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "title")
   #+end_src
* -----------------------------------
* vector-function
** note
   * address in the vector-function zone
** ><
   #+begin_src lisp

   #+end_src
* pointer-into-vector-function-body
** note
   * with the title system
     no (not much) global addresses will be used
     the title of a poniter helps to make the poniter
     become from an address to an index
* return-stack
** note
   * return-stack is a stack of pointers
     of which a pointer points into a function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers that are moving
     the pointer on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers that are pushing or popping
     the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 pointer#vector-function-body 這個 title 的數據
     的函數
     而 pointer#vector-function-body 這個 title 下
     有處理這個數據類型的函數
** (string->title "return-stack")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "return-stack")
   #+end_src
** the return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make-array `(,*size#return-stack*) :initial-element nil))

   (defparameter *pointer#return-stack* 0)

   (defun push#return-stack (object)
     (if (not (< *pointer#return-stack*
                 ,*size#return-stack*))
         (error "can not push anymore *return-stack* is filled")
         (let ()
           (save#vector :value object
                        :vector *return-stack*
                        :index *pointer#return-stack*)
           (setf *pointer#return-stack*
                 (add1 *pointer#return-stack*))
           (values *pointer#return-stack*
                   object))))

   (defun pop#return-stack ()
     (if (zero? *pointer#return-stack*)
         (error "can not pop anymore *return-stack* is empty")
         (let ()
           (setf *pointer#return-stack*
                 (sub1 *pointer#return-stack*))
           (values (fetch#vector :vector *return-stack*
                                 :index *pointer#return-stack*)
                   ,*pointer#return-stack*))))

   ;; (push#return-stack 123)
   ;; (pop#return-stack)
   #+end_src
** >< next
   #+begin_src lisp
   (defun next ()
     (let* ((pair (fetch
                   (fetch#vector :vector *return-stack*
                                 :index *pointer#return-stack*)))
            (instruction-index (car pair))
            (argument-object (cdr pair)))
       (execute-instruction :instruction-index instruction-index
                            :argument-object argument-object)))

   (defun execute-instruction (&key
                                 instruction-index
                                 argument-object)
     (funcall (fetch#vector :vector **
                            :index instruction-index)
              argument-object))
   #+end_src
* argument-stack
** the argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#argument-stack* 1024)

   (defparameter *argument-stack*
     (make-array `(,*size#argument-stack*) :initial-element nil))

   (defparameter *pointer#argument-stack* 0)

   (defun push#argument-stack (object)
     (if (not (< *pointer#argument-stack*
                 ,*size#argument-stack*))
         (error "can not push anymore *argument-stack* is filled")
         (let ()
           (save#vector :value object
                        :vector *argument-stack*
                        :index *pointer#argument-stack*)
           (setf *pointer#argument-stack*
                 (add1 *pointer#argument-stack*))
           (values *pointer#argument-stack*
                   object))))

   (defun pop#argument-stack ()
     (if (zero? *pointer#argument-stack*)
         (error "can not pop anymore *argument-stack* is empty")
         (let ()
           (setf *pointer#argument-stack*
                 (sub1 *pointer#argument-stack*))
           (values (fetch#vector :vector *argument-stack*
                                 :index *pointer#argument-stack*)
                   ,*pointer#argument-stack*))))

   ;; (push#argument-stack 123)
   ;; (pop#argument-stack)
   #+end_src
* frame-stack
** the frame-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#frame-stack* 1024)

   (defparameter *frame-stack*
     (make-array `(,*size#frame-stack*) :initial-element nil))

   (defparameter *pointer#frame-stack* 0)

   (defun push#frame-stack (object)
     (if (not (< *pointer#frame-stack*
                 ,*size#frame-stack*))
         (error "can not push anymore *frame-stack* is filled")
         (let ()
           (save#vector :value object
                        :vector *frame-stack*
                        :index *pointer#frame-stack*)
           (setf *pointer#frame-stack*
                 (add1 *pointer#frame-stack*))
           (values *pointer#frame-stack*
                   object))))

   (defun pop#frame-stack ()
     (if (zero? *pointer#frame-stack*)
         (error "can not pop anymore *frame-stack* is empty")
         (let ()
           (setf *pointer#frame-stack*
                 (sub1 *pointer#frame-stack*))
           (values (fetch#vector :vector *frame-stack*
                                 :index *pointer#frame-stack*)
                   ,*pointer#frame-stack*))))

   ;; (push#frame-stack 123)
   ;; (pop#frame-stack)
   #+end_src
* instruction-return-stack
  * in cicada language
    you can extend the instruction set of the vm
  * in the body of the definition of your instruction
    when you call a cicada function
    it will not use the return-stack to record the return point
    but to use instruction-return-stack
* primitive-instruction
** create title
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "primitive-instruction")
   #+end_src
* primitive-function
** note
   * 函數的調用 和 函數的返回值
     argument-stack 和 return-stack 和 frame-stack
     這裏就涉及到了不同模塊的東西之間的依賴關係
** create title
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "primitive-function")
   #+end_src
** instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; call#primitive-function
   ;; tail-call#primitive-function#
   #+end_src
* variable
* bool
** instruction
   * bool#literal
* fixnum
** instruction
   * fixnum#literal
* -----------------------------------
* compiler
** note
* -----------------------------------
* threaded-code interpreter
** note
* -----------------------------------
* cicada-rhapsody
  #+begin_src lisp
  (defun name-reader (stream char-bound-with-this-function)
    (read#char :from stream
               :recursive-call-to-reader? nil))

  (bind-char-to-reader
   (character "[")
   (function name-reader))

  ;; (find-reader-from-char (character "["))
  (values [123])


  (readtablep *readtable*)
  (setq zvar 123)
  (set-syntax-from-char
   #\z #\'
   (setq table2 (copy-readtable)))

  (setq *readtable* table2)
  ;; zvar =>  VAR
  (setq *readtable* (copy-readtable nil))
  ;; zvar =>  123

  [ (cicada)

  ]

  ## cicada
  ## end cicada

  cicada.cicada
  cicada.iaa
  #+end_src
* -----------------------------------
* test
  #+begin_src lisp
  (progn
    (asdf:load-system 'cicada-vm)
    (in-package :cicada-vm))
  #+end_src
* ===================================
