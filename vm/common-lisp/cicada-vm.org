#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* a set of primitive-[function|instruction]
  * primitive-[function|instruction] 应该写在能够用来测试 它们的编译器之后
* for to write the compiler
  * 这里需要良好的计划
    因为这个编译器 在代码演化到某个阶段的时候 是会被抛弃的
    [所谓 金蝉脱壳]
  * 在这里我可以运用 common-lisp 所能提供的 尽可能丰富的 资源
    而不用像在实现 vm 的时候一样
    时刻维护把代码重写为汇编的容易性
    这时所写的用于编译的函数也不会被重新映射为 cicada 的 primitive-function
  * 这里的 cicada-rhapsody 是能够贡献于 common-lisp 社区的
    [所以 我将会考虑 遵从 common-lisp 程序员 写代码的习俗]
* the first version of the compiler (in cicada-rhapsody) & 象棋比喻
  * 关于 vector-function 与 primitive-function 的接口
    * 此二者的实现方式不同
      但是它们的接口都将被编译器用到
    * 所以先写编译器
      看看需要什么样的接口
  * 我发现 就像下棋[象棋]一样
    你能同时考虑的步数越多
    你的棋艺就越精湛
    比如
    之列 vector-function 与 primitive-function 的接口函数
    就应该与使用这些接口的编译器一起被考虑
    也就是说我同时能考虑到的 "步数" 仅仅是 两步 而已
* 把那個 o 換掉
  * 之所以出現這種情況是接口沒設計好
    可能在寫編譯器的時候這個接口就會被自動更換了
* todo
** to use instruction-return-stack
** [how?] reduce dup code by better abstraction
** [maybe] to find a better hash function
** interface to cicada image buffer
** type check of load-file
   * the argument :file should be of path type
** about io
   * 總應該使用 record 來記錄 io
     record 是可以被作爲一等公民處理的
   * record 應該可以被過濾
     設計數據結構的時候需要考慮這一點
   * 並且 record 的順序是極端重要的
   * io 要從鍵盤的輸入開始 而不使用舊的標準
   * 輸入設備所產生的 record
     將被作爲 消息 傳遞給 一個 底層的 loop
     這在於 repl 並應該在回車的時候執行代碼
     而應該有一個特殊的按鍵來控制代碼的執行
     如果以 每次鍵盤的擊鍵爲輸入的話
     repl 其實就是一個小型的文本編輯器了
** write image file
** parsing image file
** [maybe] let modules be packages
** first version
   * without database of symbol usage
   * without resolving symbols
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  ;; new common-lisp hacker
  ;; please view module as directory
  ;;   which you can override by :pathname
  ;; and system as top-level directory
  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module "package-header"
              :components
              ((:file "package-header")))
     (:module "ytool"
              :components
              ((:file "ytool")))
     (:module "basic"
              :components
              ((:file "basic")))
     (:module "little-tester"
              :components
              ((:file "little-tester")))
     (:module "ytool.test" :pathname "ytool"
              :components
              ((:file "ytool.test"
                      :if-feature :with-little-test)))
     (:module "basic.test" :pathname "basic"
              :components
              ((:file "basic.test"
                      :if-feature :with-little-test)))
     (:module "cicada-rhapsody"
              :components
              ((:file "cicada-rhapsody")
               (:file "cicada-rhapsody.test"
                      :if-feature :with-little-test)))
     ;; (:module ghost-in-shell
     ;;          :components
     ;;          ((:file "ghost-in-shell")
     ;;           (:file "ghost-in-shell.test"
     ;;                  :if-feature :with-little-test)))
     (:file "cicada-vm")
     (:file "cicada-vm.test"
            :if-feature :with-little-test)))
  #+end_src
* ===================================
* note
** cicada vm
   * cicada vm is
     a threaded-code interpreter
     with a hash-table of string which is called name-table
   * the way used to implement
     a forth inner interpreter in assembly language
     is used to design this vm
   * it will be easy to implement this vm in both
     low-level language as assembly
     and high-level language as common-lisp
   * an image file is as an executable [linkable] format
   * when a image file is loaded to *cicada-image-buffer*
     host language can provide many run-time supports
     but run-time independent compile must be supported too
   * when compiling to cicada language to image file
     the compiler maintains a database of symbol-address binding
     the database records all the use of every symbol
     the database helps one to
     NOT care about the encoding of instruction and title
   * value of symbol
     need to be updated
     address of primitive-function and primitive-instruction
     need to be updated
   * when vm interpreting image file
     it reads the database first
     and resolves the symbol in the image file
     meanwhile updating the database
     only after then
     the vm can begin interpreting the image file
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
* -----------------------------------
* file header
** cicada-vm.lisp
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package :cicada-vm)
   #+end_src
** cicada-vm.test.lisp
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* cicada-object
** ----------------------------------
** note cicada-object
   * cicada-object only exist in cicada-object-vector
     for example *return-stack*
** cell-unit
   * a cell is of *cell-unit* many bytes
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* (/ *size#fixnum* 8)) ;; unit byte
   #+end_src
** ----------------------------------
** cicada-object-vector?
   * an object is two cell
     one for title (an index into title-table)
     one for value (of which the meaning is depended on its title)
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))

   (defun cicada-object-vector? (cicada-object-vector)
     (and (equal? '(unsigned-byte 8)
                  (array-element-type cicada-object-vector))
          (zero? (mod (length cicada-object-vector)
                      ,*cicada-object-size*))))
   #+end_src
** ----------------------------------
** [save|fetch]#[title|value]#cicada-object-vector
   * index
     into byte-vector
     element size *cicada-object-size*
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun save#title#cicada-object-vector
       (&key
          title
          cicada-object-vector
          index)
     (save#byte-vector :value title
                       :byte-vector cicada-object-vector
                       :size *cell-unit*
                       :index (mul *cicada-object-size*
                                   index)))

   (defun save#value#cicada-object-vector
       (&key
          value
          cicada-object-vector
          index)
     (save#byte-vector :value value
                       :byte-vector cicada-object-vector
                       :size *cell-unit*
                       :index (add *cell-unit*
                                   (mul *cicada-object-size*
                                        index))))


   (defun fetch#title#cicada-object-vector
       (&key
          cicada-object-vector
          index)
     (fetch#byte-vector :byte-vector cicada-object-vector
                        :size *cell-unit*
                        :index (mul *cicada-object-size*
                                    index)))

   (defun fetch#value#cicada-object-vector
       (&key
          cicada-object-vector
          index)
     (fetch#byte-vector :byte-vector cicada-object-vector
                        :size *cell-unit*
                        :index (add *cell-unit*
                                    (mul *cicada-object-size*
                                         index))))
   #+end_src
** ----------------------------------
** cicada-object-pointer?
** ----------------------------------
* title.name-table
** ----------------------------------
** note title
   * every object have a title
     title is the way I used to manage nameing of things
     a title could be viewed as
     a type
     a module
     a structure
   * a title is a index into title.name-table
     the index is used as the encoding of that title
     there is only one title.name-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (be)
       <field
       <update?
     * <title
       <name
       (ask)
       <object
       <find?
** ----------------------------------
** the title.name-table
   * (be) and (ask) will be served as
     (save#title.name-table) and (fetch#title.name-table)
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title.name-table* 1000)

   (defparameter *size#entry#title.name-table* 100)

   ;; the first entry of *title.name-table* reserved
   ;; for *name-hash-table*
   ;; to test if a name in *name-hash-table*
   ;; is used as title or not
   (defparameter *pointer#title.name-table* 1)

   (defparameter *title.name-table*
     ;; should be a byte-vector in assembly version
     (make-array
      `(,*size#title.name-table* ,*size#entry#title.name-table*)
      ;; note that
      ;; this table's element can be of any type
      ;; but actually
      ;; (i 0) must be an name[index] to name-hash-table
      ;; (i n) must be a vector of
      ;; #( name[index] title[index] value )
      :initial-element 0))
   #+end_src
** title?
   * index-within-title.name-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (index)
     (and (natural-number? index)
          (< index *size#title.name-table*)))
   #+end_src
** ----------------------------------
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let* ((name (string->name string))
            (index-for-title
             (fetch#name-hash-table :field :index-for-title
                                    :name name)))
       (cond
         ;; find-old
         ((not (zero? index-for-title))
          index-for-title)

         ;; creat-new
         ((< *pointer#title.name-table*
             ,*size#title.name-table*)
          ;; now
          ;; *pointer#title.name-table* is pointing to
          ;; the next free to use index
          ;; in the *title.name-table*

          ;; save title[index] to :field :index-for-title of name-hash-table
          (save#name-hash-table :value *pointer#title.name-table*
                                :field :index-for-title
                                :name name)

          ;; save name[index] to *title.name-table*
          (save#array :value name
                      :array *title.name-table*
                      :index-vector (vector *pointer#title.name-table* 0))

          ;; to update *pointer#title.name-table*
          ;; is to allocate a new index in the *title.name-table*
          (add1! *pointer#title.name-table*)

          ;; return value
          (sub1 *pointer#title.name-table*))

         (:else
          (orz ()
            ("title.name-table is filled~%")
            ("(string->title) can not make new title~%"))))))
   #+end_src
** title->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->name (title)
     (if (not (title? title))
         (error "the argument of (title->name) must be a title")
         (fetch#array
          :array *title.name-table*
          :index-vector
          (vector title 0))))
   #+end_src
** title->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->string (title)
     (if (not (title? title))
         (error "the argument of (title->string) must be a title")
         (name->string (title->name title))))
   #+end_src
** print#title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#title (title &key (to t))
     (if (not (title? title))
         (error "the argument of (print#title) must be a title")
         (print#name (title->name title)
                     :to to)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print#title
       (cicada-vm)
     (ensure
         (print#title (string->title "kkk")
                      :to nil)
         ==>
         "kkk"))
   #+end_src
** ----------------------------------
** map[#entry]#title.name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#title.name-table
       (&key
          function
          (title 1)
          (base-list '()))
     (cond ((not (< title *pointer#title.name-table*))
            base-list)
           (:else
            (cons (funcall function :title title)
                  (map#title.name-table :function function
                                        :title (add1 title)
                                        :base-list base-list)))))

   (defun map#entry#title.name-table
       (&key
          title
          function
          (field 1)
          (base-list '()))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title ,field))))
       (cond ((not (vector? content-of-field))
              base-list)
             (:else
              (cons (funcall function
                      :name (fetch#vector
                             :vector content-of-field
                             :index 0)
                      :title#object (fetch#vector
                                     :vector content-of-field
                                     :index 1)
                      :value#object (fetch#vector
                                     :vector content-of-field
                                     :index 2))
                    (map#entry#title.name-table :title title
                                                :function function
                                                :field (add1 field)
                                                :base-list base-list))))))
   #+end_src
** print#title.name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; can NOT return a string when :to == nil

   (defun print#title.name-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* title.name-table")
       ("  |------------+--------|")
       ("  | size       | ~6D |" *size#title.name-table*)
       ("  | size#entry | ~6D |" *size#entry#title.name-table*)
       ("  | title      | ~6D |" (sub1 *pointer#title.name-table*))
       ("  |------------+--------|"))
     (map#title.name-table
      :function
      (lambda (&key
                 title)
        (cat (:to to
                  :postfix (cat () ("~%")))
          ("  * ~A" (title->string title)))
        (map#entry#title.name-table
         :title title
         :function
         (lambda (&key
                    name
                    title#object
                    value#object)
           (cat (:to to
                     :postfix (cat () ("~%")))
             ("    * ~A" (name->string name))
             ("      ~A ~A" (title->string title#object) value#object)))))))

   ;; (be :title (string->title "k1")
   ;;     :name (string->name "took1")
   ;;     :title#object (string->title "my1")
   ;;     :value#object 666)
   ;; (be :title (string->title "k1")
   ;;     :name (string->name "took2")
   ;;     :title#object (string->title "my2")
   ;;     :value#object 666)
   ;; (print#title.name-table)
   #+end_src
** ----------------------------------
** be
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin be
     .field ;; index
     .update?)
   (defun be
       (&key
          title
          name
          title#object
          value#object)
     (cond
       ((not (title? title))
        (error "the argument :title of (be) must be a title"))
       ((not (name? name))
        (error "the argument :name of (be) must be a name"))
       ((not (title? title#object))
        (error "the argument :title#object of (be) must be a title"))
       (:else
        (help#be
         :title title
         :name name
         :title#object title#object
         :value#object value#object))))


   (defun help#be
       (&key
          title
          name
          title#object
          value#object
          (field 1))
     (let ((content-of-field
            (fetch#array
             :array *title.name-table*
             :index-vector `#(,title ,field))))
       (cond
         ;; creat new
         ((zero? content-of-field)
          (save#array
           :value (vector name
                          title#object
                          value#object)
           :array *title.name-table*
           :index-vector `#(,title ,field))
          (values field
                  nil))
         ;; update
         ((equal? name
                  (fetch#vector
                   :vector content-of-field
                   :index 0))
          (save#array
           :value (vector name
                          title#object
                          value#object)
           :array *title.name-table*
           :index-vector `#(,title ,field))
          (values field
                  :updated!!!))
         ;; next
         ((< field *size#entry#title.name-table*)
          (help#be :title title
                   :name name
                   :title#object title#object
                   :value#object value#object
                   :field (add1 field)))
         ;; filled
         (:else
          (error "the names under this title is too filled (be) can not do")))))
   #+end_src
** ask
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin ask
     .title
     .value
     .found?)
   (defun ask
       (&key
          title
          name)
     (cond ((not (title? title))
            (error "the argument :title of (ask) must be a title"))
           ((not (name? name))
            (error "the argument :name of (ask) must be a name"))
           (:else
            (help#ask :title title
                      :name name))))

   (defun help#ask
       (&key
          title
          name
          (field 1))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title ,field))))
       (cond
         ;; not found
         ((zero? content-of-field)
          (values 0
                  0
                  nil))
         ;; found
         ((equal? name
                  (fetch#vector :vector content-of-field
                                :index 0))
          (let ((vector#name-title-value
                 (fetch#array :array *title.name-table*
                              :index-vector `#(,title ,field))))
            (values (fetch#vector :vector vector#name-title-value
                                  :index 1)
                    (fetch#vector :vector vector#name-title-value
                                  :index 2)
                    :found!!!)))
         ;; next
         ((< field *size#entry#title.name-table*)
          (help#ask :title title
                    :name name
                    :field (add1 field)))
         ;; filled
         (:else
          (orz ()
            ("can not ask for the object under the name as you wish~%")
            ("and the names under this title is too filled"))))))
   #+end_src
** o
   * o let the .value be the main return value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin o
     .value
     .title
     .found?)

   (defun o (title-string name-string)
     (with (ask :title (string->title title-string)
                :name (string->name name-string))
           (values .value
                   .title
                   .found?)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest be--and--ask
       (cicada-vm)
     (ensure
         (list (be :title (string->title "kkk")
                   :name (string->name "took")
                   :title#object (string->title "my")
                   :value#object 666)
               (with (be :title (string->title "kkk")
                         :name (string->name "took")
                         :title#object (string->title "my")
                         :value#object 666)
                 (list .field .update?))
               (with (ask :title (string->title "kkk")
                          :name (string->name "took"))
                     (list .title .value .found?)))
         ==>
         `(1

           (1
            :UPDATED!!!)

           (,(string->title "my")
             666
             :FOUND!!!)

           )))
    #+end_src
** ----------------------------------
* name-hash-table
** ----------------------------------
** note name
   * not name value binding in name-hash-table
     name-hash-table is used to
     1. provide the name datatype
     2. implement title.name-table
   * binding will be done in title.name-table
     an object [value with title]
     will be bound to a title name pair
** ----------------------------------
** the name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-hash-table* 100333)

   (defparameter *name-hash-table#name-counter* 0)

   (defparameter *name-hash-table#string*
     (make#vector
      :length *size#name-hash-table*
      :initial-element 0))

   (defparameter *name-hash-table#index-for-title*
     (make#vector
      :length *size#name-hash-table*
      :element-type `(integer 0 ,*size#title.name-table*)
      :initial-element 0))


   (defun fetch#name-hash-table
       (&key
          name
          field)
     (cond ((equal? field :string)
            (fetch#vector
             :vector *name-hash-table#string*
             :index name))
           ((equal? field :index-for-title)
            (fetch#vector
             :vector *name-hash-table#index-for-title*
             :index name))
           (:else
            (orz ()
              ("the argument :field of (fetch#name-hash-table)~%")
              ("must be a valid field of the name-hash-table~%")
              ("but ~A is not~%" field)))))

   (defun save#name-hash-table
       (&key
          value
          name
          field)
     (cond ((equal? field :string)
            (save#vector
             :value value
             :vector *name-hash-table#string*
             :index name))
           ((equal? field :index-for-title)
            (save#vector
             :value value
             :vector *name-hash-table#index-for-title*
             :index name))
           (:else
            (orz ()
              ("the argument :field of (save#name-hash-table)~%")
              ("must be a valid field of the name-hash-table~%")
              ("but ~A is not~%" field)))))

   ;; to reverse index 0
   ;; the first entry of *name-hash-table* is reserved
   ;; for *title.name-table*
   ;; to test if a title name pair in *title.name-table*
   ;; is bound to any object or not
   (save#name-hash-table :value ""
                         :field :string
                         :name 0)
   #+end_src
** name?
   * index-within-name-hash-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (index)
     (and (natural-number? index)
          (< index *size#name-hash-table*)))
   #+end_src
** ----------------------------------
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest string->natural-number
       (cicada-vm)
     (ensure
         (list (string->natural-number "")
               (string->natural-number "@")
               (string->natural-number "@@@"))
         ==>
         (list 0
               64
               448)))
   #+end_src
** ----------------------------------
** string->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (help#string->name#find-old-or-creat-new
      :string string
      :index (mod (string->natural-number string)
                  ,*size#name-hash-table*)))

   (defun help#string->name#find-old-or-creat-new
       (&key
          string
          index
          (collision-level 0))
     (cond
       ;; creat-new
       ((not (name-hash-table-index#used? index))
        (help#string->name#creat-new
         :string string
         :index index
         :collision-level collision-level)
        index)
       ;; find-old
       ((equal? string
                (fetch#name-hash-table
                 :field :string
                 :name index))
        index)
       ;; collision
       (:else
        (help#string->name#find-old-or-creat-new
         :string string
         :index (name-hash-table-index#next :index index)
         :collision-level (add1 collision-level)))
       ))

   (defun name-hash-table-index#used? (index)
     (not (zero? (fetch#name-hash-table
                  :field :string
                  :name index))))

   (defun name-hash-table-index#as-title? (index)
     (and (name-hash-table-index#used? index)
          (not (zero? (fetch#name-hash-table
                       :field :index-for-title
                       :name index)))))

   (defparameter *name-hash-table#collision-record* '())

   (defun help#string->name#creat-new
       (&key
          string
          index
          collision-level)
     (add1! *name-hash-table#name-counter*)
     (if (not (zero? collision-level))
         (push (list :collision-level collision-level
                     :string string
                     :index index)
               ,*name-hash-table#collision-record*))
     (save#name-hash-table :value string
                           :field :string
                           :name index))

   (defun name-hash-table-index#next
       (&key index)
     (if (= index *size#name-hash-table*)
         0
         (add1 index)))
   #+end_src
** name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->string (name)
     (if (not (name? name))
         (error "the argument of (name->string) must be a name")
         (cond ((not (name-hash-table-index#used? name))
                (error "this name does not have a string"))
               (:else
                (fetch#name-hash-table :field :string
                                       :name name)))))
   #+end_src
** print#name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#name (name
                      &key (to t))
     (format to (name->string name)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name->string
       (cicada-vm)
     (ensure
         (name->string (string->name "kkk took my baby away!"))
         ==>
         "kkk took my baby away!"))

   (deftest print#name
       (cicada-vm)
     (ensure
         (print#name (string->name "kkk took my baby away!")
                     :to nil)
         ==>
         "kkk took my baby away!"))
   #+end_src
** ----------------------------------
** map#name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#name-hash-table
       (&key
          function
          (name 1)
          (base-list '()))
     (cond ((not (< name *size#name-hash-table*))
            base-list)
           ((not (name-hash-table-index#used? name))
            (map#name-hash-table :function function
                                 :name (add1 name)
                                 :base-list base-list))
           (:else
            (cons (funcall function :name name)
                  (map#name-hash-table :function function
                                       :name (add1 name)
                                       :base-list base-list)))))

   ;; (map#name-hash-table
   ;;  :function
   ;;  (lambda (&key name)
   ;;    (name->string name)))
   #+end_src
** print#name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; can NOT return a string when :to == nil

   (defun print#name-hash-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* name-hash-table")
       ("  |-----------+--------|")
       ("  | size      | ~6D |" *size#name-hash-table*)
       ("  | name      | ~6D |" *name-hash-table#name-counter*)
       ("  | collision | ~6D |" (length *name-hash-table#collision-record*))
       ("  |-----------+--------|"))
     (map#name-hash-table
      :function
      (lambda (&key name)
        (cat (:to to)
          ("  * ~A " (name->string name)))
        (cond
          ((name-hash-table-index#as-title? name)
           (cat (:to to)
             (" [as title] "))))
        (let ((collision-record-entry
               (find#record :index name
                            ,*name-hash-table#collision-record*)))
          (cond ((not (nil? collision-record-entry))
                 (destructuring-bind
                       (&key collision-level
                             string
                             index)
                     collision-record-entry
                   (cat (:to to)
                     (" [collision-level: ~A]" collision-level))))))
        (cat (:to to) ("~%")))))
   #+end_src
** ----------------------------------
* cicada-image
** ----------------------------------
** note
   * 這裏的設計可以非常豐富
** ----------------------------------
** the cicada-image
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#cicada-image-buffer* 16)

   (setf (logical-pathname-translations "cicada")
         `(("**;*.*" "home:.cicada;**;*.*")))

   (defparameter *cicada-image-filename* "cicada:test.cicada-image")

   (defparameter *cicada-image*
     (make#vector :length (mul *size#cicada-image-buffer* *cicada-object-size*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   (defparameter *pointer#cicada-image-buffer* 0)
   #+end_src
** fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch-byte#cicada-image (&key address)
     (fetch#byte-vector :byte-vector *cicada-image*
                        :size 1
                        :index address))

   (defun save-byte#cicada-image (&key address byte)
     (save#byte-vector :value byte
                       :byte-vector *cicada-image*
                       :size 1
                       :index address))

   (defin fetch#cicada-image
     .title .value)
   (defun fetch#cicada-image (&key address)
     (values (fetch#byte-vector :byte-vector *cicada-image*
                                :size *cell-unit*
                                :index address)
             (fetch#byte-vector :byte-vector *cicada-image*
                                :size *cell-unit*
                                :index (add *cell-unit*
                                            address))))

   (defun save#cicada-image (&key address title value)
     (save#byte-vector :value title
                       :byte-vector *cicada-image*
                       :size *cell-unit*
                       :index address)
     (save#byte-vector :value value
                       :byte-vector *cicada-image*
                       :size *cell-unit*
                       :index (add *cell-unit*
                                   address)))
   #+end_src
** ----------------------------------
** load cicada-image
   #+begin_src lisp :tangle cicada-vm.lisp
   (progn
     (setf stream
           (open *cicada-image-filename*
                 :direction :output
                 :if-exists :supersede))
     (format stream "cicada test~%")
     (close stream))


   (file->buffer :filename *cicada-image-filename*
                 :buffer *cicada-image*)
   #+end_src
** ----------------------------------
* return-stack
** ----------------------------------
** note
   * return-stack is a stack of pointers
     a pointer points into a (one type of) function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers
     that are moving the pointer
     which on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers
     that are pushing or popping the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 vector-function-body-pointer 這個 title
     的數據
     的函數
     而 vector-function-body-pointer 這個 title 下
     有處理這個數據類型
     的函數
** ----------------------------------
** the return-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make#vector :length (mul *cicada-object-size* *size#return-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *return-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#return-stack* 0)
   #+end_src
** push#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#return-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the argument :title of (push#return-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#return-stack*
                     ,*cicada-object-size*)
                ,*size#return-stack*))
        (error "can not push anymore *return-stack* is filled"))
       ;; side-effect
       ;; *pointer#return-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *return-stack*
               :index *pointer#return-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *return-stack*
               :index *pointer#return-stack*)
              (add1! *pointer#return-stack*)
              ;; return current-pointer
              ,*pointer#return-stack*)))
   #+end_src
** pop#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#return-stack
     .title
     .value
     .current-pointer)
   (defun pop#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (orz ()
          ("when calling (pop#return-stack)~%")
          ("the *return-stack* must NOT be empty")))
       (:else
        (sub1! *pointer#return-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index *pointer#return-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index *pointer#return-stack*)
                ,*pointer#return-stack*))))
   #+end_src
** tos#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; TOS denotes top of stack
   (defin tos#return-stack
     .title
     .value
     .current-pointer)
   (defun tos#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (orz ()
          ("when calling (tos#return-stack)~%")
          ("the *return-stack* must NOT be empty")))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index (sub1 *pointer#return-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index (sub1 *pointer#return-stack*))
                (sub1 *pointer#return-stack*)))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest return-stack
       (cicada-vm)
     (ensure
         (let* ((push1 (push#return-stack
                        :title (string->title "return-stack--push--test#1")
                        :value 147))
                (push2 (push#return-stack
                        :title (string->title "return-stack--push--test#2")
                        :value 258))
                (push3 (push#return-stack
                        :title (string->title "return-stack--push--test#3")
                        :value 369)))
           (list (sub push3 push2)
                 (sub push2 push1)
                 (with (tos#return-stack)
                   .value)
                 (with (pop#return-stack)
                   .value)

                 (with (tos#return-stack)
                   .value)
                 (with (pop#return-stack)
                   .value)

                 (with (tos#return-stack)
                   .value)
                 (with (pop#return-stack)
                   .value)))
         ==>
         (list 1
               1

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
** execute-next-instruction
   * execute-the-instruction-pointed-by-tos-of-return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; note that:
   ;; this function defines the interface of primitive-instruction

   (defun execute-next-instruction ()
     (let* ((address#vector-function-body
             (with (tos#return-stack)
                   .value))
            (primitive-instruction
             ;; this means only primitive-instruction is handled now
             (with (fetch#cicada-image
                    :address address#vector-function-body)
                   .value)))
       (funcall (primitive-instruction->host-function primitive-instruction))))
   #+end_src
** ----------------------------------
** >< [maybe] address#in-vector-function-body
** ----------------------------------
* argument-stack
** ----------------------------------
** the argument-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#argument-stack* 1024)

   (defparameter *argument-stack*
     (make#vector :length (mul *cicada-object-size* *size#argument-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *argument-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#argument-stack* 0)
   #+end_src
** push#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#argument-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the argument :title of (push#argument-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#argument-stack*
                     ,*cicada-object-size*)
                ,*size#argument-stack*))
        (error "can not push anymore *argument-stack* is filled"))
       ;; side-effect
       ;; *pointer#argument-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *argument-stack*
               :index *pointer#argument-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *argument-stack*
               :index *pointer#argument-stack*)
              (add1! *pointer#argument-stack*)
              ;; argument current-pointer
              ,*pointer#argument-stack*)))
   #+end_src
** pop#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#argument-stack
     .title
     .value
     .current-pointer)
   (defun pop#argument-stack ()
     (cond
       ((zero? *pointer#argument-stack*)
        (orz ()
          ("when calling (pop#argument-stack)~%")
          ("the *argument-stack* must NOT be empty")))
       (:else
        (sub1! *pointer#argument-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index *pointer#argument-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index *pointer#argument-stack*)
                ,*pointer#argument-stack*))))
   #+end_src
** tos#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; TOS denotes top of stack
   (defin tos#argument-stack
     .title
     .value
     .current-pointer)
   (defun tos#argument-stack ()
     (cond
       ((zero? *pointer#argument-stack*)
        (orz ()
          ("when calling (tos#argument-stack)~%")
          ("the *argument-stack* must NOT be empty")))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index (sub1 *pointer#argument-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index (sub1 *pointer#argument-stack*))
                (sub1 *pointer#argument-stack*)))))
   #+end_src
** ----------------------------------
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest argument-stack
       (cicada-vm)
     (ensure
         (list (push#argument-stack
                :title (string->title "argument-stack--push--test#1")
                :value 147)

               (push#argument-stack
                :title (string->title "argument-stack--push--test#2")
                :value 258)

               (push#argument-stack
                :title (string->title "argument-stack--push--test#3")
                :value 369)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value))
         ==>
         (list 1
               2
               3

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
* frame-stack
** ----------------------------------
** the frame-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#frame-stack* 1024)

   (defparameter *frame-stack*
     (make#vector :length (mul *cicada-object-size* *size#frame-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *frame-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#frame-stack* 0)
   #+end_src
** push#frame-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#frame-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the frame :title of (push#frame-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#frame-stack*
                     ,*cicada-object-size*)
                ,*size#frame-stack*))
        (error "can not push anymore *frame-stack* is filled"))
       ;; side-effect
       ;; *pointer#frame-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *frame-stack*
               :index *pointer#frame-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *frame-stack*
               :index *pointer#frame-stack*)
              (add1! *pointer#frame-stack*)
              ;; frame current-pointer
              ,*pointer#frame-stack*)))
   #+end_src
** pop#frame-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#frame-stack
     .title
     .value
     .current-pointer)
   (defun pop#frame-stack ()
     (cond
       ((zero? *pointer#frame-stack*)
        (orz ()
          ("when calling (pop#frame-stack)~%")
          ("the *frame-stack* must NOT be empty")))
       (:else
        (sub1! *pointer#frame-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *frame-stack*
                 :index *pointer#frame-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *frame-stack*
                 :index *pointer#frame-stack*)
                ,*pointer#frame-stack*))))
   #+end_src
** tos#frame-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; TOS denotes top of stack
   (defin tos#frame-stack
     .title
     .value
     .current-pointer)
   (defun tos#frame-stack ()
     (cond
       ((zero? *pointer#frame-stack*)
        (orz ()
          ("when calling (tos#frame-stack)~%")
          ("the *frame-stack* must NOT be empty")))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *frame-stack*
                 :index (sub1 *pointer#frame-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *frame-stack*
                 :index (sub1 *pointer#frame-stack*))
                (sub1 *pointer#frame-stack*)))))
   #+end_src
** ----------------------------------
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest frame-stack
       (cicada-vm)
     (ensure
         (list (push#frame-stack
                :title (string->title "frame-stack--push--test#1")
                :value 147)

               (push#frame-stack
                :title (string->title "frame-stack--push--test#2")
                :value 258)

               (push#frame-stack
                :title (string->title "frame-stack--push--test#3")
                :value 369)

               (with (tos#frame-stack)
                 .value)
               (with (pop#frame-stack)
                 .value)

               (with (tos#frame-stack)
                 .value)
               (with (pop#frame-stack)
                 .value)

               (with (tos#frame-stack)
                 .value)
               (with (pop#frame-stack)
                 .value))
         ==>
         (list 1
               2
               3

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
* note data in function
** >< how about a variable of many types ?
** [ title name ]
** body (bead)
   * [ 0 size ] (unit : object)
     the 0 is for coming back from body (for debug)
   * [ title instruction ] [ title value ] maybe-more
     maybe-more
** named-local-variable
   * [ number ]
   * [ name ] [ title ]
     maybe-more
** inited-local-variable
   * [ number ]
   * [ name ] [ title value ]
     maybe-more
** unnamed-local-variable
   * [ number ]
   * [ title ]
     maybe-more
** return-object
   * [ number ]
   * [ title ]
     maybe-more
* cute-comment (@ @)
** ----------------------------------
** 記
   * 下面這族函數非常有趣
     因爲 從 lisp 的角度來看
     它們所處理的數據是相當不正規的
** note
   * this version of the cute-comment
     is intend to be used in primitive-[instruction|function] definition
   * due to the restriction of common-lisp
     I have to use <::variable-name instead of <:variable-name
     and to use small-letter
** @ as macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defmacro @ (&body body)
       `(let* ((cute-comment#list (quote ,body))
               (length (length cute-comment#list)))
          (make#vector :length length
                       :initial-contents cute-comment#list)))
   #+end_src
** cute-comment->[*]
   * the length of a cute-comment
     at least will be 2 (@ -- @) ==> #(-- @)
   * using trivial order to collect
     I leave base-list there
     to change the order when wished
   * always have to protect the cursor
     to let it does not over the cute-comment[vector]
   * the length of -- be longer then one to be acceptable
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; note that
   ;;   (symbol->string '<::a)
   ;;   ==>
   ;;   "A"

   (defun | symbol <a> ? | (symbol)
     (if (not (symbol? symbol))
         false
         (let ((string (symbol->string symbol)))
           (and (>= (length string) 3)
                (equal? (string->head#char string) #\<)
                (equal? (string->end#char  string) #\>)))))

   (defparameter *<-package* (find-package "<"))
   (defun | symbol <:: ? | (symbol)
     (if (not (symbol? symbol))
         false
         (equal? *<-package*
                 (symbol-package symbol))))

   (defun | string <::a -> a | (string)
     (cat (:letter :small)
       (string)))

   (defun | string <a> -> a | (string)
     (cat (:trim
           '(#\< #\>)
           :letter :small)
       (string)))




   (defun cute-comment->unnamed-local-variable (cute-comment)
     (let ((length (length cute-comment)))
       (help ((defun loop-collect (&key
                                     (cursor 0)
                                     (base-list '()))
                ;; 兩元並查
                ;; (因 雖可回頭看 但不可[不易]更改收集)
                ;; <a> <b>  則收 a 爲類型[姓]  並繼續
                ;; <a> <::  則斥 a 爲類型[姓]  並停止
                ;; <a> ***  則收 a 爲類型[姓]  並停止
                (cond ((not (< cursor (sub2 length)))
                       (orz ()
                         ("(cute-comment->unnamed-local-variable)~%")
                         ("meet ill formed (@ ... -- ... @) cute-comment~%")
                         ("the cute-comment as vector is ~A ~%" cute-comment)
                         ("the cursor is ~A ~%" cursor)))
                      ((| <a> <b> ? | cursor)
                       (cons (string->title
                              (| string <a> -> a |
                               (symbol->string
                                (fetch#vector :vector cute-comment
                                              :index cursor))))
                             (loop-collect
                                :cursor (add1 cursor)
                                :base-list base-list)))
                      ((| <a> <:: ? | cursor)
                       base-list)
                      ('| <a> *** |
                       (cons (string->title
                              (| string <a> -> a |
                               (symbol->string
                                (fetch#vector :vector cute-comment
                                              :index cursor))))
                             base-list)))))
         (let* ((list (loop-collect))
                (list-length (length list))
                (vector-length (add1 list-length))
                (number list-length))
           (make#vector :length vector-length
                        :initial-contents (cons number list)))
         :where
         (defun | <a> <b> ? | (cursor)
           (and (| symbol <a> ? | (fetch#vector :vector cute-comment
                                                :index cursor))
                (| symbol <a> ? | (fetch#vector :vector cute-comment
                                                :index (add1 cursor)))))
         (defun | <a> <:: ? | (cursor)
           (and (| symbol <a> ? | (fetch#vector :vector cute-comment
                                                :index cursor))
                (| symbol <:: ? | (fetch#vector :vector cute-comment
                                                :index (add1 cursor))))))))


   ;; (cute-comment->unnamed-local-variable
   ;;  (@ <fixnum>
   ;;     <fixnum>
   ;;     <fixnum> <::var1
   ;;     1        <::var2
   ;;     <title>  <::var3
   ;;     fixnum (title) <::var4
   ;;     --
   ;;     <fixnum> @))

   ;; (cute-comment->unnamed-local-variable
   ;;  (@ <fixnum>
   ;;     <fixnum>
   ;;     --
   ;;     @))



   (defun cute-comment->inited-local-variable (cute-comment)
     ;; 語義待定
     )


   (defun cute-comment->named-local-variable (cute-comment)
     (let ((length (length cute-comment)))
       (help ((defun loop-collect (&key
                                     (cursor 0)
                                     (base-list '()))
                ;; 找 <::
                ;; 並 回頭看
                ;; 爲 <a>
                ;;    則 收 <:: 者 爲 有名約束變元之名
                ;;       收 a      爲 此約束變元的類型[姓]
                ;;       並 繼續
                ;;    否則 繼續
                ;; 見 --
                ;;    則止
                ;;    否則 繼續
                (cond ((not (< cursor (sub1 length)))
                       (orz ()
                         ("(cute-comment->named-local-variable)~%")
                         ("meet ill formed (@ ... -- ... @) cute-comment~%")
                         ("the cute-comment as vector is ~A ~%" cute-comment)
                         ("the cursor is ~A ~%" cursor)))
                      ((| <:: ? | cursor)
                       (cond ((zero? cursor)
                              (orz ()
                                ("(cute-comment->named-local-variable)~%")
                                ("meet ill formed (@ ... -- ... @) cute-comment~%")
                                ("a <:: is at the beginning~%")
                                ("the cute-comment as vector is ~A ~%" cute-comment)
                                ("the cursor is ~A ~%" cursor)))
                             ((| <a> ? | (sub1 cursor))
                              (cons-many (string->name
                                          (| string <::a -> a |
                                           (symbol->string
                                            (fetch#vector :vector cute-comment
                                                          :index cursor))))
                                         (string->title
                                          (| string <a> -> a |
                                           (symbol->string
                                            (fetch#vector :vector cute-comment
                                                          :index (sub1 cursor)))))
                                         (loop-collect
                                            :cursor (add1 cursor)
                                            :base-list base-list)))
                             (:else
                              (loop-collect
                                 :cursor (add1 cursor)
                                 :base-list base-list))))
                      ((| -- ? | cursor)
                       base-list)
                      (:else
                       (loop-collect
                          :cursor (add1 cursor)
                          :base-list base-list)))))
         (let* ((list (loop-collect))
                (list-length (length list))
                (vector-length (add1 list-length))
                (number (div list-length 2)))
           (make#vector :length vector-length
                        :initial-contents (cons number list)))
         :where
         (defun | <:: ? | (cursor)
           (| symbol <:: ? | (fetch#vector :vector cute-comment
                                           :index cursor)))
         (defun | <a> ? | (cursor)
           (| symbol <a> ? | (fetch#vector :vector cute-comment
                                           :index cursor)))
         (defun | -- ? | (cursor)
           (let ((dash-dash#symbol
                  (fetch#vector :vector cute-comment
                                :index cursor)))
             (and (symbol? dash-dash#symbol)
                  (let ((dash-dash#string
                         (symbol->string dash-dash#symbol)))
                    (and (> (length dash-dash#string)
                            1)
                         (equal? (cat (:trim '(#\-))
                                   (dash-dash#string))
                                 "")))))))))

   ;; (cute-comment->named-local-variable
   ;;  (@ <fixnum>
   ;;     <fixnum>
   ;;     <fixnum> <::var1
   ;;     1        <::var2
   ;;     <title>  <::var3
   ;;     fixnum (title) <::var4
   ;;     --
   ;;     <fixnum> @))



   (defun cute-comment->return-object (cute-comment)
     (let ((length (length cute-comment)))
       (help ((defun find-dash-dash (&key
                                       (cursor 0))
                (cond ((not (< cursor length))
                       (orz ()
                         ("(cute-comment->return-object)~%")
                         ("meet ill formed (@ ... -- ... @) cute-comment~%")
                         ("can not find -- in it~%")
                         ("the cute-comment as vector is ~A ~%" cute-comment)
                         ("the cursor is ~A ~%" cursor)))
                      ((| -- ? | cursor)
                       cursor)
                      (:else
                       (find-dash-dash :cursor (add1 cursor)))))
              (defun loop-collect (&key
                                     (cursor 0)
                                     (base-list '()))
                ;; 找 -- 而後類 無名函數者
                ;; 但是此時無需 兩元並查
                ;; <a>  則收 a 爲類型[姓]  並繼續
                ;; 否則 誤
                ;; 遇 @ 則止
                (cond ((= cursor (sub1 length))
                       (if (| @ ? | cursor)
                           base-list
                           (orz ()
                             ("(cute-comment->return-object)~%")
                             ("meet ill formed (@ ... -- ... @) cute-comment~%")
                             ("the end of it is not @ ~%")
                             ("the cute-comment as vector is ~A ~%" cute-comment)
                             ("the cursor is ~A ~%" cursor))))
                      ((| <a> ? | cursor)
                       (cons (string->title
                              (| string <a> -> a |
                               (symbol->string
                                (fetch#vector :vector cute-comment
                                              :index cursor))))
                             (loop-collect
                                :cursor (add1 cursor)
                                :base-list base-list)))
                      (:else
                       (orz ()
                         ("(cute-comment->return-object)~%")
                         ("meet ill formed (@ ... -- ... @) cute-comment~%")
                         ("some thing other then <> occur after -- ~%")
                         ("the cute-comment as vector is ~A ~%" cute-comment)
                         ("the cursor is ~A ~%" cursor))))))
         (let* ((list (loop-collect :cursor (add1 (find-dash-dash))))
                (list-length (length list))
                (vector-length (add1 list-length))
                (number list-length))
           (make#vector :length vector-length
                        :initial-contents (cons number list)))
         :where
         (defun | @ ? | (cursor)
           (let ((dash-dash#symbol
                  (fetch#vector :vector cute-comment
                                :index cursor)))
             (and (symbol? dash-dash#symbol)
                  (equal? dash-dash#symbol
                          '@))))
         (defun | -- ? | (cursor)
           (let ((dash-dash#symbol
                  (fetch#vector :vector cute-comment
                                :index cursor)))
             (and (symbol? dash-dash#symbol)
                  (let ((dash-dash#string
                         (symbol->string dash-dash#symbol)))
                    (and (> (length dash-dash#string)
                            1)
                         (equal? (cat (:trim '(#\-))
                                   (dash-dash#string))
                                 ""))))))
         (defun | <a> ? | (cursor)
           (| symbol <a> ? | (fetch#vector :vector cute-comment
                                           :index cursor))))))

   ;; (cute-comment->return-object
   ;;  (@ <fixnum>
   ;;     <fixnum>
   ;;     <fixnum> <::var1
   ;;     1        <::var2
   ;;     <title>  <::var3
   ;;     fixnum (title) <::var4
   ;;     --
   ;;     <fixnum>
   ;;     <fixnum> @))

   ;; (cute-comment->return-object
   ;;  (@ <fixnum>
   ;;     --
   ;;     <fixnum>
   ;;     <fixnum>
   ;;     <fixnum>
   ;;     <fixnum> @))

   ;; (cute-comment->return-object
   ;;  (@ <fixnum>
   ;;     --
   ;;     @))
   #+end_src
** ----------------------------------
* primitive-instruction
** ----------------------------------
** note
   * 用 table 來實現
     primitive-instruction 這個數據結構
     除了找到 primitive-instruction 本身在 host language 中的位置以外
     我還可以增加別的數據域
   * primitive-instruction 的製作
     與 用 (be) 給它命名是分開的
     單單在 host-language 中製作一個 primitive-instruction
     會在 *primitive-instruction-table* 中申請一個位置
     [接口函數是 make-primitive-instruction]
     所申請的位置的 index 就被爲是 primitive-instruction 的值
     而需要的時候 (be) 會給這個 index 一個名字
   * re-define a primitive-instruction
     will not cover the old one
     just re-bind the title.name
     if the old one is compiled into some function body
     it will still use the old one
     [this is the nature of forth]
** the primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-instruction-table* 1000)

   (defparameter *pointer#primitive-instruction-table* 1)

   (defparameter *primitive-instruction-table*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type 'function
      :initial-element 0))

   (defparameter *primitive-instruction-table#title*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type `(integer 0 ,*size#title.name-table*)
      :initial-element 0))

   (defparameter *primitive-instruction-table#name*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type `(integer 0 ,*size#name-hash-table*)
      :initial-element 0))


   (defparameter *primitive-instruction-table#named-local-variable*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type `vector
      :initial-element 0))

   (defparameter *primitive-instruction-table#inited-local-variable*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type `vector
      :initial-element 0))

   (defparameter *primitive-instruction-table#unnamed-local-variable*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type `vector
      :initial-element 0))

   (defparameter *primitive-instruction-table#return-object*
     (make#vector
      :length *size#primitive-instruction-table*
      :element-type `vector
      :initial-element 0))
   #+end_src
** primitive-instruction?
   * index-within-primitive-instruction-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-instruction? (index)
     (and (natural-number? index)
          (< index *size#primitive-instruction-table*)))
   #+end_src
** define-primitive-instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *title#primitive-instruction*
     (string->title "primitive-instruction"))

   (defmacro define-primitive-instruction
       (title-string
        name-string
        cute-comment
        &body body)
     `(let ((title (string->title ,title-string))
            (name (string->name ,name-string)))
        (be :title title
            :name name
            :title#object *title#primitive-instruction*
            :value#object
            (cond ((< *pointer#primitive-instruction-table*
                      ,*size#primitive-instruction-table*)
                   (save#primitive-instruction-table
                    :value (lambda () ,@body)
                    :field :instruction
                    :primitive-instruction :currnet)
                   (save#primitive-instruction-table
                    :value title
                    :field :title
                    :primitive-instruction :currnet)
                   (save#primitive-instruction-table
                    :value name
                    :field :name
                    :primitive-instruction :currnet)
                   (add1! *pointer#primitive-instruction-table*)
                   ;; return the old pointer [the index]
                   (sub1 *pointer#primitive-instruction-table*))
                  (:else
                   (orz ()
                     ("when using (define-primitive-instruction)~%")
                     ("the *primitive-instruction-table* must NOT be filled")))))))
   #+end_src
** primitive-instruction->host-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-instruction->host-function (primitive-instruction)
     (let ((host-function
            (fetch#vector :vector *primitive-instruction-table*
                          :index primitive-instruction)))
       (if (not (function? host-function))
           (orz ()
             ("from an instruction[index]: ~A ~%" primitive-instruction)
             ("(primitive-instruction->host-function) can not find any host-function"))
           host-function)))

   ;; (defun primitive-instruction->host-function (primitive-instruction)
   ;;   (fetch#vector :vector *primitive-instruction-table*
   ;;                 :index primitive-instruction))
   #+end_src
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#primitive-instruction-table
       (&key
          primitive-instruction
          field)
     (when (equal? primitive-instruction :currnet)
       (set! primitive-instruction *pointer#primitive-instruction-table*))
     (cond ((equal? field :instruction)
            (fetch#vector
             :vector *primitive-instruction-table*
             :index primitive-instruction))
           ((equal? field :title)
            (fetch#vector
             :vector *primitive-instruction-table#title*
             :index primitive-instruction))
           ((equal? field :name)
            (fetch#vector
             :vector *primitive-instruction-table#name*
             :index primitive-instruction))
           ((equal? field :named-local-variable)
            (fetch#vector
             :vector *primitive-instruction-table#named-local-variable*
             :index primitive-instruction))
           ;; ((equal? field :inited-local-variable)
           ;;  (fetch#vector
           ;;   :vector *primitive-instruction-table#inited-local-variable*
           ;;   :index primitive-instruction))
           ((equal? field :unnamed-local-variable)
            (fetch#vector
             :vector *primitive-instruction-table#unnamed-local-variable*
             :index primitive-instruction))
           ((equal? field :return-object)
            (fetch#vector
             :vector *primitive-instruction-table#return-object*
             :index primitive-instruction))
           (:else
            (orz ()
              ("the argument :field of (fetch#primitive-instruction-table)~%")
              ("must be a valid field of the primitive-instruction-table~%")
              ("but ~A is not~%" field)))))


   (defun save#primitive-instruction-table
       (&key
          primitive-instruction
          field
          value)
     (when (equal? primitive-instruction :currnet)
       (set! primitive-instruction *pointer#primitive-instruction-table*))
     (cond ((equal? field :instruction)
            (save#vector
             :value value
             :vector *primitive-instruction-table*
             :index primitive-instruction))
           ((equal? field :title)
            (save#vector
             :value value
             :vector *primitive-instruction-table#title*
             :index primitive-instruction))
           ((equal? field :name)
            (save#vector
             :value value
             :vector *primitive-instruction-table#name*
             :index primitive-instruction))
           ((equal? field :named-local-variable)
            (save#vector
             :value value
             :vector *primitive-instruction-table#named-local-variable*
             :index primitive-instruction))
           ;; ((equal? field :inited-local-variable)
           ;;  (save#vector
           ;;   :value value
           ;;   :vector *primitive-instruction-table#inited-local-variable*
           ;;   :index primitive-instruction))
           ((equal? field :unnamed-local-variable)
            (save#vector
             :value value
             :vector *primitive-instruction-table#unnamed-local-variable*
             :index primitive-instruction))
           ((equal? field :return-object)
            (save#vector
             :value value
             :vector *primitive-instruction-table#return-object*
             :index primitive-instruction))
           (:else
            (orz ()
              ("the argument :field of (save#primitive-instruction-table)~%")
              ("must be a valid field of the primitive-instruction-table~%")
              ("but ~A is not~%" field)))))
   #+end_src
** map
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#primitive-instruction-table
       (&key
          function
          (primitive-instruction 1)
          (base-list '()))
     (cond ((not (< primitive-instruction
                    ,*pointer#primitive-instruction-table*))
            base-list)
           (:else
            (cons (funcall function
                    :title (fetch#vector
                            :vector *primitive-instruction-table#title*
                            :index primitive-instruction)
                    :name (fetch#vector
                            :vector *primitive-instruction-table#name*
                            :index primitive-instruction)
                    :primitive-instruction primitive-instruction)
                  (map#primitive-instruction-table
                   :function function
                   :primitive-instruction (add1 primitive-instruction)
                   :base-list base-list)))))
   #+end_src
** print
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#primitive-instruction-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* primitive-instruction-table")
       ("  |-------------+--------|")
       ("  | size        | ~6D |" *size#primitive-instruction-table*)
       ("  | instruction | ~6D |" (sub1 *pointer#primitive-instruction-table*))
       ("  |-------------+--------|"))
     (map#primitive-instruction-table
      :function
      (lambda (&key
                 title
                 name
                 primitive-instruction)
        (cat (:to to
                  :postfix (cat () ("~%")))
          ("  * ~A ~A"
           (title->string title)
           (name->string name)))))
     (cat (:to to) ("~%")))
   #+end_src
** ----------------------------------
* primitive-function
** ----------------------------------
** the primitive-function-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-function-table* 1000)

   (defparameter *pointer#primitive-function-table* 1)

   (defparameter *primitive-function-table*
     (make#vector
      :length *size#primitive-function-table*
      :element-type 'function
      :initial-element 0))

   (defparameter *primitive-function-table#title*
     (make#vector
      :length *size#primitive-function-table*
      :element-type `(integer 0 ,*size#title.name-table*)
      :initial-element 0))

   (defparameter *primitive-function-table#name*
     (make#vector
      :length *size#primitive-function-table*
      :element-type `(integer 0 ,*size#name-hash-table*)
      :initial-element 0))


   (defparameter *primitive-function-table#named-local-variable*
     (make#vector
      :length *size#primitive-function-table*
      :element-type `vector
      :initial-element 0))

   (defparameter *primitive-function-table#inited-local-variable*
     (make#vector
      :length *size#primitive-function-table*
      :element-type `vector
      :initial-element 0))

   (defparameter *primitive-function-table#unnamed-local-variable*
     (make#vector
      :length *size#primitive-function-table*
      :element-type `vector
      :initial-element 0))

   (defparameter *primitive-function-table#return-object*
     (make#vector
      :length *size#primitive-function-table*
      :element-type `vector
      :initial-element 0))
   #+end_src
** primitive-function?
   * index-within-primitive-function-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-function? (index)
     (and (natural-number? index)
          (< index *size#primitive-function-table*)))
   #+end_src
** define-primitive-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *title#primitive-function*
     (string->title "primitive-function"))

   (defmacro define-primitive-function
       (title-string
        name-string
        cute-comment
        &body body)
     `(let ((title (string->title ,title-string))
            (name (string->name ,name-string)))
        (be :title title
            :name name
            :title#object *title#primitive-function*
            :value#object
            (cond ((< *pointer#primitive-function-table*
                      ,*size#primitive-function-table*)
                   (save#primitive-function-table
                    :value (lambda () ,@body)
                    :field :function
                    :primitive-function :currnet)
                   (save#primitive-function-table
                    :value title
                    :field :title
                    :primitive-function :currnet)
                   (save#primitive-function-table
                    :value name
                    :field :name
                    :primitive-function :currnet)
                   (save#primitive-function-table
                    :value (cute-comment->unnamed-local-variable ,cute-comment)
                    :field :unnamed-local-variable
                    :primitive-function :currnet)
                   (save#primitive-function-table
                    :value (cute-comment->named-local-variable ,cute-comment)
                    :field :named-local-variable
                    :primitive-function :currnet)
                   (save#primitive-function-table
                    :value (cute-comment->return-object ,cute-comment)
                    :field :return-object
                    :primitive-function :currnet)
                   (add1! *pointer#primitive-function-table*)
                   ;; return the old pointer [the index]
                   (sub1 *pointer#primitive-function-table*))
                  (:else
                   (orz ()
                     ("when using (define-primitive-function)~%")
                     ("the *primitive-function-table* must NOT be filled")))))))
   #+end_src
** primitive-function->host-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-function->host-function (primitive-function)
     (let ((host-function
            (fetch#primitive-function-table
             :field :function
             :primitive-function primitive-function)))
       (if (not (function? host-function))
           (orz ()
             ("from an index ~A ~%" primitive-function)
             ("(primitive-function->host-function) can not find any host-function"))
           host-function)))
   #+end_src
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#primitive-function-table
       (&key
          primitive-function
          field)
     (when (equal? primitive-function :currnet)
       (set! primitive-function *pointer#primitive-function-table*))
     (cond ((equal? field :function)
            (fetch#vector
             :vector *primitive-function-table*
             :index primitive-function))
           ((equal? field :title)
            (fetch#vector
             :vector *primitive-function-table#title*
             :index primitive-function))
           ((equal? field :name)
            (fetch#vector
             :vector *primitive-function-table#name*
             :index primitive-function))
           ((equal? field :named-local-variable)
            (fetch#vector
             :vector *primitive-function-table#named-local-variable*
             :index primitive-function))
           ;; ((equal? field :inited-local-variable)
           ;;  (fetch#vector
           ;;   :vector *primitive-function-table#inited-local-variable*
           ;;   :index primitive-function))
           ((equal? field :unnamed-local-variable)
            (fetch#vector
             :vector *primitive-function-table#unnamed-local-variable*
             :index primitive-function))
           ((equal? field :return-object)
            (fetch#vector
             :vector *primitive-function-table#return-object*
             :index primitive-function))
           (:else
            (orz ()
              ("the argument :field of (fetch#primitive-function-table)~%")
              ("must be a valid field of the primitive-function-table~%")
              ("but ~A is not~%" field)))))


   (defun save#primitive-function-table
       (&key
          primitive-function
          field
          value)
     (when (equal? primitive-function :currnet)
       (set! primitive-function *pointer#primitive-function-table*))
     (cond ((equal? field :function)
            (save#vector
             :value value
             :vector *primitive-function-table*
             :index primitive-function))
           ((equal? field :title)
            (save#vector
             :value value
             :vector *primitive-function-table#title*
             :index primitive-function))
           ((equal? field :name)
            (save#vector
             :value value
             :vector *primitive-function-table#name*
             :index primitive-function))
           ((equal? field :named-local-variable)
            (save#vector
             :value value
             :vector *primitive-function-table#named-local-variable*
             :index primitive-function))
           ;; ((equal? field :inited-local-variable)
           ;;  (save#vector
           ;;   :value value
           ;;   :vector *primitive-function-table#inited-local-variable*
           ;;   :index primitive-function))
           ((equal? field :unnamed-local-variable)
            (save#vector
             :value value
             :vector *primitive-function-table#unnamed-local-variable*
             :index primitive-function))
           ((equal? field :return-object)
            (save#vector
             :value value
             :vector *primitive-function-table#return-object*
             :index primitive-function))
           (:else
            (orz ()
              ("the argument :field of (save#primitive-function-table)~%")
              ("must be a valid field of the primitive-function-table~%")
              ("but ~A is not~%" field)))))
   #+end_src
** map
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#primitive-function-table
       (&key
          function
          (primitive-function 1)
          (base-list '()))
     (cond ((not (< primitive-function
                    ,*pointer#primitive-function-table*))
            base-list)
           (:else
            (cons (funcall function
                    :title
                    (fetch#primitive-function-table
                     :field :title
                     :primitive-function primitive-function)

                    :name
                    (fetch#primitive-function-table
                     :field :name
                     :primitive-function primitive-function)

                    :named-local-variable
                    (fetch#primitive-function-table
                     :field :named-local-variable
                     :primitive-function primitive-function)

                    ;; :inited-local-variable
                    ;; (fetch#primitive-function-table
                    ;;  :field :inited-local-variable
                    ;;  :primitive-function primitive-function)

                    :unnamed-local-variable
                    (fetch#primitive-function-table
                     :field :unnamed-local-variable
                     :primitive-function primitive-function)

                    :return-object
                    (fetch#primitive-function-table
                     :field :return-object
                     :primitive-function primitive-function)

                    :primitive-function primitive-function)

                  (map#primitive-function-table
                   :function function
                   :primitive-function (add1 primitive-function)
                   :base-list base-list)))))
   #+end_src
** print
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#primitive-function-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* primitive-function-table")
       ("  |----------+--------|")
       ("  | size     | ~6D |" *size#primitive-function-table*)
       ("  | function | ~6D |" (sub1 *pointer#primitive-function-table*))
       ("  |----------+--------|"))
     (map#primitive-function-table
      :function
      (lambda (&key
                 title
                 name
                 named-local-variable
                 unnamed-local-variable
                 return-object
                 primitive-function)
        (cat (:to to
                  :postfix (cat () ("~%")))
          ("  * ~A ~A"
           (title->string title)
           (name->string name))
          ("    unnamed-local-variable: [~A] ~A"
           (fetch#vector :vector unnamed-local-variable
                         :index 0)
           (map#vector :vector unnamed-local-variable
                       :offset 1
                       :function
                       (lambda (&key element) (title->string element))))
          ("    named-local-variable:   [~A] ~A"
           (fetch#vector :vector named-local-variable
                         :index 0)
           (map#vector :vector named-local-variable
                       :width 2
                       :offset 1
                       :function
                       (lambda (&key sub-vector)
                         (list (title->string
                                (fetch#vector :vector sub-vector
                                              :index 1))
                               (name->string
                                (fetch#vector :vector sub-vector
                                              :index 0))))))
          ("    return-object:          [~A] ~A"
           (fetch#vector :vector return-object
                         :index 0)
           (map#vector :vector return-object
                       :offset 1
                       :function
                       (lambda (&key element) (title->string element)))))))
     (cat (:to to) ("~%")))
   #+end_src
** ----------------------------------
* 記 各個表格
** ----------------------------------
** title.name-table
   * 二維
   * 語義爲姓名與物的綁定
   * 索引爲零的 第一行 不用
     索引即爲姓之編碼
   * 每行爲一姓 行首存姓作爲名之值
     (i 0) 存 (* name *)
   * 一行中存從此姓之名與物之綁定
     (i n) 存 (* name, object[title, value] *)
** name-hash-table
   * 一維
   * 語義爲名之編碼
     實現是字符串的散列函數
     即 字符串 到 上界爲某一素數的自然數集
     之間的假雙射
   * 索引爲零的 第一行 不用
     索引即爲名之編碼
   * 每一行有二值
     一爲字符串 一爲姓之索引
     如若被使用 則字符串爲所編碼的字符
     如若被用爲姓 則姓之索引之爲姓以此名爲名
** primitive-instruction-table
   * 一維
   * 語義爲指令集
   * 索引爲零的 第一行 不用
   * 其每行之值 待定
     但已知有 函數 姓 名
** primitive-function-table
   * 一維
   * 語義爲原始函數集
   * 索引爲零的 第一行 不用
   * 其每行之值 待定
     但已知有 函數 姓 名
   * 可能完全與 primitive-instruction-table 相同
     [那將是理想的設計]
     當有差異的時候另行說明
** ----------------------------------
* vector-function
** ----------------------------------
** 記
   * 函數體 中所保存的是線串碼[threaded-code][一串珠]
     也可以說一個函數體就是被線穿起來的一串珠子[bead]
     每個珠子是兩個物 一爲指令 二爲指令之參數
     不同的指令的參數個數可以不同 也就是說珠子有大有小
   * 函數頭 中保存約束變元的信息 還有返回值的信息 還有其他信息
** ----------------------------------
** fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#vector-function-body ())
   (defun save#vector-function-body ())
   #+end_src
** ----------------------------------
* >< instruction-return-stack
** note
   * in cicada language
     you can extend the instruction set of the vm
   * in the body of the definition of your instruction
     when you call a cicada function
     it will not use the return-stack to record the return point
     but to use instruction-return-stack
* -----------------------------------
* compiler of cicada language
** 記
   * 這裏的編譯器是將要被重新實現於蟬語中的
     所以
     其代碼風格趨向蟬語
   * 注意所處理的都是字符串 而不是 stream
   * 難點在於
     在這裏就要形成 所謂的 語境 概念
     所定義的是一個語境而已
     這個語境中 保留了 forth 的語法的傳統
     但是這裏不能使用虛擬機中的 姓名 機制來實現 語境
     也沒有必要這樣做
     因爲這裏的語境是單一的
** note usage in common-lisp
   * [ (: cicada :) ]
** cicada
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada (string) (cicada-language string))
   (defun cicada-language (string)
     (string->list#word string))
   #+end_src
** key-word
** test
   #+begin_src cicada
   [ (: cicada :)

   : string->char
     (* string[address, length] -- char *)
     (* drop fetch-byte *)
     get-char
     xx|swap|x drop2
     Exit
   ; define-verb

   : string ->char
     (@ <string> -- <char> @)
     (char) (* drop fetch-byte *)
     (xx|swap|x) (drop2)
   ; define-verb

   ]
   #+end_src
* -----------------------------------
* >< let it be
* >< the story begin
* ===================================
* test
  #+begin_src lisp
  (asdf:load-system :cicada-vm)
  (in-package :cicada-vm)
  (setf *print-pretty* t)
  (run-unit 'ytool)
  (run-unit 'basic)
  (run-unit 'cicada-rhapsody)
  (run-unit 'cicada-vm)

  ;; this is the first primitive-instruction
  (define-primitive-instruction
      "primitive-function" "call"
      ;; ><><>< should do title check
      ;; 还有声明副作用的语法 如何
      ;; 比如 对 return-stack 的副作用
      (@ -- @)
    (with (fetch#cicada-image
           :address (add *cicada-object-size*
                         (with (tos#return-stack)
                           .value)))
      ;; this means only primitive-instruction is handled now
      (funcall (primitive-function->host-function .value))))

  ;; * the argument of a primitive-function
  ;;   should be fetched from the *argument-stack*
  ;; * in the lisp's sense
  ;;   the primitive-functions are all about side-effect
  (define-primitive-function
      "test" "kkk"
      (@ <fixnum>
         <fixnum>
         <fixnum> <::var1
         1        <::var2
         <title>  <::var3
         fixnum (title) <::var4
         --
         <fixnum> @)
    (cat (:to *standard-output*)
      ("kkk took what away?~%")))

  (save#cicada-image
   :address 0
   :title (string->title "primitive-instruction")
   :value (o "primitive-function" "call"))

  (save#cicada-image
   :address *cicada-object-size*
   :title (string->title "test")
   :value (o "test" "kkk"))

  (push#return-stack
   :title (string->title "nevermind")
   :value 0)

  (execute-next-instruction)

  (print#primitive-instruction-table)
  (print#primitive-function-table)
  #+end_src
* ===================================
