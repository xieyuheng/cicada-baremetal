#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* TODO
  * first version
    without parsing the image file
  * parse image file
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the method used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
* -----------------------------------
* xyh-lib
** note
   * a subset of syntax
   * naming convention
     * rename functions
     * to use "#"
       to introduce symbol
       as prefix and postfix of other symbol
     * a "#" denotes an word such as
       "of" "'s" "is" "are" "for" "to" "from" and so on
       in Chinese
       this kind of words are called unfilled-word
       i.e. word which is not filled by a precise meaning
       the meaning of it should be infered from context
     * when wish to stress that a symbol is used as a bounded-variable
       use "." as its prefix
   * you should respect the function
     * when a calculation is done
       it is not respectful
       to not return all of the hard work the function had done
     * so I return multi-value
       to capture almost the whole calculation
   * function should return its audience
     * function should be defined in the way that
       1. the structure of the data applied to the function
          is as regular as possible
          [this will make the function easy to write and easy to read]
       2. when ill-structured data is applied to the function
          the function cry out loud that it is an error
       3. well defined predicate is created
          to test if the data is regular or not
       4. when call the function
          the caller should use the predicate
          to make sure that
          the structure of data is regular
          [this will make the intention of code clear]
** header
*** system declaration
    #+begin_src lisp :tangle xyh-lib.asd
    (defsystem #:xyh-lib
      :description "XIE Yuheng's library for common lisp language"
      :author "XIE Yuheng <xyheme@gmail.com>"
      ;; :depends-on ()
      :serial t
      :components ((:file "xyh-lib--package-header")
                   (:file "xyh-lib")))
    #+end_src
*** xyh-lib--package-header
    #+begin_src lisp :tangle xyh-lib--package-header.lisp
    (defpackage #:xyh-lib
      (:use #:common-lisp)
      (:export

       #:nil?
       #:add1
       #:sub1

       #:read#line
       #:read#char
       #:newline

       #:char#space?
       #:string->head#word
       #:string->tail#word
       #:string#space?
       #:string->list#word

       #:group
       ))
    #+end_src
*** (in-package #:xyh-lib)
    #+begin_src lisp :tangle xyh-lib.lisp
    (in-package #:xyh-lib)
    #+end_src
** basic
   #+begin_src lisp :tangle xyh-lib.lisp
   (defun nil? (x)
     (null x))

   (defun add1 (x)
     (+ x 1))

   (defun sub1 (x)
     (- x 1))
   #+end_src
** io
   #+begin_src lisp :tangle xyh-lib.lisp
   (defun read#line (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof))
     (read-line from eof-as-error? read-eof-as))

   (defun read#char (&key
                       (from *standard-input*)
                       (eof-as-error? t)
                       (read-eof-as 'eof))
     (read-char from eof-as-error? read-eof-as))

   (defun newline (&key (many 1))
     (cond ((= 0 many) :nothing)
           ((= 1 many) (format t "~%"))
           ((< 1 many) (format t "~%")
            (newline :many (sub1 many)))
           (:else :nothing)))
   #+end_src
** string processing
   #+begin_src lisp :tangle xyh-lib.lisp
   (defun char#space? (char)
     (let ((code (char-code char)))
       (cond ((= code 32) t)
             ((= code 10) t)
             (:else nil))))

   ;; (char#space? #\newline)
   ;; (char#space? #\space)



   (defun string->head#word (string)
     (let* ((index-start (position-if
                          (lambda (char) (not (char#space? char)))
                          string))
            (index-end (position-if
                        (lambda (char) (char#space? char))
                        string
                        :start index-start)))
       (values (subseq string
                       index-start
                       index-end)
               index-end
               index-start
               string)))

   ;; (multiple-value-bind
   ;;       (head#word
   ;;        index-end
   ;;        index-start
   ;;        string)
   ;;     (string->head#word string)
   ;;   ><><><)

   ;; (string->head#word " kkk took my baby away! ")
   ;; (string->head#word "k")
   ;; (string->head#word " k")
   ;; (string->head#word "k ")

   ;; the argument applied to string->head#word
   ;; must not be space-string

   ;; just do not handle the error
   ;; let the debuger do its job
   ;; (string->head#word " ")



   (defun string->tail#word (string)
     (multiple-value-bind
           (head#word
            index-end
            index-start
            string)
         (string->head#word string)
       (if (nil? index-end)
           ""
           (subseq string index-end))))

   ;; (string->tail#word " kkk took my baby away! ")



   (defun string#space? (string)
     (not (position-if
           (lambda (char) (not (char#space? char)))
           string)))

   ;; (string#space? " 123 ")
   ;; (string#space? "  ")
   ;; (string#space? "")



   (defun string->list#word (string &key (base-list '()))
     (cond
       ((string#space? string) base-list)
       (:else
        (cons (string->head#word string)
              (string->list#word (string->tail#word string))))))

   ;; (string->list#word " kkk took my baby away! ")
   ;; (string->list#word " kkk")
   ;; (string->list#word "kkk ")
   ;; (string->list#word " ")
   ;; (string->list#word "")
   #+end_src
** list processing
   #+begin_src lisp :tangle xyh-lib.lisp
   (defun group (list
                 &key
                   (number 2)
                   ;; (pattern '())
                   (base-list '()))
     (cond ((< (length list) 2) base-list)
           (:else
            (cons (list (first list) (second list))
                  (group (cddr list)
                         :number number)))))
   ;; (defun help#group ())
   #+end_src
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     symbol <name
     symbol <as
     (explain)
     for example
     one can explain a symbol as
     * type
     * string
     * instruction
   * 需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** header
*** system declaration
    #+begin_src lisp :tangle name-table.asd
    (defsystem #:name-table
      :description "cicada language's hash table of string"
      :author "XIE Yuheng <xyheme@gmail.com>"
      :depends-on (#:xyh-lib)
      :serial t
      :components ((:file "name-table--package-header")
                   (:file "name-table")))
    #+end_src
*** name-table--package-header
    #+begin_src lisp :tangle name-table--package-header.lisp
    (defpackage #:name-table
      (:use #:common-lisp
            #:xyh-lib)
      (:export

       ))
    #+end_src
*** (in-package #:name-table)
    #+begin_src lisp :tangle name-table.lisp
    (in-package #:name-table)
    #+end_src
** ><
   #+begin_src lisp :tangle name-table.lisp
   (defparameter *max-carry-position* 26)

   (defun string->natural-number (string)
     ())

   (defparameter *max-index* ><)

   (defun natural-number->index (natural-number)
     ())


   #+end_src
* threaded-code interpreter
** note
   * 只有 對 threaded-code 的解釋 內置在虛擬機中的
     也就是說
     這裏需要處理的 structure 有
     1. primitive-function
     2. vector-function
     3. return-stack
     4. argument-stack
     5. frame-stack
        也就是說專門有一個 stack
        專注於約束變元
        而 argument-stack 還是以 古典的 forth 的方式工作
   * 其實這些 stack 是爲了 完成函數調用語義 而設計的
     那麼這裏就遇到了
     用 小的 structure
     組成 大的 structure 的問題
     但是 在實現 threaded-code interpreter 的時候
     還不能使用 structure 的機制
     因爲這個機制還沒實現呢
     儘管
     之後
     這些處理函數都會被暴露出來
** header
*** system declaration
    #+begin_src lisp :tangle threaded-code-interpreter.asd
    (defsystem #:threaded-code-interpreter
      :description "threaded-code interpreter of cicada language"
      :author "XIE Yuheng <xyheme@gmail.com>"
      :depends-on (#:xyh-lib
                   #:name-table)
      :serial t
      :components ((:file "threaded-code-interpreter--package-header")
                   (:file "threaded-code-interpreter")))
    #+end_src
*** threaded-code-interpreter--package-header
    #+begin_src lisp :tangle threaded-code-interpreter--package-header.lisp
    (defpackage #:threaded-code-interpreter
      (:use #:common-lisp
            #:xyh-lib
            #:name-table)
      (:nicknames #:cicada-vm)
      (:export

       ))
    #+end_src
*** (in-package #:threaded-code-interpreter)
    #+begin_src lisp :tangle threaded-code-interpreter.lisp
    (in-package #:threaded-code-interpreter)
    #+end_src
** ><
   #+begin_src lisp :tangle threaded-code-interpreter.lisp

   #+end_src
* -----------------------------------
* test
  #+begin_src lisp
  (progn
    ;;(asdf:operate 'asdf:load-op 'threaded-code-interpreter)
    (asdf:load-system 'threaded-code-interpreter)
    (in-package #:threaded-code-interpreter))
  #+end_src
