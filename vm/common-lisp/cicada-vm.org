#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* TODO
  * reading & writing image file
  * vector-function
  * the funciton (next)
  * first version
    without database of symbol usage
    without resolving system
  * parsing image file
  * cicada-rhapsody
* ===================================
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the way used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
  * when a image file is loaded to *cicada-image-buffer*
    host language can provide many run-time supports
    but run-time independent compile must be supported too
  * when compiling to cicada language to image file
    the compiler maintains a database of symbol-address binding
    the database records all the use of every symbol
    the database helps one to
    NOT care about the encoding of instruction and title
  * value of symbol
    need to be updateed
    address of primitive-function and primitive-instruction
    need to be updateed
  * when vm interpreting image file
    it reads the database first
    and resolves the symbol in the image file
    meanwhile updating the database
    only after then
    the vm can begin interpreting the image file
* -----------------------------------
* asdf file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module :package-header
              :components
              ((:file "package-header")))
     (:module :basic
              :components
              ((:file "basic")
               (:file "basic.test"
                      :if-feature :with-little-test)))
     (:file "cicada-vm")
     (:file "cicada-vm.test"
            :if-feature :with-little-test)))
  #+end_src
* -----------------------------------
* (in-package :cicada-vm)
** cicada-vm.lisp
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package :cicada-vm)
   #+end_src
** cicada-vm.test.lisp
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* cell
** note
   * in cicada
     an object is two cell
     one for title
     one for value
   * a cell is *cell-unit* many bytes
     the title cell is just a index into title-table
     the maening of the value cell is depends on its title
   * in the host language of cicada
     functions
     (host-object->cicada-object)
     (cicada-object->host-object)
     are provided
** cell-unit
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* 4) ;; 4 bytes
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))
   #+end_src
* interface between host and cicada
** host-object?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun host-object? (x)
     (and (vector? x)
          (= 3 (array-dimension x
                                0))
          (equal? '<host-object>
                  (fetch#vector :vector x
                                :index 0))
          (title? (fetch#vector :vector x
                                :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest host-object?
       (cicada-vm)
     (ensure
         (host-object? #(<host-object>
                         #(<title> 0)
                         #(<name> 0)))
         ==>
         T))
   #+end_src
** make-cicada-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun make-cicada-object (&key
                                title
                                value)
     (if (not (title? title))
         (error "the agument :title of (make-cicada-object) must be checked by title?")
         (let ((cicada-object (make-array `(,*cicada-object-size*)
                                          :element-type '(unsigned-byte 8)
                                          :initial-element 0)))
           (save#byte-vector :value (title->index title)
                             :byte-vector cicada-object
                             :size *cell-unit*
                             :index 0)
           (save#byte-vector :value value
                             :byte-vector cicada-object
                             :size *cell-unit*
                             :index *cell-unit*))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest make-cicada-object
       (cicada-vm)
     (ensure
         (list (fetch#byte-vector
                :byte-vector (make-cicada-object :title (string->title "kkk")
                                                 :value 666)
                :size *cell-unit*
                :index *cell-unit*)
               (equal? (array-element-type
                        (make-cicada-object :title (string->title "kkk")
                                            :value 666))
                       '(unsigned-byte 8)))
         ==>
         (list 666
               t)))
   #+end_src
** cicada-object?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object? (x)
     (and (vector? x)
          (equal? '(unsigned-byte 8)
                  (array-element-type x))
          (= *cicada-object-size*
             (array-dimension x 0))
          (not
           (nil?
            (fetch#array
             :array *title-table*
             :index-vector (vector (fetch#byte-vector
                                    :byte-vector x
                                    :size *cell-unit*
                                    :index 0)
                                   0))))
          ))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest cicada-object?
       (cicada-vm)
     (ensure
         (cicada-object?
          (make-cicada-object :title (string->title "kkk")
                              :value 666))
         ==>
         t))
   #+end_src
** host-object->cicada-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun host-object->cicada-object (host-object)
     (if (not (host-object? host-object))
         (error "the argument of (host-object->cicada-object) must be checked by host-object?")
         (make-cicada-object :title (fetch#vector :vector host-object
                                                  :index 1)
                             :value (fetch#vector :vector host-object
                                                  :index 2))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest host-object->cicada-object
       (cicada-vm)
     (ensure
         (multiple-value-list
          (host-object->cicada-object
           `#(<host-object>
              ,(string->title "testing#host-object->cicada-object")
              #b10000000)))
         ==>
         (list `#(,(title->index
                    (string->title
                     "testing#host-object->cicada-object"))
                  0 0 0
                  128 0 0 0)
               `128)))
   #+end_src
** cicada-object->host-object
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun cicada-object->host-object (cicada-object)
     (cond ((not (cicada-object? cicada-object))
            (error "the argument of (cicada-object->host-object) must be checked by cicada-object?"))
           (:else
            `#(<host-object>
               ,(vector '<title>
                        (fetch#byte-vector :byte-vector cicada-object
                                           :size *cell-unit*
                                           :index 0))
               ,(fetch#byte-vector :byte-vector cicada-object
                                   :size *cell-unit*
                                   :index *cell-unit*)))
           ))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest cicada-object->host-object
       (cicada-vm)
     (ensure
         (cicada-object->host-object
          (host-object->cicada-object
           `#(<host-object>
              ,(string->title "testing#host-object->cicada-object")
              #b10000000)))
         ==>
         `#(<HOST-OBJECT>
            ,(string->title "testing#host-object->cicada-object")
            128)))
   #+end_src
* load image
** note
   * in the first few test versions
     the image file will just be a vector-function-body
** ><
   #+begin_src lisp
   (progn
    ;; form a (file . buffer) pair
    (setf stream (open (make-pathname :name "cicada-image-file-test~")
                       :direction ':output
                       :if-exists ':supersede))
    ;; edit the buffer
    (format stream "cicada ~%")
    ;; save-buffer-to-file
    (close stream))

   (defparameter *cicada-image-stream*
     (open (make-pathname :name "cicada-image-file-test~")
           :element-type '(unsigned-byte 8)
           :direction ':input))

   (defparameter *cicada-image-buffer*
     (make-array '(100)
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))

   (values
    (read-sequence *cicada-image-buffer*
                   ,*cicada-image-stream*)
    ,*cicada-image-buffer*)
   #+end_src
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     * <name
       <as
       <mean
       (be)
     * <name
       <as
       (explain)
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** the name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-table*
     100333)

   (defparameter *size#entry#name-table*
     100)

   (defparameter *name-table*
     (make-array
      (list *size#name-table* *size#entry#name-table*)
      :initial-element nil))

   (defun index-within-name-table? (index)
     (and (natural-number? index)
          (< index *size#name-table*)))
   #+end_src
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest string->natural-number
       (cicada-vm)
     (ensure
         (list (string->natural-number "")
               (string->natural-number "@")
               (string->natural-number "@@@"))
         ==>
         (list 0
               64
               448)))
   #+end_src
** natural-number->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-table*)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest natural-number->index
       (cicada-vm)
     (ensure
         (list (natural-number->index 0)
               (natural-number->index 123)
               (natural-number->index *size#name-table*))
         ==>
         (list 0
               123
               0)))
   #+end_src
** name?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (x)
     (and (vector? x)
          (= 2 (array-dimension x
                                0))
          (equal? '<name>
                  (fetch#vector :vector x
                                :index 0))
          (index-within-name-table?
           (fetch#vector :vector x
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name?
       (cicada-vm)
     (ensure
         (name? #(<name> 0))
         ==>
         t))
   #+end_src
** name->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->index (name)
     (cond ((not (name? name))
            (error "argument of name->index must be a name"))
           (:else
            (fetch#vector :vector name
                          :index 1))))
   #+end_src
** string->name & name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (let ((index
            (natural-number->index
             (string->natural-number string))))
       (help#string->name#find-old-or-creat-new string
                                                index)))

   (defun help#string->name#find-old-or-creat-new (string index)
     (cond
       ((not (name-table-index#used? index))
        (help#string->name#creat-new string
                                     index)
        `#(<name> ,index))

       ((equal? string
                (fetch#array :array *name-table*
                             :index-vector `#(,index 0)))
        `#(<name> ,index))

       (:else
        (help#string->name#find-old-or-creat-new
         string
         (name-table-index#next index)))
       ))


   (defun help#string->name#creat-new (string index)
    (save#array :value string
                :array *name-table*
                :index-vector `#(,index 0)))


   (defun name-table-index#used? (index)
     (string? (fetch#array :array *name-table*
                           :index-vector `#(,index 0))))

   (defun name-table-index#next (index)
     (if (= index *size#name-table*)
         0
         (add1 index)))



   (defun name->string (name)
     (cond ((not (name? name))
            (error "argument of name->string must be a name"))
           (:else
            (let ((index (name->index name)))
              (cond ((not (name-table-index#used? index))
                     (error "this name does not have a string"))
                    (:else
                     (fetch#array :array *name-table*
                                  :index-vector `#(,index 0)))
                    )))
           ))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name->string
       (cicada-vm)
     (ensure
         (name->string (string->name "kkk took my baby away!"))
         ==>
         "kkk took my baby away!"))
   #+end_src
** print-name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-name (name
                      &key (stream t))
     (format stream
             "[~A]"
             (name->string name)))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print-name
       (cicada-vm)
     (ensure
         ;; (let ((test-stream (make-string-output-stream)))
         ;;   (print-name (string->name "kkk took my baby away!")
         ;;               :stream test-stream)
         ;;   (get-output-stream-string test-stream))
         (print-name (string->name "kkk took my baby away!")
                     :stream nil)
         ==>
         "[kkk took my baby away!]"))
   #+end_src
** be & explain
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; <name
   ;; <as
   ;; <mean
   ;; (be)

   ;; <name
   ;; <as
   ;; (explain)



   ;; interface:
   ;; (multiple-value-bind
   ;;       (field
   ;;        update?
   ;;        old-mean)
   ;;     (be :name
   ;;         :as
   ;;         :mean )
   ;;   ><><><)

   (defun be (&key
                name
                as
                mean)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (be) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#be :name-index name-index
                    :as-index as-index
                    :mean mean))))



   (defun help#be (&key
                     name-index
                     as-index
                     mean
                     (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-vector `#(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-vector `#(,name-index ,field))
          (values field
                  nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (save#array :value (cons as-index mean)
                      :array *name-table*
                      :index-vector `#(,name-index ,field))
          (values field
                  :updated!!!
                  (cdr content-of-field)))

         ((< field *size#entry#name-table*)
          (help#be :name-index name-index
                   :as-index as-index
                   :mean mean
                   :field (add1 field)))

         (:else
          (error "the meaning of this name is too filled"))
         )))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (mean
   ;;        find?)
   ;;     (explain :name
   ;;              :as )
   ;;   ><><><)

   (defun explain (&key
                     name
                     as)
     (if (or (not (name? name))
             (not (name? as)))
         (error "the argument :name and :as of (explain) must be checked by (name?)")
         (let ((name-index (name->index name))
               (as-index (name->index as)))
           (help#explain :name-index name-index
                         :as-index as-index))))



   (defun help#explain (&key
                          name-index
                          as-index
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *name-table*
                         :index-vector `#(,name-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? as-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  :found!!!))

         ((< field *size#entry#name-table*)
          (help#explain :name-index name-index
                        :as-index as-index
                        :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not explain the name as the way you wish~%"
                  "and the meaning of this name is too filled")))
         )))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest be--and--explain
       (cicada-vm)
     (ensure
         (list (be :name (string->name "kkk")
                    :as (string->name "took")
                    :mean "my baby away!")
               (multiple-value-list
                (be :name (string->name "kkk")
                    :as (string->name "took")
                    :mean "my baby away!"))
               (multiple-value-list
                (explain :name (string->name "kkk")
                         :as (string->name "took"))))
         ==>
         (list 1
               `(2
                 :UPDATED!!!
                 "my baby away!")
               `("my baby away!"
                 :found!!!))
       ;; (list 2
       ;;         `(2
       ;;           :UPDATED!!!
       ;;           "my baby away!")
       ;;         `("my baby away!"
       ;;           :found!!!))
       ))
   #+end_src
** meaningful?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun meaningful? (&key
                         name
                         as)
       (multiple-value-bind
             (mean
              find?)
           (explain :name name
                    :as as)
         find?))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest meaningful?
       (cicada-vm)
     (ensure
         (meaningful? :name (string->name "kkk")
                      :as (string->name "took"))
         ==>
         :found!!!))
   #+end_src
* title-table
** note
   * title is the way I used to manage name of things
     a title can be viewed as
     a type
     a module
     a structure
   * a title is a index into title-table
     the index is used as the encoding of that title
     there is only one title-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (entitle)
     * <title
       <name
       (ask)
   * every object have a title
** the title-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title-table*
     1000)

   (defparameter *size#entry#title-table*
     100)

   (defparameter *title-table*
     (make-array
      (list *size#title-table* *size#entry#title-table*)
      :initial-element nil))

   (defun index-within-title-table? (index)
     (and (natural-number? index)
          (< index *size#title-table*)))

   (defparameter *pointer#title-table* 0)
   #+end_src
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let ((name (string->name string))
           (name#title (string->name "title")))
       (cond
         ((meaningful? :name name
                       :as name#title)
          `#(<title>
             ,(explain :name name
                       :as name#title)))

         ((< *pointer#title-table*
             ,*size#title-table*)
          ;; to create a new title is
          ;; to allocate a new index in the title-table
          ;; and save the name#title to the field number 0 of the entry
          (be :name name
              :as name#title
              :mean *pointer#title-table*)
          (save#array :value name#title
                      :array *title-table*
                      :index-vector (vector *pointer#title-table* 0))
          ;; update *pointer#title-table*
          (setf *pointer#title-table*
                (add1 *pointer#title-table*))
          `#(<title>
             ,(sub1 *pointer#title-table*)))

         (:else
          (error "title-table is filled, can not make new title")))))
   #+end_src
** title?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (x)
     (and (vector? x)
          (= 2 (array-dimension x
                                0))
          (equal? '<title>
                  (fetch#vector :vector x
                                :index 0))
          (index-within-title-table?
           (fetch#vector :vector x
                         :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest title?
       (cicada-vm)
     (ensure
         (list (title? #(<title> 0))

               (title? (string->title "testing#title?")))
         ==>
         (list t
               t)))
   #+end_src
** title->index
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->index (title)
     (cond ((not (title? title))
            (error "argument of title->index must be a title"))
           (:else
            (fetch#vector :vector title
                          :index 1))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest title->index
       (cicada-vm)
     (ensure
         (let ((test1 (title->index (string->title "testing#1#title->index")))
               (test2 (title->index (string->title "testing#2#title->index"))))
           (- test2 test1))
         ==>
         1))
   #+end_src
** entitle & ask
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; <title
   ;; <name
   ;; <object
   ;; (entitle)

   ;; <title
   ;; <name
   ;; (ask)



   ;; interface:
   ;; (multiple-value-bind
   ;;       (field
   ;;        update?
   ;;        old-object)
   ;;     (entitle :title
   ;;              :name
   ;;              :object )
   ;;   ><><><)

   (defun entitle (&key
                     title
                     name
                     object)
     (if (or (not (title? title))
             (not (name? name))
             (not (host-object? object)))
         (error "one or more the arguments of (entitle) is of wrong type")
         (let ((title-index (title->index title))
               (name-index (name->index name)))
           (help#entitle :title-index title-index
                         :name-index name-index
                         :object object))))



   (defun help#entitle (&key
                          title-index
                          name-index
                          object
                          (field 1))
     (let ((content-of-field
            (fetch#array :array *title-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ((nil? content-of-field)
          (save#array :value (cons name-index object)
                      :array *title-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  nil
                  nil))

         ((equal? name-index
                  (car content-of-field))
          (save#array :value (cons name-index object)
                      :array *title-table*
                      :index-vector `#(,title-index ,field))
          (values field
                  :updated!!!
                  (cdr content-of-field)))

         ((< field *size#entry#title-table*)
          (help#entitle :title-index title-index
                        :name-index name-index
                        :object object
                        :field (add1 field)))

         (:else
          (error "the names under this title is too filled"))
         )))



   ;; interface:
   ;; (multiple-value-bind
   ;;       (object
   ;;        find?)
   ;;     (ask :title
   ;;          :name )
   ;;   ><><><)


   (defun ask (&key
                 title
                 name)
     (if (or (not (title? title))
             (not (name? name)))
         (error "one or more the arguments of (ask) is of wrong type")
         (let ((title-index (title->index title))
               (name-index (name->index name)))
           (help#ask :title-index title-index
                     :name-index name-index))))



   (defun help#ask (&key
                      title-index
                      name-index
                      (field 1))
     (let ((content-of-field
            (fetch#array :array *title-table*
                         :index-vector `#(,title-index ,field))))
       (cond
         ((nil? content-of-field)
          (values nil
                  nil))

         ((equal? name-index
                  (car content-of-field))
          (values (cdr content-of-field)
                  :found!!!))

         ((< field *size#entry#title-table*)
          (help#ask :title-index title-index
                    :name-index name-index
                    :field (add1 field)))

         (:else
          (error (concatenate
                  'string
                  "can not ask for the object under the name as you wish~%"
                  "and the names under this title is too filled")))
         )))


   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest entitle--and--ask
       (cicada-vm)
     (ensure
         (list (entitle :title (string->title "kkk")
                        :name (string->name "took")
                        :object `#(<host-object>
                                   ,(string->title "my")
                                   "baby away!"))
               (multiple-value-list
                (entitle :title (string->title "kkk")
                         :name (string->name "took")
                         :object `#(<host-object>
                                    ,(string->title "my")
                                    "baby away!")))
               (multiple-value-list
                (ask :title (string->title "kkk")
                     :name (string->name "took"))))
         ==>
         (list `1
               `(1
                 :updated!!!
                 #(<host-object> ,(string->title "my") "baby away!"))
               `(#(<host-object> ,(string->title "my") "baby away!")
                  :found!!!))))
    #+end_src
** entitled?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun entitled? (&key
                       title
                       name)
     (multiple-value-bind
           (object
            find?)
         (ask :title title
              :name name)
       find?))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest entitled?
       (cicada-vm)
     (ensure
         (entitled? :title (string->title "kkk")
                    :name (string->name "took"))
         ==>
         :found!!!))
   #+end_src
** print-title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print-title (title &key (stream t))
     (if (not (title? title))
         (error "the argument of (print-title) must be checked by title?")
         (print-name (fetch#array :array *title-table*
                                  :index-vector `#(,(title->index title) 0))
                     :stream stream)))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print-title
       (cicada-vm)
     (ensure
         ;; (let ((test-stream (make-string-output-stream)))
         ;;   (print-title (string->title "kkk")
         ;;                :stream test-stream)
         ;;   (get-output-stream-string test-stream))
         (print-title (string->title "kkk")
                      :stream nil)
         ==>
         "[title]"))
   #+end_src
** (string->title "title")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "title")
   #+end_src
* -----------------------------------
* vector-function
** note
   * address in the vector-function zone
** ><
   #+begin_src lisp

   #+end_src
* pointer-into-vector-function-body
** note
   * with the title system
     no (not much) global addresses will be used
     the title of a poniter helps to make the poniter
     become from an address to an index
* return-stack
** note
   * return-stack is a stack of pointers
     of which a pointer points into a function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers that are moving
     the pointer on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers that are pushing or popping
     the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 pointer#vector-function-body 這個 title 的數據
     的函數
     而 pointer#vector-function-body 這個 title 下
     有處理這個數據類型的函數
** (string->title "return-stack")
   #+begin_src lisp :tangle cicada-vm.lisp
   (string->title "return-stack")
   #+end_src
** the return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make-array `(,(*  *cicada-object-size*
                        ,*size#return-stack*))
                 :element-type '(unsigned-byte 8)
                 :initial-element 0))

   ;; pointer is an index into *return-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#return-stack* 0)

   (defun push#return-stack (cicada-object)
     (cond
       ((not (cicada-object? cicada-object))
        (error "the argument of (push#return-stack) must be checked by cicada-object?"))

       ((not (<  (*  *pointer#return-stack*
                     ,*cicada-object-size*)
                 ,*size#return-stack*))
        (error "can not push anymore *return-stack* is filled"))

       (:else
        (let ()
          (copy#byte-vector :from cicada-object
                            :from-index 0
                            :to *return-stack*
                            :to-index (*  *pointer#return-stack*
                                          ,*cicada-object-size*)
                            :size *cicada-object-size*)
          (setf *pointer#return-stack*
                (add1 *pointer#return-stack*))
          (values *pointer#return-stack*
                  cicada-object)))))

   (defun pop#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error "can not pop anymore *return-stack* is empty"))

       (:else
        (setf *pointer#return-stack*
              (sub1 *pointer#return-stack*))
        (values (fetch#byte-vector :byte-vector *return-stack*
                                   :index (*  *pointer#return-stack*
                                              ,*cicada-object-size*))
                ,*pointer#return-stack*))))

   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest push#return-stack
       (cicada-vm)
     (ensure
         (list (multiple-value-list
                (push#return-stack
                 (make-cicada-object :title (string->title "kkk")
                                     :value 666)))
               (multiple-value-list
                (push#return-stack
                 (make-cicada-object :title (string->title "kkk")
                                     :value 666)))
               (multiple-value-list
                (pop#return-stack))
               (multiple-value-list
                (pop#return-stack)))
         ==>
         (list `(1 ,(make-cicada-object :title (string->title "kkk")
                                        :value 666))
               `(2 ,(make-cicada-object :title (string->title "kkk")
                                        :value 666))
               `(,(title->index (string->title "kkk"))
                 1)
               `(,(title->index (string->title "kkk"))
                 0))))
   #+end_src
** >< next
   #+begin_src lisp
   (defun next ()
     (let* ((pair (fetch
                   (fetch#vector :vector *return-stack*
                                 :index *pointer#return-stack*)))
            (instruction-index (car pair))
            (argument-object (cdr pair)))
       (execute-instruction :instruction-index instruction-index
                            :argument-object argument-object)))

   (defun execute-instruction (&key
                                 instruction-index
                                 argument-object)
     (funcall (fetch#vector :vector **
                            :index instruction-index)
              argument-object))
   #+end_src
* argument-stack
** the argument-stack
* frame-stack
** the frame-stack
* instruction-return-stack
  * in cicada language
    you can extend the instruction set of the vm
  * in the body of the definition of your instruction
    when you call a cicada function
    it will not use the return-stack to record the return point
    but to use instruction-return-stack
* primitive-instruction
** create title
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (string->title "primitive-instruction")
   #+end_src
* primitive-function
** note
   * 函數的調用 和 函數的返回值
     argument-stack 和 return-stack 和 frame-stack
     這裏就涉及到了不同模塊的東西之間的依賴關係
** create title
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; (string->title "primitive-function")
   #+end_src
** instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; call#primitive-function
   ;; tail-call#primitive-function
   #+end_src
* variable
* bool
** instruction
   * bool#literal
* fixnum
** instruction
   * fixnum#literal
* -----------------------------------
* compiler
** note
* -----------------------------------
* threaded-code interpreter
** note
* -----------------------------------
* cicada-rhapsody
  #+begin_src lisp
  (defun name-reader (stream char-bound-with-this-function)
    (read#char :from stream
               :recursive-call-to-reader? nil))

  (bind-char-to-reader
   (character "[")
   (function name-reader))

  ;; (find-reader-from-char (character "["))
  (values [123])


  (readtablep *readtable*)
  (setq zvar 123)
  (set-syntax-from-char
   #\z #\'
   (setq table2 (copy-readtable)))

  (setq *readtable* table2)
  ;; zvar =>  VAR
  (setq *readtable* (copy-readtable nil))
  ;; zvar =>  123

  [ (cicada)

  ]

  ## cicada
  ## end cicada

  cicada.cicada
  cicada.iaa
  #+end_src
* -----------------------------------
* play
  #+begin_src lisp
  (asdf:load-system 'cicada-vm)
  (in-package :cicada-vm)
  (run-tests 'basic)
  (run-tests 'cicada-vm)
  #+end_src
* ===================================
