#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** [maybe] let modules be packages
** first version
   * without database of symbol usage
   * without resolving symbols
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  ;; new common-lisp hacker
  ;; please view module as directory
  ;;   which you can override by :pathname
  ;; and system as top-level directory
  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module "package-header"
              :components
              ((:file "package-header")))
     (:module "ytool"
              :components
              ((:file "ytool")))
     (:module "basic"
              :components
              ((:file "basic")))
     (:module "little-tester"
              :components
              ((:file "little-tester")))
     (:module "ytool.test" :pathname "ytool"
              :components
              ((:file "ytool.test"
                      :if-feature :with-little-test)))
     (:module "basic.test" :pathname "basic"
              :components
              ((:file "basic.test"
                      :if-feature :with-little-test)))
     (:module "cicada-rhapsody"
              :components
              ((:file "cicada-rhapsody")
               (:file "cicada-rhapsody.test"
                      :if-feature :with-little-test)))
     (:module "architecture"
              :components
              ((:file "architecture")
               (:file "architecture.test"
                      :if-feature :with-little-test)))
     (:module "instruction-set"
              :components
              ((:file "instruction-set")
               (:file "instruction-set.test"
                      :if-feature :with-little-test)))
     (:module "compiler"
              :components
              ((:file "compiler")
               (:file "compiler.test"
                      :if-feature :with-little-test)))
     ;; (:module ghost-in-shell
     ;;          :components
     ;;          ((:file "ghost-in-shell")
     ;;           (:file "ghost-in-shell.test"
     ;;                  :if-feature :with-little-test)))
     ))
  #+end_src
* -----------------------------------
* test
** load-system & in-package & run-unit
   #+begin_src lisp
   (asdf:load-system :cicada-vm)

   (in-package :cicada-vm)
   (setf *print-pretty* t)

   (run-unit 'ytool)
   (run-unit 'basic)
   (run-unit 'cicada-rhapsody)
   (run-unit 'architecture)
   #+end_src
** ><
   #+begin_src lisp
   ;; this is the first primitive-instruction
   (define-primitive-instruction "primitive-function" "call"
       ;; ><><>< should do title check
       ;; 还有声明副作用的语法 如何
       ;; 比如 对 return-stack 的副作用
       (@ -- @)
     (with (fetch#cicada-image
            :address (add *cicada-object-size*
                          (with (tos#return-stack)
                            .value)))
       ;; this means only primitive-instruction is handled now
       (funcall (primitive-function->host-function .value))))

   ;; * the argument of a primitive-function
   ;;   should be fetched from the *argument-stack*
   ;; * in the lisp's sense
   ;;   the primitive-functions are all about side-effect
   (define-primitive-function "test" "kkk"
       (@ <fixnum>
          <fixnum>
          <fixnum> <::var1
          1        <::var2
          <title>  <::var3
          fixnum (title) <::var4
          --
          <fixnum> @)
     (cat (:to *standard-output*)
       ("kkk took what away?~%")))

   (save#cicada-image
    :address 0
    :title (string->title "primitive-instruction")
    :value (o "primitive-function" "call"))

   (save#cicada-image
    :address *cicada-object-size*
    :title (string->title "test")
    :value
    ;; (o "test" "kkk")
    (o "fixnum" "add1"))

   (push#argument-stack
    :title (string->title "fixnum")
    :value 0)

   (push#return-stack
    :title (string->title "nevermind")
    :value 0)

   (execute-next-instruction)

   (print#primitive-instruction-table)
   (print#primitive-function-table)

   (list (with (tos#argument-stack)
           .value)
         (with (tos#argument-stack)
           .title))
   #+end_src
* ===================================
