#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
** [how] reduce dup code by better abstraction
** [maybe] to find a better hash function
** interface to cicada image buffer
** type check of function
   * load-file
     the argument :file should be of path type
** about io
   * 總應該使用 record 來記錄 io
     record 是可以被作爲一等公民處理的
   * record 應該可以被過濾
     設計數據結構的時候需要考慮這一點
   * 並且 record 的順序是極端重要的
   * 輸入設備所產生的 record
     將被作爲 消息 傳遞給 一個 底層的 loop
     這在於 repl 並應該在回車的時候執行代碼
     而應該有一個特殊的按鍵來控制代碼的執行
     如果以 每次鍵盤的擊鍵爲輸入的話
     repl 其實就是一個小型的文本編輯器了
** write image file
** vector-function
** the funciton (next)
** parsing image file
** cicada-rhapsody
** first version
   * without database of symbol usage
   * without resolving symbols
   * move let modules become packages
* ===================================
* system file
  #+begin_src lisp :tangle cicada-vm.asd
  (push :with-little-test *features*)

  ;; new common-lisp hacker
  ;; please view module as directory
  ;;   which you can override by :pathname
  ;; and system as top-level directory
  (defsystem :cicada-vm
    :description "virtual machine of cicada language"
    :author "XIE Yuheng <xyheme@gmail.com>"
    :depends-on ()
    :serial t
    :components
    ((:module "package-header"
              :components
              ((:file "package-header")))
     (:module "basic"
              :components
              ((:file "basic")))
     (:module "little-tester"
              :components
              ((:file "little-tester")))
     (:module "basic.test" :pathname "basic"
              :components
              ((:file "basic.test"
                      :if-feature :with-little-test)))
     (:module "cicada-rhapsody"
              :components
              ((:file "cicada-rhapsody")
               (:file "cicada-rhapsody.test"
                      :if-feature :with-little-test)))
     ;; (:module ghost-in-shell
     ;;          :components
     ;;          ((:file "ghost-in-shell")
     ;;           (:file "ghost-in-shell.test"
     ;;                  :if-feature :with-little-test)))
     (:file "cicada-vm")
     (:file "cicada-vm.test"
            :if-feature :with-little-test)
     ))
  #+end_src
* ===================================
* note
** cicada vm
   * cicada vm is
     a threaded-code interpreter
     with a hash-table of string which is called name-table
   * the way used to implement
     a forth inner interpreter in assembly language
     is used to design this vm
   * it will be easy to implement this vm in both
     low-level language as assembly
     and high-level language as common-lisp
   * an image file is as an executable [linkable] format
   * when a image file is loaded to *cicada-image-buffer*
     host language can provide many run-time supports
     but run-time independent compile must be supported too
   * when compiling to cicada language to image file
     the compiler maintains a database of symbol-address binding
     the database records all the use of every symbol
     the database helps one to
     NOT care about the encoding of instruction and title
   * value of symbol
     need to be updated
     address of primitive-function and primitive-instruction
     need to be updated
   * when vm interpreting image file
     it reads the database first
     and resolves the symbol in the image file
     meanwhile updating the database
     only after then
     the vm can begin interpreting the image file
** number theory and hash function
   * 也許 hash function 可以動態地改變自己
     例如
     需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
* -----------------------------------
* file header
** cicada-vm.lisp
   #+begin_src lisp :tangle cicada-vm.lisp
   (in-package :cicada-vm)
   #+end_src
** cicada-vm.test.lisp
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (in-package :cicada-vm)
   #+end_src
* -----------------------------------
* cicada-object
** ----------------------------------
** note cicada-object
   * cicada-object only exist in cicada-object-vector
     for example *return-stack*
** cell-unit
   * a cell is of *cell-unit* many bytes
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cell-unit* (/ *size#fixnum* 8)) ;; unit byte
   #+end_src
** ----------------------------------
** cicada-object-vector?
   * an object is two cell
     one for title (an index into title-table)
     one for value (of which the meaning is depended on its title)
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *cicada-object-size*
     (* 2 *cell-unit*))

   (defun cicada-object-vector? (cicada-object-vector)
     (and (equal? '(unsigned-byte 8)
                  (array-element-type cicada-object-vector))
          (zero? (mod (length cicada-object-vector)
                      ,*cicada-object-size*))))
   #+end_src
** ----------------------------------
** [save|fetch]#[title|value]#cicada-object-vector
   * index
     into byte-vector
     element size *cicada-object-size*
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun save#title#cicada-object-vector
       (&key
          title
          cicada-object-vector
          index)
     (save#byte-vector :value title
                       :byte-vector cicada-object-vector
                       :size *cell-unit*
                       :index (mul *cicada-object-size*
                                   index)))

   (defun save#value#cicada-object-vector
       (&key
          value
          cicada-object-vector
          index)
     (save#byte-vector :value value
                       :byte-vector cicada-object-vector
                       :size *cell-unit*
                       :index (add *cell-unit*
                                   (mul *cicada-object-size*
                                        index))))


   (defun fetch#title#cicada-object-vector
       (&key
          cicada-object-vector
          index)
     (fetch#byte-vector :byte-vector cicada-object-vector
                        :size *cell-unit*
                        :index (mul *cicada-object-size*
                                    index)))

   (defun fetch#value#cicada-object-vector
       (&key
          cicada-object-vector
          index)
     (fetch#byte-vector :byte-vector cicada-object-vector
                        :size *cell-unit*
                        :index (add *cell-unit*
                                    (mul *cicada-object-size*
                                         index))))
   #+end_src
** ----------------------------------
** cicada-object-pointer?
** ----------------------------------
* title.name-table
** ----------------------------------
** note title
   * every object have a title
     title is the way I used to manage nameing of things
     a title could be viewed as
     a type
     a module
     a structure
   * a title is a index into title.name-table
     the index is used as the encoding of that title
     there is only one title.name-table
     so the encoding works will
   * the interface is as
     * <title
       <name
       <object
       (be)
       <field
       <update?
     * <title
       <name
       (ask)
       <object
       <find?
** ----------------------------------
** title-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#title.name-table* 1000)

   (defparameter *size#entry#title.name-table* 100)

   (defparameter *title.name-table*
     ;; should be a byte-vector in assembly version
     (make-array
      `(,*size#title.name-table* ,*size#entry#title.name-table*)
      ;; note that
      ;; this table's element can be of any type
      ;; but actually
      ;; (i 0) must be an name[index] to name-hash-table
      ;; (i n) must be a vector of
      ;; #( name[index] title[index] value )
      :initial-element 0))

   ;; the first entry of *title.name-table* reserved
   ;; for *name-hash-table*
   ;; to test if a name in *name-hash-table*
   ;; is used as title or not
   (defparameter *pointer#title.name-table* 1)
   #+end_src
** title?
   * index-within-title.name-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title? (index)
     (and (natural-number? index)
          (< index *size#title.name-table*)))
   #+end_src
** ----------------------------------
** string->title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->title (string)
     (let* ((name (string->name string))
            (index-for-title
             (fetch#vector :vector *name-hash-table#index-for-title*
                           :index name)))
       (cond
         ;; find-old
         ((not (zero? index-for-title))
          index-for-title)

         ;; creat-new
         ((< *pointer#title.name-table*
             ,*size#title.name-table*)
          ;; now
          ;; *pointer#title.name-table* is pointing to
          ;; the next free to use index
          ;; in the *title.name-table*

          ;; save title[index] to *name-hash-table#index-for-title*
          (save#vector :value *pointer#title.name-table*
                       :vector *name-hash-table#index-for-title*
                       :index name)

          ;; save name[index] to *title.name-table*
          (save#array :value name
                      :array *title.name-table*
                      :index-vector (vector *pointer#title.name-table* 0))

          ;; to update *pointer#title.name-table*
          ;; is to allocate a new index in the *title.name-table*
          (add1! *pointer#title.name-table*)

          ;; return value
          (sub1 *pointer#title.name-table*))

         (:else
          (error (cat ()
                   ("title.name-table is filled~%")
                   ("(string->title) can not make new title~%")))))))
   #+end_src
** title->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->name (title)
     (if (not (title? title))
         (error "the argument of (title->name) must be a title")
         (fetch#array
          :array *title.name-table*
          :index-vector
          (vector title 0))))
   #+end_src
** title->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun title->string (title)
     (if (not (title? title))
         (error "the argument of (title->string) must be a title")
         (name->string (title->name title))))
   #+end_src
** print#title
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#title (title &key (stream t))
     (if (not (title? title))
         (error "the argument of (print#title) must be a title")
         (print#name (title->name title)
                     :stream stream)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest print#title
       (cicada-vm)
     (ensure
         (print#title (string->title "kkk")
                      :stream nil)
         ==>
         "kkk"))
   #+end_src
** ----------------------------------
** map[#entry]#title.name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#title.name-table
       (&key
          function
          (title 1)
          (base-list '()))
     (cond ((not (< title *pointer#title.name-table*))
            base-list)
           (:else
            (cons (funcall function :title title)
                  (map#title.name-table :function function
                                        :title (add1 title)
                                        :base-list base-list)))))

   (defun map#entry#title.name-table
       (&key
          title
          function
          (field 1)
          (base-list '()))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title ,field))))
       (cond ((not (vector? content-of-field))
              base-list)
             (:else
              (cons (funcall function
                      :name (fetch#vector
                             :vector content-of-field
                             :index 0)
                      :title#object (fetch#vector
                                     :vector content-of-field
                                     :index 1)
                      :value#object (fetch#vector
                                     :vector content-of-field
                                     :index 2))
                    (map#entry#title.name-table :title title
                                                :function function
                                                :field (add1 field)
                                                :base-list base-list))))))
   #+end_src
** print#title.name-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; can NOT return a string when :to == nil

   (defun print#title.name-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* title.name-table")
       ("  |------------+--------|")
       ("  | size       | ~6D |" *size#title.name-table*)
       ("  | size#entry | ~6D |" *size#entry#title.name-table*)
       ("  | title      | ~6D |" (sub1 *pointer#title.name-table*))
       ("  |------------+--------|"))
     (map#title.name-table
      :function
      (lambda (&key
                 title)
        (cat (:to to
                  :postfix (cat () ("~%")))
          ("  * ~A" (title->string title)))
        (map#entry#title.name-table
         :title title
         :function
         (lambda (&key
                    name
                    title#object
                    value#object)
           (cat (:to to
                     :postfix (cat () ("~%")))
             ("    * ~A" (name->string name))
             ("      ~A ~A" (title->string title#object) value#object)))))))

   ;; (be :title (string->title "k1")
   ;;     :name (string->name "took1")
   ;;     :title#object (string->title "my1")
   ;;     :value#object 666)
   ;; (be :title (string->title "k1")
   ;;     :name (string->name "took2")
   ;;     :title#object (string->title "my2")
   ;;     :value#object 666)
   ;; (print#title.name-table)
   #+end_src
** ----------------------------------
** be
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin be
     .field ;; index
     .update?)
   (defun be
       (&key
          title
          name
          title#object
          value#object)
     (cond
       ((not (title? title))
        (error "the argument :title of (be) must be a title"))
       ((not (name? name))
        (error "the argument :name of (be) must be a name"))
       ((not (title? title#object))
        (error "the argument :title#object of (be) must be a title"))
       (:else
        (help#be
         :title title
         :name name
         :title#object title#object
         :value#object value#object))))


   (defun help#be
       (&key
          title
          name
          title#object
          value#object
          (field 1))
     (let ((content-of-field
            (fetch#array
             :array *title.name-table*
             :index-vector `#(,title ,field))))
       (cond
         ;; creat new
         ((zero? content-of-field)
          (save#array
           :value (vector name
                          title#object
                          value#object)
           :array *title.name-table*
           :index-vector `#(,title ,field))
          (values field
                  nil))
         ;; update
         ((equal? name
                  (fetch#vector
                   :vector content-of-field
                   :index 0))
          (save#array
           :value (vector name
                          title#object
                          value#object)
           :array *title.name-table*
           :index-vector `#(,title ,field))
          (values field
                  :updated!!!))
         ;; next
         ((< field *size#entry#title.name-table*)
          (help#be :title title
                   :name name
                   :title#object title#object
                   :value#object value#object
                   :field (add1 field)))
         ;; filled
         (:else
          (error "the names under this title is too filled (be) can not do")))))
   #+end_src
** ask
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin ask
     .title
     .value
     .found?)
   (defun ask
       (&key
          title
          name)
     (cond ((not (title? title))
            (error "the argument :title of (ask) must be a title"))
           ((not (name? name))
            (error "the argument :name of (ask) must be a name"))
           (:else
            (help#ask :title title
                      :name name))))

   (defun help#ask
       (&key
          title
          name
          (field 1))
     (let ((content-of-field
            (fetch#array :array *title.name-table*
                         :index-vector `#(,title ,field))))
       (cond
         ;; not found
         ((zero? content-of-field)
          (values 0
                  0
                  nil))
         ;; found
         ((equal? name
                  (fetch#vector :vector content-of-field
                                :index 0))
          (let ((vector#name-title-value
                 (fetch#array :array *title.name-table*
                              :index-vector `#(,title ,field))))
            (values (fetch#vector :vector vector#name-title-value
                                  :index 1)
                    (fetch#vector :vector vector#name-title-value
                                  :index 2)
                    :found!!!)))
         ;; next
         ((< field *size#entry#title.name-table*)
          (help#ask :title title
                    :name name
                    :field (add1 field)))
         ;; filled
         (:else
          (error (cat ()
                   ("can not ask for the object under the name as you wish~%")
                   ("and the names under this title is too filled")))))))
   #+end_src
** o
   * o let the .value be the main return value
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin o
     .value
     .title
     .found?)

   (defun o (title-string name-string)
     (with (ask :title (string->title title-string)
                :name (string->name name-string))
           (values .value
                   .title
                   .found?)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest be--and--ask
       (cicada-vm)
     (ensure
         (list (be :title (string->title "kkk")
                   :name (string->name "took")
                   :title#object (string->title "my")
                   :value#object 666)
               (with (be :title (string->title "kkk")
                         :name (string->name "took")
                         :title#object (string->title "my")
                         :value#object 666)
                 (list .field .update?))
               (with (ask :title (string->title "kkk")
                          :name (string->name "took"))
                     (list .title .value .found?)))
         ==>
         `(1

           (1
            :UPDATED!!!)

           (,(string->title "my")
             666
             :FOUND!!!)

           )))
    #+end_src
** ----------------------------------
* name-hash-table
** ----------------------------------
** note name
   * not name value binding in name-hash-table
     name-hash-table is used to
     1. provide the name datatype
     2. implement title.name-table
   * binding will be done in title.name-table
     an object [value with title]
     will be bound to a title name pair
** ----------------------------------
** name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-hash-table* 100333)

   (defparameter *name-hash-table#string*
     (make#vector
      :length *size#name-hash-table*
      :initial-element 0))

   ;; to reverse index 0
   ;; the first entry of *name-hash-table* is reserved
   ;; for *title.name-table*
   ;; to test if a title name pair in *title.name-table*
   ;; is bound to any object or not
   (save#vector :value ""
                :vector *name-hash-table#string*
                :index 0)

   (defparameter *name-hash-table#index-for-title*
     (make#vector
      :length *size#name-hash-table*
      :element-type `(integer 0 ,*size#title.name-table*)
      :initial-element 0))

   (defparameter *name-hash-table#name-counter* 0)
   #+end_src
** name?
   * index-within-name-hash-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name? (index)
     (and (natural-number? index)
          (< index *size#name-hash-table*)))
   #+end_src
** ----------------------------------
** string->natural-number
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest string->natural-number
       (cicada-vm)
     (ensure
         (list (string->natural-number "")
               (string->natural-number "@")
               (string->natural-number "@@@"))
         ==>
         (list 0
               64
               448)))
   #+end_src
** ----------------------------------
** string->name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun string->name (string)
     (help#string->name#find-old-or-creat-new
      :string string
      :index (mod (string->natural-number string)
                  ,*size#name-hash-table*)))

   (defun help#string->name#find-old-or-creat-new
       (&key
          string
          index
          (collision-level 0))
     (cond
       ;; creat-new
       ((not (name-hash-table-index#used? index))
        (help#string->name#creat-new
         :string string
         :index index
         :collision-level collision-level)
        index)
       ;; find-old
       ((equal? string
                (fetch#vector
                 :vector *name-hash-table#string*
                 :index index))
        index)
       ;; collision
       (:else
        (help#string->name#find-old-or-creat-new
         :string string
         :index (name-hash-table-index#next :index index)
         :collision-level (add1 collision-level)))
       ))

   (defun name-hash-table-index#used? (index)
     (not (zero? (fetch#vector
                  :vector *name-hash-table#string*
                  :index index))))

   (defun name-hash-table-index#as-title? (index)
     (and (name-hash-table-index#used? index)
          (not (zero? (fetch#vector
                       :vector *name-hash-table#index-for-title*
                       :index index)))))

   (defparameter *name-hash-table#collision-record* '())

   (defun help#string->name#creat-new
       (&key
          string
          index
          collision-level)
     (add1! *name-hash-table#name-counter*)
     (if (not (zero? collision-level))
         (push (list :collision-level collision-level
                     :string string
                     :index index)
               ,*name-hash-table#collision-record*))
     (save#vector
      :value string
      :vector *name-hash-table#string*
      :index index))

   (defun name-hash-table-index#next
       (&key index)
     (if (= index *size#name-hash-table*)
         0
         (add1 index)))
   #+end_src
** name->string
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun name->string (name)
     (if (not (name? name))
         (error "the argument of (name->string) must be a name")
         (cond ((not (name-hash-table-index#used? name))
                (error "this name does not have a string"))
               (:else
                (fetch#vector :vector *name-hash-table#string*
                              :index name))
               )))
   #+end_src
** print#name
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#name (name
                      &key (stream t))
     (format stream
             "~A"
             (name->string name)))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest name->string
       (cicada-vm)
     (ensure
         (name->string (string->name "kkk took my baby away!"))
         ==>
         "kkk took my baby away!"))

   (deftest print#name
       (cicada-vm)
     (ensure
         (print#name (string->name "kkk took my baby away!")
                     :stream nil)
         ==>
         "kkk took my baby away!"))
   #+end_src
** ----------------------------------
** map#name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#name-hash-table
       (&key
          function
          (name 1)
          (base-list '()))
     (cond ((not (< name *size#name-hash-table*))
            base-list)
           ((not (name-hash-table-index#used? name))
            (map#name-hash-table :function function
                                 :name (add1 name)
                                 :base-list base-list))
           (:else
            (cons (funcall function :name name)
                  (map#name-hash-table :function function
                                       :name (add1 name)
                                       :base-list base-list)))))

   ;; (map#name-hash-table
   ;;  :function
   ;;  (lambda (&key name)
   ;;    (name->string name)))
   #+end_src
** print#name-hash-table
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; can NOT return a string when :to == nil

   (defun print#name-hash-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* name-hash-table")
       ("  |-----------+--------|")
       ("  | size      | ~6D |" *size#name-hash-table*)
       ("  | name      | ~6D |" *name-hash-table#name-counter*)
       ("  | collision | ~6D |" (length *name-hash-table#collision-record*))
       ("  |-----------+--------|"))
     (map#name-hash-table
      :function
      (lambda (&key name)
        (cat (:to to)
          ("  * ~A " (name->string name)))
        (cond
          ((name-hash-table-index#as-title? name)
           (cat (:to to)
             (" [as title] "))))
        (let ((collision-record-entry
               (find#record :index name
                            ,*name-hash-table#collision-record*)))
          (cond ((not (nil? collision-record-entry))
                 (destructuring-bind
                       (&key collision-level
                             string
                             index)
                     collision-record-entry
                   (cat (:to to)
                     (" [collision-level: ~A]" collision-level))))))
        (cat (:to to) ("~%")))))
   #+end_src
** ----------------------------------
* cicada-image
** ----------------------------------
** note
   * 這裏的設計可以非常豐富
** ----------------------------------
** the cicada-image
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#cicada-image-buffer* 16)

   (setf (logical-pathname-translations "cicada")
         `(("**;*.*" "home:.cicada;**;*.*")))

   (defparameter *cicada-image-filename* "cicada:test.cicada-image")

   (defparameter *cicada-image*
     (make#vector :length (mul *size#cicada-image-buffer* *cicada-object-size*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   (defparameter *pointer#cicada-image-buffer* 0)
   #+end_src
** fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch-byte#cicada-image (&key address)
     (fetch#byte-vector :byte-vector *cicada-image*
                        :size 1
                        :index address))

   (defun save-byte#cicada-image (&key address byte)
     (save#byte-vector :value byte
                       :byte-vector *cicada-image*
                       :size 1
                       :index address))

   (defin fetch#cicada-image
     .title .value)
   (defun fetch#cicada-image (&key address)
     (values (fetch#byte-vector :byte-vector *cicada-image*
                                :size *cell-unit*
                                :index address)
             (fetch#byte-vector :byte-vector *cicada-image*
                                :size *cell-unit*
                                :index (add *cell-unit*
                                            address))))

   (defun save#cicada-image (&key address title value)
     (save#byte-vector :value title
                       :byte-vector *cicada-image*
                       :size *cell-unit*
                       :index address)
     (save#byte-vector :value value
                       :byte-vector *cicada-image*
                       :size *cell-unit*
                       :index (add *cell-unit*
                                   address)))
   #+end_src
** ----------------------------------
** load cicada-image
   #+begin_src lisp :tangle cicada-vm.lisp
   (progn
     (setf stream
           (open *cicada-image-filename*
                 :direction :output
                 :if-exists :supersede))
     (format stream "cicada test~%")
     (close stream))


   (file->buffer :filename *cicada-image-filename*
                 :buffer *cicada-image*)
   #+end_src
** ----------------------------------
* >< vector-function
** ----------------------------------
** note
** ----------------------------------
** >< fetch & save
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun fetch#vector-function-body ())
   (defun save#vector-function-body ())
   #+end_src
** ----------------------------------
* return-stack
** ----------------------------------
** note
   * return-stack is a stack of pointers
     a pointer points into a (one type of) function-body
   * the pointer on the top of return-stack
     always points into next instruction
   * it is the vary callers
     that are moving the pointer
     which on the top of return-stack
     to the next instruction in a function-body
   * it is the vary callers
     that are pushing or popping the return-stack
   * primitive-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
     3. at the end
        the celler will try to return to next instruction
   * vector-function
     1. at the begin
        the caller will move
        the pointer on the top of return-stack
        to the next instruction in a function-body
     2. during
        push a new pointer to the return-stack
     3. at the end
        the celler will try to return to next instruction
   * I will let all this things be done by the instructions
     the machine knows nothing about how to do
     it calls instructions and let instruction do
     the machine only knows next next next
   * an instruction is an object with its title (of course)
   * the things that saved into the return-stack
     are will titled pointer objects (of course)
     a pointer into a function-body
     shoud contain the function-body and an index
   * vector-function 這個 title 下
     有能夠造
     具有 vector-function-body-pointer 這個 title
     的數據
     的函數
     而 vector-function-body-pointer 這個 title 下
     有處理這個數據類型
     的函數
** ----------------------------------
** the return-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#return-stack* 1024)

   (defparameter *return-stack*
     (make#vector :length (mul *cicada-object-size* *size#return-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *return-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#return-stack* 0)
   #+end_src
** push#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#return-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the argument :title of (push#return-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#return-stack*
                     ,*cicada-object-size*)
                ,*size#return-stack*))
        (error "can not push anymore *return-stack* is filled"))
       ;; side-effect
       ;; *pointer#return-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *return-stack*
               :index *pointer#return-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *return-stack*
               :index *pointer#return-stack*)
              (add1! *pointer#return-stack*)
              ;; return current-pointer
              ,*pointer#return-stack*)))
   #+end_src
** pop#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#return-stack
     .title
     .value
     .current-pointer)
   (defun pop#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error (cat ()
                 ("when calling (pop#return-stack)~%")
                 ("the *return-stack* must NOT be empty"))))
       (:else
        (sub1! *pointer#return-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index *pointer#return-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index *pointer#return-stack*)
                ,*pointer#return-stack*))))
   #+end_src
** tos#return-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; TOS denotes top of stack
   (defin tos#return-stack
     .title
     .value
     .current-pointer)
   (defun tos#return-stack ()
     (cond
       ((zero? *pointer#return-stack*)
        (error (cat ()
                 ("when calling (tos#return-stack)~%")
                 ("the *return-stack* must NOT be empty"))))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index (sub1 *pointer#return-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *return-stack*
                 :index (sub1 *pointer#return-stack*))
                (sub1 *pointer#return-stack*)))))
   #+end_src
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest return-stack
       (cicada-vm)
     (ensure
         (list (push#return-stack
                :title (string->title "return-stack--push--test#1")
                :value 147)

               (push#return-stack
                :title (string->title "return-stack--push--test#2")
                :value 258)

               (push#return-stack
                :title (string->title "return-stack--push--test#3")
                :value 369)

               (with (tos#return-stack)
                 .value)
               (with (pop#return-stack)
                 .value)

               (with (tos#return-stack)
                 .value)
               (with (pop#return-stack)
                 .value)

               (with (tos#return-stack)
                 .value)
               (with (pop#return-stack)
                 .value))
         ==>
         (list 1
               2
               3

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
** execute-next-instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; note that:
   ;; this function defines the interface of primitive-instruction
   ;; as:
   ;; 1. (<primitive-instruction> :title :value )
   ;;    the return-stack will likely be updated by primitive-instruction
   ;; 2. at the end of <primitive-instruction>
   ;;    the (execute-next-instruction) will likely be called again
   ;; [compare this to real CPU to understand it]

   (defun execute-next-instruction ()
     (let* ((address#vector-function-body
             (with (tos#return-stack)
               .value))
            (primitive-instruction
             ;; this means only primitive-instruction is handled now
             (with (fetch#cicada-image
                    :address address#vector-function-body)
               .value)))
       (with (fetch#cicada-image
              :address (add *cicada-object-size*
                            address#vector-function-body))
         (funcall (primitive-instruction->host-function primitive-instruction)
                  :title .title
                  :value .value))))
   #+end_src
** ----------------------------------
** >< [maybe] address#in-vector-function-body
** ----------------------------------
* primitive-instruction
** ----------------------------------
** note
   * 用 table 來實現
     primitive-instruction 這個數據結構
     除了找到 primitive-instruction 本身在 host language 中的位置以外
     我還可以增加別的數據域
   * primitive-instruction 的製作
     與 用 (be) 給它命名是分開的
     單單在 host-language 中製作一個 primitive-instruction
     會在 *primitive-instruction-table* 中申請一個位置
     [接口函數是 make-primitive-instruction]
     所申請的位置的 index 就被爲是 primitive-instruction 的值
     而需要的時候 (be) 會給這個 index 一個名字
   * re-define a primitive-instruction
     will not cover the old one
     just re-bind the title.name
     if the old one is compiled into some function body
     it will still use the old one
     [this is the nature of forth]
** the primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-instruction-table* 1000)

   (defparameter *primitive-instruction-table*
     (make#vector
      :length *size#primitive-instruction-table*
      :initial-element 'function))

   (defparameter *primitive-instruction-table#title*
     (make#vector
      :length *size#primitive-instruction-table*
      :initial-element `(integer 0 ,*size#title.name-table*)))

   (defparameter *primitive-instruction-table#name*
     (make#vector
      :length *size#primitive-instruction-table*
      :initial-element `(integer 0 ,*size#name-hash-table*)))

   (defparameter *pointer#primitive-instruction-table* 1)
   #+end_src
** primitive-instruction?
   * index-within-primitive-instruction-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-instruction? (index)
     (and (natural-number? index)
          (< index *size#primitive-instruction-table*)))
   #+end_src
** define-primitive-instruction
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *title#primitive-instruction*
     (string->title "primitive-instruction"))

   (defmacro define-primitive-instruction
       (title-string
        name-string
        &body body)
     `(let ((title (string->title ,title-string))
            (name (string->name ,name-string)))
        (be :title title
            :name name
            :title#object *title#primitive-instruction*
            :value#object
            (let ((host-funciton
                   (lambda (&key title value)
                     ,@body)))
              (cond
                ((< *pointer#primitive-instruction-table*
                    ,*size#primitive-instruction-table*)
                 (save#vector
                  :value host-funciton
                  :vector *primitive-instruction-table*
                  :index *pointer#primitive-instruction-table*)
                 (save#vector
                  :value title
                  :vector *primitive-instruction-table#title*
                  :index *pointer#primitive-instruction-table*)
                 (save#vector
                  :value name
                  :vector *primitive-instruction-table#name*
                  :index *pointer#primitive-instruction-table*)
                 (add1! *pointer#primitive-instruction-table*)
                 ;; return the old pointer [the index]
                 (sub1 *pointer#primitive-instruction-table*))
                (:else
                 (error (cat ()
                          ("when using (define-primitive-instruction)~%")
                          ("the *primitive-instruction-table* must NOT be filled")))))))))
   #+end_src
** primitive-instruction->host-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-instruction->host-function (primitive-instruction)
     (let ((host-function
            (fetch#vector :vector *primitive-instruction-table*
                          :index primitive-instruction)))
       (if (not (function? host-function))
           (error (cat ()
                    ("from an instruction[index]~%")
                    ("(primitive-instruction->host-function) can not find any host-function")))
           host-function)))

   ;; (defun primitive-instruction->host-function (primitive-instruction)
   ;;   (fetch#vector :vector *primitive-instruction-table*
   ;;                 :index primitive-instruction))
   #+end_src
** ----------------------------------
** map#primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#primitive-instruction-table
       (&key
          function
          (primitive-instruction 1)
          (base-list '()))
     (cond ((not (< primitive-instruction
                    ,*pointer#primitive-instruction-table*))
            base-list)
           (:else
            (cons (funcall function
                    :title (fetch#vector
                            :vector *primitive-instruction-table#title*
                            :index primitive-instruction)
                    :name (fetch#vector
                            :vector *primitive-instruction-table#name*
                            :index primitive-instruction)
                    :primitive-instruction primitive-instruction)
                  (map#primitive-instruction-table
                   :function function
                   :primitive-instruction (add1 primitive-instruction)
                   :base-list base-list)))))
   #+end_src
** print#primitive-instruction-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#primitive-instruction-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* primitive-instruction-table")
       ("  |-------------+--------|")
       ("  | size        | ~6D |" *size#primitive-instruction-table*)
       ("  | instruction | ~6D |" (sub1 *pointer#primitive-instruction-table*))
       ("  |-------------+--------|"))
     (map#primitive-instruction-table
      :function
      (lambda (&key title name primitive-instruction)
        (cat (:to to
                  :postfix (cat () ("~%")))
          ("  * ~A ~A"
           (title->string title)
           (name->string name))))))
   #+end_src
** ----------------------------------
* primitive-function
** ----------------------------------
** the primitive-function-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#primitive-function-table* 1000)

   (defparameter *primitive-function-table*
     (make#vector
      :length *size#primitive-function-table*
      :initial-element 'function))

   (defparameter *primitive-function-table#title*
     (make#vector
      :length *size#primitive-function-table*
      :initial-element `(integer 0 ,*size#title.name-table*)))

   (defparameter *primitive-function-table#name*
     (make#vector
      :length *size#primitive-function-table*
      :initial-element `(integer 0 ,*size#name-hash-table*)))

   (defparameter *pointer#primitive-function-table* 1)
   #+end_src
** primitive-function?
   * index-within-primitive-function-table?
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-function? (index)
     (and (natural-number? index)
          (< index *size#primitive-function-table*)))
   #+end_src
** define-primitive-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *title#primitive-function*
     (string->title "primitive-function"))

   (defmacro define-primitive-function
       (title-string
        name-string
        &body body)
     `(let ((title (string->title ,title-string))
            (name (string->name ,name-string)))
        (be :title title
            :name name
            :title#object *title#primitive-function*
            :value#object
            (let ((host-funciton
                   (lambda ()
                     ,@body)))
              (cond
                ((< *pointer#primitive-function-table*
                    ,*size#primitive-function-table*)
                 (save#vector
                  :value host-funciton
                  :vector *primitive-function-table*
                  :index *pointer#primitive-function-table*)
                 (save#vector
                  :value title
                  :vector *primitive-function-table#title*
                  :index *pointer#primitive-function-table*)
                 (save#vector
                  :value name
                  :vector *primitive-function-table#name*
                  :index *pointer#primitive-function-table*)
                 (add1! *pointer#primitive-function-table*)
                 ;; return the old pointer [the index]
                 (sub1 *pointer#primitive-function-table*))
                (:else
                 (error (cat ()
                          ("when using (define-primitive-function)~%")
                          ("the *primitive-function-table* must NOT be filled")))))))))
   #+end_src
** primitive-function->host-function
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun primitive-function->host-function (primitive-function)
     (let ((host-function
            (fetch#vector :vector *primitive-function-table*
                          :index primitive-function)))
       (if (not (function? host-function))
           (error (cat ()
                    ("from an function[index]~%")
                    ("(primitive-function->host-function) can not find any host-function")))
           host-function)))

   ;; (defun primitive-function->host-function (primitive-function)
   ;;   (fetch#vector :vector *primitive-function-table*
   ;;                 :index primitive-function))
   #+end_src
** ----------------------------------
** map#primitive-function-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun map#primitive-function-table
       (&key
          function
          (primitive-function 1)
          (base-list '()))
     (cond ((not (< primitive-function
                    ,*pointer#primitive-function-table*))
            base-list)
           (:else
            (cons (funcall function
                    :title (fetch#vector
                            :vector *primitive-function-table#title*
                            :index primitive-function)
                    :name (fetch#vector
                            :vector *primitive-function-table#name*
                            :index primitive-function)
                    :primitive-function primitive-function)
                  (map#primitive-function-table
                   :function function
                   :primitive-function (add1 primitive-function)
                   :base-list base-list)))))
   #+end_src
** print#primitive-function-table
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun print#primitive-function-table
       (&key
          (to *standard-output*))
     (cat (:to to
               :postfix (cat () ("~%")))
       ("* primitive-function-table")
       ("  |----------+--------|")
       ("  | size     | ~6D |" *size#primitive-function-table*)
       ("  | function | ~6D |" (sub1 *pointer#primitive-function-table*))
       ("  |----------+--------|"))
     (map#primitive-function-table
      :function
      (lambda (&key title name primitive-function)
        (cat (:to to
                  :postfix (cat () ("~%")))
          ("  * ~A ~A"
           (title->string title)
           (name->string name))))))
   #+end_src
** ----------------------------------
* argument-stack
** ----------------------------------
** the argument-stack
   * the following functions
     should be used like assembly macro
   #+begin_src lisp :tangle cicada-vm.lisp
   (defparameter *size#argument-stack* 1024)

   (defparameter *argument-stack*
     (make#vector :length (mul *cicada-object-size* *size#argument-stack*)
                  :element-type '(unsigned-byte 8)
                  :initial-element 0))

   ;; pointer is an index into *argument-stack*
   ;; one step of push pop is *cicada-object-size*
   (defparameter *pointer#argument-stack* 0)
   #+end_src
** push#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defun push#argument-stack
       (&key
          title
          value)
     (cond
       ;; type check
       ((not (title? title))
        (error "the argument :title of (push#argument-stack) must a title"))
       ;; filled
       ((not (< (mul *pointer#argument-stack*
                     ,*cicada-object-size*)
                ,*size#argument-stack*))
        (error "can not push anymore *argument-stack* is filled"))
       ;; side-effect
       ;; *pointer#argument-stack* is always
       ;; a free to use index into cicada-object-vector
       (:else (save#title#cicada-object-vector
               :title title
               :cicada-object-vector *argument-stack*
               :index *pointer#argument-stack*)
              (save#value#cicada-object-vector
               :value value
               :cicada-object-vector *argument-stack*
               :index *pointer#argument-stack*)
              (add1! *pointer#argument-stack*)
              ;; argument current-pointer
              ,*pointer#argument-stack*)))
   #+end_src
** pop#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   (defin pop#argument-stack
     .title
     .value
     .current-pointer)
   (defun pop#argument-stack ()
     (cond
       ((zero? *pointer#argument-stack*)
        (error (cat ()
                 ("when calling (pop#argument-stack)~%")
                 ("the *argument-stack* must NOT be empty"))))
       (:else
        (sub1! *pointer#argument-stack*)
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index *pointer#argument-stack*)
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index *pointer#argument-stack*)
                ,*pointer#argument-stack*))))
   #+end_src
** tos#argument-stack
   #+begin_src lisp :tangle cicada-vm.lisp
   ;; TOS denotes top of stack
   (defin tos#argument-stack
     .title
     .value
     .current-pointer)
   (defun tos#argument-stack ()
     (cond
       ((zero? *pointer#argument-stack*)
        (error (cat ()
                 ("when calling (tos#argument-stack)~%")
                 ("the *argument-stack* must NOT be empty"))))
       (:else
        (values (fetch#title#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index (sub1 *pointer#argument-stack*))
                (fetch#value#cicada-object-vector
                 :cicada-object-vector *argument-stack*
                 :index (sub1 *pointer#argument-stack*))
                (sub1 *pointer#argument-stack*)))))
   #+end_src
** ----------------------------------
** test
   #+begin_src lisp :tangle cicada-vm.test.lisp
   (deftest argument-stack
       (cicada-vm)
     (ensure
         (list (push#argument-stack
                :title (string->title "argument-stack--push--test#1")
                :value 147)

               (push#argument-stack
                :title (string->title "argument-stack--push--test#2")
                :value 258)

               (push#argument-stack
                :title (string->title "argument-stack--push--test#3")
                :value 369)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value)

               (with (tos#argument-stack)
                 .value)
               (with (pop#argument-stack)
                 .value))
         ==>
         (list 1
               2
               3

               369
               369

               258
               258

               147
               147)))
   #+end_src
** ----------------------------------
* >< frame-stack
* summary of tables
** ----------------------------------
** title.name-table
   * 二維
   * 語義爲姓名與物的綁定
   * 索引爲零的 第一行 不用
     索引即爲姓之編碼
   * 每行爲一姓 行首存姓作爲名之值
     (i 0) 存 (* name *)
   * 一行中存從此姓之名與物之綁定
     (i n) 存 (* name, object[title, value] *)
** name-hash-table
   * 一維
   * 語義爲名之編碼
     實現是字符串的散列函數
     即 字符串 到 上界爲某一素數的自然數集
     之間的假雙射
   * 索引爲零的 第一行 不用
     索引即爲名之編碼
   * 每一行有二值
     一爲字符串 一爲姓之索引
     如若被使用 則字符串爲所編碼的字符
     如若被用爲姓 則姓之索引之爲姓以此名爲名
** primitive-instruction-table
   * 一維
   * 語義爲指令集
   * 索引爲零的 第一行 不用
   * 每行一值 爲函數
** primitive-function-table
   * 一維
   * 語義爲原始函數集
   * 索引爲零的 第一行 不用
   * 每行一值 爲函數
** ----------------------------------
* >< [maybe] instruction-return-stack
** note
   * in cicada language
     you can extend the instruction set of the vm
   * in the body of the definition of your instruction
     when you call a cicada function
     it will not use the return-stack to record the return point
     but to use instruction-return-stack
* -----------------------------------
* >< let it be
* >< the story begin
* ===================================
* test
  #+begin_src lisp
  (asdf:load-system :cicada-vm)
  (in-package :cicada-vm)
  (setf *print-pretty* t)
  (run-unit 'basic)
  (run-unit 'cicada-rhapsody)
  (run-unit 'cicada-vm)


  ;; this is the first primitive-instruction
  (define-primitive-instruction
      "primitive-function"
      "call"
    ;; ><><>< should do title check
    (funcall (primitive-function->host-function value)))

  ;; * the argument of a primitive-function
  ;;   should be fetched from the *argument-stack*
  ;; * in the lisp's sense
  ;;   the primitive-functions are all about side-effect
  (define-primitive-function
      "test"
      "kkk"
    (cat (:to *standard-output*)
      ("kkk took what away?~%")))


  (save#cicada-image
   :address 0
   :title (string->title "primitive-instruction")
   :value (o "primitive-function" "call"))

  (save#cicada-image
   :address *cicada-object-size*
   :title (string->title "test")
   :value (o "test" "kkk"))

  (push#return-stack
   :title (string->title "nevermind")
   :value 0)

  (execute-next-instruction)

  (print#primitive-instruction-table)
  (print#primitive-function-table)
  #+end_src
* ===================================
