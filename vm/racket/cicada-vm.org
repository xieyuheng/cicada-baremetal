#+TITLE:  cicada vm
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* TODO
  * first version
    without parsing the image file
  * parse image file
* note
  * cicada vm is
    a threaded-code interpreter
    with a hash-table of string which is called name-table
  * the method used to implement
    a forth inner interpreter in assembly language
    is used to design this vm
  * it will be easy to implement this vm in both
    low-level language as assembly
    and high-level language as common-lisp
  * an image file is as an executable [linkable] format
* -----------------------------------
* name-table
** note
   * everything about name
     will be implemented by the name-table
   * a symbol is a index into name-table
     the interface is as
     symbol <name
     symbol <as
     (explain)
     for example
     one can explain a symbol as
     * type
     * string
     * instruction
   * 需要能夠聲明兩個 symbol 完全同一
     或它們的某個 域 同一
     這是爲了實現對多種人類語言的支持
     比如 英文 漢文 異體字
** the table
   #+begin_src scheme :tangle threaded-code-interpreter.rkt
   ;; must be a prime number

   ;; 1000003  ;; about 976 k
   ;; 1000033
   ;; 1000333
   ;; 100003   ;; about 97 k
   ;; 100333
   ;; 997
   ;; 499
   ;; 230      ;; for a special test

   (defparameter *size#name-table*
     100333)

   (defparameter *size#entry#name-table*
     100)

   (defparameter *name-table*
     (make-array
      (list *size#name-table* *size#entry#name-table*)
      :initial-element nil))
   #+end_src
** string->natural-number
   #+begin_src scheme :tangle threaded-code-interpreter.rkt
   (defparameter *max-carry-position* 22)

   (defun string->natural-number (string
                                  &key
                                    (counter 0)
                                    (sum 0))
     (if (string#empty? string)
         sum
         (multiple-value-bind
               (head#char
                tail#char
                string)
             (string->head#char string)
           (string->natural-number
            tail#char
            :counter (if (< counter *max-carry-position*)
                         (add1 counter)
                         0)
            :sum (+ sum
                    (shift#left
                     :step counter
                     :number (char->code head#char)))))))

   ;; (string->natural-number "")
   ;; (string->natural-number "@")
   ;; (string->natural-number "@@@")
   #+end_src
** natural-number->index
   #+begin_src scheme :tangle threaded-code-interpreter.rkt
   (defun natural-number->index (natural-number)
     (if (not (natural-number? natural-number))
         (error "argument of natural-number->index must be a natural-number")
         (mod natural-number *size#name-table*)))

   ;; (natural-number->index 0)
   ;; (natural-number->index 123)
   ;; (natural-number->index 123.123)
   #+end_src
** string->name name->string
   #+begin_src scheme :tangle threaded-code-interpreter.rkt
   (defun name? (x)
     (and (array? x)
          (= 1 (array-rank x))
          (= 2 (array-dimension x
                                0))
          (equal :<name>
                 (aref x
                       0))))

   (name? #(:<name> "123"))

   (defun print-name (name
                      &key (stream t))
     (format stream
             "#name: ~A"
             '><))


   (defun help#string->symbol#find-old-or-creat-new
       ())

   (defun string->name (string)
     (let ((index
            (natural-number->index
             (string->natural-number string))))
       ()
       ))


   (defun symbol->string (index)
     ())
   #+end_src
* threaded-code interpreter
** note
   * 只有 對 threaded-code 的解釋 內置在虛擬機中的
     也就是說
     這裏需要處理的 structure 有
     1. primitive-function
     2. vector-function
     3. return-stack
     4. argument-stack
     5. frame-stack
        也就是說專門有一個 stack
        專注於約束變元
        而 argument-stack 還是以 古典的 forth 的方式工作
   * 其實這些 stack 是爲了 完成函數調用語義 而設計的
     那麼這裏就遇到了
     用 小的 structure
     組成 大的 structure 的問題
     但是 在實現 threaded-code interpreter 的時候
     還不能使用 structure 的機制
     因爲這個機制還沒實現呢
     儘管
     之後
     這些處理函數都會被暴露出來
** ><
   #+begin_src scheme :tangle threaded-code-interpreter.rkt

   #+end_src
* -----------------------------------
* test
  #+begin_src lisp
  (progn

    (asdf:load-system 'threaded-code-interpreter)
    (in-package :threaded-code-interpreter)

    )
  #+end_src

