#+TITLE:  組合子記 / note on combinator
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com


* TODO
  * 文日進 而常改
  * 明確代碼之形式變換
  * 明確語圖之形式變換
  * 明確運算律
  * 嘗試形成一種新的比喻
    * 是否應該
      直接使用 組合子 這個名字
      然後具體的描述其行爲
      而讓讀者自己想像其比喻呢
    * 使用可以相互結合的精靈來比喻嗎
    * 用細胞來比喻嗎
* 題記
  * 內容來自 老頑童 smullyan 之組合子問答集
    但是我並不用鳥來做比喻了
    鳥的比喻中只有 函數作用 這一種操作
    限制操作方式
    對於研究空間的整體性質是有價值的
    但是對於設計一般性的語言而言
    則沒有一點兒好處
  * 在下文中
    稱 組合子之空間
    爲 組合子之林
    以紀念 smullyan 的比喻
  * 所以
    以明顯的方式用棧
    追求理解的簡單性和具體性
    只要有形式上的運算律
    就能夠對代碼進行變換
    而不再追求形式上的單純性
  * 將獲得的最重要的特點是
    [比諸 lambda-calculus[木答演算]]
    計算的順序是被明指
    等號 在木答演算中的意義是無向路
    而這裏
    必須避免對這種迷失方向的無向路之使用
* 序
  * 皖有頑童 其名爲恆
  * 小寫字母以表之無類
    大寫字母或中文以表之有類
  * 命名依組合子的行爲
    而 蟬語[或 lambda-calculus] 中
    對約束變元的命名是爲了標記
    以描述函數體的內部結構
* 引
  * 首先注意這裏所有的組合子都是一元化的[即 curry]
    也就是說這裏所展示的
    只是蟬語的一個簡單部分而已
  * 其 一元化 提示人們
    當看到一個組合子
    在蟬語的語法下所形成的表達式的時候
    兩個重要的觀察是
    1. 看它能否 返回 一個單一的值
    2. 看它是否要 作用於 一個單一的值
  * 需處理的數據類型有
    * 符號
    * 無名組合子
  * 對數據類型的操作如下
  * 命名
    核心語義之一
    用以 把 匿名組合子 與 符號 綁定
    綁定之後 這個符號的語義就是 有名組合子
    有名組合子 和 無名組合子 統稱爲 組合子
  * 製作匿名組合子
    核心語義之一
    一種標記語言 以形成有向圖
    用 [ ] 這個 borderfix notation
    對應與語圖中的多邊形
    我也不確定應該如何比喻
    具體地
    它對入棧一個用雙向鏈接的鏈表實現的樹
    樹中的某些位置可以被標記語言鏈接到其他地方
    注意
    用以嵌套以形成樹的
    有三種 括號 [ ] { } ( )
    所以在實現的時候一定要加標籤
    因爲 [ ] 會直接入棧數據
    而 { } ( ) 不是直接入棧數據
  * 作用
    核心語義之一
    以 ( ) 這這個 borderfix notation
    來表示之
    其作用於 組合子 之效果
    爲
    代之以體 並 依次執行
    1. 有名者之作用 如 B (A)
    2. 無名者之作用 如
       [ (M) (F) ] { (M) (F) }
       [ (M) (F) ] [ (M) (F) ] (apply)
       [ (M) (F) ] (M) (F)
       * 如上之前二
         在語圖中並不存在對應者
         而其三 在語圖中有對應者
  * 在代碼中可只以 [ ] 和 (apply) 來推導語義
    { }  =  [ ] (apply)
    ( )  =  [ ] (apply) (apply)
  * 而在語圖中 總需
    以 大圈 爲 { }
    以 小圈 爲 ( )
  * 這個等價變換有時循環
    比如
    (apply)
    [ apply ] (apply) (apply)
    apply (apply)
    所以這個[從到右的]變換 並不爲解釋器所用
    只爲人的理解
  * 複合
    這個操作是 製作匿名組合子 的一種特殊情況而已
    即 [ (M) (F) ]
    它並不涉及約束變元
    相比 製作匿名組合子
    複合 並不是 核心語義
  * 這樣就完全具體了
    但是
    注意
    在之後的閱讀中
    有的時候需要對構造函數的方式做限制
    這都是爲了觀察在限制下空間有什麼性質而已
* 律
** 記
   * 總結運算律於此
* 嘲嘲
** 1 嘲嘲不已 戀戀然
   * 若 x (M)  =  x (x)
     則 稱嘲
     * 就這種公理性的等式[變形]
       來設計表達式轉寫器
       其實也可以實現一個語言
       但是我認爲
       用內部的 以代換語義爲核心的 有向圖
       來實現其語言
       則效果更好
   * 例如
     [ .x (:x) ]
     * [ .x (:x) ] =
       [ .x [ :x ] (apply) (apply) ] =
       [ .x .x (apply) ]
   * 若 B (A)  =  B
     則稱 A 戀 B
   * 若 林中 允許以 [ (A) (B) ] 來製作無名組合子
     則稱 此林 允許複合
   * 問
     若
     知 嘲 之存在
     知 允許複合
     則 衆子皆有所戀 邪
   * 衆子皆有所戀之林
     稱 戀戀然
*** 解
    * 然也
      解 x (F)  =  x 即可
      試觀察解的形狀
      而設 x 爲 y (x)
      而解 y (x) (F)  =  y (x)
      蓋無窮之 (F) (F) (F) ...
      儘管其非一真實組合子
      但其形似所求之解
      可以 M 造無窮 (F) 如此如此
      [ (M) (F) ] (M) (F) =
      [ (M) (F) ] (M) (F) (F)
      因
      [ (M) (F) ] (M) =
      [ (M) (F) ] (M) (F)
      更知
      [ (M) (F) ] (M) =
      [ (M) (F) ] (M) (F) =
      [ (M) (F) ] (M) (F) (F)
      故而 [ (M) (F) ] (M) 即爲 (x)
      且知 [ (M) (F) ] (M) (F) 亦爲 (x)
    * 但知此解徒有形式
      而不可爲編程之用
      因其作用無窮不已耳
    * 其實
      其可用與否在於語言的實現方式
      只是在蟬語的實現方式下
      它無用而已
** 2 自戀
   * egocentric narcissistic
   * 問
     若
     知 嘲 之存在
     知 允許複合
     則 林子中有自戀之組合子 邪
*** 解
    * 解 E  =  E (M)
      由 E (M) =  E (E)
      得 E  =  E (E)
    * E = [ (M) (M) ] (M)
** 3 佳之存在 戀戀然
   * agreeable
   * 若 x (A)  =  x (B)
     則稱 A 認同 B 於 x
   * 若 A 認同 每一 組合子 於 某一 組合子
     則稱 佳
   * 問
     若
     知 佳 之存在
     知 允許複合
     則 林中 戀戀然 邪
*** 解
    * 給 F 而求其所戀
    * 設 A 爲 佳
      則 可解
      x (A) =
      x (A) (F)
      則 x (A) 爲 F 所戀
      因 A 認同 [ (A) (F) ] 於 x 耳
    * 比之與 M
      [ (M) (F) ] (M) =
      [ (M) (F) ] (M) (F)
      知其簡
    * 嘲即爲佳
      是故
      觀察以嘲解 x (F) = x 之過程
      弱化其條件
      而得佳
** 4 佳之親善
   * 設 (C)  =  (B) (A)
     知 允許複合
     則
     C 佳 而 A 佳 也
*** 解
    * _ (B) (A) = _ (B) (D) 可解
      _ (A) = _ (D) 之解亦明矣
** 5 複合
   * (C) (B) (A) =
     { (C) { (B) (A) } } =
     { { (C) (B) } (A) }
   * 易證之於代碼之變換
   * 其後二者 不可畫於語圖
** 6 容
   * compatible
   * 知 允許複合
   * 以 M 解
     x (A)  =  y
     y (B)  =  x
   * 得解者 稱 A B 容
*** 解
    * y (B) (A)  =  y
      以解的 y
      代回解得 x
** 7 樂
   * 與己容者 稱樂
     x (A)  =  y
     y (A)  =  x
   * 有所戀者 必樂
     證明之
*** 解
    * 設 a (A)  =  a
      以解 x y
      x y 者
      皆 a 也
      需證邪
** 8 常
   * 有所戀者 稱常
   * 由前知 常必樂
   * 不以 嘲 尋 樂
     亦不以 嘲 尋 常
     試證
     如若有一樂 必有一常
*** 解
    * 知
      x (A)  =  y
      y (A)  =  x
      則
      x (A) (A)  =  x
      則
      (A) (A) 爲所尋之常也
** 9 自絕戀
   * hopelessly egocentric
   * A (A)  =  A 者 自戀
     x (A)  =  A 者 自絕戀
     x (A)  =  B 者
     稱 A 恆於 B
     或 A 絕戀 B
   * 若 y ( x (K) )  =  x
     則稱 分
     即 x (K) 恆於 x
     K 之型意表分支也
     故名之 分
   * 例如
     [ [ :x .y (drop) ] ]
   * 問
     若
     知 允許複合
     何以
     以 M K 尋一自絕戀者 邪
*** 解
    * K 所戀者是也
    * 因 X (K) = X
      而 y (X) = y ( X (K) ) = X
    * 分者 絕戀者
      皆退化的組合子
      從構造方面講
      其退化彰於 (drop)
      從行爲方面講
      其退化亦可表述爲外部的性質
** 10 恆者戀者
   * 如若 x 恆於 y
     則 x 必戀 y
   * A 恆於 B 者
     A 絕戀 B 者也
** 11 分
   * 若 K (K)  =  K
     則 K 自絕戀
   * x (K) =
     x ( K (K) ) =
     K
** 12 再分
   * 若 x (K) 自戀
     則 K 必戀 x
*** 解
    * 若
      x (K) ( x (K) ) =
      x (K)
      則
      x =
      x (K) ( x (K) ) =
      x (K)
** 13 簡單的練習
   * 如若 A 自絕戀
     則 x (A)  =  y (A)
** 14 再一簡單的練習
   * 如若 A 自絕戀
     則 y ( x (A) )  =  A
** 15 自絕戀是傳染的
   * A 自絕戀
     則 x (A) 自絕戀
** 16 分 是可以被消去的
   * x (K)  =  y (K)
     則 再作用於任意一值
     而知 x = y
** 17 恆者 必恆於一
   * 如若
     x (A) = B
     x (A) = C
     則 B = B
** 18 分 之消去
   * 若 K 戀 x (K)
     則 K 戀 x
*** 解
    * K 戀 x (K) 者
      x (K) (K) =
      x (K)
      後邊消去一 (K) 即可知之
** 19 孤獨
   * 自絕戀 之 分
     必極孤獨 邪
*** 解
    * 此時林中獨有一個 分 也
      因爲
      x =
      y ( x (K) ) =
      y (K) =
      K
      而 x 是林中的任意一組合子
** 20 若傻爲佳 則戀戀然
   * 若 x (I)  =  x
     則稱 傻
   * 戀所有之組合子者 傻也
   * 如若 I 爲佳
     則不必知更多條件
     而可得 林之戀戀然
*** 解
    * 因
      任意 y 存在 x
      x (I)  =  x (y)  =  x
      則尋得 x 爲 y 所戀
** 21 若戀戀然 則傻爲佳
   * 這也由同上的等式得出
     x (y)  =  x  =  x (I)
** 22 容容然
   * 若
     x (A)  =  y
     y (B)  =  x
     得解
     則 稱 A B 容
   * 林中任意二子皆相容者
     稱林 容容然
   * 又知
     衆子皆有所戀之林者 戀戀然也
     a (A)  =  a
   * 問
     知 其林容容然
     知 有一傻
     則
     其林 戀戀然 邪
     其傻爲佳 邪
*** 解
    * 容容然 知
      x (B) (A) = x 可解
      就 傻而解
      得 林之 戀戀然
    * 而 若戀戀然 則傻爲佳
      故傻爲佳
** 23 傻自絕戀
   * 傻自絕戀則孤獨
     x = x (I) = (I)
** 24 靈
   * lark
   * 若
     y ( x (L) ) = y (y) (x)
     則稱 靈
   * 例如
     [ [ .y (:y) (.:x) ] ]
   * 問
     由 L 和 I
     可得 M 邪
*** 解
    * I (L) 爲 M
      y ( I (L) ) =
      y (y) (I) =
      y (y)
      知之
** 25 靈之存在 戀戀然
   * 問
     知 靈之存在
     則 戀戀然 邪
   * 戀戀然而常
     常而樂
   * 下面各問
     直至結尾
     皆不用函數複合
     此靈之爲用矣
*** 解
    * F (L) ( F (L) ) =
      F (L) ( F (L) ) (F)
    * F (L) ( F (L) ) 爲 F 所戀
    * 若記 X = F (L)
      則簡化爲
      X (X) =
      X (X) (F)
    * 正與
      記 X = [ (M) (F) ]
      而化
      [ (M) (F) ] (M) (F) =
      [ (M) (F) ] (M) (F) (F)
      爲
      X (X) =
      X (X) (F)
      相同
      只不用函數複合以構造耳
    * 由 L 和 I 可得 M
      是故
      觀察以嘲解 x (F) = x 之過程
      變更其條件
      而得靈
** 26 靈自絕戀 則無不戀靈
   * 由 靈自絕戀
     得 L ( x (L) ) = L (L) = L
   * 由 靈之定義
     得 L ( x (L) ) = L (L) (x) = L (x)
   * 而得證
** 27 如若靈不分 而分不靈 則靈不戀分
   * 若 K (L) = K
     則 再作以 y
     得 y (K (L)) = y (K)
     即 y (y) (K) = y (K)
     而 (K) 可消
     故得 y (y) = y
     即林中之組合子皆自戀
   * 代入以 K
     得 K (K) = K
     K 自戀則自絕戀 如下
     K = x ( K (K) ) = x (K)
     而 K 自絕戀
     則 K 爲林中孤獨組合子耳
     與 L 之存在相矛盾
   * 故而 依歸謬法
     得 K (L) =/= K
     即 靈不戀分
** 28 如若靈不分 而分不靈 若而有分戀靈 則無不戀靈
   * 之前以 靈自絕戀 爲條件
     而得 無不戀靈 之結論
   * 而此一例
     又是以弱化的[變更的]條件 而得相同結論
   * K 所戀者 自絕戀矣
     故 靈自絕戀
     而靈自絕戀 則無不戀靈
     得證
** 29 若只有靈則必有自戀者
   * 此爲 以靈 由函數作用 構造 自戀者 之遊戲也
     注意 只用作用 不用複合
   * 提示如下
   * 所尋者 y (y) = y 之解也
   * 代 y 以 x (x)
     轉而解 x (x) ( x (x) ) = x (x)
     注意
     即使有
     y = x (x)
     也未必有
     y (y) = x (x)
     因此解得 x 之後
     仍需帶回 以得原方程的解
   * 靈者 其特點在於
     單由函數作用 即可 以其解出 任意組合子之所戀
     而在此空間中 只知靈之存在
     故而 能作爲 解其所戀者 之對象中
     最簡單者 即爲 L 本身
     次簡單者 爲 L (L)
*** 解
   * 我斷言
     此 x 爲 L (L) 之所戀者 時
     它就爲上面的方程的一個解
   * 依照之前所敘述的解所戀者之法
     由 L 解出這個 x 即可
   * 由
     F 之所戀爲 F (L) ( F (L) )
     而得
     x = L (L) (L) ( L (L) (L) )
     y = L (L) (L) ( L (L) (L) ) ( L (L) (L) ( L (L) (L) ) )
   * 證明很簡單
     由 x 爲 L (L) 之所戀者
     知 x ( L (L) ) = x
     由此可以解除 x 的不依賴於 L 的性質
     _ (x) =
     _ ( x ( L (L) ) ) =
     _ ( x (x) (L) ) =
     _ (_) ( x (x) )
   * 代 x 入 空格就驗證了上面的輔助性方程
   * 另外
     由 L 和 I 可得 M 矣
     如若 由 L 可得 I
     則 單憑 L 即可得 M
     由此知靈之重要矣
* 愛神子
  * 知衆之所戀者 稱愛神
  * 這裏處理方式略有不同
    1. smullyan 不得不把函數複合作爲一個前綴函數來處理
       即把 與 M 的複合 即爲函數 A 的作用
       用 A M F 與函數作用求 _ (F) = _
    2. 我用 M F 與函數作用還有函數複合求 _ (F) = _ 即可
       即 對我來說 [ (M) (F) ] 顯然也在森林裏
  * 其實更細化得 由 M 的性質知這裏的 A 其實爲 L
    所求爲 (L) (M) 或 [ (L) (M) ]
* 豐
