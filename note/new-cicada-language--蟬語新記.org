#+TITLE:  蟬語新記 / new note on cicada language
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* ===================================
* 姓名
** 語義
   * <物 <姓 <名 (命)
   * 基本語義很簡單
     讓命名形成兩個層次耳
** 姓之爲類型 用以分類函數
   * 每物皆有姓
     綁定一物於某名後 必再賦之以姓
   * 姓之首要運用在於
     爲結構化的數據的類型編碼
     之後
     就能形成對一羣複雜的函數的分類與命名
     這在與
     每作一函數必爲[常爲]處理某些數據
     而數據階有類型 姓即爲其類型之編碼
     數據與其類型一並 可被稱爲物
     當需要給函數賦以姓名時
     則其所作用諸物之主要者
     使函數之姓從之
     再取名即可
     這樣依姓而分函數爲類
     就讓人對一羣複雜的函數有了更好的理解
   * 某一數據類型的處理函數可能需要
     1. 初始化函數
     2. 等詞
     3. 問詢結構化數據的性質的函數
** [否決] 數學結構
   我知道某些語言中
   有試圖捕捉數學結構這個概念的嘗試
   不管是用 type 還是用 module
   沒有一個不流於對數學的拙劣模仿
   所以我放棄這種嘗試
   而強調在這方面數學語言與程序語言的差異
** 姓之爲語境 用以分類語法關鍵詞
   * 我之前沒能設計出很好的語法擴展機制
     導致第一個版本中 很多地方重寫反工
     現在我小心爲之
   * 一個語境是一個姓
     用 :title: 表示之
     我用這個概念來解決
     1. 語法關鍵詞之間的集體相互調用問題
        [因爲 它們之間有很多相互遞歸調用]
        這在於
        * 一個姓就代表一個語境
        * 每一個個語法關鍵詞
          在聲明其所要[遞歸]相互調用的其他語法關鍵詞的時候
          將不逐個聲明 而以語境爲單位
        * 並且
          我提供語義 以使得 在聲明所要遞歸調用的語境時
          能夠局部覆蓋其中的某個語法關鍵詞
          過着局部增加 等等
     2. 語法關鍵詞的重載問題
        這在於
        同一個語法關鍵詞在不同的語境下的意義可以不同
   * 在編譯器運行的每個時刻
     不是 在某個語境中
     而是 在某個語法關鍵詞的控制之下
     而這個語法關鍵詞 一定屬於某個語境
   * 在不同的語法關鍵詞的控制下
     讀取字符串的方式不同
     有的 一詞一詞的讀
     有的 一字一字的讀
     有的 認爲某些 bar-ket 爲特殊
   * "自治性" 的意思就是說
     每個語法關鍵詞都要從最底層的字符串處理寫起
     語法關鍵詞是那些一定在[常常在]編譯期被調用的函數
     它們統一[至少]以
     被編譯的[帶有光標的][也可能帶有其他元數據的]字符串
     爲隱含的參數
     在讀字符串並移動光標的過程中
     它們會編譯各種數據各個數據域
   * 這種設計看似很底層
     但是其實只要實現好
     相對應於各種對字符串的讀取方式的幫助函數
     [也就是做好 對函數的因子分解]
     那麼就能從橫向控制複雜性
     而不是去形成不同的處理層次
     [兩種控制複雜性的思路之間並沒有優劣之分]
   * 注意
     每個語境下除了要有 被空格分割的 語法關鍵詞之外
     還需要有別的 處理機制
     比如
     1 2 (add) = 1 (add 2) = (add 1 2)
     (arg2:> 2)
     2#1100_0110
     這些時候 需要的謂詞是非平凡的
     [也就是說 對其他的語法關鍵詞的出現的判斷是平凡的]
** 姓之爲區 用以形成相對的地址
   * 每個地址都是相對某個區而言的
** 語法不重要
   * 有了語境的概念之後
     語法就應該能夠被靈活地改變了
     所以語法就不重要了
   * 所以對於所設計的某個語義
     不必在語法的設計決策上 耗費過多的時間
     因爲
     要知道
     當發現所設計的語法不好用時
     可以隨時更換設計
** 姓之爲結構
** 姓之爲模塊
* 約束變元
** 遞歸調用
   * 如果一個函數遞歸調用了自身
     那麼在遞歸調用時
     這個函數的作用還沒有結束
     所以
     函數的作用過程中
     其約束變元的值不能真的被代入到
     約束變元所標記的
     函數體中的位置中
     因爲否則
     對這個函數的遞歸調用
     就會更新這個這個位置下的值
   * 所以
     用一個分離的約束變元棧
     來保存函數作用過程中所獲得的
     約束變元的值
     而函數體內約束變元的位置上
     保存到這個棧中的 index
** 明顯的參數
   * 明顯的參數所提供的額外信息
     只被用來重排參數的順序而已
   * 可以[應該]有更多的用處嗎
   * 明顯的參數作爲一個 特殊的 name
     出現在參數棧中就行了
* 函數體內的結構化數據
** 函數能夠返回函數
   * 如果
     外層的函數的作用會返回一個內層的函數
     並且
     內層的函數中包含了
     由外層的函數所綁定的約束變元
     [ .x [ :x ] .y ]
     那麼
     當外層的函數的作用結束之後
     內層的函數中所包含的
     由外層的函數所綁定的約束變元
     必須還具有形成綁定時的值
   * 簡單的解法有兩種
     1. 每個函數都是 函數體+名與值的綁定的鏈表
     2. 返回一個內層函數的複製
        並且在複製的同時把約束變元的值
        真正地代入到約束變元所標記的
        內層函數的函數體中的位置當中
   * 傳統的 scheme 實現使用第一種解法
     而我使用第二種解法
     只爲嘗試一些新的想法而已
   * 這種解法下
     1. [缺點]
        函數不是 閉包[closure]
        而 當把函數處理成 閉包 時
        每個函數都是 函數體+名與值的綁定的鏈表
        如果有兩個函數僅僅是 對名的綁定不同
        那麼這兩個函數就可以重用一個函數體
        而使用不同的對名的綁定
        而在我所選擇的處理方式下
        不能重用 函數體
        這樣就浪費了內存
     2. [缺點]
        當返回很大的函數體時
        複製其函數體的過程會很浪費時間
     3. [缺點]
        參數不足時的函數作用
        不能被看作一種函數返回函數的特殊情況
        來以一致的方式處理
     4. [優點]
        而在每個函數作用的時候
        因爲其中約束變元的值已經被代入了
        所以將在此處節省時間
     5. [優點]
        因爲函數體不被 不同的 名與值的綁定的鏈表 共用
        所以可以對函數體作副作用
        從觀念上看
        可以認爲函數的實體性更強了
** 函數返回對結構化的數據的複製
   * 進一步而言
     每當一個函數需要返回一個結構化的數據之時
     [比如 無名的函數]
     都需要能夠返回這個結構化的數據的複製
     [我可以提供明顯的語法以聲明對複製的需要與否]
     並且當被複製的結構化的數據中
     包含由這個函數所綁定的約束變元的時候
     這個約束變元的值
     會在複製函數遍歷結構化的數據的同時
     被代入到其位置之中
   * 注意
     複製結構化的數據的時候
     其 所申請的內存的種類[比如 是否需要 GC]
     其 在 雙向鏈表 單向鏈表 向量 這三種數據結構之間的轉換
     都可能需要相關的語法來聲明
** 複製中的圈狀引用
   * 當複製一個結構化的數據的時候
     我要求其中的所有的 圈狀引用 都能夠被探測並保留
   * 這是一個非常難以高效實現的性狀
     複製壓縮性的 GC 算法中所使用的技術
     可能夠在這裏重用
** 參數不足時的函數作用
   * 如果使用 閉包
     那麼就能以一致的方式
     處理這種 返回函數的函數 的特殊情況
     也就是將所有的多元函數都 一元化[curry]
   * 如果不使用 閉包
     而返回函數體的複製
     那麼所使用的算法就將面臨其最惡劣的情況
     所以
     我還是要使用閉包
   * 要麼返回複製要麼返回閉包
     我提供不同的處理方式以供選擇
   * 當然
     對各種情況我也會設計合理的默認處理方式
   * 如果不提供 複製與閉包之間的選擇的話
     我可以把 參數不足時的函數作用 統一處理成 閉包
     而把 內部返回的函數處理成 複製
     這樣就限制了閉包的層次
     使得做多隻有一層閉包
** [否決] 變長的棧中的值
   * 對變長值的需要在於
     這樣就可以在沒有 GC 的時候實現閉包了
     因爲對於閉包而言
     名與值的綁定的鏈表
     需要用 GC 來實現
   * 就像複雜指令集中的變長指令一樣
     如果我允許變長指令的話
     棧的接口就要在時間複雜度上增加一個常數了
     還由於
     複雜的接口會讓 primitive-function 也變複雜
   * 所以我放棄這種計
* 編譯
** 本質
   * 編譯的本質是
     化人可識之名
     爲機器可以處理之數
** 姓的尋找
   * 基本的原理是
   * 所給予編譯器的信息 可以只是函數的名
   * 對與函數的姓
     將可以從
     在之前被編譯到函數體內的
     數據的姓中推斷出來
   * 當在編譯時期 沒法推斷出來姓的時候
     就編譯一個 用來在運行時期
     將 棧中的數據的姓
     與 函數體中被調用的函數的名
     進行匹配的 動態處理函數 進函數體中
     並且把需要處理的函數名也編譯到函數體中
   * 這樣就能夠達到對函數名的重載的效果
** 提前作用
   * 首先要注意某些輸入輸出類型的副作用函數
     不能被提前作用
   * 是否讓 提前作用 也自治呢
     自治的好處在於靈活
     而壞處在於語法可能複雜
     但是 因爲有語境這個概念的幫助
     所以 可能自治並不會語法變得太複雜
   * 在推斷出了函數的姓的時候
     關於函數作用的時機
     基本的原則是
   * 儘可能在編譯時期處理更多的函數作用
     並且視這種編譯期的處理爲對運行時效率的優化
   * 唯一的不能進行提前作用的情況是 參數不齊全
     如果保證在處理每次函數作用的時候
     都在是參數補全的時候才放棄優化
     那麼就能達到一種理論上的最優
   * 如果
     儘管 參數不全
     但是 但是某些約束變元已經可以用來綁定了
     那麼這時也許可以進行一些特殊的處理
     以避免完全運行時的對約束變元的處理
   * 但是如果對約束變元的處理是
     將約束變元的值入約束變元棧
     那麼
     這種處理就只能運行時來進行了
** 找姓的原則
   * 編譯器在找姓時所用的機制
     就決定了在省略姓時
     函數作用所能出現的形態
   * 我的設計是
     從第一個的參數的姓
   * 要知道如果有歧義總可以加上姓
   * 如果需要動態性
     則我提供明顯的方式以聲明姓之所從之位置
   * 性狀是
     如果函數與其兩個參數同姓
     那麼跟其二者之任一階可
     [如果用預先指定等等複雜的機制 就將沒有這個性狀]
   * 每次找到姓之後
     都會匹配參數的名
     作爲檢查
** 有默認值的參數
   * 有默認值的一定是有名參數
     有默認值的有名參數 和 一般的有名參數不同類
     因爲 我希望某些參數在被省略時 能夠自動形成 curry
     而 有初始值的參數在被省略時不會自動形成 curry
   * 有初始值的參數 其實就是這個函數的局部變元
     只不過當把這種特性按照 具有初始值的參數來實現的時候
     就提供了接口來改變這些函數的局部變元
** 對姓已經找好的編譯好的函數作用
   * 此時看的是棧中的值
     而不再是函數體中前面的值
   * 此時函數處理參數的方式
     就決定了參數在棧中的排佈格式
   * 條件是
     1. 完全省略參數名是允許的
        此時會按約定的順序來處理
     2. 約定的順序可以以明顯的方式聲明
        也可以在定義函數時
        根據函數體的幾何而自動生成
        [當然這寫是構造函數時的事]
   * 函數可以被分爲很多類
     比如
     1. 函數完全使用有名的約束變元
     2. 函數完全使用無名的約束變元
     3. 函數使用了兩者
   * 我的設計是[別的設計方式也是可以想像的]
     要求
     所有的有名的約束變元
     必須出現在棧的頂端[即使在省略名時]
     此時
     用有名參數的個數
     去查看棧中參數的命名情況
     有名者依名無名者依序 即可
   * 這樣的特點是
     當參數的順序排佈正確是
     就可以隨時給某個位置的函數添加或省略參數名
   * 注意
     有名參數是可以有默認值的
     我把有默認值的參數另立一類來處理
     我要有初始值的參數不能出現在無名的局部變元之後
     它們的出現將不被計算爲有名的參數
** 逆
   * 我需要讓我的編譯器具有良好的反編譯的能力
     爲此
     首先
     我需要在函數體中保存的就是
     這個函數被綁定到的姓名
   * 難點在於
     如果我允許一個函數體被綁定到多個姓名
     那麼
     就需要用鏈表來實現這裏的數據結構了
   * 在每個函數體內還需要編碼它對約束變元的使用情況
     這裏可以限制約束變元的姓
     也可以不限制
** 初期的函數 是 指令所組成的向量
   * 一個 向量函數
     是一個指令所組成的向量
     附加一些元信息
     元信息中
     靜態的部分用向量實現
     動態的部分用鏈表實現[鏈表所分配的數據區域還不確定]
** 由小組大
   * 所能使用的抽象方式幾乎就只是函數而已
     由小的函數組成大的函數的方式是
     複合 與 作用
     但是隻要我保持使用 姓 的方式的靈活性
     那麼我就能夠模仿
   * 比如
     繼承[遺傳] 與 變異
     這在於
     在製造新的東西的時候
     利用已經製造過了的類似的東西
     具體地
     1. 可以 複製別人的處理函數過來
        並對其作一些修改
        尤其是 初始化函數可能需要這種方式的變異
        尤其是 關於函數類型的數據也需要改寫
     2. 也可以 直接聲明重用別人的處理函數
        既然我已經決定要用多種數據結構來實現函數體了
        那麼此時我就也應該能選擇
        在複製函數體的時候
        使用那種數據類型
     3. 也可以 不作複製
        而以別的處理函數爲基礎 複合一個新的函數出來
** >< 對所使用的編譯器的聲明
   * 也就是對所使用的語法的聲明
   * 每塊代碼前面都有
     對 用來編譯這塊代碼所使用的編譯器的聲明
     同時 還有對這個編譯器的配置的明顯說明
   * 這裏需要設計一個通用的語法
     如果有通用的語法
     那麼從每個語言中都能容易地轉到別的語言
     只要讓每個語言都調用一個全局的函數來處理 [] 就行了
   * 用特殊的括號來聲明語境的轉換 (: :)
     每次進 [] 的時候可以轉換語境
     也可以維持之前的語境
   * 比如可以通過明顯的聲明
     來把 (function) 簡化成 function
** 嫁接機制
   * 當聲明需要 抓取計算的時候
     用來實現函數作用接口的 三個 stack
     都要從 vector 轉變爲 list
   * 所以對計算的抓取是要使用明顯的語法來聲明的
     當不要抓取的時候再聲明
     以轉會 vector
** 基本的定義函數的語法
   * 關念上
     應該是先生成一個無名函數
     然後給這個無名函數綁定一個名字
   * 但是實現上
     猶豫開始時沒有 gc
     所以無名函數所佔用的內存不能收回
     所以一定要保證
     不要讓對無名函數的生成氾濫了
   * 這種無名函數的作用可以是
     形成無名的幫助函數
* 類型
** 類型檢查
   * 類型檢查 類似於 提前作用
     只不過 因爲 約束變元的出現
     而使得無法直接使用值來做提前作用
     故
     轉而 使用類型來做提前作用
   * 所謂 type constructor
     就是類似 "type -> type" 和 "[type]" 的東西
     它們都是爲了使得對類型的計算能夠進行下去的機制而已
     我並不在乎這些機制
     我只要把對類型的計算進行下去就行了
** [否決] 類型推導
   * 類型推導 在於
     利用函數的類型來推導約束變元的類型
     要知道
     爲了進行 類型檢查
     所有的約束變元都是要有類型的
     這樣就導致了在我的設計中沒法使用類型推導
     因爲 我是從值來推導函數的 而不是相反
** 每個約束變元都有類型[姓]
   * 約束變元這個名字翻譯自英文的 bound-variable
     其意義爲
     這個 變元[名字] 的意義
     [具體的在程序語言中 這個意義就是 名與值之間的綁定]
     是被約束在某個區域[語境]之內的
     出了這個區域之後 其意義就改變了
     其特點是
     變元名字的選取是任意的
     它的目的只是爲了標記區域中的位置
   * 無名的約束變元
     argument-stack for unnamed-local-variable
   * 有名的約束變元
     frame-stack for named-local-variable
   * 函數體內應該保存其約束變元[還有返回值]的類型信息
     其用性自名 不做分說
   * 保存約束變元信息的地方是函數的頭
     而不是每個約束變元所標記的位置
   * primitive-function 和 vector-function
     都需要相關的類型信息
     但是其實現方式不同
     所以 這裏就需要保持其接口設計的一致
** [暫時否決] 複雜的類型的編碼
   * 類型之間就必須能夠相互嵌套了
     因此就沒法用 姓 來簡單的給類型編碼了
     必須使用別的數據結構
   * 使用 複姓 的概念
     每個複姓還是有一個主姓的
     比如 list number
   * 自治性
   * 注意
     編碼的目的是讓對類型的計算能夠進行下去
   * 我放棄這種類型編碼
     我在需要的時候編譯動態的函數調用
     我把這些性狀留給以後去考慮
     因爲對它們的引入將大大改變語言的性質
     某些性質上的差異和既有的設計之間是不可調和的
* 鏈表處理
  * 不應該使用 pair 來實現 list 這個數據結構
    因爲這樣每個 list 中需要保存很多多餘的類型信息
  * 可以說 lisp 對 list 的認識是侷限性非常強的
    而熟悉 lisp 者 常常不自知
* 註釋的格式
  * 在之前 對棧的操作的註釋是被忽略的
    也就是說
    編碼者 辛辛苦苦鍵入的信息被愚蠢的機器忽略了
    我現在就設計新的 註釋的格式 來修正這一錯誤
  * 要求這個 註 中所能包含的信息有
    1. 副作用 類型
       包括 編譯到內存的信息
    2. 還有輸入輸出信息等等
       仔細想像 副作用的類型其實 十分有限
       這些信息必須足以讓 詞典編撰者 推導出
       這個函數的作用能否在編譯時期被處理
       如果這裏有困難
       那就直接把 這個性質變成一個明顯的聲明好了
* 文庫
  * 美 代碼的集合 之名曰 文庫
  * 包含完整的工具鏈
  * 用於指定編譯和加載代碼順序的格式用 org-mode 寫成
    其處理的也是 org-mode file
    規定了如何 編織 編譯 和 加載
  * 跟所謂文學編程相關的
    有 publish 函數
    對應於 每個 org 文件
    還要有相應的 描述其樣式的 style 文件
    然後才能 publish
* -----------------------------------
* 性狀的層次
** 沒夠動態內存管理的條件能夠實現的性狀
   1. 約束變元棧
   2. 對所使用的編譯器的靈活轉換
   3. 基本的編譯器
   4. 沒有函數是無名的
      在開始的時候所編譯的函數都是存在於不可回收的內存中的
      其實可以有結構化的數據
      只不過它們所佔用的內存都不能回收而已
** 只有在有動態的內存管理之後才能實現的性狀
   1. 返回函數的函數
   2. 嫁接機制
   3. 對計算的抓取
* ===================================
