#+TITLE: note on digrap
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* note
  我曾經仰慕米開朗基羅
  仰慕他高超的技藝與他的天才和熱情
  現在我開始慢慢地理解他
  我明白了他在開始的時候也一定只是
  單純地
  被那些建築的和諧的美所吸引
  直到他逐漸懂得光與影與結構的奧祕
  直到他在觀察與練習中掌握雕鑿石塊的技術
  直到他領悟到與自然交談的方式與態度
  然後他自然地去創造新的美與和諧
  然後專注於這個嚴肅的事業
* ==================================================
* digrap
  以有向圖爲基本數據結構的語言:
  DIGRAP :== DIrected GRAph Processing

  實現對有向圖而言的各種等詞:
  1. 在以圖爲數據結構編程時
     這些這些等詞是基本工具
  2. 在實現數學形式語言時
     這些等詞是形成命題的基礎

  說對λ-cal還有對rewrite-rules的實現就是對圖(圖的圖)的惰性求值
  這裏這些圖的特點是什麼
  反過來問: 是什麼使得對它們的惰性求值可以用λ-cal或rewrite-rules來描述?

  是對節點和邊的標記系統嗎?(約束變元)
  每個站在一個節點上看看這個節點的標記
  再看看某一條有向邊的標記
  就能知道從這個節點沿着這個有向邊走過去的節點的標記

  這對cayley-graph的使用有什麼啓示

  note about λ-cal:
  我把對λ-cal的實現理解爲對有向圖的惰性求值
  但是這樣作好像並不自然
  不管是在理解方面還是在實現方面都是在倒退
  因爲
  當人對一個有向圖的惰性求值形成了λ-cal這樣的編碼
  他就獲得了更特殊化的語義

  我把一次-sβ->理解爲添加一個節點再刪去一個節點
  而他把一次-sβ->理解爲把一個編碼轉化爲另一個編碼
* >< λ-cal
** readings
[[shell:xpdf /media/math/person/barendregt.henk/lambda-calculi-with-types.pdf &]]
[[shell:xpdf ~/math/person/barendregt.henk/the-lambda-calculus:its-syntax-and-semantics.pdf &]]
[[shell:xpdf ~/math/person/barendregt.henk/introduction-to-lambda-calculus--barendregt-barendsen--2000.pdf &]]
[[shell:xpdf ~/math/person/barendregt.henk/church.pdf &]]

[[shell:xpdf ~/learning-lambda-cal/Lambda-Calculus_and_Combinators.pdf &]]

[[shell:xpdf ~/learning/lambda-cal/readings/abstract-computing-machines--the-lambda-calculus-perspective--2005.pdf &]]

** old notes

好的講授方式是先在非形式化的語言下試着描述
以發現對理論的哪部分作嚴格的形式化是有必要的
這正是數學研究的典型過程
數學家正是要在觀察中發現結構 然後通過形式化的描述來增進對問題的認識


scott限制函數與某個拓撲空間上的連續函數集
然後λ-cal的理論就有了拓撲(幾何)解釋
那麼根遞歸函數有關的不動點概唸的幾何意義是什麼呢?


pure λ-calculus

models of λ-calculus are objects in category (of course)
and these categories are cartesian closed
(then non-unary functions can reduced to unary functions)

*λ-calculus studies functions as rules (but not geometry object)*

no matter use λ-term as expression defined by grammars
or λ-post-term as directed graph
one can always captures the concept of ``terms modulo convertibility''
which is the principle object of the study
the following questions need to be studied:
1. λ-definability
   λ-可定義的函數的集合等於遞歸函數的集合
2. the relations between non-convertible terms
   定義一個λ-可定義函數的term要麼是一個要麼有無窮多個
3. the limit of λ-calculus to captures the notion of function
   term的集合上有一個自然的拓撲結構:tree-topology
   term -> Bohm-tree -> scott-topology
   所有的λ-可定義函數都是就這個拓撲而言的連續函數


conversion

all about ``terms modulo convertibility''

use λ-terms to introduce ``terms modulo convertibility''
the set of λ-terms is a set of strings defined inductively by grammars
the theories on this string-level is called syntax
≡ denotes the syntactic equality

[x:=N] is an function act on λ-terms
which is used with rules to define =β=(or just =)(β-convertibility)
this equivalence relation define the theory λ (or λ-calculus)
(when there is rules there is theory)
provability in the theory λ of equation is denoted by λ⊦(M=β=N)
one can say M and N is convertible when λ⊦(M=β=N)
this seems a loop-define
bacause the notion: provability of proof-theory is used
to define the equivalence relation
rules give a partial-order on the set of λ-terms

connectives and quantifiers which can describe propositions
will be used in the discussion about λ-cal

what is equation?
equation in λ-cal is proposition with many quantifiers

** an enlighten
關於類型論
因爲每引入一個新的類型
就可以引入一些相應的referece-rules

所以一次啓蒙在於
類型論讓人認識到
referece-rules並不必以一階邏輯爲中心
而是可以相當任意的創造的

比如
我可以以字符串或者有向圖爲基本數據結構
來實現一個形式理論
那麼對於字符串或者有向圖我都自然有一些基本的``等詞''
對推理規則的引入的自由性就在於:
推理規則中對這些等詞的引入不能違背
這些等詞在基本數據結構中本來的語義
此限之外別無它限

更常見的是
推理規則需要引入
以基本等詞爲基礎在基本數據結構中實現的其它關係
對其它關係的實現本身並不會違背基本等詞
但是引入這些關係的推理規則可能會違背基本等詞
所以需要加上上面的限制

因此首先我要一個直覺性的並且具有可構造性的數學結構
當我用計算機來實現一個數據結構時
很自然地我就得到上面的良好性質
然後我引入一些針對這種數學結構的推理規則
之後我就得到了一個形式語言
用這個語言我可以推導出一些描述這個數學結構的一般性質的命題
這些命題的正確性由推理規則和數學結構的相容性保證
這些命題是具有實在意義的因爲我是一個純粹的形式主義者
+ 關於術語:
  這裏 爲了描述上面的形式語言於數學結構之間的關係
  我通過創造新的術語
  並且把對這些術語的使用只侷限在我在上面所描述的這種關係
  來避免歧義
  稱上面的關係爲
  形式語言捕捉到數學結構
  既然我是在創造一個語言來描述我的幻想
  那麼這個動詞是很生動的
  一組推理規則可能能於一個數學結構相容
  而又於另一個數學結構不容
  即這組推理規則所形成的形式語言
  能夠捕捉到某些數學結構
  而捕捉不到其它數學結構
  + >< 考慮完備性
    我是不是應該更改我的術語
    當形式語言就某個數學結構而言具有完備性的時候
    應該怎麼說??
** >< type-free λ-cal
*** notations
formal-language
== 形式語言 == 形式理論

exp == expression == formula
== 表達式

grammar == grammar-formula == BNF
== 形式語法 == 形式語法公式
+ 用來歸納定義一個字符串的子集

等詞
每個等詞都應該與某個類型的數據相聯繫
否則會引起很多歧義
+ 這裏可以看出類型論的一些合理性
  因爲在類型論中對等號的使用正是如此

等號
等號是被濫用最多的數學符號
在定義形式語言的時候一定要小心使用
等號的基本語義:
1. 賦值
3. 基本等詞
2. 等價關係

priori == 先驗的
*** inductive definition of the set of exp
var ::= v | var'
term ::= var | (term term) | (λ var . term)
the set of all terms is denoted by Λ

其中括號的使用是爲了形成樹的語義
由遞歸定義
一個term被理解爲一個有根的樹
+ 樹可因根的選取而獲得一個定向
這個有向樹中只有葉節點是被標記了的
用來標記葉節點的是var或者是字符"λ"或"."

用字符串來實現一個形式語言時
字符串之間的相等就是基本等詞
給出兩個字符串時
人們可以區分它們是相同還是不同
+ 這是一個先驗的假設
  但是在計算機上的可實現性增強了這個假設的合理性
  先驗假設的合理性 == 假設中的概念在機器上的可實現性
這樣就得到了就字符串而言的基本的等詞
這個等詞記爲``==''

等詞永遠根所使用的模型有關
*** indude-tree(Λ; ∈term-intro1, ∈term-intro2)
term於term之間有引入關係
比如M,N引入(M N)
所以也許可以用推理規則來描述這個歸納定義
用推理規則來描述歸納定義也許具有更大的普遍性

+ 也就是說我統一把這種``類後繼關係''用inference-rules來描述
  這樣在用圖論對整個理論的想像之中
  因爲形成了統一的理解方式
  所以一切都變得簡單了

----- (∈var axiom)
v∈var
這裏v是真正的字符

x∈var
------------ (∈var introduction)
x'∈var
這裏x是字符串的模式匹配中的pattern-variable
'是真正的字符

x∈var
----------- (∈term axiom)
x∈term

M∈term
N∈term
------------- (∈term introduction1)
(M N) ∈term

x∈var
M∈term
------------------- (∈term introduction2)
(λ x . M) ∈term

此時就顯然可以看出term和term之間的引入關係
可以形成一個以Λ中的元素爲節點
以(∈term introduction1)於(∈term introduction2)爲有向邊
的無窮有向樹
記爲:
inductive-definition-tree(Λ;(∈term introduction1),(∈term introduction2))
ID-Tree(Λ; ∈term-intro1, ∈term-intro2)
indude-tree(Λ; ∈term-intro1, ∈term-intro2)

*** substitution
這是一個基本的對表達式的集合Λ
中的元素的處理(被參數化的函數)
| M       | M[x:=N]            |
|---------+--------------------|
| x       | N                  |
| y(=/=x) | y                  |
| PQ      | (P[x:=N])(Q[x:=N]) |
| λx.P    | λx.P               |
| λy.P    | λy.(P[x:=N])       |
*** the set of free(resp. bound) variables of M, notation FV(M)(resp. BV(M))
**** note
FV與BV都是基本的表達式的集合Λ上的函數
+ 當把集合理解爲
  比如說表達式的有限時
  上面這些集合論中的概念是很容易實現的
  當然這裏又需要一些先驗的假設
  然而同樣因爲在機器上的可實現性
  這些假設是合理的
+ >< 如何理解這裏對等號的使用??
**** FV
FV(x) := {x}
FV(MN) := FV(M)∪FV(N)
FV(λx.M) := FV(M)\{x}
**** BV
BV(x) := ∅
BV(MN) := BV(M)∪BV(N)
BV(λx.M) := BV(M)∪{x}
*** =α=
**** =α= introduction
α-conversion

公式 λx.M =α= λy.M[y:=x]
+ y不在M中自由出現
其實是在描述一個pattern-matching
而我用下面的對實現而言更直接的定義

N == M[y:=x]
M == N[x:=y]
-------------------- =α= introduction
λx.M =α= λy.N

**** an example
an affirmation(allegation)(assertion) of the following proposition
λt.tzt =α= λs.szs

1. λx.M pattern-matching λt.tzt
   1) λ == λ, so
      the pattern is matched successfully
   2) pattern-vars binding:
      x -- t
      M -- tzt
2. λy.N pattern-matching λs.szs
   1) λ == λ, so
      the pattern is matched successfully
   2) pattern-vars binding:
      y -- s
      N -- szs
3. performing M[x:=y]
   where:
   M -- tzt
   x -- t
   y -- s
   so performing tzt[t:=s]
   we get: szs
   so N == M[y:=x]
4. performing N[x:=y]
   where:
   N -- szs
   x -- t
   y -- s
   so performing szs[s:=t]
   we get: tzt
   so M == N[x:=y]
5. so λt.tzt =α= λs.szs

**** compatibility
就與Λ的歸納定義的相容性擴展

M =α= N
------------
ML =α= NL
LM =α= LN
λv.M =α= λv.N

**** note
變元只是語法對象 它們的意義只在於
人們想要利用這些語法對象來說明一些語義
*語言是爲了表達*

這個等價關係使得表達式的集合Λ獲得了有向圖的語義
也就是說等價關係的引入可以被看成是對語義的引入
或者在這裏我可以進行一次模型的轉換
去直接用有向圖來實現我想要定義的形式語言
這時Λ就是有向圖的集合而不是字符串的集合
逃離``線性的字符串''這種概唸的限制而使用圖論
+ 然而要明白
  ``線性的字符串''的概唸的重要價值是
  作爲輸入需要被解釋的表達式的工具
  即 作爲人控制機器的方式
  ``線性的字符串''與機器對形式理論的實現之間是有區別的

用有向圖來實現一個形式語言時
有向圖之間的某種相等就是基本等詞
+ 可以想象有向圖之間可以定義各種的相等
給出兩個有向圖時
人們可以區分它們是相同還是不同
+ 同樣這也是一個先驗的假設
  但是在計算機上的可實現性增強了這個假設的合理性
  先驗假設的合理性 == 假設中的概念在機器上的可實現性
這樣就得到了就有向圖而言的基本的等詞
這個等詞記爲``==''或``=α=''
但是要知道此時``=α=''的意義已經完全變了
它不再作爲一個等價關係而被別的基本等詞來引入
而是它本身就是一個基本等詞

對於所有在我希望定義的形式語言裏要使用到的exp
我也可以形成歸納定義
需要更改的是上面的term ::= (λ var . term)這一項
但是因爲所定義的表達式的幾何性質
此時已經不能用一般的形式語法公式來作歸納定義了
因爲這些定義之中還設計到對有向圖的操作
而不是隻涉及到對字符串的簡單操作

但是我可以嘗試用推理規則對term的集合作歸納定義如下:

----- (∈var axiom)
v∈var
+ 這裏v是真正的字符

x∈var
------------ (∈var introduction)
x'∈var
+ 這裏x是字符串的模式匹配中的pattern-variable
  '是真正的字符

x∈var
----------- (∈term axiom)
x∈term

M∈term
N∈term
------------- (∈term introduction1)
(M N) ∈term

x∈var
M∈term
------------------- (∈term introduction2)
(λ . M[free:x := (* --> λ)]) ∈term
+ 這裏M已經是有向圖了
  而它後面的方括號中描述了一個對它的操作
  把x在M中的所有自由出現換成無名節點
  然後把這些無名節點全部都連接到最前面的λ點

*** variable convention
+ 當我把有向圖作爲公式來實現我的形式語言的時候
  我其實根本不需要這個技術性處理

assume that the bound and free variables in a situation differ

在用字符串來實現λ-cal這個形式語言時
在一個term中如果需要的話總是重命名約束變元
使得它們不與term中出現的其它任何自由變元相同
這樣在進行substitution的時候就不用考慮那麼多了

*** closed λ-term (combinator)
M is called closed λ-term (combinator)
if FV(M) == ∅
the set of closed λ-terms is denoted by Λ°

*** >< ``λ-cal as a formal theory of equations between λ-terms''
**** note
``λ-cal as a formal theory of equations between λ-terms''
這句話是什麼意思?
首先提到equation的時候就應該想到代數結構
代數結構總是最豐富而有趣的

**** >< λ-cal as algebra-structure
***** note
我可以試着用我理解代數結構的方式來理解λ-cal
=η=於-sη->的性質我還不熟悉
這也許會讓下面的討論成問題

***** 關於運算律
λ-term的集合
顯然就λ-application構成代數結構
+ λ-abstraction在代數結構中的意義是什麼呢?
  單純地把它作爲對term的遞歸定義嗎?
與羣作爲代數結構的區別在於
這裏的可計算性(或者說可構造性)

****** 在=β=的意義下
******* 沒有交換律:
MN =/β= NM

******* 沒有沒有結合律:
(MN)L =/β= M(NL)

******* 沒有消去律:
LM =β= LN
----><-----
M =β= N

反例是:
L :== K*
K*xy =β= y

****** >< 在添加=η=的意義下
****** 有趣的問題是可不可以形成更高等級的運算
由λ-cal的性質我知道
函數方程的解總是在term的集合Λ中的 !!!
>< 因此沒法就函數方程的解擴充Λ嗎 ???

>< 問題是生麼樣的函數方程的解纔是有意義的呢?
不動點方程顯然是一個
FX =β= X
這個方程描述了
λ-term之間的``X是F的不動點''這種二元關係

****** >< 解方程的重點就是熟悉恆等變換
*** -sβ->
**** -sβ-> introduction
β-step-reduction
+ 共軛的有<-sβ-

也就是說公式(λx.M)N -sβ-> M[x:=N]
其實是在描述一個pattern-matching
而我用下面的對實現而言更直接的定義

M* =α= M[x:=N]
-------------------- -sβ-> introduction
(λx.M)N -sβ-> M*

**** an example
an affirmation(allegation)(assertion) of the following proposition
λx.F(xx) λx.F(xx) -sβ-> F(λx.F(xx) λx.F(xx))

1. (λx.M)N pattern-matching λx.F(xx) λx.F(xx)
   1) λ == λ, so
      the pattern is matched successfully
   2) pattern-vars binding:
      x -- x
      M -- F(xx)
      N -- λx.F(xx)
2. performing M[x:=N]
   where:
   x -- x
   M -- F(xx)
   N -- λx.F(xx)
   we get F(λx.F(xx) λx.F(xx))
3. F(λx.F(xx) λx.F(xx)) =α= F(λx.F(xx) λx.F(xx))
   so
   λx.F(xx) λx.F(xx) =β= F(λx.F(xx) λx.F(xx))

**** compatibility
就與Λ的歸納定義的相容性擴展

M -sβ-> N
------------
ML -sβ-> NL
LM -sβ-> LN
λv.M -sβ-> λv.N

*** graph(Λ;-sβ->)
如果使用字符串來是實現形式語言的話
一切都是字符串
``(λx.M)N -sβ-> M*''其實也只不過是字符串
只不過比表達式的集合作爲字符串的集合高了一個層次
並且對這個更高層次的字符串的集合的歸納定義也變得複雜了

然而更好的理解方式是於形成更高層次的語義
+ 比如上面對=α=所作的
-sβ->是一個類似於後繼關係的二元關係
這裏以-sβ->爲有向邊
顯然能形成以Λ中的元素爲節點的有向圖
記爲graph(Λ;-sβ->)

在計算機中實現一個能作λ-cal的語言
其實就是實現graph(Λ;-sβ->)的lazy-eval
+ graph(Λ;-sβ->)是一個無窮圖所以需要lazy-eval
每次計算其實就是給出求出局部的graph(Λ;-sβ->)
只不過這裏的局部是極端的
即只有圖中的一個點
可以說λ-cal的理論就可以理解爲對這個無窮有向圖的局部lazy-eval

而證明λ-cal中的定理就是去證明這個無窮有向圖的性質
比如下面的church-rosser theorem所作的

另外
在機器輔助證明系統中
比如在coq中
tactics就可以被看作是對無窮有向圖的惰性求值

*** -β->
β-reduction

-sβ->類似於後繼關係
-β->是一個偏序關係

-sβ->就傳遞性生成-β->
這種生成即是用有向路來代替有向邊
因此-β->這個二元關係定義爲:
graph(Λ;-sβ->)中的兩個節點之間是存在有向路

1. 以-sβ->爲基礎
   M -sβ-> N
   ----------
   M -β-> N
2. 添加自反性
   M -β-> M
3. 添加傳遞性
   M -β-> N
   N -β-> L
   ----------
   M -β-> L
*** =β=
β-conversion

-β->是一個偏序關係
=β=是等價關係

-β->就對稱性生成=β=
這種生成即是用無向路來代替有向路
因此=β=這個二元關係定義爲:
graph(Λ;-sβ->)中的兩個節點之間是存在無向路
+ path is equality
  -sβ->: 有向邊
  -β->: 有向路
  =β=: 無向路
  構造性的數學中
  數學結構都是歸納定義的
  等價關係自然地被定義爲歸納定義有向樹中的無向路
  + >< 在hott中有的數學結構被稱爲是高階歸納定義的
    比如同倫類
    這是什麼意思???

1. 以-β->爲基礎:
   M -β-> N
   -----------
   M =β= N
2. 添加對稱性
   M =β= N
   ---------
   N =β= M
3. 還要再添加一次傳遞性
   M =β= N
   N =β= L
   ----------
   M =β= L

   + 爲什麼還要多添加一次傳遞性???
     下面錯誤的定義2說明了
     再次添加傳遞性的必要

   + DEFINE2(錯誤的定義):
     M -β-> N
     -----------
     M =β= N

     M <-β- N
     -----------
     M =β= N

     上面這兩個推理規則代替了``或''這個詞
     這樣會有些不好嗎?
     這樣的定義能成嗎?
     能證明對稱性與傳遞性嗎?
     試驗如下:
     因爲
     首先
     M <-β- N
     -----------
     M =β= N
     等價於
     M -β-> N
     -----------
     N =β= M
     所以對稱性的事實是顯然的
     + 我都不想說是證明了
     其次
     M =β= N
     N =β= L
     ----------
     - 有四種引入上面兩個節點的可能性
       我必須說明每種都能推出M =β= L
       1) M -β-> N
          N -β-> L
          ---------
          M -β-> L
          ---------
          M =β= L

       2) N -β-> M
          N -β-> L
          ---------
          此時已經不能推出
          M -β-> L或L -β-> M了
          因此不能推出M =β= L了
          所以這種定義是錯誤的

*** belated definitions
**** compatible
集合Λ上的關係-R-被稱爲是與對集合Λ的歸納定義相容的
如果:
1.
   M1 -R- N1    M2 -R- N2
   -----------------------
   (M1 M2) -R- (N1 N2)
   或
   M -R- N
   -----------------
   (M Z) -R- (N Z)
   (Z M) -R- (Z N)

2.
   M -R- N
   -------------------
   (λv.M) -R- (λv.N)

如果用字符串來實現形式理論
那麼-R-可以被實現爲對第二層次的字符串的集合的歸納定義
也就是說對於形式理論來說
引入一個關係其實是在歸納定義一個集合

**** congruence relation
Λ上與Λ的歸納定義相容的關係-R-
如果是等價關係
+ 即 對稱 自反 傳遞
則稱其爲全等關係:congruence
記爲=R=
**** reduction relation
Λ上與Λ的歸納定義相容的關係
如果是偏序關係
+ 即 自反 傳遞
則稱其爲約化關係:reduction
記爲<-R-
因爲沒有對稱性
所以共軛的有-R->
+ 儘管<-sβ-使用了類似的記號
  但是它並不是reduction relation
  但是考慮有向圖就知道使用<-sβ-這種記號是合理的
  + >< 或者我應該設計更好的記號來區分傳遞性???
**** β-redex
(λx.M)N
就是表達式中模式匹配到的λ-abstraction的application
**** β-normal form (β-nf)
λ-term which dose not have any β-redex
as subexpression
這顯然可以通過用模式匹配來寫一個
表達式的集合上的謂詞來實現
**** M has a β-normal form
if ∃N : M =β= N ∧ N is β-normal form
*** >< church-rosser theorem
**** aim
實現了 <-β- =β= =α= x:A x∈A 這些關係以後
就可以用謂詞演算所提供連接詞與量詞來形成
關於形式理論的一般性質的命題
比如這裏的這個命題就是如此

>< 這個命題所依賴的推理規則屬於什麼形式語言??
不論如何這個命題都不像某些命題那樣迂腐
而是真正給了我們一些關於形式理論的知識

THEOREM:
∀M,N∈Λ s.t. M =β= N
∃L∈Λ : L <-β- M ∧ L <-β- N

這個定理並沒有它看起來的那麼不平凡
因爲
用公式(λx.M)N :== M[x:=N]去定義-sβ->

=β=其實被定義爲<-β-的交換化
即<-β-然後忽略方向
即<-β-添加對稱性
而<-β-被定義爲<-sβ-從有向邊到有向路的生成

對這個定理的證明就是對
關係-sβ->所形成的有向圖graph(Λ;-sβ->)的性質的觀察

**** lemmas
1. if: M is β-nf
   then:
   M -β-> N
   ---------
   N =α= M
   β-nf 作爲有向圖的葉節點當然有這種性質

2. M -sβ-> M'
   ------------
   M[x:=N] -sβ-> M'[x:=N]
   就引入-sβ->的推理規則作歸納證明即可

**** 回到church-rosser theorem
∀M,N∈Λ s.t. M =β= N
∃L∈Λ : L <-β- M ∧ L <-β- N

即

M =β= N
----------
∃L :
L <-β- M
L <-β- N

這樣寫還是沒能脫離謂詞演算
不過好多了
因爲更接近實現方式了

加強其條件如下:
M <-β- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N
或者按書上的說法:
M -β-> N1
M -β-> N2
--------------
∃N3 :
N1 -β-> N3
N2 -β-> N3

加強的條件中排除了=β=
+ 可以看出這是
  爲了證明命題
  而去在等價變換的前提下加強命題的條件
+ 因爲
  M <-β- Z
  N <-β- Z
  ----------
  M =β= N
  所以
  等價變換只需要考慮一個方向
  即是需要在假設:
  M <-β- Z
  N <-β- Z
  ----------
  ∃L :
  L <-β- M
  L <-β- N
  的正確性的前提下
  按引入=β=的推理規則來分類用歸納法證明:
  M =β= N
  ----------
  ∃L :
  L <-β- M
  L <-β- N

  PROOF:
  1. M -β-> N
     -----------
     M =β= N

     此時引入節點M =β= N的父節點是M -β-> N
     而M -β-> N中不包含``=β=''
     所以這個推理規則被認爲是一個``基礎步驟''
     此時沒有歸納假設
     需要證明:
     ∃L :
     L <-β- M
     L <-β- N
     並且已經有假設成立的定理:
     M <-β- Z
     N <-β- Z
     ----------
     ∃L :
     L <-β- M
     L <-β- N
     了
     顯然此時只要取Z爲M就行了

  2. N =β= M
     ---------
     M =β= N

     此時引入節點M =β= N的父節點是N =β= M
     而N =β= M中包含了``=β=''
     所以這個推理規則被認爲是一個``歸納推步''
     此時有歸納假設:
     N =β= M
     ----------
     ∃L :
     L <-β- N
     L <-β- M
     需要證明:
     ∃L :
     L <-β- M
     L <-β- N
     然後由量詞下面那兩項的交換性這是顯然的
     這並沒有用到已經假設成立了的定理:
     M <-β- Z
     N <-β- Z
     ----------
     ∃L :
     L <-β- M
     L <-β- N

  3. M =β= L
     L =β= N
     ----------
     M =β= N

     此時引入節點M =β= N的父節點是
     M =β= L和L =β= N
     而它們中都包含了``=β=''
     所以這個推理規則被認爲是一個``歸納推步''
     此時有歸納假設:
     1) M =β= L
        ----------
        ∃P1 :
        P1 <-β- M
        P1 <-β- L

     2) L =β= N
        ----------
        ∃P2 :
        P2 <-β- L
        P2 <-β- N

        這兩個約束變元被下面當成
        對所取的一個元素的命名了
     需要證明:
     ∃P :
     P <-β- M
     P <-β- N
     使用已經假設成立了的定理:
     P1 <-β- L
     P2 <-β- L
     ----------
     ∃P :
     P <-β- P1
     P <-β- P2
     由<-β-的性質就知道此時存在的P
     就是
     ∃P :
     P <-β- M
     P <-β- N
     中所需要找的P

     EDN-OF-PROOF.

**** 系
1. if: M has N a β-normal form
   i.e. M =β= N ∧ N is β-normal form
   then:
   M -β-> N

   這是非常好的性質
   它說明如果一個λ-term有β-nf
   按一定的方式rewrite下去就一定能得到這個β-nf
   + 按壞的方式rewrite下去可能無限循環

   PROOF:

   M =β= N
   ---------
   ∃L :
   L <-β- M
   L <-β- N

   N is β-nf
   L <-β- N
   -----------
   L =α= N

   L <-β- M
   L =α= N
   ------------
   N <-β- M

   END-OF-PROOF.

2. a λ-term has at most one β-nf

   PROOF:

   N1 <-β- M
   N2 <-β- M
   -------------------------
   ∃L :
   L <-β- N1
   L <-β- N2

   L <-β- N1
   L <-β- N2
   N1 is β-nf
   N2 is β-nf
   --------------
   N1 =α= N2

   END-OF-PROOF.

   這也是很好的性質
   它說明β-nf的唯一性

**** 例子
1. syntactical consistency
   這是推理規則們的性質

   按照上面所引入的這些推理規則
   沒有=α=關係的一對β-nf
   + 比如常量ture和false
   不可能被推出=β=關係
   即不可能證明
   ture =β= false

   因此``語法一致性''在這裏就是=α=於=β=之間的關係 !!!
   後引入的等價關係不傷害之前的等價關係
   即是一致性(或者說相容性)
   但是爲什麼後引入的等價關係有可能傷害之前的等價關係呢?
   首先要知道
   如果用有向圖來實現形式理論的話
   這裏的=α=根本就是不需要被作爲等價關係而引入的
   有向圖之間的本源``等詞''就夠了
   所以在這裏
   這個``之前引入的等價關係''可以被理解爲是本源等詞
   + 畢竟模型輪中的模型關係是相對的
   這樣推理規則不與本源``等詞''相衝突
   就被認爲是一致性
   + 就數學結構而言
     + 數學結構即指 以集合論爲中心的形式語言系統
     與本源``等詞''有關的實現是一個結構的模型
     而形式理論是這個結構的形式理論
   現在再問``爲什麼會產生衝突?''
   因爲:
   1) 對推理規則的引入是任意的
      推理規則是要去形成有向圖
      而
      反而
      要求被引入的以``等詞''爲語義的節點
      + ``等詞''的語義其實就是命題的語義
        而命題在命題演算中的語義就是布爾代數
        在這個模型的約束下
        推理規則不能同時既推出一個命題真也推出這個命題假
        這纔是數理邏輯中的一致性啊
        我在別的文本中討論的是什麼呢?
        也許問題在於這種一致性對一階邏輯的依賴
        如果同倫類型論於一階邏輯是完全不同的形式語言的話
        那麼同倫類型論中一致性也一定有不同的意義
        兩種一致性之間有什麼關係呢?
        它們都是因爲語義的需要而給推理規則作的限制
        + 不光推理規則是可以自由引入的
          那些產生一致性概唸的``限制''也是可以自由引入的
          到這裏就太形而上了
          因爲追問一個語言的語義
          一個人可以永不停止
      不與本源``等詞''衝突纔是一個附加條件
      + 一個啓蒙也許在於
        可以去想辦法具體地度量這種不一致性
        對不一致性的系統度量一定也能給我們很多知識
   2) 推理規則所能形成的有向圖是複雜的
      + 就這裏的-sβ->而言
        -sβ->有向邊所代表的關係
        -β->是有向路所代表的關係
        =β=是無向路所代表的關係



2. (λx.xx)(λx.xx) has no β-nf

   otherwise:
   (λx.xx)(λx.xx) -β-> N
   N is  β-nf

   but:
   (λx.xx)(λx.xx) -β-> (λx.xx)(λx.xx)
   while
   (λx.xx)(λx.xx) is not β-nf

**** 再次回到church-rosser theorem
現在就可以集中精力證下面的東西了

M <-β- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N

這是關係<-sβ-所形成的有向圖的良好性質
它說分開的東西一定有可能被重新融合

***** main lemma

M <-sβ- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N

the way to proof this is similar to
``radioactive tracing isotopes''
in experimental biology

PROOF:

已知 M <-sβ- Z 具體rewrite了那個 β-redex
又已知 N <-β- Z
通過 N <-β- Z 求的 其對邊 L <-β- M
+ 如果在模仿 N <-β- Z 求的 其對邊 L <-β- M 的過程中
  那個β-redex被消除了
  那麼我作模仿的時候就省略這步消除繼續模仿後面的
然後就發現能自然得到
M <-sβ- Z 的對邊: L <-β- N

END-OF-PROOF.

這個證明其實是給出了尋找
L <-β- M
L <-β- N
的算法

***** after the main lemma
在已知:
M <-sβ- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N
成立的條件下
證明:
M <-β- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N

PROOF:

把M <-β- Z拆開成一步一步的<-sβ-
就發現一個算法是顯然的

END-OF-PROOF.

這就證明完了church-rosser theorem
感覺生麼都沒證明
其實是給出了一個算法而已
當然這個結果確實描述着整個形式理論的性質
**** ><><>< remark
church-rosser theorem
所歸結到的那個有向圖的性質很像

``我先定義自由的代數結構
然後給出代數結構的圖論表示
然後說明這個代數結構中的運算律如何對應於
它的圖論表示的圖的性質
也就是說這個性質很像是運算律''

>< 現在一件很明瞭的事就是
我必須傾儘自己的全力寫一個有向圖處理語言
這簡直太重要了

*** >< see and acting
**** fixed point theorem
∀F∈Λ ∃X∈Λ : FX == X
``對每一個函數F都可以構造出它的不動點X''
這當然可以被理解成一個方程了
這樣的對這個方程的可解性的敘述
形成了傳統數學形式語言中的一個命題
但是理解這些需要記號``ͱ''嗎?
先看下面對這個命題的證明再說:
HEURSITIC:
X == FFFFF...(無窮個F作用於自身)
這種東西顯然滿足所給出的方程
F(X) == F(FFFFF...)
== FFFFF... == X
但是這種東西在語法上是不合法的
因此我們定義F*
而F*是那種作用於自身一次就能額外的在外面獲得一個F的那種term
也就是說:F*F* == F(F*F*)
可以說F*對自身的作用就是在形成潛在的FFFFF...
DEFINE:
+ 如何理解這種定義呢?
  這種定義是在另一個變量名的空間找一些名字
  來幫助我們描述我們想描述的東西
F* :== λx.F(xx)
X :== F*F*
然後驗證X就是所求的term:
X == F*F* == λx.F(xx) λx.F(xx)
== F(λx.F(xx) λx.F(xx))
== F(F*F*)
== FX
**** Y combinator
對上面的定理的解法(給出F而構造X的方法)
的抽象(λ-abstraction)
就讓我們得到了Y combinator
∀F∈Λ : F(YF) == YF
只要把term: λx.F(xx) λx.F(xx)中的F
用λ-abstraction抽象出來就行了:
Y == λf.(λx.f(xx) λx.f(xx))
== λfx.f(xx)(λx.f(xx))
**** 關於方程
``λ-cal as a formal theory of equations between λ-terms''
如果我接受∀F∈Λ ∃X∈Λ : FX == X
這種描述方程的方式
那麼我就理解了那句話中的``方程''這個詞的意思

∀F∈Λ ∃X∈Λ : FX == X是謂詞邏輯中的一個邏輯命題
對這個命題的陳述同時還使用了集合論中的概念
這個命題的語義是方程的可解性
其中量詞所引入的F與X都是約束變元

那麼是不是量詞以某種方式給出一些約束變元
然後我用等詞形成這些約束變元之間的等式
這樣所形成的謂詞演算中的邏輯命題就是
一個關於這個等式所對應的方程的可解性的命題
+ 代數就在於方程
  而方程就在於變元的使用
  所以這是當然的
+ 因此我想反過來說更好:
  我先用一些自由變元與等詞形成一個等式
  + 但是這裏變元的類型與等詞的類型都是有待明確的
  然後我在這個等式前面添加量詞
  量詞是擴展了的量詞 即 集合論的語法糖
  當添加適當的量詞 而形成了一個命題時
  我就得到了一個關於
  開始的那個等式的一個方程的可解性的命題

我是通過構造一個解來證明這個命題的
這種構造之所以能形成對這個命題的證明
是因爲我隱含地使用了謂詞演算中的推理規則
現在我試圖把我隱含使用的東西明顯地寫出來
首先∀F∈Λ ∃X∈Λ : FX == X
是(∀F (F∈Λ → ∃X (X∈Λ ∧ (FX == X))))
的語法糖
然後我就不想往下寫了
因爲從這裏就可以看出
一階邏輯與集合論所組成的混雜語
是很不好的 幾乎沒有可用性的形式語言
語法和語義是脫節的
可以用一些抽象層次把這種脫節的現象消除
+ >< 也許在實際對形式語言的應用中
  一個人可以總結出來這樣的一種
  用來彌補脫節現象的形式語言塔

現在我就理解了那句話了
因爲任何一個數學理論
都是一個關於方程的形式理論
只不過 形成方程不一定是等詞而已

並且我還知道了對於任何一個關於方程的理論
重要的是要能``熟練的對等式作恆等形變''
比如``移項''之類的操作
也就是說要``熟悉這種語言的語義''
**** corollary
∀C == C[f,x] ∈Λ
+ 這個等式是對可能存在的依賴關係的明確聲明
  可見等號這個東西是被相當可怕地濫用了的
∃F∈Λ ∀X∈Λ : FX == C[F,X]
+ where C[F,X] == C[f:=F][x:=X]
現在爲了證明這裏給出的方程的可解性
需要構造的是F了 下面給出典型的解法:
+ 根據F所需要滿足的性質來向後計算
+ 熟練的對等式作恆等形變
+ 首先這個解法是以不動點方程的求解公式爲基礎的
  就像解某些代數方程時
  人們可以以二次方程的求根公式爲基礎
  將需要求解的方程轉化爲二次方程
∀X∈Λ : FX == C[F,X]
<== Fx == C[F,x]
<== F == λx.C[F,x]
<== F == (λf.λx.C[f,x])F
+ 上面這步已經化歸成功了
<== F == Y(λf.λx.C[f,x])

APPLICATION:
1. 求F 使得對任意X 有:
   FX == XF
   + 存在和任意X都交換的term T
   此時: C[F,X] == XF
   再寫一遍求解過程作爲練習:
   ∀X : FX == XF
   <== Fx == xF
   <== F == λx.xF
   <== F == (λf.λx.xf)F
   <== F == Y(λf.λx.xf)
2. 求G 使得對任意X,Z 有:
   GXZ == ZG(ZXG)
   + 類似於前面那個一元的交換性
   此時: C[G,X,Z] == ZG(ZXG)
   再寫一遍求解過程作爲練習:
   ∀X,Z : (GX)Z == ZG(ZXG)
   <== (Gx)z == zG(zxG)
   <== G == λx.λz.zG(zxG)
   <== G == (λx.λz.zg(zxg))G
   <== G == Y(λx.λz.zg(zxg))

*** >< normalization
一個λ-term可以形成這樣一個邊標記的有向圖
用來標記有向邊的是β-redex
如何形成這個有向圖是顯然的
+ λ-term M 對應的有向圖被記爲DG-β(M)
  被稱爲reduction graph
church-rosser theorem的證明就被歸結爲
對這種單個λ-term所形成的有向圖的性質的證明

**** strongly normalizing
如果DG-β(M)是有窮的
then M is called strongly normalizing

1. DG-β(M)中的兩條路就是
   對M的兩種rewrite方式
   如church-rosser theorem的證明過程所展示的那樣
   兩條路可以用來交織成一個網
   所以每條路就像是有限圖的一個``維度''
   但是兩條路所交織成的一個網
   的幾何結構
   又比平面上整數形成的晶格複雜的多
2. 有可能沿一個維度圖DG-β(M)是有限的
   + M以這種方式rewrite可以找到β-nf
   而沿另一個維度DG-β(M)是無窮的
   所以M是strongly normalizing
   它就一定有β-nf
   但是就算它有β-nf
   它也不一定是strongly normalizing
**** >< leftmost reduction strategy is normalizing
for a proof see:
barendregt[1984],THEOREM:13.2.2
*** >< bohm trees and approximation
``bohm trees  is a kind of infinite normal form''
**** lemma
every term in Λ
matchs one of the following two patterns
or another:
1. λx1...xn.yN1...Nm
   + where n,m>=0
     pattern-var y matchs var
     + free or non-free both matched by y
     pattern-var Ni matchs term
2. λx1...xn.(λy.N0)N1...Nm
   + where n>=0, m>=1
就集合Λ的歸納定義證明
**** 一些輔助定義
***** head normal form (hnf)
M is called a head normal form
if M matchs
λx1...xn.yN1...Nm
+ where n,m>=0
which must be an λ-abstraction
例:
ac(bc) is a hnf
bc is a hnf
λabc.ac(bc) is a hnf

and the variable matched by y
is called the head variable of M
***** M has a hnf if M =β= N ∧ N is a hnf
***** head redex
if M matchs
λx1...xn.(λy.N0)N1...Nm
+ where n>=0, m>=1
then (λy.N0)N1 is called the head redex of M
**** some property of tree
1. as partially ordered set
2. there is a root
3. each node(point,joint) has
   finitely many direct successors
4. the set of predecessors of a node
   is finite and is linearly ordered
**** >< bohm tree of term M
notation BT(M)
***** >< lemma
***** BT(M) is well defined and
M =β= N
--------
BT(M) = BT(N)
** >< the system λ->curry (systems of type assigment)
*** note about ``ͱ''
推理規則定義表達式的集合
並且給出以這些表達式爲節點
以推理規則爲有向邊的無窮有向圖

上面的type-free λ-cal中的推理規則並不包含``ͱ''
而下面的推理規則包含``ͱ''

此時爲了好的理解還是要去形成圖論的語義
首先要知道
在逐層地構建一個形式語言時
圖的節點一次次地在變化
每次圖的節點都是上次的圖

下面的推理規則所給出的圖的節點是包含``ͱ''的表達式
type-free λ-cal中的推理規則
可以用來處理下面的表達式的``ͱ''的前半部分或後半部分
但是不觸及``ͱ''本身

設計一個以``ͱ''爲核心的語法層次
是爲了做局部的(臨時的)假設
+ 語法上
  假設寫在``ͱ''的前面
  作爲context的內容
也就是爲了在證明的過程中使用``反證法''和``歸納法''等技術

有一些推理規則只不過是在給命題作``恆等變形''
也許是在爲另一些推理規則的使用做準本
+ type-free λ-cal中不觸及``ͱ''的推理規則都是如此
  除此之外還有一些觸及``ͱ''的推理規則也是如此
而另一些推理規則才真正是在``推理''
這裏``恆等變形''值得深入討論
首先這個概念在代數化的看待問題上很有幫助
因爲恆等變形是解任何方程的手段
並且在這裏這個概念就更有意思
因爲有時恆等變形類的推理規則提供的是
同一個語義在不同語法層面上的轉化
明顯地提出這種轉化是否能爲理解這一切提供一個代數的視角??

增加假設 減少結論 會讓ͱ節點變弱
減少假設 增加結論 會讓ͱ節點變強
把ͱ寫成橫線``--------''或者``========''時
ͱ節點就像是分數一樣
可以形成一個正比例函數和一個反比例函數
從代數的角度看
數學論證就是在對這種ͱ節點作恆等變形
如果統一用有向圖來理解代數
那麼這種相似性就是自然的了

*** inductive definition of the set of exp
tvar ::= α | tvar'
type ::= tvar | (tvar -> tvar)
the set of all types is denoted by T

var ::= v | var'
term ::= var | (term term) | (λ var . term)
the set of all terms is denoted by Λ
*** notations
one writes
ͱ M:σ
to assign type σ∈T to term M∈Λ

1. M is called a *subject*
2. M:σ is called a *statement*
3. as a special statement
   x:σ is called a *declaration*
4. a *basis* is a set of declaration
   with distinct variables as subject

``ͱ'' pronounced ``yields''
the thing on the left-side of ͱ
is called *context*
the thing on the right-side of ͱ
is called *conclusion*
*** type assigment
**** inference-rules
a statement M:σ is derivable from a basis Γ
denoted: Γ ͱ M:σ
if Γ ͱ M:σ can be inferenced by the following inference-rules:

+ where the basis Γ is locally presupposed

(x:σ)∈Γ
--------- (axiom)
Γ ͱ x:σ
+ 這個引入表明瞭類型指定可以在局部任意引進
  而下面的``->introduction''
  會把context中臨時引入的類型指定消除

Γ,x:σ ͱ M:τ
------------------- (->introduction)
Γ ͱ (λx.M):(σ->τ)
+ 假設(context)中的類型指定x:σ
  會在這個引入規則中被消除

Γ ͱ M:(σ->τ)
Γ ͱ N:σ
--------------- (->elimination)
Γ ͱ (MN):τ

**** 如果從圖論的角度來理解這種類型系統
那麼節點是帶有``ͱ''的表達式更高一層次的表達式
+ 前面的type-free λ-cal中圖graph(Λ;-sβ->)的節點
  可以看做是省略了``ͱ''的表達式
  因爲在那裏對推理規則的描述還不需要``ͱ''這個記號
基本的``類後繼關係''就來源於上面的兩個推理規則
這就像是在indude-tree(Λ; ∈term-intro1, ∈term-intro2)中的
所有變元節點上釋放一些相同或不同小精靈
沿着有向樹的有向邊旅行時
這些小精靈會按它們路過的有向邊的類型
而在道路的交匯之處於其它的小精靈按規則結成夥伴
+ 上面的推理規則並不能給所有的term附上類型
  比如x:σ,y:τ並不能給出xy的類型
  這是因爲作者簡化了推理規則嗎?

**** 如果我強調λ-abstraction中的約束變元的非本質性
即如果我用有向圖來描述λ-abstraction
那麼
Γ,x:σ ͱ M:τ
------------------- (->introduction)
Γ ͱ (λx.M):(σ->τ)

就需要被改寫爲:
Γ ͱ M:τ
x∈var
σ∈tvar
------------------------------------------ (->introduction)
Γ ͱ (λ:σ.M[free:x := (* --> λ)]) : (σ->τ)
+ 也就是說釋放小精靈的過程也是非本質的
  或者說type assigment的性質基本上就是
  indude-tree(Λ;(∈term introduction1),(∈term introduction2))
  的性質
上面的改寫其實是不對的
因爲它丟失了ͱ的語義

**** examples
1. ͱ (λx.x):(σ->σ)

   ----------- (axiom)
   x:σ ͱ x:σ
   ---------------- (->introduction)
   ͱ (λx.x):(σ->σ)

2. y:σ ͱ (λx.x)y:σ

   ----------- (axiom)
   x:σ ͱ x:σ
   ---------------- (->introduction)
   ͱ (λx.x):(σ->σ)


   --------------------------------- (axiom)
   y:σ ͱ y:σ

   y:σ ͱ (λx.x):(σ->σ)
   y:σ ͱ y:σ
   --------------------------------- (->elimination)
   y:σ ͱ (λx.x)y:σ

**** 這裏我就是在手動實現一個機器輔助證明系統了
都是關於推導規則的
推導規則使用就相當於是在惰性求值一個有向圖
而且 特殊地 這裏的有向圖是一棵有向樹(推理樹)

在實現一個機器輔助證明系統時
在需要的時候一個人可以用show函數之類的東西
打印出易於閱讀的現在的樹是什麼
人機的交流過程 就是單純的對這個樹的操作
推理樹以及其它的底層東西的存儲就是實現者需要設計的了

**** 用對又向圖的操作來理解我使用這個輔助證明系統的方式過程
***** 首先要知道節點是什麼
節點是被``ͱ''連接的東西
``ͱ''的前面是第二層次的若干個表達式的列表
``ͱ''的後面是一個第二層次的表達式

因此節點是第三層次的表達式

要知道``ͱ''的使用是爲了使用複雜的證明技術

***** 基本操作有兩個
1. 引入新節點

2. 根據推理規則i
   從已有的若干個節點:x1,x2,...(在任何位置都行)
   構造一個新的節點:y
   在圖中增添有向邊:
   x1-->y, x2-->y, ...
   也許所有這些有向邊還應該用
   推理規則i的這次使用標記
   + 標記 即是 邊到推理規則的某此使用的映射
   + 注意:
     同一個推理規則的每次使用都是需要被區分的

3. 其實是
   一個無窮的有向圖已經在哪裏了
   我只需要去惰性求值出它的一部分

***** 這樣對每個形式理論的學習就是
1. 對每個具體的推理規則的實現方式的學習
2. 對每個具體的引入節點的規則的實現方式的學習
   比如按規則對
   λx.F(xx) λx.F(xx) =β= F(λx.F(xx) λx.F(xx))
   的肯定
   就是一次對節點的引入

3. 還有對更底層的東西學習
   比如是用:
   + 線性的字符串
   + 有限有向圖
   + 其它的更複雜的數據結構
   來作爲最基本的(或者是某個層次的)表達式

***** 一些哲學話題
1. 什麼數據結構是被形式主義所允許的呢?
   如果只是``線性的字符串''那就太狹隘了
   我想``有限有向圖''是不錯的基礎
   就用機器來實現形式理論而言
   它們二者的基本性是相當的
   對它們的使用
   都可以被理解爲是一個小孩在拿一些積木
   自顧自地做遊戲

2. 應該如何認識一個人可以在這裏所作的選擇呢?
   對於人機的互動而言
   ``線性的字符串''是不可避免的
   或者說只有``線性的字符串''纔是方便的
   但是就人類的理解而言它們又是不方便的

3. 可能對於人了理解來說三維的連續模型是最容易理解的
   對於四維模型人類就無法形成恰當的想像了
   而在一二三維中維數越高越好
   而對於機器來說一維的離散模型是最容易實現的

*** >< pragmatics of constants
這個標題讓人想到關於命名系統的問題
除了單純地用λ-abstraction寫出函數然後進行作用之外
一個良好的命名系統對於實現具有可用性的
機器輔助證明系統來說是非常重要的
因此對形式理論來說也是重要的
+ 這裏可以發現一個要點
  那就是
  對於一個邏輯學的研究者或者學習者而言
  時刻把實現一個機器輔助證明系統
  當做目標
  是非常有宜的
  這個機器輔助證明系統也許並不是研究的終極目的
  但是對``實現''的熱切渴望
  使得人對理論的理解上容不得半點兒的馬虎
  這當然是好的
  一個明確的目標把人變勤奮了
但是作者想要在這個標題下介紹的是這個問題嗎?

其實
constants的使用在於在不違背形式主義精神的前提下
增加第一層次表達式的可讀性
否則的話
var只能是:
v
v'
v''
v'''
v''''
這些東西被當做基本的``字符''了
但是顯然用這些字符構造起來的表達式沒有什麼可讀性
constants的使用就是說
人可以隨時以具有較強可讀性的方式引入新的基本``字符''
比如:
+ type-constant:
  nat
+ term-constant:
  0:nat
  suc:(nat->nat)
這些常量不能作爲約束變元在推理規則中使用
使用了其實也沒關係
因爲反正它們都變成約束變元了 只有局部意義
但是這樣會減弱可讀性 這就與引入常量的初衷相悖了

``ML is essentially λ->curry
extended with a constant Y
and type-assignment Y:((σ->σ)->σ) for all σ''
*** >< λ->curry的性質
**** 首先定義一個作用於basis的函數:dom
let basis Γ :== {x1:σ1,x2:σ2,...,xn:σn}
+ 也就是說使用記號:==來做命名
  關於命名系統還需要更細緻地討論
DEFINE:
dom(Γ) == {x1,x2,...,xn}
+ 上面這個定義被理解爲對字符串
  (更好地應該說 字符串的列表)的操作
  就像substitution這種東西差不多
  但是這裏顯然是在濫用等號了
DEFINE:
Γ(xi) == σi
Γ as a partial function
這裏類型已經亂了
應該定義
proj(Γ xi) == σi
而把Γ(xi)當做proj(Γ xi)的語法糖
+ 但是不理論如何
  這裏都和上面的函數一樣涉及到了濫用等號的問題
let V0 be a set of variables
DEFINE:
Γ↾V0 == {x:σ | x∈V0 ∧ σ == Γ(x)}
這個東西類似於proj(Γ xi)在
第二個自變元的集合上的重載
但是又有區別
+ 如何形式化地理解這裏這些亂七八雜的定義
DEFINE:
σ[α:=τ]
也就是把文本中出現的類型也定義substitution
這就又真真正正是一個字符串的操作了
**** basis lemma for λ->curry
let Γ be a basis
1. if:
   Γ'⊃Γ
   then:
   Γ ͱ M:σ
   --------
   Γ' ͱ M:σ

   這是推理規則嗎?
   如果是 那麼推理規則就不光可以被先驗地引進
   並且還可以被證明 !!!
   所以這一定不是推理規則吧 !!!
   一定不是
   因爲這裏涉及到了集合論裏的東西
   如何排除這些東西呢?
   排除了它們之後還能作證明嗎?
   不排除它們的時候證明是如何被完成的呢?
   我想純粹的形式主義所構建的形式體系
   至少一定是在集合論的語法之外的
   因爲集合論的語法是
   一階邏輯這種形式語言中的一個形式理論
   既然那裏(構建集合論的形式理論時)可以排除集合論的語法
   那麼這裏爲什麼不行呢?
   畢竟如果不排除它們的話類型就又亂了
   即 我所使用的各種形式語言就交織在一起了
   這也許是合法的
   但是這對於理解而言是不宜的

   也許排除集合論的概唸的方式就是把這裏的集合
   理解爲表達式的有序列表(或許應該遺忘列表的有序性)
   這個列表被維持成其中的表達式不相互重複的狀態

2. Γ ͱ M:σ
   --------
   FV(M)⊂dom(Γ)

   這個引理是關於
   對自由變元的類型指定的引入的

3. Γ ͱ M:σ
   --------
   Γ↾FV(M) ͱ M:σ

   這個引理是關於
   在context中消除對
   引入自由變元的類型聲明沒有貢獻的項的

PROOF:
by induction on the derivation of M:σ
也就是就推理規則對Γ ͱ x:σ之類的斷言的引入方式
+ 即 引入這第三層次表達式的方式
  或推理規則對這第三層次的表達式的歸納定義

(x:σ)∈Γ
--------- (axiom)
Γ ͱ x:σ

Γ,x:σ ͱ M:τ
------------------- (->introduction)
Γ ͱ (λx.M):(σ->τ)

Γ ͱ M:(σ->τ)    Γ ͱ N:σ
-------------------------- (->elimination)
Γ ͱ (MN):τ

1. 下面的分類是按Γ ͱ M:σ被推理規則生成的方式來分的
   Γ ͱ M:σ作爲有向圖中的一個節點
   它被添加入有向圖中的方式只有三種
   1) (axiom)
      這是顯然的
      具體的實現設計到對列表Γ的處理
   2) (->introduction)
      已知Γ ͱ M:σ形如Γ ͱ (λx.M):(σ->τ)
      + 這個``已知''顯然是通過一個模式匹配來實現的
      是被Γ,x:σ ͱ M:τ引入的
      在Γ'⊃Γ的前提下
      引入節點Γ',x:σ ͱ M:τ
      + 這裏需要Γ',x:σ還是一個basis
        即它還表示着一個集合
        即作爲列表的表達式其中的表達式不重複
        即需要x:σ不在Γ'中
        (或者是x不在dom(Γ')中???)
      然後就可以引入節點Γ' ͱ (λx.M):(σ->τ)
   3) (->elimination)
      已知Γ ͱ M:σ形如Γ ͱ (MN):τ
      是被Γ ͱ M:(σ->τ)    Γ ͱ N:σ引入的
      在Γ'⊃Γ的前提下
      用集合論中的推理規則(在這裏被實現爲列表處理)
      引入節點Γ' ͱ M:(σ->τ)    Γ' ͱ N:σ
      然後就可以引入節點Γ' ͱ (MN):τ

      現在總結一下這上面的證明是在作什麼
      首先術語上這些命題被某些作者稱爲是``元語言''中的命題
      ``元語言''是就人的理解方式而言
      具有根本性的東西
      我想這裏的:
      ``字符串處理''
      ``列表處理''
      ``有窮有向圖處理''
      其根本性就在於它們能夠用機器來方便的實現
      或者說其中的基本關係能夠用機器來方便的實現
      比如說對``字符串處理''而言的等詞``==''
      對``列表處理''而言的``∈''
      >< 對``有窮有向圖處理''而言有什麼呢???
2. 類似於1.
3. 類似於1.

我需要這些元語言中的命題
這在於
數學的特點就在於
我去用``證明''的形式對我所觀察與思考的東西
形成一些``一般性的''論斷
+ 這裏就用機器實現而言
  論斷的一般性就在於模式匹配
即 數學是一種想要儘可能一般地描述
人們通過觀察所總結到的規律的語言(或行爲)
而 這種對一般性的追求
可能是人們爲了使人們自己能對所觀察到的東西
形成更``經濟的''理解
或者說``更好的''理解

**** generation lemma for λ->curry
1. Γ ͱ x:σ
   ----------
   (x:σ)∈Γ

2. Γ ͱ MN:τ
   ---------------
   ∃σ(Γ ͱ M:(σ->τ) ∧ Γ ͱ N:σ)

   這個命題其實是說
   有向圖中的每個可以模式匹配到Γ ͱ MN:τ的節點
   在圖中都有模式匹配到Γ ͱ M:(σ->τ)與Γ ͱ N:σ的
   直接父節點
   這就像我說:``我坐在地上玩積木
   我一個一個地把積木摞起來
   那麼要麼最上面的積木的下面一定存在一個積木
   要麼最上面的積木的下面就是地面''
   難道我需要形成一個一階邏輯中的命題來描述這個事實嗎?
   用謂詞演算中的命題來描述這個事實
   反而模糊了這個事實
   這就是有窮有向圖的``本源性''

   這裏用到了謂詞演算
   而且連詞是寫在``ͱ''類的表達式之間的
   這下又不清楚了
   >< 可能我必須先重新構造起來一階邏輯的形式體系
   然後才能作我希望作的討論???
   這是不可能的!!!
   因爲這些討論的目的就是爲了脫離一階邏輯的形式體系
   而建立新的形式體系

3. Γ ͱ λx.M:ρ
   ---------------
   ∃σ,τ(Γ,x:σ ͱ M:τ ∧ ρ == (σ->τ))

   這個迂腐的命題和上面的命題一樣值得被批判
**** >< typability of subterms in λ->curry

**** >< substitution lemma for λ->curry
1.
2.
**** >< subject reduction theorem for λ->curry
the subset of Λ that
having a certain type in λ→
is closed under reduction
** >< the system λ->church
*** inductive definition of the set of exp
tvar ::= α | tvar'
type ::= tvar | (tvar -> tvar)
var ::= v | var'
term ::= var | (term term) | (λ var:type . term)

church system與curry system的區別就是
對於church system來說所有的term的集合
的歸納定義變了

*** inference-rules
(x:σ)∈Γ
--------- axiom
Γ ͱ x:σ
+ 集合可以看成是有序列表

Γ,x:σ ͱ M:τ
---------------------- ->introduction
Γ ͱ (λx:σ.M):(σ->τ)
+ 這裏是唯一與curry system不同的地方

Γ ͱ M:(σ->τ)
Γ ͱ N:σ
-------------------------- ->elimination
Γ ͱ (MN):τ

*** ><>< 從圖論的角度理解上面的推理規則所形成的形式理論
*** >< 類型的加入
把類型作爲term的組成部分之後
理論如何變得複雜了?
首先
約束變元是帶類型的
這樣變元的數量就成了一個笛卡爾積嗎?

*** >< -sβ->
DEFINE:
(λx:σ.M)N -sβ-> M[x:=N]
如果這裏對N:σ沒有要求
那麼對於-sβ->來說
``(λx:σ.M)''中的``:σ''就成了虛置的部分
因爲在實際用對字符串的操作實現-sβ->時
根本用不到``:σ''
如果``:σ''不是用來限制N:σ的
那麼它還有什麼用呢?

*** >< basis lemma for λ->church
let Γ be a basis
+ 即一些先驗的變元對類型的屬於關係的列表

1. if:
   Γ'⊃Γ
   then:
   Γ ͱ M:σ
   --------
   Γ' ͱ M:σ

2. Γ ͱ M:σ
   --------
   FV(M)⊂dom(Γ)

3. >< Γ ͱ M:σ
   --------

*** >< original version of λ->
如果寫成:
λx:σ.x:τ
λx:σ.x:τ : σ->τ
那麼:
(λx:σ.x:τ)N:σ -sβ-> ???
N:σ ???
N:τ ???
都不對

實際上所使用的是:
x:σ ͱ x:σ
----------
ͱ (λx:σ.x):(σ->σ)

(λx:σ.x:τ)這種項是不會被引入的

*** >< λ-cube

** >< 用一個遺忘函子來把church轉化成curry (即從範疇論的角度來理解)
遺忘函子就是簡單地把所有對約束變元的類型聲明都刪除

** >< classical logic formal language
*** note
在學習了這麼多形式語言之後
也許改回顧最初所學習的形式語言
既然我已經有了去對比各種語言之間的差異的能力
那麼我對classical logic formal language的理解一定也可以變得更深刻了

而且對於理解propositions as types來說
經典數理邏輯的知識是必要的

*** 回到<<元數學導論>>
模型的方法起初是爲了證明公理的無矛盾性
而且模型的概念具有相對性
這在我想要使用有向圖爲基礎來建立其它形式語言的過程中也可以看出來
因爲我必須還要有一個語言能夠描述有向圖的一般性質
這種對一般性質的描述必然又用到一個形式語言

*** 在傳統的以集合論爲中心的數學的形式化基礎中
人們把某些命題當做證明的目的 即結論
來探索對這些結論的論證
人們希望論證的作爲結論的命題有什麼樣的形式?
我想共同點在於它們都是對一些關係的判斷
而關係是定義於集合的
這樣整個形式體系就是以集合論爲中心的
*** >< logic of statements recovered via curry-howard
傳統的謂詞演算由curry-howard
在類型論中重新實現 ???

** lecture-by-henk
*** readings
#+begin_src emacs-lisp
(eshell-command "ranger ~/learning/lambda-cal/lecture-by-henk/")
#+end_src
[[shell:xpdf ~/learning/lambda-cal/lecture-by-henk/typed-lambda-calculus/readings/introduction-to-type-theory.pdf &][introduction-to-type-theory]]
[[shell:xpdf ~/learning/lambda-cal/lecture-by-henk/typed-lambda-calculus/readings/logical-verification-course-notes.pdf &][logical-verification-course-notes]]
[[shell:xpdf ~/learning/lambda-cal/lecture-by-henk/typed-lambda-calculus/readings/lambda-calculus-with-types.pdf &][lambda-calculus-with-types]]

*** type-free-λ-cal
**** symbol
給出兩個symbol
人們可以區分它們是相等還是不相等
這是一個先驗的假設
**** alphabet
一個symbol的有限集合
**** word
只與alphabet有關
**** language
歸納定義一個word組成的集合
然後稱這個集閤中的元素爲formula或expression
formula于歸納定義的方式有關
常用的進行歸納定義的方法是grammar

>< 我想expression的集合可以是有向圖
**** theory
language的子集
根語義有關
**** combinatory logic(CL)作爲一個形式理論
***** alphabet
ΣCL = {I, K, S, x, ', ), (, =}
***** language
constant := I | K | S

variable := x | variable'

term := constant | variable | (term term)

formula := term =β= term
+ 上面這個應該不出現在這裏
  因爲就我的理解而言它們應該屬於第二層次的exp
***** 模式匹配對=β=的引入
****** note
沒有(λx.M)N =β= M[x:= N]
就是說這個形式理論中
有λ-application
但是沒有λ-abstraction
****** 於ISK有關的
即把第二層次的exp的作爲節點引入一個有向圖(一個推理場景)
+ >< 這個課程想把所有λ-term都編譯到ISK嗎???

in the following P,Q,R are pattern-vars

----------(I-axiom)
IP =β= P

-----------(K-axiom)
KPQ =β= P

----------------(S-axiom)
SPQR =β= PR(QR)

****** 其它引入=β=的推理規則

in the following P,Q,R are pattern-vars

--------------(axiom)
P =β= P

P =β= Q
--------(交換性)
Q =β= P

P =β= Q
Q =β= R
------------(傳遞性)
P =β= R

下面的兩個在一起就等價於
=β=與集合language的遞歸定義的相容性

P =β= Q
-----------
PR =β= QR

P =β= Q
-----------
RP =β= RQ

***** >< cool examples
****** >< doubling
下面的等號代表命名
D :== SII

------------
Dx =β= xx
****** >< composition
****** >< self-doubling, life!
**** >< representing algebraic functions in CL
**** λ-cal作爲一個形式理論
***** alphabet
Σ = {x, ', (, ), λ, =}
***** language
variable := x | variable'
term := variable | (term term) | (λ variable term)
formula := term =β= term
****** 主要的引入=β=的模式匹配
模式匹配用下面的等式來表達
DEFINE:
(λx.M)N =β= M[x:= N]

如果M,N在上面的公式所表達的模式匹配下匹配成功
---------------------------------------------
M =β= N
****** 其它引入=β=的推理規則
in the following M,N,L are pattern-vars

--------------(axiom)
M =β= M

M =β= N
--------(交換性)
N =β= M

M =β= N
N =β= L
------------(傳遞性)
M =β= L

下面的兩個在一起就等價於
=β=與集合language的遞歸定義的相容性

M =β= N
-----------
ML =β= NL
LM =β= LN

M =β= N
--------------
λx.M =β= λx.N
***** bureaucracy
****** substitution
| M       | M[x:=N]            |
|---------+--------------------|
| x       | N                  |
| y(=/=x) | y                  |
| PQ      | (P[x:=N])(Q[x:=N]) |
| λx.P    | λx.P               |
| λy.P    | λy.(P[x:=N])       |
****** variable convention
assume that the bound and free variables in a situation differ

在用字符串來實現λ-cal這個形式語言時
在一個term中如果需要的話總是重命名約束變元
使得它們不與term中出現的其它任何自由變元相同
這樣在進行substitution的時候就不用考慮那麼多了

****** The set of free (bound) variables of M , notation FV(M ) (resp. BV(M ))
******* FV
FV(x) = {x}
FV(MN) = FV(M)∪FV(N)
FV(λx.M) = FV(M)\{x}
******* BV
BV(x) = ∅
BV(MN) = BV(M)∪BV(N)
BV(λx.M) = BV(M)∪{x}
***** =η=
λx.Mx -sη-> M
**** exercises
***** in-class problems
****** PROBLEM3:
******* (a)
π :== λxyf.fxy
<M, N> :== π MN
+ it ``packages'' two λ-terms in one single λ-term
  這是一個笛卡爾積的模型
show that there are π1, π2 ∈ λ such that:
π1 <M, N> -β-> M
π2 <M, N> -β-> N

SHOW:

+ 下面出現的那些外在定義的的東西
  應該和理論中的term用=α=相連嗎?
<M, N> =α= λxyf.fxy M N -ssβ-> λf.fMN
有:
(λf.fMN)L -sβ-> LMN
所以:
L :== λxy.x
LMN -ssβ-> M

L :== λxy.y
LMN -ssβ-> N

所以:
π1 :== (λpl.pl)(λxy.x)
π1 <M, N> -sβ-> (λl.(λf.fMN)l)(λxy.x)
-sβ-> (λf.fMN)(λxy.x) -sβ-> (λxy.x)MN -ssβ-> M

π2 :== λpl.lp(λxy.y)
π2 <M, N> -sβ-> (λl.(λf.fMN)l)(λxy.y)
-sβ-> (λf.fMN)(λxy.y) -sβ-> (λxy.y)MN -ssβ-> N

END-OF-THE-SHOW.

******* (b)
show that for F,G∈Λ there exists F^,G*∈Λ such that
F^ <x, y> -β-> F xy
G* xy -β-> G <x, y>

show that there are T-curry,T-uncurry∈Λ such that
+ 即求一個同構變換
T-uncurry F -β-> F^
T-curry G -β-> G*

SHOW:

F xy
<-sβ- (λf.fxy)F
=α= <x, y> F
<-sβ- (λp.pF) <x, y>
so:
F^ :== (λp.pF)
so:
T-uncurry :== (λf.(λp.pf)) =sugar= (λfp.pf)

G <x, y>
=α= G(λf.fxy)
<-sβ- (λxy.G(λf.fxy)) xy
so:
G* :== (λxy.G(λf.fxy))
so:
T-curry :== (λg.(λxy.g(λf.fxy))) =sugar= (λgxy.g(λf.fxy))

END-OF-THE-SHOW.

******* (c)
check whether
+ 即驗證同構變換的性質
T-uncurry (T-curry f) -β-> f
T-curry (T-uncurry f) -β-> f

SHOW:

T-curry (T-uncurry f)
=α= (λgxy.g(λf.fxy)) ((λfp.pf) f)
-sβ-> (λgxy.g(λf.fxy)) (λp.pf)
-sβ-> λxy.(λp.pf)(λf'.f'xy)
-sβ-> λxy.(λf'.f'xy)f
-sβ-> λxy.fxy
就作用於MN而言f與λxy.fxy相同
=η= f
但是T-uncurry (T-curry f) -β-> f其實是不成立的

T-uncurry (T-curry f)
=α= (λfp.pf) ((λg.(λxy.g(λf.fxy))) f)
-sβ-> λp.p((λgxy.g(λf.fxy)) f)
-sβ-> λp.p(λxy.f(λf'.f'xy))
就作用與<M,N>而言f與λp.p(λxy.f(λf'.f'xy))相同
因爲:
λp.p(λxy.f(λf'.f'xy)) <M,N>
-sβ-> (λc.cMN) (λxy.f(λf'.f'xy))
-sβ-> (λxy.f(λf'.f'xy))MN
-sβ-> f(λf'.f'MN)
=α= f <M,N>
但是T-curry (T-uncurry f) -β-> f其實是不成立的

END-OF-THE-SHOW.

從這個習題可以看出類型系統的必要性
沒有類型系統就不能良好地去描述同構於同態

***** >< take-home problems
**** >< lazy-ski (compiler from lambda calculus to ``lazy-combinators'')
*need pmatch.scm*
#+begin_src scheme :result value :session *scheme* :scheme ikarus
(define occur-free?
  (lambda (y exp)
    (pmatch exp
      [`,x
       (guard (symbol? x))
       (eq? y x)]
      [`(lambda (,x) ,e) (and (not (eq? y x)) (occur-free? y e))]
      [`(,rator ,rand) (or (occur-free? y rator) (occur-free? y rand))])))

(define value?
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) #t]
      [`(lambda (,x) ,e) #t]
      [`(,rator ,rand) #f])))

(define app? (lambda (x) (not (value? x))))

(define term-length
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) 0]
      [`(lambda (,x) ,e) (+ 1 (term-length e))]
      [`(,rator ,rand) (+ 1 (term-length rator) (term-length rand))])))

;; call-by-name compiler to S, K, I
(define compile
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) x]
      [`(,M ,N) `(,(compile M) ,(compile N))]
      [`(lambda (,x) (,M ,y))
       (guard (eq? x y) (not (occur-free? x M))) (compile M)]
      [`(lambda (,x) ,y) (guard (eq? x y)) `I]
      [`(lambda (,x) (,M ,N)) (guard (or (occur-free? x M) (occur-free? x N)))
       `((S ,(compile `(lambda (,x) ,M))) ,(compile `(lambda (,x) ,N)))]
      [`(lambda (,x) ,M) (guard (not (occur-free? x M))) `(K ,(compile M))]
      [`(lambda (,x) ,M) (guard (occur-free? x M))
       (compile `(lambda (,x) ,(compile M)))])))

;; call-by-name compiler to S, K, I, B, C
(define compile-bc
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) x]
      [`(,M ,N) `(,(compile-bc M) ,(compile-bc N))]
      [`(lambda (,x) ,y) (guard (eq? x y)) `I]
      [`(lambda (,x) (,M ,y))
       (guard (eq? x y) (not (occur-free? x M))) (compile-bc M)]
      [`(lambda (,x) (,M ,N)) (guard (and (not (occur-free? x M)) (occur-free? x N)))
       `((B ,(compile-bc M)) ,(compile-bc `(lambda (,x) ,N)))]
      [`(lambda (,x) (,M ,N)) (guard (and (occur-free? x M) (not (occur-free? x N))))
       `((C ,(compile-bc `(lambda (,x) ,M))) ,(compile-bc N))]
      [`(lambda (,x) (,M ,N)) (guard (or (occur-free? x M) (occur-free? x N)))
       `((S ,(compile-bc `(lambda (,x) ,M))) ,(compile-bc `(lambda (,x) ,N)))]
      [`(lambda (,x) ,M) (guard (not (occur-free? x M))) `(K ,(compile-bc M))]
      [`(lambda (,x) ,M) (guard (occur-free? x M))
       (compile-bc `(lambda (,x) ,(compile-bc M)))])))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ski->lanbda converter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; create gensyms
(define fv
  (let ((n -1))
    (lambda (x)
      (set! n (+ 1 n))
      (string->symbol
       (string-append (symbol->string x) "." (number->string n))))))

;; substitution with free variable capturing avoiding
(define subst
  (lambda (x y exp)
    (pmatch exp
      [`,u (guard (symbol? u)) (if (eq? u x) y u)]
      [`(lambda (,u) ,e)
       (cond
        [(eq? u x) exp]
        [(occur-free? u y)              ; possible capture, switch names
         (let* ([u* (fv u)]
                [e* (subst u u* e)])
           `(lambda (,u*) ,(subst x y e*)))]
        [else
         `(lambda (,u) ,(subst x y e))])]
      [`(,e1 ,e2) `(,(subst x y e1) ,(subst x y e2))]
      [`,exp exp])))


;; combinator definitions
(define com-table
  '((S . (lambda (f) (lambda (g) (lambda (x) ((f x) (g x))))))
    (K . (lambda (x) (lambda (y) x)))
    (I . (lambda (x) x))
    (B . (lambda (f) (lambda (g) (lambda (x) (f (g x))))))
    (C . (lambda (a) (lambda (b) (lambda (c) ((a c) b)))))))

;; substitute combinator with their lambda term definitions
(define sub-com
  (lambda (exp defs)
    (cond
     [(null? defs) exp]
     [else (sub-com (subst (caar defs) (cdar defs) exp) (cdr defs))])))

(define ski->lambda
  (lambda (exp)
    (sub-com exp com-table)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; tests
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define to-number `(lambda (n) ((n (lambda (x) (,add1 x))) 0)))

(interp `(,to-number ,(ski->lambda (compile-bc `(,!-n ,lfive)))))
;; => 120
(term-length `(,! ,lfive))
;; => 93
(term-length (compile `(,! ,lfive)))
;; => 144
(term-length (compile-bc `(,! ,lfive)))
;; => 73
#+end_src
*** type-λ-cal
**** church-style
***** grammars
type:
A ::= a | (A -> A)

term:
M ::= x | (M M) | (λ x:A . M)

contexts:
Γ ::= <empty> | Γ, x:A
+ 就是一個list而已

***** note
在形成λ-abstraction的時候
有向圖中不止是要指定帶入點的位置
還需要指出允許被帶入數據的類型

相同的untype λ-abstraction
在指定了不同的類型之後就是相互不同的term了
這些term的類型當然也是不同的

因此用有向圖來實現type λ-cal時
對於λ-abstraction就需要
1. 把需要被帶入的自由變元出現的位置挑出來
   鏈接到λ上
2. 指定一個這種帶入所允許的輸入類型
   並且知道在這些自由變元屬於這個類型的條件下
   整個項的類型是什麼
   即 x:A ͱ M:B 的語義
   然後就可以得到
   ͱ (λ x:A . M) : A->B
   整個這第二點就是推理規則的語義

**** minimal logic
***** note
1. implicational logic
   i.e. only connective is ->

2. intuitionistic
   not classical
   即 推導不出下面的節點
   ͱ ((a->b)->a)->a
   + 它的語義是什麼?
     爲什麼推到不出來它就是非經典邏輯

***** grammar of formulas
A ::= a | (A -> A)
+ 與``類型''的集合的歸納定義完全相同

***** rewrite-rules
****** implication introduction
Γ, A ͱ B
----------
Γ ͱ A -> B

****** implication elimination (modus ponens)
Γ ͱ A
Γ ͱ A -> B
----------
Γ ͱ B

****** example
``if a then it holds that if b then a''
``a implies that b implies a''
a -> b -> a
== a -> (b -> a)

a, b ͱ a
------------
a ͱ b -> a
-----------------
ͱ a -> (b -> a)


in type theory:

x:a, y:b ͱ x:a
----------------------------
x:a ͱ (λ y:b . x) : b -> a
-----------------------------------------
ͱ (λ x:a . (λ y:b . x)) : a -> b -> a

****** BHK interpretation
Luitzen Egbertus Jan Brouwer
Arend Heyting
Andrey Kolmogorov

intuitionistic interpretation of logical connectives:
|-----------------+---------------------------------------|
| proof of A ∧ B  | pair of a proof of A and a proof of B |
| proof of A ∨ B  | either a proof of A or a proof of B   |
| proof of A -> B | mapping of proofs of A to proofs of B |
| proof of ¬A     | proof of A -> 上                      |
| proof of 上     | <does not exist>                      |
| proof of 下     | the unique proof of 下                |
|-----------------+---------------------------------------|
**** styles of logic
***** note
所有這些所謂邏輯風格都應該能簡潔地在grap中實現
因爲它們都是不過是對無窮有向圖的惰性求值而已

***** logic style 1: Hilbert system
****** just one proof rule: modus ponens (MP)
Γ ͱ A
Γ ͱ A -> B
----------
Γ ͱ B

****** axiom schemes
K : A -> B -> A
S : (A -> B -> C) -> (A -> B) -> A -> C

example: proof of a -> a
|---+-------------------------------------------------+--------|
| 1 | (a -> (b -> a) -> a) -> (a -> b -> a) -> a -> a | S      |
| 2 | a -> (b -> a) -> a                              | K      |
| 3 | (a -> b -> a) -> a -> a                         | MP 1,2 |
| 4 | a->b->a                                         | K      |
| 5 | a->a                                            | MP 3,4 |
|---+-------------------------------------------------+--------|
所以I也是可以被推到出來的:SKK =β= I

****** Curry-Howard for Hilbert system
|-------------------+------+---------------------------|
| logic             | <==> | type theory               |
|-------------------+------+---------------------------|
| *Hilbert system*  | <==> | *typed combinatory logic* |
|-------------------+------+---------------------------|
| proof of a -> a   | <==> | SKK =β= I                 |
|-------------------+------+---------------------------|
| deduction theorem | <==> | converting lambda terms   |
|                   |      | to combinatory logic      |
|-------------------+------+---------------------------|

***** logic style 2: sequent calculus
****** notations
sequents:
A1, ..., An ͱ B1, ..., Bm

to be read as:
A1 ∧ ... ∧ An ͱ B1 ∨ ... ∨ Bm

A1, ..., An and B1, ..., Bn are sets, not lists

****** intro/elim versus left/right
for each logical connective *:
- natural deduction:
  intro rules *I (introduction)
  elim rules  *E (elimination)
- sequent calculus:
  left rules  *L
  right rules *R

****** rewrite-rules
1. assumption rule

   ------------- ass
   Γ, A ͱ A, Δ

2. left rule for implication

   Γ ͱ A, Δ
   Γ, B ͱ Δ
   ---------------- ->L
   Γ, A -> B ͱ Δ

3. right rule for implication

   Γ, A ͱ B, Δ
   ---------------- ->R
   Γ ͱ A -> B, Δ

****** example: proof of a -> b -> a
---------- ass
a, b ͱ a
---------- ->R
a ͱ b -> a
---------- ->R
ͱ a -> b -> a

****** cuts
cut rule
Γ ͱ Δ, A    A, Γ ͱ Δ
--------------------- cut
Γ ͱ Δ

但是語義上不是Γ ͱ Δ, A要強過Γ ͱ Δ嗎
這是因爲
如果沒有cut就沒有消去規則了
所以這樣的話
在證明過程中就只能是讓節點的大小遞增
也就是一種不能回頭的證明
而下面的定理說明這種不能回頭的證明總存在

cut elimination theorem:
all provable statements can also be proved with a cut-free proof

****** >< Curry-Howard for sequent calculus
***** logic style 3a: natural deduction, Gentzen-style
****** rewrite-rules
1. assumption rule
   A ∈ Γ
   --------- ass
   Γ ͱ A

2. implication introduction

   Γ, A ͱ B
   ---------------- ->I
   Γ ͱ A -> B

3. implication elimination

   Γ ͱ A -> B
   Γ ͱ A
   ----------------- ->E
   Γ ͱ B

****** example: proof of a -> b -> a
---------- ass
a, b ͱ a
------------- ->I
a ͱ b -> a
--------------- ->I
ͱ a -> b -> a

與前面的minimal logic完全相同

****** intro/elim versus left/right, revisited
1. natural deduction: introduction and elimination rules
   ... ͱ ...
   ----------------- *I
   ... ͱ  ... * ...

   ... ͱ ... * ...
   ----------------- *E
   ... ͱ ...

2. sequent calculus: left and right rules
   ... ͱ ...
   --------------- *L
   ... * ... ͱ ...

   ... ͱ ...
   ---------------- *R
   ... ͱ ... * ...

3. 反正都是要把東西弄到右下角
   ``ͱ'' 與 ``------------''
   其實在兩個不同的語法層次
   提供着相似的語義
   所以在那種語法層次中推進證明都是沒有關係的

4. >< 這帶來了什麼啓示呢?
   我可不可以設計形式語言把不同的語法層次對稱化 ???

****** >< 是否可以列舉出分別易於在intro/elim和left/right中理解的推理的例子
畢竟這些風格被某些人採用正是因爲它們可以方便的用來表達出易於理解的推理過程
****** Curry-Howard for natural deduction
在例子中體會:

---------- ass
a, b ͱ a
------------- ->I
a ͱ b -> a
--------------- ->I
ͱ a -> b -> a

----------------
x:a, y:b ͱ x:a
----------------------------
x:a ͱ (λ y:b . x) : b -> a
----------------------------------------
ͱ (λ x:a . (λ y:b . x)) : a -> b -> a

與前面的minimal logic中所作的對比完全相同

***** >< logic style 3b: natural deduction, Jaskowsky/Fitch-style
這種推理風格的發明
是爲了探索``ͱ''的語義

>< 即當以以``ͱ''爲核心的表達式爲有向圖的節點時
對那些推理規則所形成的節點之間的關係的直觀理解是什麼???

這裏使用了更高維數的模型來理解這一切
太酷了

不過本質上還是樹結構
因爲下面的模型是等價的:
1. tree
2. sexp
3. 圈圈
4. 泡泡

**** >< detour elimination
**** >< consistency
* >< hott
** readings
[[shell:evince ~/learning/hott/readings/hott-online-323-g28e4374.pdf &]]

** 動機
去以構建一個機器輔助證明系統爲目的
也許能幫助人理解這裏的工作

想要提供一個更好的對數學基礎的形式化的動機是
希望能夠設計出可用性更強的機器輔助證明系統

** 關於推理規則
在構造性的數學中
如果我有一個數學結構
+ 按經典的集合論語義來理解
  我所使用的基本集合是我用歸納定義來得到的
然後如果我定義等價關係
作爲歸納定義有向樹中的無向路
對於基本集中的兩個具體元素
我已經有一種方法來判斷它們之間是否具有某個等價關係了

那麼如果我在這裏引入一些推理規則
這些推理規則的應該是什麼樣子的呢?
它們的恰當的地位是什麼?
首先
當引入一些推理規則的時候
我就得到形式理論
這時在這個形式理論和我的數學結構之間
可以問
1. 一致性(協調性,相容性)
2. 完備性
這兩個主要問題
形式理論與數學結構之間的關係
就是形式理論的推理規則與數學結構的基本集中的基本等詞之間的關係
+ 基本等詞(或者其它基本關係)提供了形式理論中的基本命題
當我把形式理論與數學結構之間的一般關係明確了
我就可以
1. 自由地引入推理規則對某個數學結構形成形式理論
2. 把所能形成的各種形式理論
   作爲描述我的數學結構中的那些一般性質的語言
   + 要知道
     能形成什麼樣的命題都是和形式理論有關的
   + 甚至如果我說``形式理論爲我提供了證明的工具''
     那都是不恰當的
     因爲
     1. ``證明''的意義包含於是形式理論本身
        因爲是推理規則在構建以命題爲節點的有向圖
     2. ``去證明什麼樣的東西''也包含於形式理論本身
        因爲是推理規則在決定以基本命題爲基礎
        形式理論中的其它命題長什麼樣
        即如何由基礎命題引入複合命題

>< 在這中思路中類型論的位置又在哪 ???
>< 同倫論和範疇論呢 ???

** 如果我希望把有向圖作爲描述其它形式理論的萬有基礎
那麼如果我把有向圖當做數學結構
有限有向圖作爲數學結構已經是具有可構造性的了
此時我就必須提供關於這個數學結構的一些推理規則
這些推理規則對於我所描述的其它形式理論來說
就像公理一樣
我不可能說我排除了一切的先驗性
因爲我是在用一個形式理論來作爲萬有的基礎去描述其它形式理論
那麼我的這個形式理論就沒基礎了
它就是先驗的了

>< 但是也許這裏的先驗性更容易被接受
因爲有限有向圖對於人們來說是很直觀的

** 等詞的意義
說兩個集合等勢時
它們之間的雙射可以是多種多樣的

說兩個拓撲空間對同倫等價時
它們之間的同倫變換可能是多種多樣的

當我說等詞 M =β= N 成立的時候
在graph(Λ;-sβ->)中
我可能能以很多的方式找到
來對這個等詞形成判定的無向路

除了我的形式語言的基本等詞的判定方式可能是單一的之外
對其它的等詞的判定都是不單一的

重要的是要理解到
對非基本等詞的判定是要找一條路

** formalization (觀點來自俄國人V.V.的演講)
好的形式體化
應該使得各種層次的``等價''都成爲可能

用同倫理論來編碼數學對象就可以實現這一點
+ 這在於證明:
  formalism of higher equivalences
  (theory of higher groupoids)(範疇論)
  ==
  homoptopy theory
但是這種編碼是不可用的
因爲同倫理論本身就是複雜的數學理論

類型論可以在這裏起到它的作用
用來幫助同倫理論對其它數學對象的編碼

因爲類型論提供了直接面向同倫理論的形式語言

關於``不接受'':
用編程界的術語來打比方:
數學家的社區不接受某種東西
可能是因爲
這種東西的syntax沒有良好對應的semantics
+ 比如類型論剛產生時候的處境
+ 而我關於運算的等級的理論是已經擁有了semantics
  但是缺少一種有良好語法的語言來討論這些東西

** type theory
*** 動機
類型論內 每個變元都被指定類型
作下面的考慮就知道這是自然的:
集合論構建在一階邏輯的形式理論的基礎上
而在實際的數學事件中
人們卻直接使用集合論和一階邏輯所構成的
一種混雜形式語言
也就是在用量詞引入約束變元的同時規定約束變元所在的集合
也就是說量詞不是被單獨使用的 而總是與集合一同使用的
這種擴展了的量詞的使用可以被看成是
之使用單純量詞的一階邏輯語言的``語法糖''
+ >< 類型論處理了這個問題嗎?
  也就是要給這種混雜語言一個理論基礎?

*** 類型有兩種語義:
1. 集合
2. 命題
   (a:A是a對A所代表的命題的可證性的見證)

``一個變元對一個類型的屬於''
與``一個元素對一個集合的屬於不同''
後者是一個一階邏輯中的命題
前者是一個證明論層次上的元命題

*** as languages
一階邏輯與集合論
類型論
它們都作爲數學基礎的兩種形式語言
它們之間的關係是什麼?
+ 就像德語與中文之間的關係一樣
  一種語言可以用來介紹另一種語言嗎?

*** functions not are as relations
but are a primary concept in type-theory

*** 推理規則 v.s. 公理
- 類型論:
  動態的推理規則
- 一階邏輯 + 集合論:
  一階邏輯的推理規則 + 集合論的靜態公理

*** polymorphic identity function:
id :== λ(A:U).λ(x:A).x

也就是說表達式中類型所在位置也可以用來作符號代入
但是問題也跟着來了:
後面的λ(x:A)對前面代入的A有依賴性
即只有代入A之後才知道後面的東西的類型是什麼
使得沒法用正常的記號寫出這個λ-abstraction的類型

只能引入記號∏:
id : ∏(A:U).A -> A

∏(A:U).A is just like λ(A:U).A
it is ∏-abstraction,
the type of a ∏-abstraction is not important,
∏-abstraction is for to help people to describe
the type of λ-terms like λ(A:U).λ(x:A).x

所作出來的函數的 前面所需要帶入的類型可以被看做是
對後面所輸入的函數的類型的要求

*** universes and families
同集合論中一樣
這裏需要用類型的universes的層次結構來避免
U∞:U∞所能引起的悖論
1. 每一層次的universes對於cartesian-product封閉
   observing that:
   ordered pairs are a primitive concept,
   as are functions.
2. 每一層次的universes包含前一層次
   這樣規定的不好之處在於
   一個變元所屬的類型不再是唯一的了

同樣也有families的概念
但是既然families是函數那就也應該可以用
類似λ-abstraction的東西來把它們寫出來
這樣就產生了∏-abstraction和上面的
對λ(A:U).λ(x:A).x的類型的記法

*** >< 語言
對比 人類交流語言 程序語言 數學語言 的基本功能

要創造一個人造人類交流語言
我需更要實現的核心功能有那些?

要設計一個新的(一般目的的)程序語言
我需要實現的核心語義有那些?

要給數學基礎設計一個新的形式語言
我需要獲得的核心語義有那些?

這三種語言之間有什麼區別?
首先原料不同
比如語音的需要不同
普通的人類交流語言需要語音
而數學語言完全不需要語音
一個數學家在家安靜地看書 然後給朋友寫信就行了
程序語言也不需要語音

數學語言的基本語義在於能夠聲明我證明了某個東西是真理
也就是說其核心語義在於證明
在於讓將思想概念之間的關係完全形式化
不管是
一階邏輯+集合論
範疇論
類型論
都有推理規則來作證明

發明一種新的推理規則之後
這種推理規則所產生的理論的整體性質是什麼?
那種有向圖的結構所能形成的幾何的幾何性質是什麼?
+ >< 這是我感興趣的
  也許第四級運算的不可能性就是一個整體性質呢?!!!

與類型論相比
一階邏輯與集合論所構成的數學的基礎語言就像一種混雜語
因爲此時公理是在集合論中的
而推演規則是在一階邏輯中的

*** dependent pair types
∑(x:A).B(x)
這個式子作爲類似λ-abstraction的東西
帶入a:A後 在類型公式中的得到的類型是:
A×B(a)

而∏(x:A).B(x)
被帶入a:A後 在類型公式中的得到的類型是:
B(a)

*** how to define functions
to define a function
is to construct elements of A->B

to define a function
is to show the rewrite-rule of it
by some equations
*** natural numbers
the essential property of the natural numbers
is that we can
define functions by recursion
and perform proofs by induction

*** propositions as types
*translation of logical connectives into
type-forming operations*

The basic principle of the logic of type theory
is that a proposition is not merely true or false
but rather can be seen as the collection of
all possible witnesses of its truth

since types classify the available mathematical objects
and govern how they interact
propositions are nothing but special types
namely, types whose elements are proofs

這裏反證法的語義是``直覺主義''的 或 ``構造性的''
¬¬A == (A->0)->0
=/= A

the propositions-as-types versions of “or” and “there exists”
can include more information than
just the fact that the proposition is true

*** >< 類型之間的依賴性爲什麼是重要的?
據說這還是各種形式理論中一直以來所確實的

*** >< 關於應用
機器證明被用來作爲對代碼進行靜態分析的工具
並且已經形成了相關的產業

** syntax
t ::= x | c | f | λx.t | t(t')

f as defined constant
each defined constant has zero, one or more *defining equations*

f(x1,...,xn) :== t
where t does not involve f

f就是rewrite-rule
或者說f用來微觀地定義一個代數結構
+ 比如SKI就是f的代表

** contexts
A context is a list
x1:A1, x2:A2, ..., xn:An
which indicates that the distinct variables
x1, ..., xn are assumed to have types
A1, ..., An, respectively

the context holds assumptions

(x1:A1, ..., xn:An) ctx
------------------------------------Vble
x1:A1 , ..., xn:An ͱ xi:Ai

** methodology
每個基本的東西:
笛卡爾積,等詞,不交併 等等
都是通過給出一個類型而給出的
+ propositions as types是什麼?
  是兩個形式語言之間的關係嗎?
  一階邏輯與類型論??
  兩個形式語言之間的關係是通過模型法而被探索出的嗎??
  當同時爲同一個模型構造兩種形式語言的時候就會出現這種問題了

>< 每次補充定義類型都會增加新的推演規則 ??
這使得這種語言更加靈活

*** formation rule
stating when the type former can be applied

Γ ͱ A:Ui    Γ, x:A ͱ B:Ui
---------------------------Π-FORM
Γ ͱ ∏(x:A).B:Ui

每個證明論意義下的論斷
都必須用``ͱ''來明確其語境(條件)
因此推演規則就是在``ͱ''語句之間的作推演

∏(x:A).B
是這種語言提供的描述類型之間依賴關係的方法之一
比如Γ, x:A ͱ B:Ui
就是包含了對一種對類似的依賴性的描述
也可以理解爲B:A->U

*** introduction rules
stating how to inhabit the type

Γ, x:A ͱ b:B
----------------------Π-INTRO
Γ ͱ λ(x:A).b:∏(x:A).B

*** elimination rules
or an induction principle
stating how to use an element of the type

Γ ͱ f:∏(x:A).B    Γ ͱ a:A
---------------------------Π-ELIM
Γ ͱ f(a):B[a/x]

*** computation rules
which are judgmental equalities
explaining what happens
when elimination rules are applied to results of introduction rules

Γ, x:A ͱ b:B    Γ ͱ a:A
-----------------------------------Π-COMP
Γ ͱ (λ(x:A).b)(a) == b[a/x] : B[a/x]

*** uniqueness principles
(optional)
which are judgmental equalities
explaining how every element of the type
is uniquely determined by the results of
elimination rules applied to it

Γ ͱ f:∏(x:A).B
------------------------------Π-UNIQ
Γ ͱ f == (λx.f(x)) : ∏(x:A).B

** from-video
*** ><
**** note
types are ∞-groupoids
∞-groupoid is a algebra-structure of category theory

workflow:
數學給類型論提供新想法
類型論給數學提供新形式證明方式

type的兩個基本語義:
1. spaces as types
2. propositions as types

同倫不變性對這個形式語言來說是內蘊的
空間的同倫類就是這個語言的基本元素
**** π...1(S^1) = Z(Zahl)
Circle is inductively generated by:
(point) base : Circle.
(path) loop : base = base.

we get free ∞-groupoid with these generators
id
loop^[-1]
loop o loop
inv : loop o loop^[-1] = id
...

***** Circle recursion
function:
f : Circle ->  X
is determined by:
base' : X
loop' : base' = base'
***** Circle induction
to prove ∀x:Circle,P(x)
suffices to prove
1. prove P(base)
2. the proof you give is continuously in the loop
***** π_1(S^1)
π_1(S^1) == 0-truncation of Ω(S^1)
== set of connected componets of Ω(S^1)

to prove:
Ω(S^1) = Z(Zahl)

is to define:
+ 即找同構映射
winding : Ω(S^1) -> Z(Zahl)

is to represent the universal cover in type theory
the universal cover is fibration
in type theory fibration is familiy of types
對fibration的經典定義是保持道路的連續映射
+ path-lifting
  proj : E -> B
  B中的path:
  path-of-B : p(e) =B= y
  的逆像是E中的path:
  proj^[-1](path-of-B) : e =E= p^[-1](y)
  主意這裏通過固定一個E中的e點來簡化說明

語義上映射的像集被映射的定義域纖維化
實際上是一個空間被令一個空間參數化
這就自然得到了fibration在type-theory中的表示

fibration = familiy of types
+ 也就是說fibration是familiy of types的語義之一
  familiy of types還有邏輯學上的語義
notation:
(E(x))_x:B
+ 語義上 即B對空間E的參數化
  給出一個參數b:B後E(b)是E的子空間
  因此E(x)所描述的依賴關係就是上面的proj^[-1]
Π x:B . E(x)
((Π x:B . E(x)) b) --> E(b) == proj^[-1](b)
where E(b) is a type (a fiber)

語義中對path的保持性由下面的式子捕捉:(transport)
∀ path : b1 =B= b2
gives equivalence E(b1) == E(b2)
什麼意思?
B中的道路給出高維度的道路嗎?

so here we have the universal cover:
(Cover(x))_x:S1
DEFINE:
Cover(base) :== Z(Zahl)
transport_Cover(loop) :== successor
即定義纖維化就是去
定義纖維
+ 這裏是:Cover(base) :== Z(Zahl)
然後定義lifting the path的時候所給出的纖維上的變換是什麼
+ 這裏是:transport_Cover(loop) :== successor
  transport_Cover(loop o loop) :== successor o successor
  等等
DEFINE:
winding : Ω(S^1) -> Z(Zahl)
(winding path) :== ((transport_Cover path) 0)
+ 我用lisp的語法了要不然歧義太大

https://video.ias.edu/sites/video/files/ams/2012.restore/2012/MembersSeminar/Licata-2012-11-26.hi.mp4
and about group
https://video.ias.edu/members/rivin

**** >< the hopf fibration
*** constructive-type-theory-and-homotopy
**** about equivalence
在我對λ-cal的理解中
t:Λ這樣一個類型聲明甚至都是構造性的
它說明t是無窮有向圖graph(Λ;-sβ->)中的一個節點
而p:Id_Λ(a,b)說明
p是graph(Λ;-sβ->)中的兩點a,b間的一條有向路
+ 或者寫成p:a =β= b這樣寫的話就更明確了``Id_Λ''的意義
  因爲對每個類型(比如這裏的Λ)可能可以定義不同的等詞
  比如我可以寫α:Id_(Id_Λ)(p,q)
  但是這裏我需要知道類型(或空間)Id_Λ中的等詞是什麼
  當Λ是一個拓撲空間時α:Id_(Id_Λ)(p,q)就是
  道路p,q之間的homotopy
  但是當Λ是λ-term的集合時上面的類型(Id_Λ)(p,q)中的等詞又是什麼呢?
  考慮這樣一個有向圖:N
  它的節點是二維平面上的所有整數點
  有向邊是橫座標或者縱座標上的後繼關係
  這樣的圖中顯然(Id_N)(p,q)中的等詞是有自然定義的
  因爲我可以相像一條無向邊在這個圖中的``連續移動''
  對於圖graph(Λ;-sβ->)來說當然也可以有這樣的理解
  太棒了

但是問題是在類型論中對t:Λ這樣的聲明是如何理解的?
是先驗的嗎?
是隨意引入的嗎?
是構造性的嗎?
來形式化Id概唸的推理規則是下面這樣的:

A:type
----------------------- Id formation
x,y:A ͱ Id_A(x,y):type
+ 那麼對應於Id_A的等詞只能是單一的了???
  這樣的情況是可以接受的嗎??

a:A
---------------- Id introduction
r(a):Id_A(a,a)
+ r denotes reflexivity

x,y:A, z:Id_A(x,y) ͱ B(x,y,z):type
x:A ͱ b(x):B(x,x,r(x))
---------------------------------------- Id elimination
x,y:A, z:Id_A(x,y) ͱ J(b,x,y,z):B(x,y,z)
+ heuristic:
  x = y
  B(x,x)
  -------
  B(x,y)

a:A
----------------------------------- Id computation
J(b,a,a,r(a)) = b(a) : B(a,a,r(a))
+ ``bookkeeping of witness-terms''
  什麼意思???

**** about dependent
dependent types are fivrations
so x:A ͱ B(x) has the following lifting-property

x:A ͱ B(x)
---------------------
x:A y:B(x) ͱ y:B(x)
-------------------------------
x:A ͱ (λ y.y) : (B(x) -> B(x))

p:Id_A(a,b), x:A ͱ (λ y.y) : (B(x) -> B(x))
----------------------------------------------??用到Id-elim嗎??
p*:B(a)->B(b)

A中的路p:Id_A(a,b)
被舉到B空間族裏
就成了兩個纖維B(a),B(b)之間的映射

p*:B(a)->B(b)
a^:B(a)
-----------------
p*(a^):B(b)

**** homotopy interpretation of type theory
concrete:
|-------------------+------+-----------------------------|
| type              | <==> | space (homotopy type)       |
|-------------------+------+-----------------------------|
| term              | <==> | map                         |
|-------------------+------+-----------------------------|
| a:A               | <==> | point a:1->A (a map)        |
|-------------------+------+-----------------------------|
| p:Id_A(a,b)       | <==> | path p from a to b in A     |
|-------------------+------+-----------------------------|
| h:Id_(Id_A)(p,q)  | <==> | homotopy h from p to q in A |
|-------------------+------+-----------------------------|
| dependent type    | <==> | fibration                   |
| x:A ͱ B(x)        |      | map:B -> A                  |
|-------------------+------+-----------------------------|
| identity type     | <==> | fibration                   |
| x,y:A ͱ Id_A(x,y) |      | map:Id_A -> (A x A)         |
|-------------------+------+-----------------------------|

>< abstract:
even better
we have abstract axiomatic description
via Quillen model categories
only need weak factorization system of it

沒有範疇論的基礎weak factorization system我還沒法理解
只知道weak factorization system與上面的四個推理規則完全契合

* >< graph-grammar
** readings
[[shell:xpdf ~/learning/digrap/graph-grammar/graph-grammars--an-introduction-to-the-double-pushout-approach.pdf &][graph-grammars--an-introduction-to-the-double-pushout-approach]]
基本而比較系統的介紹 內容豐富

[[shell:xpdf ~/learning/digrap/graph-grammar/hyperedge-replacement-graph-grammars.pdf &][hyperedge-replacement-graph-grammars]]
一般介紹

[[shell:xpdf ~/learning/digrap/graph-grammar/graph-grammars-and-operations-on-graphs.pdf &][graph-grammars-and-operations-on-graphs]]
非graph-grammar之一般介紹
而描述把字符串解釋成對圖的操作的解釋器

[[shell:xpdf ~/learning/digrap/graph-grammar/concept-formation-using-graph-grammars.pdf &][concept-formation-using-graph-grammars]]
根機器學習有關的:
從一些圖中學習出一種對這類圖的graph-grammar

[[shell:xpdf ~/learning/digrap/graph-grammar/a-graph-grammar-methodology-for-generative-systems.pdf &][a-graph-grammar-methodology-for-generative-systems]]
關於:
graph transformations
自動機的設計 於 人工智能

[[shell:xpdf ~/learning/digrap/graph-grammar/context-free-graph-grammar.pdf &][context-free-graph-grammar]]

** note
考慮同倫論中的粘貼方法
比如cell-complexes的定就很像是遞歸定義
根這裏提供的語法有些類似嗎?

** >< handbook-of-graph-grammars
[[shell:xpdf ~/learning/digrap/graph-grammar/handbook-of-graph-grammars-and-computing-by-graph-transformation.pdf &][handbook-of-graph-grammars]]
*** node replacement graph grammars
**** note
首先要明白這裏想做的是用一種形式語言
來歸納定義一個有向圖的集合
而不是用一種形式語言描述對有向圖的操作

就像用有限狀態機可以寫出一個謂詞來代表一個字符串的集合一樣
這裏在好的條件下也可以寫出一個謂詞來代表一個有限圖的集合
+ so called recognizing string-language and graph-language

但是與考慮字符串的時候一樣
對有限圖的處理就是另一回事了

圖中的每一點在replacement-rules的作用下可以爆炸開來形成一個子圖
這個子圖的中的點會被用新的邊與原來的圖中的節點連接起來
+ >< 這與對無窮有向圖的惰性求值有什麼關係??
  這給出了一種方式來惰性求值一個無窮有向圖嗎???

**** production
a production is (M,D,E)
M : mather
D : daughter
E : embedding mechanism

a production can be applied to H
H : host graph

to apply is (M,D,E) on H
is to replace M in H by D
and attach D to H/M by E

two main type of embedding:
1. gluing
   定義是顯然的
2. connecting
   定義是顯然的
   + note that
     there are old edges between M and H/M
     has been removed during the application

two main approaches of graph-grammars
1. the gluing approach
   (the algebraic approach)
2. the connecting approach
   (the algorithmic approach)
   (the set approach)

>< -β->顯然可以用上面的方法來描述

**** NLC and edNCE
NLE : note ladel controlled
NCE : neighbourhood controlled embedding

**** NLC
此時被操作的對象是無向點標記圖
M : 單個的節點
E : connecting embedding

production形如X->D
其中X是一個對H中node的標記

connecting instructions:
E == ((μ1 . δ1) (μ2 . δ2) ...)
+ the so called connection relation
當(M,D,E)中的M是單點m時
a-list中的項(μ,δ)表示需要連接
m的neighbourhood中被標記爲μ的點
與D中被標記爲δ的點

>< 當我寫下一個MN時
對application的理解有兩種方式
一個是M作用於N 一個是N作用於M

an NLC graph grammar is
notation:
G == (Σ, Δ, P, C, S)
L(G) : 歸納定義的有向圖的集合

**** edNCE
C-edNCE:
C- denote confluent
d denote directed
e denote edge ladels in addition to node ladels

** >< deterministic graph grammars
用圖語法來生成正規無窮有向圖
*** notations
deterministic graph grammar =generate=> regular graphs

** ><>< about
看前人寫的論文越看越覺得它們愚蠢
沒幾個人在論文裏用他們所創造的語言畫出多少有意義的圖來

* misc & remarks
** PLATONISM
*the world of mathematics exists independently of the mind of the mathematician*
*every statement that makes mathematical sense is either true or false*
statement that makes mathematical sense are called proposition
** BROUWER
*the foundation of mathematics is in the intuition of the mathematical intellect*
*proof by contradiction is not an acceptable proof rule*
** ><
`if ... then ...'
is different form
`thus' `therefore' `so' `hence' `since'
in mathematical reasoning (about the rules of inference)

converse and contraposition

bi-tree of proposition
=connectives=>
proposition

open proposition
=quantifiers=>
less-open proposition

quantifiers:
if is there is no set theory at first
how can there be quantifiers ?
by inference-rules of course
and by the following sugar
∃x∈A(...) :=sugar= ∃x(Ax∧...)
∀x∈A(...) :=sugar= ∀x(Ax∧...)
and there are matter of scope
just as in the case of λ-abstraction

function:
f: X -> Y
∀x∈X∃!y∈Y(xfy)
here comes another kind of scope problem
about dependence
∀x∈X∃!y=y(x)∈Y(xfy(x))

scope problem should always solved by graph theory

inference-rules:
(A A→B) ==> B
C→A(x) ==> C→∀xA(x)
A(x)→C ==> ∃xA(x)→C


rewrite-rules are about computation
but inference-rules are not
>< do not have a computational nature ??
>< yes ???

``the quantiers usually range over
an infinite set and therefore one loses decidability''

``Aristotle had already remarked that it is often hard to find proofs
but the verification of a putative one can be done in a relatively easy way''

so i should write something to help to show a math proof

A more eficient way to represent proofs employs typed lambda terms
and is called the propositions-as-types
which maps propositions into types
and proofs into the corresponding inhabitants
>< how about axioms ?

* hacking
** 關於無窮有向圖的惰性求值
1. 對無窮有向圖的處理只能是惰性的
   機器需要知道的是如何在需要的時候到達這個圖中的任何一個節點
   當機器已經有這樣的知識之後
   既然關於這個圖的一切已經蘊含於這些知識當中了
   我如何能表達關於這個圖的一般性質
   我現在只知道對這些性質的表達一定是在一個更高層次的語言中進行的
2. 既然實現一個形式語言被我理解爲
   實現對一個無窮有向圖的惰性求值
   我想最適合用我的語言實現的語言應該是
   一些製作形式語言的工具
   + 首先hott中各種關於語言的實驗在我的語言中就方便多了
3. 更廣泛的
   當我能方便的處理有向圖時
   因爲使用了一個性質更豐富的基礎數據結構
   在使用這個語言的時候對於很多事情都能產生新的想法
   尤其是關於計算的理論
   還有關於數學
** 關於範疇論於運算級
既然我已經給出來了自由代數結構這個基礎
>< 那麼我關於運算級的想法是否可以用範疇論的語言來表達??
+ 不可以
  因爲範疇論不適合用來描述具體的(構造性的)數學結構
  要知道在最開始發展等級理論的時候我就是要發展彌補範疇論的這種弱點的方法
>< 級數的升高惡化着級數升高的條件
使得級數的繼續升高成爲不可能???
** as language
最沮喪的時候
也要知道
hott是關於語言的學問
因爲我已經發現
在回到更傳統的數學活動當中時
我的思考方式和表達方式
已經被λ-cal與類型論完全改變了
我想更深刻的
改變我的認識與方法的是
1. 對形式語言的學習
   增強了我對數學概唸的表達能力之外
   還讓我形成了排斥形而上學的習慣
2. 對計算理論的學習
   現在在方法上面我更注重可構造性和可實現性
** 關於極簡主義
我已經知道該如何去推廣λ-cal以形成一個數學背景
來設計我的語言的語法了
只是還有一兩個問題沒有想通

除此之外對於理論的創造而言有一個重要的哲學觀點需要被我認同
那就是極簡主義
``programming languages should be designed not by piling feature on top of feature
but by removing the weaknesses and restrictions that make additional features appear necessary''
-- R5RS

但是我很難遵循極簡主義
因爲我處理的問題本身的複雜性
但是這只不過是一個藉口而已
``有很多方式可以建立幾何學
但是是歐幾里得說明我們只需要五個公理''
古代的人也許也認爲那種幾何是複雜的呢

那麼我需要作的就是看到有向圖處理的本質

但是也許我的整個計劃就是在違背極簡主義

* --------------------------------------------------
* ζ-cal
** note
也許最後我會發現我所尋找的解決辦法極其簡單
只不過我一直沒能認清一直就在我眼前的事實而已
abstraction與application的意義本來就是相當廣的
比如λ-abstraction對rewrite的抽象可以是就有向圖而言的
我稱這種廣義的λ-cal爲ζ-cal
ζ-cal == basic-directed-graph-processing
       + ζ-abstraction
       + ζ-application
       + ζ-lazy-eval
** my understanding of λ-cal
λ-ap是對葉節點被自由變元標號了的
分叉數爲2或1的樹(有向圖)的遍歷
其中每次遍歷到λ-ap的時候樹就會按<-β-所描述的規則變化
1) λ-ab的局部性:
   對一個葉節點對的處理並不會影響這個葉節點對之外的圖的其他部分
2) λ-ab的形成的任意性:
   以任意一個term爲基礎
   然後指定一個自由變元
   就可以形成一個λ-ab
   之後這個自由變元就變成約束變元了
** 類比
1) 用鏈表來實現λ-cal
   之後寫出複雜的列表處理的函數就全在於λ-cal了
   此時還需要對rewrite(比如-β->)的實現
   即一個解釋器
   + 此時需要對約束變元作技術性的處理
     要麼用重命名的方法
     要麼用用有向圖來處理
   + 反過來λ-cal可以完成對鏈表的處理
2) 用有向圖處理來實現ζ-cal
   反過來這種ζ-cal可以完成對有向圖的處理
   之後寫出複雜的有向圖處理函數就全在於ζ-cal了
   + 有了這層語義
     就算是對有向圖這種複雜數據結構的處理
     也能使用函數式編程範式了
3) 類比還在於 我能把λ-cal包含在ζ-cal之內
** ζ-cal作爲λ-cal的推廣
下面的理解最重要:
應該把λ-cal也理解爲一個對二叉樹的惰性求值系統
+ 用樹來考慮下面的東西
尤其是考慮到絕對的自由變元時更應該如此
那麼這種惰性求值系統的特點是什麼呢???
有所謂的惰性求值之後就能用有限的元素來表達無窮的結構
那是因爲對與這種圖人們規定了一種特殊的遍歷方式 即-β->
並且要知道 一個term是不是λ-abstraction都沒有關係
對λ-abstraction內部的東西也是可以進行求值的
λ-abstraction並沒有特殊性
+ 難點在於當遍歷到一個λ-application時
  它本身與周圍的圖的鏈接方式是平凡的
  它求值之後所得的東西與周圍的圖的鏈接方式也是平凡的
  但是對與一般的有向圖這一點並不成立
  這裏的複雜性可能是本質的
  也就是說ζ-cal必須描述兩種鏈接方式
  + 但是如果有局部性的話 如何呢?
    整個式子((ζ <body>) <arg>)是以某種方式嵌在一個被遍歷的大的圖中的
    <body>的外圍與外面的大圖的鏈接方式是已知的
    而<arg>被代入<body>所改變的邊並不影響<body>的外圍與大圖的鏈接
    這就是局部性
    但是問題又回來了
    即 這樣就沒法把(ζ <body>)當作一個獨立的東西了
    只有當指明瞭<body>與大圖的鏈接方式的時候(ζ <body>)纔有意義
    或者(ζ <body>)可以被當作獨立的東西
    但是每次被放入大圖中的時候都必須說明<body>中
    沒有被ζ的抽象所影響的部分如何與大圖相鏈接
    沒錯
    這是合理的
    因爲在有向圖處理中擴大一個圖就是去說明一些複雜的鏈接方式
    這樣一個重大的問題就解決了
    + 可以說就幾何直覺而言現在已經沒有任何難點了
    還有一個重要的問題就是形成遞歸
    這將是要在下面提到的
    即 形成具有無窮性的結構(比如遞歸)的本質不在於巧妙的term
    而在於自我引用
在有向圖處理中
在一個需要惰性求值的點處對原圖的其他部分的引用也是可以想像的
+ 畢竟λx.F(xx) λx.F(xx)之所以能形成遞歸對遞歸函數的定義
  是因爲前面的λ-abstraction作用於與自身相同的λ-abstraction
  或者說前面的λ-abstraction在作用於自身
類似於分形的圖是經過無窮次的遞歸得來的
因此就與fixed-point有關
因此也與遞歸有關
+ 考慮Y所生成的遞歸函數作爲無窮二叉樹的性質
  那也是分形
  因爲那是在-β->的特殊指引下自身在引用自身
  這就是分形的本質
  也是那些正規的無窮圖的本質
** 對圖的基本處理
有以下基本操作:(其實ζ-cal本身就也是被基本的有向圖處理實現的)
1. 利用樹來初始化一個圖
2. 將兩個圖用一些新的有向邊相連
3. 刪除某些節點
4. 刪除某些邊
5. 改變某個點或邊中所存放的東西
   點和邊裏是可以存放東西的
   而且沒有類型的限制想存放什麼就存放什麼
   就像lisp的list能夠保存任何類型的數據一樣
   我需要我的有向圖也有能力保存任何東西在裏面
** ζ-abstraction (ζ-ab)
對於一個圖 指定其中的一個基點
1. 以這個基點爲基礎用一棵樹來指明一個有序節點列
   這個有序節點列是爲之後的"擴大"所準備的接口
   當這些接口被拼接時這個圖會被擴大
2. 以這個基點爲基礎用一棵樹來指明一些將被刪除的節點
   這樣會使這個圖縮小
3. ><><>< 那麼其他的對圖的操作如何呢???
   這就是所有的操作嗎???
4. >< 可以變大可以變小我就掌控了所有的變化 ??
5. 所列出來的兩個點列中
   哪些點會被刪除或者哪些點會被鏈接
   都是要等到ζ-application的時候纔會被明確的
6. 整個ζ-abstraction也是一個特殊的圖而已
   只要使用從一點出發的一些有向邊來指明一次抽象中的
   接口節點列和所能刪除的節點列 就行了
   這樣我就可以利用ζ-abstraction把某一類型處理抽象出來
7. 一個ζ-ab作爲一個gexp
   就像一個小機器一樣
   在ζ-cal的語義中它以其中被抽象了的點爲接口
   對於一個ζ-ab(as gexp)我可以實現一些基本的函數來查看它作爲機器的性質
   比如:
   1) 詢問這個ζ-ab中所有被抽象了的點
   2) 詢問一個點的接口點列和可刪除點列
   3) 等等
   4) 這些詢問所返回到的信息應該能直接被ζ-ap中的ζ-con利用
** ζ-application (ζ-ap)
這時候我手上有兩個ζ-ab
就像我知道一個函數(λ-abstraction)的性質一樣
+ 函數的:參數個數與類型 返回值個數與類型
  其中個數不是本質的類型纔是本質的
在這裏我也知道ζ-ab的性質:
1. 它所能刪除的點列
2. 它的接口點列
一次ζ-ap就是:(注意只有兩個ζ-ab才能被作用)
ζ-ap == (ζ-ab ζ-con ζ-ab)
其中ζ-connection是對連接方式的描述
+ 注意這看起來是對稱的
ζ-ap也是用一個圖來表述的
這樣一個ζ-ap的結果就可能是一個新的ζ-ap
+ 對ζ-ab的處理就是一個需要類似於解釋器的東西的地方!!
+ 雖然不是類型系統
  對接口與連接方式的匹配的要求
  同樣也是對函數的輸入與輸出的限制
  也許引入適當的語義
  我就能以這種方式給出一個類型系統的模型
** ζ-lazy-eval
1. 這是很樸素的想法
   即上面的ζ-ap是真正被遍歷到的時候纔會被進行的
   因爲ζ-abstraction也是用一個圖來實現的
   所以這種lazy-eval很容易實現
2. 對於lazy-eval這個詞
   其實還可以有不同的理解
   因爲這裏所描述的惰性
   並不是primitive的惰性
** 關於嵌套與自我引用
1. 其實也很簡單
   ζ-ap的嵌套是自然的
   一個ζ-ap的結果就可能是一個新的ζ-ap
   它使得對某個圖的遍歷方式變得複雜
2. 而自我引用就是沿着新的邊走卻又走回了原來的節點
   這些一起使得可以形成複雜的無窮圖
** 關於透明性
所謂透明性就是把ζ-abstraction於ζ-application都表示成有向圖
這樣我可以完全剔除約束變元
而解釋器對ζ-cal的實現就是有向圖處理
** 再次回到基本操作
1. 顯然只要基本操作不改變ζ-ab中的接口點列中的點
   那麼任何操作都是合法的
   也就是說ζ-ab是可以被基本操作來作用的 它們跟一般的圖沒什麼區別
2. 基本操作甚至可以形成手術
   來改變描述ζ-ab中的接口點列和可以被刪除的節點列的有向邊
   這就是透明性所帶來的好處
   任意一個用圖描述的圖的算法
   都是一個圖而已
   可以很容易的拿出來修改與考察
** >< 關於代數
如果我希望作類比
那麼就應該有更完整的類比
即 λ-cal的代數的一面也應該被類比到
這看似異想天開
因爲一般的代數結構自然的會形成二叉樹
但是這其實並不是不可能
考慮一下高維同論羣就知道了 !!!

考慮跟λ-cal有關的豐富的數學理論:
範疇論 代數拓撲 等等
可想而知ζ-cal這種計算模型的背後所隱含的數學理論是非常新而豐富的

比如我可以嘗試先在λ-cal的圖論意義和λ-cal的代數意義之間建立一種關係
然後再利用這種關係從ζ-cal的圖論找到ζ-cal的代數意義

但是這幾乎是不可能的
因爲在進行一個ζ-ap的時候
我不光只需要那兩個ζ-ab而已
我還需要一個額外的東西來指明這兩個ζ-ab如何相鏈接
這已經出離一般的代數結構之外了

但是也沒有出離的太遠
畢竟這是不過是:
(ζ-ab ζ-con ζ-ab) -> ζ-graph
+ ζ-graph == gexp

既然如此
其實代數意義就已經喪失了

如果只是在遍歷圖的時候其中的一些部分被惰性求值
那麼如何觸發一次ζ-ap的進行??
這一點還沒想清楚
完全的惰性求值就沒有這種顯式的觸發
也許增加一個可以控制ζ-ap的觸發的機制
我就能實現對求值時間的控制

如果我固定一種(或某些)ζ-con
並且將ζ-ab一一定那個的方式封裝起來
我就很容易回到一種代數語義
比如利用上面的方法我可以回到λ-cal
** >< 例子(需要更多的例子)
對那個無窮五星圖
遍歷到中點的鄰點時需要把中點代換爲一個五星
然後把代入的五星與原圖相連
這就是用惰性求值的ζ-ap來實現的
但是完全自我引用就會形成循環
所以對自我引用應該至少提供兩種處理方式
1. 一種會形成真正的新的節點
2. 而另一種不會
對於形成真正的新節點者
自我引用是假的
自我引用只是提供了一個和自己相同的模板來擴大這個圖
** >< 打印
我需要對文件的結構化讀寫 這裏有是一個新的設計領域
>< 打印可以用支撐樹來作嗎?
圖中也許必須包含一些額外的信息來建議如何把一個圖打印出來
** 何謂用圖來表示對圖的操作?
即對圖的遍歷方式有兩類
一類是按語法遍歷
一類是按語義遍歷

按語義遍歷就是說 像((λ ***) ***)節點對一樣被<-β-處理一樣
這樣我就能夠把ζ-abstraction在圖中利用其它ζ-abstraction的作用來代來代去
然後形成ζ-ap
ζ-ap的返回值可能還是ζ-ap
+ 有一步的-ζ->和多步的-ζ->
  即我能控制求值的方式
我的圖的表達式中也要有匹配到某種模式的圖被按語義處理
這需要一些設計 但是簡單的
重點是所有這些必須都用有向圖處理來實現
** 關於編程範式的形成
純粹的(只有變量沒有常量)λ-cal是用list來表示處理list的算法
+ 或者說 是用λ-term來表示處理λ-term的算法
  其實只是代入而已 所以說成是list更確切
增添上常量之後就形成了函數式編程系統
lisp中list的一個特點是 list中可以包含任何其他類型的數據
這些常量就是用來處理這些數據用的
+ 在scheme中:
  atom: 非list類型的數據
  primitive: 處理這類數據的函數

這樣就給了digrap以啓發:
ζ-cal是用directed-graph來表示處理directed-graph的算法
directed-graph的點和邊中可以包含其他類型的數據
對其他類型的數據的處理用primitive來完成

>< 問題是這兩種類型的函數如何相互協調???
在lisp中primitive的作用方式與λ-ab的作用方式是一致的
但是在初步的設計中digrap中ζ-ab的作用方式並不與primitive的作用方式一致
只要解決了這個問題
我就形成了一種新的編程範式
** >< 關於對函數式編程範式的維持
看看一個ζ-ap的樣子:(ζ-ab ζ-con ζ-ab)
就知道我能得到的是比以λ-cal爲核心的函數式編程範式更豐富的一種編程範式

而每個對於gexp的操作(比如一個基本操作或者一個ζ-ab)都可以有兩個版本
一個使用被處理的圖本身(通過地址)
一個使用新複製的一個被處理的圖
這樣一個第二個版本的ζ-ab就可以像數學中的函數一樣
在多次的作用中維持一致的行爲
這就是我所繼承的函數式編程範式的基因

要想形成新的編程範式在於用我所設計的模型來形成各種基本的計算語義

比如:
1. 利用ζ-cal來實現λ-cal
2. 利用ζ-cal來實現遞歸函數
3. 利用ζ-cal來實現類型系統
在作這些工作的時候我一定能發現更多的
對我應該如何設計ζ-cal的啓示

首先既然λ-cal被理解爲是用有向二叉樹表達的對有向二叉樹的操作
那麼用ζ-cal來實現λ-cal是非常簡單的
也就是說ζ-cal的抽象能力顯然比λ-cal更大 但是也更複雜
因爲使用了結構更豐富的數據結構
所以我的計算模型一定可以以更簡單的方式表達一些
利用λ-cal和其他計算模型表達起來更複雜的計算
** ><><>< 什麼是計算???
在我的語言內
計算竟被理解爲用圖表達的對圖的操作
把這個問題追問下去很可能令人陷入瘋狂
** 關於高階函數
在digrap中函數的階的樣子很不一樣
可以把一個gexp中的被抽象了的點的個數定義爲方程的階
但是這些點之間是平行的關係
所以階這個詞所暗示的序關係其實是錯誤的
* --------------------------------------------------
* implementation
** note & rationale
- h :: 獲得關於一個理論的堅固知識的方式就是去實現它
       這同時也幫一個人考察了他所觀察的理論的可實現性

digrap是嵌入scheme的
嵌入scheme是正確的選擇
並且需要自己寫一個有digrap要求的某些特殊性狀的scheme實現

設計了多個語言層次
每一層次的語言都需要被設計的:
1) 方便編譯器工作
2) 方便人閱讀
用wordy-list來實現每個層次的語法
也許這樣的實現效率不高
但是在我看來處理wordy-list的代碼更可讀
並且所實現的語法也更容易處理
並且注意
在上面的基礎上嘗試優化語法很容易
因爲很容易把字符串解析成用wordy-list表示的語法分析樹

語言層次的描述如下
1. 在scheme中實現一個有向圖的數據結構
   即 設計有向圖的表示
   並 寫出處理以這種表示的有向圖的基本函數
2. 但是之後並不使直接用scheme中所提供的
   closure這種抽象方法來進行對有向圖的處理(儘管不限制你這樣做)
   + 上面的這句話隱含地認同了sicp中對
     primitive-function與the-way-to-make-abstraction之間的關係的理解方式
   而是實現一個新的語法
   然後用一個編譯器把這種語法轉換到scheme中對有向圖的基本操作
3. 然後利用所實現的數據結構與編譯器來實驗ζ-cal這種新的計算模型
4. 研究這種計算模型的數學性質
5. 嘗試以這種計算模型爲中心 設計一個新的編程範式
** draft & misc
#+begin_src scheme
;; 下面這些單個的symbol都可以被當作變量名在設計語法的時候使用
$
@
%
^
&
a.1.b.
#+end_src

#+begin_src scheme
'#0=((vertex-1 #0# ()))

(print-graph #f)

(let ([v '((vertex-1 () ()))])
  (set-car! (cdr (car v)) v)
  v)


;; 下面的兩段測試可以發現ikarus的局部變量的行爲是錯的
(let ([v '((vertex-1 <address> ()))])
  (set-car! (cdar v) v)
  (eq? v (cadar v))
  ;; v
  ;; (cadar v)
  )

(define v
  (let ([v '((vertex-1 <address> ()))])
    (set-car! (cdar v) v)
    v))
(eq? v (cadar v))
#+end_src
** >< 關於lazy-eval
- k :: 什麼是lazy-eval 惰性求值?
- x :: 就是懶得去求值的意思
       比如構造子在構造一個數據結構的時候
       構造子它就像一個函數一樣 它的參數是一些表達式
       這些表達式可以是解釋器能夠解釋的任何複雜的嵌套的東西
       比如一個表達式裏面又有很多構造子對參數的作用等等
       構造子如果是懶惰的
       你讓它構造東西的時候
       它就只作最基本的工作
       它把這些表達式放到該放的地方之後就不管了
       當你之後要需要知道構造子所構造的部分的值的時候
       你會用與構造子對應的詢問子來詢問
       這時候詢問子纔會完成求值的工作
       也就是說構造子是懶惰的
       把活都交給詢問子來幹了
       比如LISP中的的懶惰版本的cons可以叫做zons
       (zons (λi.i λi.i) (λi.i λi.i))
       根本就不會對它的兩個參數求值
       只有當(zar (zons (λi.i λi.i) (λi.i λi.i))) => λi.i
       的時候纔會對它的第一個參數求值 等等
- k :: 那麼
       是不是任何結構化數據的構造子都能變得懶惰 ???
- x :: 其實我也不知道
       你可以嘗試去找找反例
       如果找不到反例
       你可以嘗試形成一個小理論(也許需要補充一些假設什麼的)
       去證明對你的問題的肯定是一個真命題
       但是我懶得這麼作了
- k :: 看來根那些構造子一樣
       你也是懶惰的
- x :: 懶惰也沒什麼不好
       另外我想指出
       對於惰性求值這個術語還能有別的理解方式
       那就是函數的惰性求值
       構造子可以被理解爲函數
       我們正是在這種理解方式下來解釋懶惰的構造子的
       函數也可以被理解爲構造子
       函數的惰性求值也有類似的解釋 我就懶得說了
- k :: 但是至少說一說函數爲什麼是構造子 ???
       這並不顯然
       最好能給我舉一些例子
- x :: 好的
       讓我們來考慮純粹的理論性的λ-cal
       說它是理論性的是因爲
       雖然它能夠用來編碼你能想像到的所有數據結構
       並且它能夠用來表達所有可計算的函數
       但是使用起來並不方便 計算起來也不高效
       但是我們就先來考慮這種簡單的東西 因爲我們想要理解到問題的本質
       首先是它的表達式的集合的歸納定義(或者說遞歸定義):
       #+begin_src bnf
       簡單得寫就是:
       <λ-term> ::= <var> | (<λ-term> <λ-term>) | (λ<var>.<λ-term> <λ-term>)

       分開來可以寫成:
       <λ-term> ::= <var> | <λ-application> | <λ-abstraction>
       <λ-application> ::= (<λ-term> <λ-term>)
       <λ-abstraction> ::= λ<var>.<λ-term>
       <var> :: {一個先驗定義的符號集 與自然數集等勢}
       #+end_src
       先不考慮懶惰不懶惰的問題
       這種表達式其實是二叉樹 你能看出來嗎??
       比如:
       (a (b (λx.[c (x ((x m) n))] (λi.i λi.i))))
       我用[]表示了那個直接跟在λ面的特殊的<λ-term>
- k :: 上面的例子真是構複雜的了
       但是我能理解
       畢竟想要存儲表達式就必須有一個數據結構
       而這裏的數據結構就是二叉樹
       並且我知道
       這個二叉樹只有葉節點是有內容的
       只要使用括號就能用線性的字符串來表達這些二叉樹
       並且我還知道
       是<λ-term> ::= (<λ-term> <λ-term>)這一個歸納定義項在是形成着二叉樹
       但是λ<var>.<λ-term>這個東西我有點不理解
       它好像是二叉樹的簡單語義之外的東西??
- x :: 沒錯
       有了它其實我們得到的就不是單純的二叉樹了
       而是一個有向圖
       這個有向圖的支撐樹是一個二叉樹
       這個支撐樹就是上面你所指出的那個歸納定義項所形成的
       而支撐樹之外的有向邊就是令你迷惑的那個λ<var>.<λ-term>形成的
       只要把λ<var>.<λ-term>中
       <λ-term>裏面與λ後面的<var>相等的<var>鏈接到λ後面的<var>
       你就得到整個有向圖了
       如果我能在黑板上給你畫一下的話
       那麼不用言說你也會明白我的意思
- k :: 我明白了
       我能想像出你所希望描述的有向圖了
       現在給我解釋什麼是函數的惰性求值吧!
- x :: 這樣來想
       在LISP中用構造子cons來構造列表(LISP中的這個構造子是勤快的)
       (cons 1 (cons 2 (cons 3 '())))
       這與直接寫出表達式'(1 2 3)是一樣的
       而在上面我寫出表達式 也與我用構造子來構造這個表達式是一樣的
       這裏我需要懶惰處理的是(λx.[c (x ((x m) n))] (λi.i λi.i))
       因爲這一項就是需要被求值的項
       它求值之後應該得到(c (m n))
       這就是構造子懶得乾的事
       構造子和函數可以以差不多的方式來理解
       也就是說函數也可以是懶惰的
       構造子以參數爲基礎進行構造 就類似於 函數拿到參數然後進行代入
       當函數懶得對參數求值而直接進行代入的時候就是惰性求值
       但是要注意一個參數可能被代入到多個點 就像上面一樣
       這時候如果對一個點的參數求值了 那麼其他的點就都應該知道這個被求值的結果了
       這一點是對惰性求值的實現方面的問題 想要實現這種東西並不困難
- k :: 惰性求值有什麼好處呢??
       哦! 我看到了一種好處
       比如在上面(car (λx.[c (x ((x m) n))] (λi.i λi.i))) => c
       當使用惰性求值的時候詢問子car沒有詢問到的地方就不需要被求值
       因此(λi.i λi.i)根本就沒有被求值
- x :: 沒錯
       更重要的是這種求值方式在λ-cal的理論中具有優越性
       這裏我就需要引用一些別人的書來給你看了!
- k :: 那麼digrap中的惰性求值應該如何實現呢 ???
- x :: 這個留到下次討論吧!
---------------------------------------------
** wordy-lisp (wlist)
*** primer
- lisp ::
  + list processing
  + sexp (or list)
  + λ-cal
- digrap ::
  + directed graph processing
  + gexp
  + ζ-cal
*** k :: Good idea, x!
x :: how about wordy-lisp!
1. associated list processing (or wordy list processing)
2. we can call a exp of it a wexp (or a wlist)
3. <body>中表達式的求值順序可以用顯示規定
   這樣表達式的排版就是自由的
4. 函數的形式參數名稱之外再加一個明顯的說明性標記(或者不加)
   這樣參數的代入順序就可以是自由的
   不用記憶順序(那是死記硬背的)
   只用記住參數的說明性標記(這是理解記憶的)
   可以想像如何可以用很多的說明性標記來標記同一點
   這樣記不住這個還能記住其他的
5. 函數的作用順序也可以是自由的
   當參數不齊全時就形成curry
   這樣就使得對一個函數(尤其是多參數的)的使用變得極爲靈活
6. 類型系統不是問題
   可以保留一個:type關鍵詞
7. OO也不是問題
   通過元素之間的相互克隆
   就可以達到OO的效果
8. 錯誤處理也不是問題
   可以保留一個:error關鍵詞
9. 每個保留的關鍵詞都可以用來形成這種語法的新語義
   對語言的動態擴展也不是問題
   我將得到比scheme更強大的macro系統
   因爲我可以有(至少)兩個層次的macro
   一個是用戶增加一個:key-word中的key-word
   並定義這個key-word影響它所在的表達式的方式
   一個是(更高級的)用戶增加<key>
   並定義對增加的<key>的處理方式
10. 很容易作爲編譯器或語法解析器的目標語言
11. >< 難點是
    編譯或解釋這種語法以形成所需要的語義
    就需要很多的查找和排序工作
    不過那不正是電子計算機擅長的工作嗎!!
*** inductive definition
#+begin_src bnf
<wordy-list>
   ::= '() | <field> | (append <wordy-list> <wordy-list>)

# 下面這個版本的可以保留<wordy-list>內的所有loop
<wordy-list>
   ::= '() | <field> | (append! <wordy-list>[non-null] <wordy-list>)


<field>
   ::= (<key> <non-key-val> ...)
       {這裏的list必須是proper-list}

<key> == <field-name>

<key>
   ::= {所有的以冒號開頭的symbol}

<non-key-val>
   ::= {不是<key>的任何類型的值,特別地可以是一個<wordy-list>}

<atom-relative-to-wordy-list> {簡稱<atom-to-wlist>}
   ::= {所有不是<wordy-list>的東西都是相對於<wordy-list>來說的原子}
# 上面這種相對原子的概唸對每種歸納定義的結構化的數據都適用
# 因爲這些原子將被作爲遞歸函數的基本步驟
#+end_src
這裏對於這個數據類型需要一些分析與解釋
1. 這樣設計數據類型是爲了儘量減少人類認知上的負擔
2. 可以發現這個歸納定義的形式是相當良好的
   有了這樣典型的歸納定義 就可以很方便地寫遞歸函數了
*** some helper-functions
#+begin_src scheme
(define string<-symbol symbol->string)
(define list<-string string->list)

(define not-proper-list?
  (lambda (x)
    (and (pair? x)
         (not (list? x)))))
#+end_src
*** predicates
#+begin_src scheme
(define key?
  (lambda (x)
    (and (symbol? x)
         (eq? #\: (car (list<-string
                        (string<-symbol x)))))))
;; test:
;; (key? 1)
;; (key? ':kkk)
;; (key? '::kkk)
;; (key? '卡夫卡)


(define wordy-list?
  (lambda (x)
    (and (list? x)
         (or (null? x);; can be '() 因爲要作爲遞歸函數的基本步驟
             (key? (car x))))))
;; (wordy-list? '())
;; (wordy-list? '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4 . 1))



(define field?
  (lambda (x)
    (and (list x)
         (not (null? x))
         (key? (car x))
         (not (wordy-list? (cdr x))))))
#+end_src
*** note about wlist-processing
這裏有一個很重要的說明:
在scheme中用副作用來構造帶有loop的list這件事困擾了我很久
我現在明白這是因爲我對我寫的代碼所表達的東西的理解
和機器實際上對我代碼的處理方式之間有一個偏差
這可以說成是一種語義的錯亂
對這一點的解釋如下:
1. 首先要明白當結構化的數據被作爲參數來傳遞的時候自然而然傳遞的是地址
2. 其次要熟悉scheme中的一種編程風格
   這種風格是用遞歸函數處理歸納定義的數據的標準方式
   + 這種標準處理方式在ml這種具有更強類型限制的語言中體現的最爲明顯
   這種風格是:
   1) 函數以輸入的結構化數據爲原材料
      因爲所使用的結構化的數據有良好的遞歸定義
      所以很容易形成遞歸函數去解構這個結構
   2) 然後在這個拆解原料的過程中
      函數會利用拆解所得到部分原料
      並添加一些新的物質
      去構建一個需要被輸出的結構化數據
   3) 重要是 當一個東西被當成原料而傳給某個函數的時候
      做了這樣的重要假設:
      這些原料是以後不需要的了 並且這些原料沒有同時在別的地方被用到
      即 這些原料中的任何部分的地址別人都不知道
      只有當下這個原料所服務於的那個函數知道
   4) 在函數構造需要被輸出的新的結構化數據的時候
      原料的一些部分被用到
      同時原料的另一些部分沒有被用到
      那些沒有被用到的原料的部分當然就是需要被垃圾回收器回收的廢料了
3. scheme中的列表處理函數基本上都是以這種風格寫成的
   這是一種很好的風格
   它使得編程變得清晰簡單而明瞭
4. 但是
   當我需要用副作用來構造帶有loop的list的時候 問題就來了
   因爲上面的那個重要的假設不再被滿足了
   並且
   略微形而上地說
   這裏所處理的東西(至少從表面上來看)不再具有良好的歸納定義了
   這就決定了這種東西不容易使用遞歸函數來處理
   但是這只是表面
   其實我們所定義的數據結構總不是雜亂無章的
   否則就無``結構''可言了
   其實我們所定義的數據結構總是有一定的正規性的
   總是可以使用遞歸函數來處理的
   這種可被遞歸函數處理的性質從某種意義上來說就是``結構''的本質
   這樣
   此時我們就需要新的理解方式與處理風格
   這時遞歸函數的行爲
   不是解構的同時構造
   而是遍歷的同時修改
   或者遍歷的同時記錄需要做修改的地方的信息
   然後遍歷之後一起作修改
   就是用很多副作用去修改原來的值
   然後返回的還是原來的值的地址 只不過原來的值被修改過了
   甚至有時可以不返回值 因爲在別的地方還能引用到原來的數據
   注意這種風格是如何與上面那個重要的假設完全相反的
5. 如何理解這些呢 ???
   這種新的風格
   可能需要我能自由地在函數中引用cons的car和cdr的地址
   scheme並不支持這樣的操作
   這與垃圾回收有衝突嗎???
   不衝突
   因爲在我獲取一個明顯的地址之後這一個cons就被着重標記爲不能被回收的了
   當我進行完對這個地址的副作用之後我可以取消這個着重標記表示允許回收
   也就是說使用兩bits
   一個表示``回收--不回收''
   一個表示``允許回收--不允許回收''
6. 這裏如此多的副作用顯然違背了函數式編程
   但是爲了能更方便的寫出比如digrap這種程序
   語言的這樣的性狀是有利的
   當我發現scheme給digrap的實現造成極大的困難的時候
   我就會自己寫一個類似scheme的LISP
7. 還發現scheme中失誤的一點
   爲了實現digrap中的那個有向圖的數據結構
   wlist中的某些位置需要記錄wlist中其他位置的地址
   但是在scheme中列表與列表的地址是沒有區別的
   >< 也許我可以用一個閉包來記錄這個地址
   這樣就可以有一個僞地址數據類型 並且打印起來也好看
   >< 但是我不這樣作
   因爲這並不是正確的實現方式
   這樣作只是在scheme錯誤的設計上修補而已
   應該更改編譯器本身的設計以實現我的目標
8. 你馬上就發現兩種處理風格並不衝突
   並且常常需要同時使用這兩種處理
   那麼重要的就是
   我應該用上面的兩種風格來規範化自己寫的函數
   並且用上面所指出的揭示函數行爲的特徵來描述函數的行爲
*** wlist-processing
#+begin_src scheme
;; 就接口而言 curry總是可以增加使用上的靈活性
;; 並且簡化對使用方式的理解: 因爲所有的作用都是一元的了

;; (take n) => <taker>
;; (<taker> <field>) => <val>
;;   例如 (take n) will take the key of <field>
(define take
  (lambda (n)
    (lambda (field)
      (letrec ([R (lambda (n lis)
                    (cond [(= n 0)
                           (car lis)]
                          [else
                           (R (sub1 n) (cdr lis))]))])
        (if (>= n (length field))
          (error 'take
            "taker too far!" n (sub1 (length field)) field)
          (R n field))))))
;; ((take 1) '(:kkk))
;; ((take 3) '(:kkk 1 2 3))
;; ((take 4) '(:kkk 1 2 3))


;; (find <key>) => <finder>
;; (<finder> <wordy-list>) => <field> | #f
;;    上面當失敗的時候是否不應該簡單地返回#f
;;    而去返回更多的信息 比如找什麼key的時候失敗了
;;    其實用#f也行 因爲返回值正常的時候返回的都是列表
;;    但是其他的函數的錯誤處理可能就不能這麼草率了
;; 注意:
;;   所返回的是一個新構建的列表
;;   但是列表裏的元素還是老元素
;;   因此對於finder所返回的值要小心地使用副作用
;; 又注意:
;;   所返回的新列表會喪失``在列表內引用列表頭''的性質
;;   所返回的:
;; (:0-dimension-geometry-object-list
;;      #2=[:v vertex-2 :address #2#
;;          :can (:value 222)
;;          :abut-edge-list
;;             (:e edge:2-->3 :address #4#)
;;             (:e edge:3-->2 :address #6#)])
;; 對其中#2#的引用不會喪失``在列表內引用列表頭''的性質
;; 但是如果是(:kkk 1 2 . #0=(:tree 7 8 9 #0#) 4 5 6)
;; 那麼
;; ((find ':tree)
;;  '(:kkk 1 2 . #0=(:tree 7 8 9 #0#)))
;; =>
;; (:tree 7 8 9 #0=(:tree 7 8 9 #0#))
;; 而不是#0=(:tree 7 8 9 #0#)
;; 也就是說返回值喪失了``在列表內引用列表頭''的性質
;; 但是從某種語義上來說
;; (:kkk 1 2 . #0=(:tree 7 8 9 #0#) 4 5 6)中的#0#並不是對列表頭的引用不是嗎?
;; 看你從什麼角度去理解了
;; 但是一定要小心而仔細地分析find這類函數的性質
(define find
  (lambda (key)
    (lambda (wordy-list)
      (letrec ([find-the-key
                (lambda (wordy-list)
                  (cond [(null? wordy-list)
                         #f]
                        [(eq? key (car wordy-list))
                         (cons (car wordy-list)
                               (find-2nd-key (cdr wordy-list)))]
                        [else
                         (find-the-key (cdr wordy-list))]))]
               [find-2nd-key
                (lambda (wordy-list)
                  (cond [(null? wordy-list)
                         wordy-list]
                        [(atom? wordy-list)
                         wordy-list]
                        [(not (key? (car wordy-list)))
                         (cons (car wordy-list)
                               (find-2nd-key (cdr wordy-list)))]
                        [(key? (car wordy-list))
                         '()]
                        ))])
        (cond [(not (key? key))
               (error 'find "inupt must be a key" key)]
              [(null? wordy-list)
               #f]
              [else
               (find-the-key wordy-list)])
        ))))
;; test:

;; ((find ':k0) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((find ':k1) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((find ':k2) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((find ':k4) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))

;; 儘管下面的測試看似正確
;; 但是非proper-list不被看作是wordy-list
;; wordy-list?這個謂詞會幫助判斷
;; 所以需要一個例外處理來處理下面的東西
;; 否則這種形式被(有意或無意地)濫用後 將會帶來麻煩
;; ((find ':k4) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4 . 1))

;; ((find ':k3) '(:k1 1
;;              :k2 2 2 2
;;              :k3 3 (3) ()
;;              :k4))
;; ((find ':can) '[:v :can <-- <-- λ])
;; ((find ':can) '[:v :can (:v-type black :kkk kkk)])



;; ((find ':type)
;; '(:type <<graph>>

;;   :0-dimension-geometry-object-list
;;      #2=[:v vertex-2 :address #2#
;;          :can (:value 222)
;;          :abut-edge-list
;;             (:e edge:2-->3 :address #4#)
;;             (:e edge:3-->2 :address #6#)]

;;      #3=[:v vertex-3 :address #3#
;;          :can (:value 333)
;;          :abut-edge-list
;;             (:e edge:2-->3 :address #4#)
;;             (:e edge:3-->2 :address #6#)]

;;   :1-dimension-geometry-object-list
;;      #4=[:e edge:2-->3 :address #4#
;;          :can (:edge-type black-arrow)
;;          :abut-vertex-list
;;             (:v vertex-2 :address #2#)
;;             (:v vertex-3 :address #3#)]

;;      #6=[:e edge:3-->2 :address #6#
;;          :can (:edge-type black-arrow)
;;          :abut-vertex-list
;;             (:v vertex-3 :address #3#)
;;             (:v vertex-2 :address #2#)]
;;      ))




;; (let ([first-edge-fo-first-vertex-finder
;;        (lambda (a-graph)
;;          ((find ':e)
;;           ((take 1)
;;            ((find ':abut-edge-list)
;;             ((take 1)
;;              ((find ':0-dimension-geometry-object-list) a-graph))))))])
;;   (first-edge-fo-first-vertex-finder
;;    '(:type <<graph>>

;;      :0-dimension-geometry-object-list
;;         #2=[:v vertex-2 :address #2#
;;             :can (:value 222)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;         #3=[:v vertex-3 :address #3#
;;             :can (:value 333)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;      :1-dimension-geometry-object-list
;;         #4=[:e edge:2-->3 :address #4#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-2 :address #2#)
;;                (:v vertex-3 :address #3#)]

;;         #6=[:e edge:3-->2 :address #6#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-3 :address #3#)
;;                (:v vertex-2 :address #2#)]
;;         )
;;    ))



;; (let ([can-of-first-edge-fo-first-vertex-finder
;;        (lambda (a-graph)
;;          ((find ':can)
;;           ((take 1)
;;            ((find ':address)
;;             ((take 1)
;;              ((find ':abut-edge-list)
;;               ((take 1)
;;                ((find ':0-dimension-geometry-object-list) a-graph))))))))])
;;   (can-of-first-edge-fo-first-vertex-finder
;;    '(:type <<graph>>

;;      :0-dimension-geometry-object-list
;;         #2=[:v vertex-2 :address #2#
;;             :can (:value 222)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;         #3=[:v vertex-3 :address #3#
;;             :can (:value 333)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;      :1-dimension-geometry-object-list
;;         #4=[:e edge:2-->3 :address #4#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-2 :address #2#)
;;                (:v vertex-3 :address #3#)]

;;         #6=[:e edge:3-->2 :address #6#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-3 :address #3#)
;;                (:v vertex-2 :address #2#)]
;;         )

;;    ))


;; (address-find <key>) => <address-finder>
;; (<address-finder> <wordy-list>) => <wordy-list>
;; 不構建新列表而直接返回找到的列表的地址
;; 有點像又兩個參數的cdr
;; 第一個參數是<field-name> (即<key>)
;; 第二個參數是<wordy-list>
(define address-find
  (lambda (key)
    (lambda (wordy-list)
      (letrec ([find-the-key
                (lambda (wordy-list)
                  (cond [(null? wordy-list)
                         #f]
                        [(eq? key (car wordy-list))
                         wordy-list]
                        [else
                         (find-the-key (cdr wordy-list))]))])
        (cond [(not (key? key))
               (error 'find "inupt must be a key" key)]
              [(null? wordy-list)
               #f]
              [(eq? key (car wordy-list))
               wordy-list]
              [else
               (find-the-key wordy-list)])
        ))))
;; test:
;; ((address-find ':k0) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k1) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k2) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k3) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k4) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))




(define append-two!
  ;; SIDE-EFFECT on wlist-1, 所以append-two!的第一個參數不能是'()
  ;; RETURN-VAL wlist-1
  (lambda (wlist-1 wlist-2)
    (letrec ([R! (lambda (wlist-1)
                   (cond [(null? (cdr wlist-1)) ;; (= 1 (length wlist-1))
                          (set-cdr! wlist-1 wlist-2)]
                         [else
                          (R! (cdr wlist-1))]))])
      (cond [(null? wlist-1)
             (error 'append-two!
               "append-two!'s 1th-arg can not be '()" wlist-1 wlist-2)]
            [(not-proper-list? wlist-1)
             (error 'append-two!
               "append-two!'s 1th-arg can not be a not proper-list"
               wlist-1 wlist-2)]
            ;; [(not (list? wlist-2))
            ;;  (error 'append-two!
            ;;    "append-two!'s 2th-arg must be a list" wlist-1 wlist-2)]
            ;; 上面的一句對類型的控制比較嚴格一點
            [(and (not (pair? wlist-2))
                  (not (null? wlist-2)))
             (error 'append-two!
               "append-two!'s 2th-arg must be a pair or '()" wlist-1 wlist-2)]
            [else
             ;; SIDE-EFFECT
             (R! wlist-1)
             ;; RETURN-VAL
             wlist-1]))))
;; test:
;; (append-two! '(1 2 3) '(kkk))
;; (append-two! '() '(kkk))
;; (append-two! '(1 2 . 3) '(kkk))
;; (let ([kkk '(1 2 3)])
;;   (append-two! kkk '(kkk))
;;   (append-two! kkk '(kkk))
;;   (append-two! kkk '(kkk))
;;   kkk)
;; (let ([kkk '(1 2 3)])
;;   (append kkk '(kkk))
;;   (append kkk '(kkk))
;;   (append kkk '(kkk))
;;   kkk)

(define-syntax append!
  (syntax-rules ()
    [(_)
     (error 'append!
       "append! is a syntax with at least 2 args, not 0 arg !")]
    [(_ anthing)
     (error 'append!
       "append! is a syntax with at least 2 args, not 1 arg !" anthing)]
    [(_ wlist-1 wlist-2)
     (append-two! wlist-1 wlist-2)]
    [(_ wlist-1 wlist-2 wlist-3 ...)
     (append!
      (append-two! wlist-1 wlist-2) wlist-3 ...)]
    ))
;; test:
;; (append! '(1 2 3) '(1 2 3) '(kkk))
;; (append! '(kkk) '() '(kkk))
;; (append! '(0 0 0) '(kkk) '(1 2 . 3))
;; (append! '(0 0 0) '(1 2 . 3) '(kkk))
;; (let ([kkk '(1 2 3)])
;;   (append! kkk '(kkk))
;;   (append! kkk '(kkk))
;;   (append! kkk '(kkk))
;;   kkk)
;; (let ([kkk '(1 2 3)])
;;   (append kkk '(kkk))
;;   kkk)


;; 一個同構變換:
;; 主要的區別是
;; alist中遞增一下就能找到下一個field
;;   而wlist中可能需要很多對key?判斷才能找到下一個field
;; wlist的樣子看起來很簡單括號很少並且更容易理解
;;   而alist看起來很複雜
;; alist在視覺上的的劣勢很容易用一個語法解析器來彌補
;; wlist理解起來還是更簡單

;; 爲了獲得alist的優勢 並不必作同構變換
;; 只要跑一遍wlist 然後增加一個key.address-alist就行了
;; 真正的同構變換會破壞原來的結構化數據的結構
;; 即 第一個field的尾部被一個'()截斷了
;; 但是更重要的是注意這種截斷並不影響wlist中的loop
;; 也就是說不會影響wlist中的某些位置對其他位置的地址的記錄

;; 注意只有當使用同構所節省的時間超過
;; 同構變換所浪費的時間
;; (define alist<-wlist
;;   (lambda (wlist)
;;     ()))

;; (define wlist<-alist
;;   (lambda (alist)
;;     ()))


;; 用副作用刪除和增加field
;; (delete! <key>) => <deleter!>
;; (<deleter!> <wordy-list>) => {WITH-SIDE-EFFECT} <wordy-list> | #f
;; (define delete!
;;   (lambda (key)
;;     (lambda (wordy-list)
;;       需要定義find-next-field
;;       )))

;; (substitute! <field>) => <substituent!>
;; ((<substituent!> <key>) )
;; (define substitute!
;;   (lambda (key)
;;     (lambda (wordy-list)
;;
;;       )))


;; 用副作用刪除和增加field中的值
;; 用副作用更改field的名字




(define insert-val-to-the-2nd-position-of-a-list!
  (lambda (val lis)
    (if (null? lis)
      (error 'insert-val-to-the-2nd-position-of-a-list!
        "input list can not be '() !")
      (set-cdr! lis (append!
                      (list val)
                      (cdr lis))))))


(define insert-a-val-to-a-field-of-a-wlist!
  (lambda (val field-name wlist)
    (insert-val-to-the-2nd-position-of-a-list!
     val ((address-find field-name) wlist))))
;; test:
;; (define kkk '(:kkk))
;; (insert-a-val-to-a-field-of-a-wlist! 1 ':kkk kkk)

;; 發現如果可以自由的改變參數的順序 那將是極好的
;; 在wordy-lisp中就可以做到這一點
;; 我可以直接用macro把wordy-lisp嵌入到scheme中嗎 ???
;; 如果能自動實現動態的curry 就更好了 !!!
;; 太酷了
;; 甚至可以自動變換求值順序形成不同的curry
;; 太酷了 太酷了
(define to-a-field-of-a-wlist--let-us-insert-a-val!
  (lambda (field-name wlist val)
    (insert-val-to-the-2nd-position-of-a-list!
     val ((address-find field-name) wlist))))
#+end_src
*** note about constructor
如果使用wordy-list的明顯的標籤
那麼這些標籤就可以看作是每個結構化對象(數據)的構造子
那麼模式匹配和類型推到當然就不成問題

!!! 上面的兩項其實是錯的
因爲這裏的明顯的標籤雖然用來命名了對象中的一部分
但是並沒有形成對一個集合的歸納定義
而模式匹配是爲了寫遞歸函數處理歸納定義的集合(數據類型)

但是仔細一想其實又是可以的
因爲不論如何它們確實能夠擔當構造子的角色
** representation-of-graph
*** 0.01
#+begin_src scheme
(define <<graph>>?
  (lambda (x)
    (and (list x)
         (not (null? x))
         (eq? (car x) '<<graph>>))))

;; 希望給出比較不平凡的例子作爲測試
;; 以使所有的遞歸在基本的測試中都能被跑到
(define example-graph
  ;; memory == O(|V|+|E|)
  '(<<graph>>
    ;; 約定: 在下面的表示中 每一個點邊元素都用方括號

    ;; vertex-list (0-dimension-geometry-object-list)
    ;; 點中有一個列表 保存着與自己相鄰的所有邊的地址
    ;; 這樣從點出發能夠找到與它相鄰的所有邊
    ;; 這種對地址的保存就實現着點和邊的相鄰關係
    (#2=[(vertex-2 #2# (:value 222))
         (edge:2-->3 #4#) (edge:3-->2 #6#)]
     #3=[(vertex-3 #3# (:value 333))
         (edge:2-->3 #4#) (edge:3-->2 #6#)])

    ;; edge-list (1-dimension-geometry-object-list)
    ;; 邊中有一個列表 保存這與自己相鄰的所有點的地址
    ;; 這樣從邊出發能夠找到與它相鄰的所有點
    ;; 這種對地址的保存就實現着點和邊的相鄰關係
    (#4=[(edge:2-->3 #4# (:edge-type black-arrow))
         ;; 兩個點在下面的列表中儲存的順序
         ;; 體現着這條邊連接它們的方式
         (vertex-2 #2#) (vertex-3 #3#)]
     #6=[(edge:3-->2 #6# (:edge-type black-arrow))
         (vertex-3 #3#) (vertex-2 #2#)])

    ;; 可以發現圖的幾何語義限制了上面的列表的樣子
    ;; 在圖的語義下:
    ;;   2-dim幾何體 能且只能 與兩個1-dim幾何體相連
    ;;        並且其鄰接列表是有序的
    ;;   1-dim幾何體 能 與0個或1個或多個2-dim幾何體相連
    ;;        並且遺忘了其鄰接列表的順序

    ;; 顯然在這裏我們可以進行推廣
    ;; 在這種實現方式下所能得到的最廣泛的推廣是:
    ;;   可以有n-dim幾何體列表
    ;;   幾何體都可以和任意維數的幾何體相連接
    ;; 顯然利用這種實現的推廣
    ;; 只要再向上面一樣添加某先限制條件
    ;; 就能夠形成代數拓撲中的某些復形的語義

    ;; 但是要注意的是限制條件對語義的影響可能是相當微妙的
    ;; 幾何語義的建立 可以幫助我們決定應該實現什麼樣的 基本處理函數
    ;; 基本的觀察 與 基本的幾何想像 總能把人們引向有趣而豐富的理論
    ))
#+end_src
*** 0.02
下面的數據結構可以被視爲是圖論型數據庫的實現
只要
1. 把:0-dimension-geometry-object-list
   替換爲:data
2. 把:1-dimension-geometry-object-list
   替換爲:relation
   並且取消與edge的語義有關的限制
   使得:relation與:data完全對稱
   + 並且 :can of :relation 中
     可以保存對關係的額外描述等等
3. 上面的東西顯然能夠勝任一個數據庫
   它的特點是保存的很簡潔
   插入和刪除還有查詢比較複雜

#+begin_src scheme
(define <<graph>>?
  (lambda (x)
    (and (wordy-list? x)
         (not (null? x))
         (eq? ((take 1)
               ((find ':type)
                x))
              '<<graph>>))))

;; (<<graph>>? example-graph)

;; 下面希望給出比較不平凡的例子作爲測試
;; 以使所有的遞歸在基本的測試中都能被跑到
(define example-graph
  ;; memory == O(|V|+|E|)
  '(:type <<graph>>
    ;; 約定: 在下面的表示中 每一個點邊元素都用方括號

    :0-dimension-geometry-object-list
    ;; 每個點中有一個列表:abut-edge-list
    ;; 保存着與自己相鄰的所有邊的地址
    ;; 這樣從點出發能夠找到與它相鄰的所有邊
    ;; 這種對地址的保存就實現着點和邊的相鄰關係

    #2=[:v vertex-2 :address #2#
        :can (:value 222)
        :abut-edge-list
        ;; 如果一個key的名字說明這一項是list
        ;; 那麼它後面根的常常就是一個list的wordy-list
        ;; 要知道基本的元素在這裏都是用wordy-list來表達的
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]

    #3=[:v vertex-3 :address #3#
        :can (:value 333)
        :abut-edge-list
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]


    :1-dimension-geometry-object-list
    ;; 每個邊中有一個列表:abut-vertex-list
    ;; 保存着與自己相鄰的所有點的地址
    ;; 這樣從邊出發能夠找到與它相鄰的所有點
    ;; 這種對地址的保存就實現着點和邊的相鄰關係

    #4=[:e edge:2-->3 :address #4#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           ;; 兩個點在這個列表中儲存的順序
           ;; 體現着這條邊連接它們的方式
           (:v vertex-2 :address #2#)
           (:v vertex-3 :address #3#)]

    #6=[:e edge:3-->2 :address #6#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           (:v vertex-3 :address #3#)
           (:v vertex-2 :address #2#)]



    ;; 可以發現圖的幾何語義限制了上面的列表的樣子
    ;; 在圖的語義下:
    ;;   1-dim幾何體 能且只能 與兩個0-dim幾何體相連
    ;;        並且其鄰接列表是有序的
    ;;   0-dim幾何體 能 與0個或1個或多個1-dim幾何體相連
    ;;        並且遺忘了其鄰接列表的順序

    ;; 顯然在這裏我們可以進行推廣
    ;; 在這種實現方式下所能得到的最廣泛的推廣是:
    ;;   可以有n-dim幾何體列表
    ;;   幾何體都可以和任意維數的幾何體相連接
    ;; 顯然利用這種實現的推廣
    ;; 只要再向上面一樣添加某先限制條件
    ;; 就能夠形成代數拓撲中的某些復形的語義

    ;; 但是要注意的是限制條件對語義的影響可能是相當微妙的
    ;; 幾何語義的建立 可以幫助我們決定應該實現什麼樣的 基本處理函數
    ;; 基本的觀察 與 基本的幾何想像 總能把人們引向有趣而豐富的理論


    ))
#+end_src
** basic-functions-for-graph
*** note
刪除和添加節點並不是簡單在這個集閤中增加元素
而需要修改圖的各部分 讓圖的各部分對圖的描述保持一致
- add-vertex
- add-edge
- delete-vertex
- delete-edge
其他操作顯然都能用這4個基本操作的複合來完成
*** some helper-functions (not using)
也許這裏的函數應該被作爲另外的lib分離出去
**** 0.01

#+begin_src scheme
;; 下面的add-to-list-end!把x添加到list的末尾
;; 由於scheme的限制 這樣的實現方式最簡單
;; 因爲add-to-list-end!是一個副作用
;; 所以只有有名字能引用到它的參數lis的時候這個函數纔有意義
(define add-to-list-end!
  (lambda (x lis)
    (letrec ([R (lambda (x lis)
                  (cond [(null? (cdr lis))
                         (set-cdr! lis (list x))]
                        [else
                         (R x (cdr lis))]))])
      (if (null? lis)
        (error 'add-to-list-end! "can not add ~s to null list" x)
        (R x lis)))))

;; 非副作用的版本更簡單 但是現在還用不到
;; (define add-to-list
;;   (lambda (x lis)
;;     ))


(define find-address-in-vertex-list-by-name
  (lambda (name vertex-list)
    (cond [(null? vertex-list)
           (error 'find-address-in-vertex-list-by-name "can not find name: ~s in list" name)]
          ;; 想要說出是那個list就要使用call/cc
          [else
           (if (equal? name (caaar vertex-list))
             ;; 使用equal?這樣vertex-name就可以是list或vector了
             (cadaar vertex-list)
             (find-address-in-vertex-list-by-name name (cdr vertex-list)))])))
;; (letrec
;;     ([v '(v v)]
;;      [g '(g g)])
;;   ;; 想要把g中的地址mark到v中
;;   (cons
;;    (let ()
;;      ;; 直接用car與cdr找到需要被mark的g中的地址就可以了
;;      (set-cdr! v (cdr g))
;;      v)
;;    (cons
;;     (let ()
;;       g)
;;     '())))
#+end_src
**** 0.02

#+begin_src scheme
;; 下面的add-to-list-end!把x添加到list的末尾
;; 由於scheme的限制 這樣的實現方式最簡單
;; 因爲add-to-list-end!是一個副作用
;; 所以只有有名字能引用到它的參數lis的時候這個函數纔有意義
(define add-to-list-end!
  (lambda (x lis)
    (letrec ([R (lambda (x lis)
                  (cond [(null? (cdr lis))
                         (set-cdr! lis (list x))]
                        [else
                         (R x (cdr lis))]))])
      (if (null? lis)
        (error 'add-to-list-end! "can not add ~s to null list" x)
        (R x lis)))))

;; 非副作用的版本更簡單 但是現在還用不到
;; (define add-to-list
;;   (lambda (x lis)
;;     ))


(define find-address-in-vertex-list-by-name
  (lambda (name vertex-list)
    (cond [(null? vertex-list)
           (error 'find-address-in-vertex-list-by-name "can not find name: ~s in list" name)]
          ;; 想要說出是那個list就要使用call/cc
          [else
           (if (equal? name (caaar vertex-list))
             ;; 使用equal?這樣vertex-name就可以是list或vector了
             (cadaar vertex-list)
             (find-address-in-vertex-list-by-name name (cdr vertex-list)))])))
;; (letrec
;;     ([v '(v v)]
;;      [g '(g g)])
;;   ;; 想要把g中的地址mark到v中
;;   (cons
;;    (let ()
;;      ;; 直接用car與cdr找到需要被mark的g中的地址就可以了
;;      (set-cdr! v (cdr g))
;;      v)
;;    (cons
;;     (let ()
;;       g)
;;     '())))

;; 下面這個語法關鍵詞不是拿來用的
;; 而是想用來說明 如果能自由的安排<body>中表達式的執行順序
;; 那麼將很有利於提高代碼的可讀性
;; 因爲這樣<body>中代碼的排列順序就可以和執行順序不一樣
;; 這就使得更好的排版方式成爲可能
(define-syntax one-sexp-RETURNED--after-SIDE-EFFECTS-performed
  (syntax-rules ()
    [(_ one-sexp-RETURNED SIDE-EFFECT ...)
     (begin
       SIDE-EFFECT
       ...
       one-sexp-RETURNED)]))
#+end_src
*** add-vertex
**** 0.01

#+begin_src scheme
;; 下面兩個東西給出比較不平凡的例子作爲測試
;; 以使所有的遞歸在基本的測試中都能被跑到
(define syntax-example-of-add-vertex
  '((vertex-1 (:value 111))
    [(edge:1-->2 (:edge-type black-arrow))
     (vertex-2)]
    [(edge:1-->3 (:edge-type black-arrow))
     (vertex-3)]
    [(edge:1-->2 (:edge-type red-arrow))
     (vertex-2)]
    [(edge:1-->3 (:edge-type red-arrow))
     (vertex-3)]
    ))

(define example-graph
  '(<<graph>>

    (#2=[(vertex-2 #2# (:value 222))
         (edge:2-->3 #4#) (edge:3-->2 #6#)]
     #3=[(vertex-3 #3# (:value 333))
         (edge:2-->3 #4#) (edge:3-->2 #6#)])

    (#4=[(edge:2-->3 #4# (:edge-type black-arrow))
         (vertex-2 #2#) (vertex-3 #3#)]
     #6=[(edge:3-->2 #6# (:edge-type black-arrow))
         (vertex-3 #3#) (vertex-2 #2#)])
    ))


(define add-vertex
  (lambda (v g)
    (add-vertex! v (list-copy g))))

(define add-vertex!
  (lambda (v g)
    ;; g = graph
    ;; v = out of graph representation of a vertex for add-vertex
    (let* ([g-vertex-list (cadr g)]
           [g-edge-list (caddr g)]

           ;; 下面生成processed-vertex-head的同時需要:
           ;; 1. 擴充g-vertex-list中的其他點的相鄰邊列表
           ;; 2. 擴充g-edge-list
           [processed-vertex-head
            (letrec ([vertex-head (car v)]
                     [subvertex-list (cdr v)]
                     [processed-vertex-head (fun-to-handle-vertex-head
                                             vertex-head)]

                     [fun-to-handle-vertex-head
                      ;;     (vertex-name . treasury-of-vertex) ==>
                      ;; #0=[(vertex-name #0# treasury-of-vertex) ...]
                      (lambda (vertex-head)
                        (pmatch-who 'add-vertex!:fun-to-handle-vertex-head  vertex-head
                          [`(,vertex-name . ,treasury-of-vertex)
                           (let ([x `[(,vertex-name <address-of-this-vertex> . ,treasury-of-vertex)]])
                             (set-car! (cdar x) x)
                             x)]))]

                     [fun-to-handle-edge-head
                      ;; 除了約束變元的名字以外 與fun-to-handle-vertex-head完全相同
                      ;;     (edge-name . treasury-of-edge) ==>
                      ;; #0=[(edge-name #0# . treasury-of-edge) ...]
                      (lambda (edge-head)
                        (pmatch-who 'add-vertex!:fun-to-handle-edge-head  edge-head
                          [`(,edge-name . ,treasury-of-edge)
                           (let ([x `[(,edge-name <address-of-this-edge> . ,treasury-of-edge)]])
                             (set-car! (cdar x) x)
                             x)]))]

                     [rec-fun-to-run-through-subvertex-list
                      ;; return a processed-subvertex-list
                      (lambda (subvertex-list)
                        (cond [(null? subvertex-list) subvertex-list]
                              [else
                               (cons (pmatch-who 'add-vertex!:rec-fun-to-run-through-subvertex-list
                                         (car subvertex-list)
                                       [`[(,edge-name . ,<treasury-of-edge>)
                                          (,subvertex-name)]
                                        (let ([processed-edge-head (fun-to-handle-edge-head `(,edge-name . ,<treasury-of-edge>))])
                                          (set-cdr! processed-edge-head
                                                    ;; 下面是與這個edge相鄰的兩個vertex的列表
                                                    `((,(caar processed-vertex-head) ,(cadar processed-vertex-head))
                                                      ;; 下面用到了一次對圖的vertex-list的查找
                                                      (,subvertex-name ,(find-address-in-vertex-list-by-name subvertex-name g-vertex-list))))
                                          (add-to-list-end! processed-edge-head g-edge-list)
                                          ;; 在返回值之前還需要把上面安插好的edge添加到與這個邊相鄰的vertex的edge-list中
                                          (add-to-list-end! `(,(caar processed-edge-head) ,(cadar processed-edge-head))
                                                        (cdr (find-address-in-vertex-list-by-name subvertex-name g-vertex-list)))
                                          ;; 下面是這個let的返回值:
                                          ;; 需要返回一個將被添加到processed-vertex-head的相鄰邊列表中的項
                                          ;; (cadar processed-edge-head)是這個edge的地址
                                          `(,edge-name ,(cadar processed-edge-head)))])
                                     (rec-fun-to-run-through-subvertex-list (cdr subvertex-list)))]))])
              (set-cdr! processed-vertex-head
                        (rec-fun-to-run-through-subvertex-list
                         subvertex-list))
              ;; 下面是這個letrec的返回值:
              processed-vertex-head)])

      (add-to-list-end! processed-vertex-head g-vertex-list)
      ;; now! g-vertex-list and g-edge-list are processed
      ;; 下面是let*的返回值 也是這個函數的返回值:
      (list '<<graph>> g-vertex-list g-edge-list)
      )))


;; test:
;; (add-vertex syntax-example-of-add-vertex
;;             example-graph)

;; (define example-graph '(<<graph>> (1) ()))
;; (add-vertex '((vertex-1 (:value 111)))
;;          example-graph)
;; 下面的錯誤來自於add-to-list-end! 它表明在這種實現方式下空圖是沒有意義的
;; 圖的點列表和邊列表都不能是空集
;; 要知道在scheme中add-to-list-end!這種侷限性是本質的
;; (define example-graph '(<<graph>> () ()))
;; (add-vertex '((vertex-1 (:value 111)))
;;             example-graph)
;; (define example-graph '(<<graph>>
;;                   (#2=[(vertex-2 #2# (:value 222))])
;;                   ([(1 2 3)])))
;; (add-vertex '((vertex-1 (:value 111))
;;               [(edge:1-->2 (:edge-type black-arrow))
;;                (vertex-2)])
;;             example-graph)
;; 如果希望以最簡單的方式使用空圖那麼就必須作特殊約定(比如約定每個圖有一個不可見的基礎點)
;; 可以這樣來做:
;; 約定每個圖中至少有兩點以及鏈接這兩點的一邊
;; 這三個幾何元素不是浪費了 而是可以保存一些這個圖的基本信息
;; 但是下面的eval不能正常工作太讓人震驚了
;; 而使用define-syntax又將造成無限循環
;; (define give-me-a-base-graph
;;   (lambda ()
;;     (define kkk
;;       '(<<graph>>
;;         (#1=[(base-vertex-1 #1# (:value 111))
;;              (base-edge:1-->2 #3#)]
;;             #2=[(base-vertex-2 #2# (:value 222))
;;                 (base-edge:1-->2 #3#)])
;;         (#3=[(base-edge:1-->2 #3# (:edge-type base-arrow))
;;              (base-vertex-1 #1#) (base-vertex-2 #2#)])))
;;     kkk))
;; (add-vertex '((vertex-1 (:value 111)))
;;             (give-me-a-base-graph))
#+end_src
**** 0.02

#+begin_src scheme
(define syntax-example-of-add-vertex
  '(:type vertex-representation-for-add-vertex

    :v vertex-1
    :can (:value 111)

    :abut-edge-list-representation-for-add-vertex
       (:e edge:1-->2
        :can (:edge-type black-arrow)
        :abut-vertex-of-this-edge vertex-2)

       (:e edge:1-->3
        :can (:edge-type black-arrow)
        :abut-vertex-of-this-edge vertex-3)

       (:e edge:1-->2
        :can (:edge-type red-arrow)
        :abut-vertex-of-this-edge vertex-2)

       (:e edge:1-->3
        :can (:edge-type red-arrow)
        :abut-vertex-of-this-edge vertex-3)

       ))

(define example-graph
  '(:type <<graph>>


    :0-dimension-geometry-object-list

    #2=[:v vertex-2 :address #2#
        :can (:value 222)
        :abut-edge-list
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]

    #3=[:v vertex-3 :address #3#
        :can (:value 333)
        :abut-edge-list
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]


    :1-dimension-geometry-object-list

    #4=[:e edge:2-->3 :address #4#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           (:v vertex-2 :address #2#)
           (:v vertex-3 :address #3#)]

    #6=[:e edge:3-->2 :address #6#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           (:v vertex-3 :address #3#)
           (:v vertex-2 :address #2#)]


    ))


(define add-vertex
  (lambda (vertex-to-be-processed the-graph)
    (add-vertex! vertex-to-be-processed (list-copy the-graph))))


;; add-vertex!它不是一個遞歸函數
;; add-vertex!完全是一個副作用
;; 返回的是副作用之後的輸入的圖的地址
;; 需要控制求值順序
;; 先作出這個新的點 再把新的點加進圖裏
;; 在製作這個新的點的同時需要:
;; 用遞歸的副作用擴充1-dimension-geometry-object-list
;;           同時擴充0-dimension-geometry-object-list
;; 程序不應該寫成下面這樣
;; 這簡直太可怕了 !!!
(define add-vertex!
  (lambda (vertex-to-be-processed the-graph)
    (let ([processed-vertex
           (let* ([head-of-processed-vertex ((find ':v) vertex-to-be-processed)]
                  [address-of-processed-vertex  head-of-processed-vertex]
                  [list-of-abut-edge-to-be-processed
                   (cdr ((find ':abut-edge-list-representation-for-add-vertex)
                         vertex-to-be-processed))]
                  [insert-a-new-maked-edge-to-the-graph-and-return-it-as-abut-edge
                   ;; 注意: 插入一個邊的同時還需要調整這個邊指向的點
                   (lambda (abut-edge-to-be-processed)
                     (let* ([head-of-new-maked-edge ((find ':e) abut-edge-to-be-processed)]
                            [address-of-new-maked-edge head-of-new-maked-edge])
                       (insert-val-to-a-field-of-a-wlist!
                         (append!
                           head-of-new-maked-edge
                           `(:address ,address-of-new-maked-edge)
                           ((find ':can) abut-edge-to-be-processed)
                           `(:abut-vertex-list
                             (:v ,((take 1) ((find ':v) address-of-processed-vertex))
                                 :address ,address-of-processed-vertex)
                             (:v ,((take 1) ((find ':abut-vertex-of-this-edge) abut-edge-to-be-processed))
                                 :address
                                 ,(let* ;; 去找到地址
                                      ([name-of-this-vertex
                                        ((take 1)
                                         ((find ':abut-vertex-of-this-edge)
                                          abut-edge-to-be-processed))]
                                       [address-of-this-vertex
                                        (letrec
                                            ([R (lambda (vertex-list-of-the-graph)
                                                  (cond [(null? vertex-list-of-the-graph)
                                                         (error 'add-vertex!
                                                           "can not find a vertex in graph" name-of-this-vertex)]
                                                        [(eq? ((take 1)
                                                               ((find ':v)
                                                                (car vertex-list-of-the-graph)))
                                                              name-of-this-vertex)
                                                         ((take 1)
                                                          ((find ':address)
                                                           (car vertex-list-of-the-graph)))]
                                                        [else
                                                         (R (cdr vertex-list-of-the-graph))]))])
                                          (R (cdr ((find ':0-dimension-geometry-object-list)
                                                   the-graph))))])
                                    ;; 在找到的地址裏作副作用
                                    (insert-val-to-a-field-of-a-wlist!
                                      (append
                                       ((find ':e) abut-edge-to-be-processed)
                                       `(:address ,address-of-new-maked-edge))
                                      ':abut-edge-list address-of-this-vertex)
                                    ;; 返回地址
                                    address-of-this-vertex))))
                         ':1-dimension-geometry-object-list the-graph)
                       (append
                        ((find ':e) abut-edge-to-be-processed)
                        `(:address ,address-of-new-maked-edge))))])
             ;; make-a-vertex
             (append!
               head-of-processed-vertex
               `(:address ,address-of-processed-vertex)
               ((find ':can) vertex-to-be-processed)
               `(:abut-edge-list
                 ,(map insert-a-new-maked-edge-to-the-graph-and-return-it-as-abut-edge
                       list-of-abut-edge-to-be-processed))))])
      (insert-val-to-a-field-of-a-wlist!
        processed-vertex ':0-dimension-geometry-object-list the-graph)
      the-graph)))
;; test:
;; (add-vertex syntax-example-of-add-vertex
;;             example-graph)

;; (:type <<graph>>
;;        :0-dimension-geometry-object-list
;;   #0=(:v vertex-1 :address #0# :can (:value 111)
;;        :abut-edge-list
;;        ((:e edge:1-->2 :address
;;           #1=(:e edge:1-->2 :address #1# :can
;;                  (:edge-type black-arrow) :abut-vertex-list
;;                  (:v vertex-1 :address #0#)
;;                  (:v vertex-2 :address
;;                  #2=(:v vertex-2 :address #2# :can
;;                       (:value 222) :abut-edge-list
;;                       (:e edge:1-->2 :address
;;                         #3=(:e edge:1-->2 :address #3# :can
;;                              (:edge-type red-arrow)
;;                              :abut-vertex-list
;;                              (:v vertex-1 :address #0#)
;;                              (:v vertex-2 :address #2#)))
;;                       (:e edge:1-->2 :address #1#)
;;                       (:e edge:2-->3 :address
;;                         #4=(:e edge:2-->3 :address #4# :can
;;                              (:edge-type black-arrow)
;;                              :abut-vertex-list
;;                              (:v vertex-2 :address #2#)
;;                              (:v vertex-3 :address
;;                                #5=(:v vertex-3 :address #5#
;;                                     :can (:value 333)
;;                                     :abut-edge-list
;;                                     (:e edge:1-->3 :address
;;                                       #6=(:e edge:1-->3
;;                                            :address #6# :can
;;                                            (:edge-type
;;                                              red-arrow)
;;                                            :abut-vertex-list
;;                                            (:v vertex-1
;;                                              :address #0#)
;;                                            (:v vertex-3
;;                                              :address #5#)))
;;                                     (:e edge:1-->3 :address
;;                                       #7=(:e edge:1-->3
;;                                            :address #7# :can
;;                                            (:edge-type
;;                                              black-arrow)
;;                                            :abut-vertex-list
;;                                            (:v vertex-1
;;                                              :address #0#)
;;                                            (:v vertex-3
;;                                              :address #5#)))
;;                                     (:e edge:2-->3 :address
;;                                       #4#)
;;                                     (:e edge:3-->2 :address
;;                                       #8=(:e edge:3-->2
;;                                            :address #8# :can
;;                                            (:edge-type
;;                                              black-arrow)
;;                                            :abut-vertex-list
;;                                            (:v vertex-3
;;                                              :address #5#)
;;                                            (:v vertex-2
;;                                              :address #2#)))))))
;;                       (:e edge:3-->2 :address #8#)))))
;;          (:e edge:1-->3 :address #7#)
;;          (:e edge:1-->2 :address #3#)
;;          (:e edge:1-->3 :address #6#)))
;;   #2# #5# :1-dimension-geometry-object-list #6# #3# #7# #1#
;;   #4# #8#)

#+end_src
**** 0.03
#+begin_src scheme
;; (define syntax-example-of-add-vertex
;;   '(:type vertex-representation-for-add-vertex

;;     :v vertex-1
;;     :can (:value 111)

;;     :abut-edge-list-representation-for-add-vertex
;;        (:e edge:1-->2
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-of-this-edge vertex-2)

;;        (:e edge:1-->3
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-of-this-edge vertex-3)

;;        (:e edge:1-->2
;;         :can (:edge-type red-arrow)
;;         :abut-vertex-of-this-edge vertex-2)

;;        (:e edge:1-->3
;;         :can (:edge-type red-arrow)
;;         :abut-vertex-of-this-edge vertex-3)

;;        ))

;; (define example-graph
;;   '(:type <<graph>>


;;     :0-dimension-geometry-object-list

;;     #2=[:v vertex-2 :address #2#
;;         :can (:value 222)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]

;;     #3=[:v vertex-3 :address #3#
;;         :can (:value 333)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]


;;     :1-dimension-geometry-object-list

;;     #4=[:e edge:2-->3 :address #4#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-2 :address #2#)
;;            (:v vertex-3 :address #3#)]

;;     #6=[:e edge:3-->2 :address #6#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-3 :address #3#)
;;            (:v vertex-2 :address #2#)]


;;     ))


(define find-vertex-address-in-vertex-list
  (lambda (name-of-vertex vertex-list-of-the-graph)
    (cond [(null? vertex-list-of-the-graph)
           (error 'find-vertex-address
             "can not find a vertex in graph" name-of-vertex)]
          [(eq? ((take 1) ((find ':v) (car vertex-list-of-the-graph)))
                name-of-vertex)
           ((take 1) ((find ':address) (car vertex-list-of-the-graph)))]
          [else
           (find-vertex-address-in-vertex-list
            name-of-vertex
            (cdr vertex-list-of-the-graph))])))

(define add-vertex
  (lambda (vertex-to-be-processed the-graph)
    (add-vertex! vertex-to-be-processed (list-copy the-graph))))


;; add-vertex!它不是一個遞歸函數
;; 不是遞歸函數就意味着我可以最明顯的平鋪直敘的方式把程序先寫出來
;; 也許正是在這種平鋪直敘中最容易把程序先寫對
;; 也許正是在這種平鋪直敘中最容易找到程序中重複的模式
;;     把這些重複的模式抽象出來就簡化了代碼

;; add-vertex!完全是一個副作用
;; 返回的是副作用之後的輸入的圖的地址

;; 需要控制求值順序
;; 作出這個新的點
;; [1]把新的點加進0-dimension-geometry-object-list裏
;; 在製作這個新的點的同時需要:
;; [2]用遞歸的副作用擴充1-dimension-geometry-object-list
;; [3]          同時調整0-dimension-geometry-object-list中的其他點

(define add-vertex!
  (lambda (vertex-to-be-processed the-graph)
    (let ([list-of-abut-edge-to-be-processed
           (cdr ((find ':abut-edge-list-representation-for-add-vertex)
                 vertex-to-be-processed))])

      ;; SIDE-EFFECT:[1]============================================
      (let* ([head-of-processed-vertex ((find ':v) vertex-to-be-processed)]
             [address-of-processed-vertex  head-of-processed-vertex])
        (to-a-field-of-a-wlist--let-us-insert-a-val!
          ':0-dimension-geometry-object-list the-graph
          (append!
            head-of-processed-vertex
            `(:address ,address-of-processed-vertex)
            ((find ':can) vertex-to-be-processed)
            `(:abut-edge-list
              ,(map
                ;; SIDE-EFFECT-by-map:[2]==========================================
                (lambda (abut-edge-to-be-processed)
                  (let* ([head-of-new-maked-edge ((find ':e) abut-edge-to-be-processed)]
                         [address-of-new-maked-edge head-of-new-maked-edge])
                    ;; let*在上面的好處是 這樣就又更大的scope 返回值的之後也可能引用到這些綁定
                    (to-a-field-of-a-wlist--let-us-insert-a-val!
                      ':1-dimension-geometry-object-list the-graph
                      (append!
                        head-of-new-maked-edge
                        `(:address ,address-of-new-maked-edge)
                        ((find ':can) abut-edge-to-be-processed)
                        `(:abut-vertex-list
                          (:v ,((take 1) ((find ':v) address-of-processed-vertex))
                              :address ,address-of-processed-vertex)
                          (:v ,((take 1) ((find ':abut-vertex-of-this-edge) abut-edge-to-be-processed))
                              :address
                              ;; SIDE-EFFECT:[3]==========================================
                              ,(let* ([name-of-this-vertex
                                       ((take 1)
                                        ((find ':abut-vertex-of-this-edge)
                                         abut-edge-to-be-processed))]
                                      [address-of-this-vertex
                                       (find-vertex-address-in-vertex-list
                                        name-of-this-vertex
                                        (cdr ((find ':0-dimension-geometry-object-list)
                                              the-graph)))])
                                 (to-a-field-of-a-wlist--let-us-insert-a-val!
                                   ':abut-edge-list address-of-this-vertex
                                   (append
                                    ((find ':e) abut-edge-to-be-processed)
                                    `(:address ,address-of-new-maked-edge)))
                                 ;; RETURN-VAL:[3]--------------------------------
                                 address-of-this-vertex)))))
                    ;; RETURN-VAL-by-map:[2]--------------------------------
                    (append
                     ((find ':e) abut-edge-to-be-processed)
                     `(:address ,address-of-new-maked-edge))))
                    list-of-abut-edge-to-be-processed)))))

      ;; RETURN-VAL:[1]--------------------------------
      the-graph)))


;; test:
;; (add-vertex syntax-example-of-add-vertex
;;             example-graph)


;; (:type <<graph>> :0-dimension-geometry-object-list
;;        #0=(:v vertex-1 :address #0# :can (:value 111)
;;               :abut-edge-list
;;               ((:e edge:1-->2 :address
;;                    #1=(:e edge:1-->2 :address #1# :can
;;                           (:edge-type black-arrow) :abut-vertex-list
;;                           (:v vertex-1 :address #0#)
;;                           (:v vertex-2 :address
;;                               #2=(:v vertex-2 :address #2# :can
;;                                      (:value 222) :abut-edge-list
;;                                      (:e edge:1-->2 :address
;;                                          #3=(:e edge:1-->2 :address #3# :can
;;                                                 (:edge-type red-arrow)
;;                                                 :abut-vertex-list
;;                                                 (:v vertex-1 :address #0#)
;;                                                 (:v vertex-2 :address #2#)))
;;                                      (:e edge:1-->2 :address #1#)
;;                                      (:e edge:2-->3 :address
;;                                          #4=(:e edge:2-->3 :address #4# :can
;;                                                 (:edge-type black-arrow)
;;                                                 :abut-vertex-list
;;                                                 (:v vertex-2 :address #2#)
;;                                                 (:v vertex-3 :address
;;                                                     #5=(:v vertex-3 :address #5#
;;                                                            :can (:value 333)
;;                                                            :abut-edge-list
;;                                                            (:e edge:1-->3 :address
;;                                                                #6=(:e edge:1-->3
;;                                                                       :address #6# :can
;;                                                                       (:edge-type
;;                                                                        red-arrow)
;;                                                                       :abut-vertex-list
;;                                                                       (:v vertex-1
;;                                                                           :address #0#)
;;                                                                       (:v vertex-3
;;                                                                           :address #5#)))
;;                                                            (:e edge:1-->3 :address
;;                                                                #7=(:e edge:1-->3
;;                                                                       :address #7# :can
;;                                                                       (:edge-type
;;                                                                        black-arrow)
;;                                                                       :abut-vertex-list
;;                                                                       (:v vertex-1
;;                                                                           :address #0#)
;;                                                                       (:v vertex-3
;;                                                                           :address #5#)))
;;                                                            (:e edge:2-->3 :address
;;                                                                #4#)
;;                                                            (:e edge:3-->2 :address
;;                                                                #8=(:e edge:3-->2
;;                                                                       :address #8# :can
;;                                                                       (:edge-type
;;                                                                        black-arrow)
;;                                                                       :abut-vertex-list
;;                                                                       (:v vertex-3
;;                                                                           :address #5#)
;;                                                                       (:v vertex-2
;;                                                                           :address #2#)))))))
;;                                      (:e edge:3-->2 :address #8#)))))
;;                (:e edge:1-->3 :address #7#)
;;                (:e edge:1-->2 :address #3#)
;;                (:e edge:1-->3 :address #6#)))
;;        #2# #5# :1-dimension-geometry-object-list #6# #3# #7# #1#
;;        #4# #8#)

#+end_src
*** note about add-vertex
- k :: 讓我們來總結一下上面作副作用的方法
       看看我們是不是能夠提取出來一種更具體的代碼風格
- x :: 記得在寫list-copy的時候我們發現了一個可以改進scheme的地方
       我想問的是 這種改進能不能利用我們上面所使用的風格來實現??
       並且 如何實現編譯器才能以明顯地方式使用地址
*** add-edge
#+begin_src scheme
;; (define syntax-example-of-add-edge
;;   '(:type edge-representation-for-add-edge

;;     :e kkk-edge
;;     :can (:value kkk)

;;     :abut-vertex-list-representation-for-add-edge
;;        (:v vertex-2)
;;        (:v vertex-3)

;;        ))

;; (define example-graph
;;   '(:type <<graph>>

;;     :0-dimension-geometry-object-list

;;     #2=[:v vertex-2 :address #2#
;;         :can (:value 222)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]

;;     #3=[:v vertex-3 :address #3#
;;         :can (:value 333)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]


;;     :1-dimension-geometry-object-list

;;     #4=[:e edge:2-->3 :address #4#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-2 :address #2#)
;;            (:v vertex-3 :address #3#)]

;;     #6=[:e edge:3-->2 :address #6#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-3 :address #3#)
;;            (:v vertex-2 :address #2#)]


;;     ))

(define add-edge
  (lambda (edge-to-be-processed the-graph)
    (add-edge! edge-to-be-processed (list-copy the-graph))))

;; 比add-vertex簡單多了
;; 構造新邊
;; [1]加到:1-dimension-geometry-object-list中
;; 構造新邊的過程中需要
;; [2]調整:0-dimension-geometry-object-list中的兩個點
(define add-edge!
  (lambda (edge-to-be-processed the-graph)
    (let ([list-of-abut-vertex-to-be-processed
           (cdr ((find ':abut-vertex-list-representation-for-add-edge)
                 edge-to-be-processed))]
          [vertex-list-of-the-graph
           (cdr
            ((find ':0-dimension-geometry-object-list)
             the-graph))])

      ;; SIDE-EFFECT:[1]==========================================
      (let* ([head-of-processed-edge ((find ':e) edge-to-be-processed)]
             [address-of-processed-edge head-of-processed-edge]
             [name-of-vertex-1
              ((take 1)
               (car list-of-abut-vertex-to-be-processed))]
             [address-of-vertex-1
              (find-vertex-address-in-vertex-list
               name-of-vertex-1
               vertex-list-of-the-graph)]
             [name-of-vertex-2
              ((take 1)
               (cadr list-of-abut-vertex-to-be-processed))]
             [address-of-vertex-2
              (find-vertex-address-in-vertex-list
               name-of-vertex-2
               vertex-list-of-the-graph)])
        (to-a-field-of-a-wlist--let-us-insert-a-val!
          ':1-dimension-geometry-object-list the-graph
          (append!
            head-of-processed-edge
            `(:address ,address-of-processed-edge)
            ((find ':can) edge-to-be-processed)
            `(:abut-vertex-list
              (:v ,name-of-vertex-1
                  :address
                  ,(let ([address-of-this-vertex address-of-vertex-1])
                     ;; SIDE-EFFECT:[2](1)==============================
                     (to-a-field-of-a-wlist--let-us-insert-a-val!
                       ':abut-edge-list address-of-this-vertex
                       (append
                        ((find ':e) edge-to-be-processed)
                        `(:address ,address-of-processed-edge)))
                     ;; RETURN-VAL:[2](1)--------------------------------
                     address-of-this-vertex))
              (:v ,name-of-vertex-2
                  :address
                  ,(let ([address-of-this-vertex address-of-vertex-2])
                     ;; SIDE-EFFECT:[2](2)==============================
                     (to-a-field-of-a-wlist--let-us-insert-a-val!
                       ':abut-edge-list address-of-this-vertex
                       (append
                        ((find ':e) edge-to-be-processed)
                        `(:address ,address-of-processed-edge)))
                     ;; RETURN-VAL:[2](2)--------------------------------
                     address-of-this-vertex)))))))

    ;; RETURN-VAL:[1]--------------------------------
    the-graph))

;; test:
;; (add-edge syntax-example-of-add-edge
;;           example-graph)

;; (:type
;;  <<graph>>
;;  :0-dimension-geometry-object-list
;;  #0=(:v vertex-2 :address #0# :can (:value 222)
;;         :abut-edge-list
;;         (:e kkk-edge :address
;;             #1=(:e kkk-edge :address #1# :can (:value kkk)
;;                    :abut-vertex-list (:v vertex-2 :address #0#)
;;                    (:v vertex-3 :address
;;                        #2=(:v vertex-3 :address #2# :can
;;                               (:value 333) :abut-edge-list
;;                               (:e kkk-edge :address #1#)
;;                               (:e edge:2-->3 :address
;;                                   #3=(:e edge:2-->3 :address #3# :can
;;                                          (:edge-type black-arrow)
;;                                          :abut-vertex-list
;;                                          (:v vertex-2 :address #0#)
;;                                          (:v vertex-3 :address #2#)))
;;                               (:e edge:3-->2 :address
;;                                   #4=(:e edge:3-->2 :address #4# :can
;;                                          (:edge-type black-arrow)
;;                                          :abut-vertex-list
;;                                          (:v vertex-3 :address #2#)
;;                                          (:v vertex-2 :address #0#)))))))
;;         (:e edge:2-->3 :address #3#)
;;         (:e edge:3-->2 :address #4#))
;;  #2# :1-dimension-geometry-object-list #1# #3# #4#)
#+end_src
*** >< delete-vertexa
*** >< delete-edge
** syntax of directed-graph-processing language
*** design the syntax
1. 使用sexp作爲基礎
   單純的是因爲這樣語法分析就很方便
2. 在語法的設計上我決定大量的利用樹
   因爲樹是可以方便的用sexp來表達的
   而sexp是很容易被處理的
*** 關於語法的遞歸定義
用我的語法描述同一個圖的方式顯然不唯一
所以不能用歸納定義良好地定義 然後再被遞歸函數處理
對圖的處理將是那些進行副作用的基本有向圖操作
還有ζ-cal
*** what is needed?
**** by daedalus
1. 通過描述一個只有根節點被標記了的有向樹
   並描述這些樹的節點之間的另外的有向邊的連接關係
   來讓機器初始化一個連通度更高的有向圖
2. 被標記了的節點是這個圖的入口
   我可以沿着有向邊或逆着有向邊行走以遍歷這個圖
   以這種遍歷方式爲基礎我可以實現call-by-need
**** >< by inference-rules
1. 首先是對inference-rules的正確理解
2. 需要不斷的向一個有向圖中引入節點
   新引入的節點有可能以原圖中的節點爲父節點
   或者新引入的節點是一個孤立的點
   等等
3. 必須有一個良好的對有向邊的標記系統
   因爲每個inference-rule的一次出現都必須被獨立標記
**** by cayley-graph
1. why not use cayley-graph to model a group?
   人們以前爲什麼沒有這樣做過?
2. 惰性
   因爲有趣的cayley-graph常常是無窮的
   所以我必須實現一種對圖的惰性構造
**** category theory
範疇論中的論證與實現都是在用一些圖而已
而代數化的理解範疇論更是能聯繫起來更多的問題
**** beyond the needs
1. 我的有向圖處理語言的適用性必須足夠地廣泛
   重要的是
   在我的語言內要同時保證
   對上面所有這些問題的解法
   都可以用簡明的語法描述給機器聽
   如果成功了那麼我的語言就一定還能適用到一些我現在還沒想到的地方
2. 也許需要同時實現對有向圖的各種表示
   比如就圖之間的同構這種拓撲性質而言
   可能需要特殊的對圖的表示
3. 也許實現各種不同的表示之間的快速地同構變換
   還要維護對一個圖的多種表示同時存在的情形
   如果同構變換的速度不夠快的話
   + 爲了作出良好的判斷
     我需要算法分析的知識
   這時可能就要接受兩種表示之間的差異
   讓一個圖的多種表示漸進地改變
   如果真是這樣那實現起來就相當複雜了
**** why need?
1. 使用有向圖處理語言
   而不是字符串或列表處理語言
   可能速度會變慢
   但是這使編程者對代碼的理解更加清晰
   在這方面複雜性的降低所帶來的好處
   完全可以彌補速度變慢所帶來的不足
2. 當使用=α=這種概念來處理約束變元的時候
   實現起來出現了困難
   其實就已經說明這種想法錯了
   而應該改用更清晰的方法來實現所希望的特性
   即使用有向圖
3. 當被引入的關係是等價關係時
   比如=β=
   與其把這種引入理解爲
   對更高一層次的字符串的集合的歸納定義
   還不如直接把等價關係理解爲分類
   然後用與分類有關的算法來實現這些東西也許會好些
   + 算法分析的知識變地越來約迫切了
   這裏能用圖論來理解嗎?
   能
   等價關係就是以歸納定義樹爲基礎
   一個後繼型關系所成的有向圖中的無向路
4. 當被引入的關係是由類後繼關係生成的偏序關係時
   比如-β->爲-sβ->所生成
   與其把這種引入理解爲
   對更高一層次的字符串的集合的歸納定義
   還不如直接把後繼關係理解爲有向圖
   這樣纔是自然的
5. 實現一個形式理論的方式如果和最自然的理解方式相一致
   那當然是最好的
6. 對一個字符串的集合的歸納定義
   其實想定義的是樹
   每個被認爲是元素的表達式其實都是樹
   只不過只有葉節點被標記了
   var ::= v | var'
   term ::= var | (term term) | (λ var . term)
   就是典型的例子
   歸納定義的字符串的集合的時候所使用的括號``()''
   其實是爲了形成樹的語義
   即 如果直接用樹來定義term就沒必要使用括號了
   但是實踐中
   人必須能告訴機器應該怎麼作
   因此想要在這裏省略括號而形成更適合於人類的理解
   人就發現還是得使用括號
   因爲sexp作爲語法已經很簡明瞭

*** init a graph
**** design
現在明白類似javascript的alist處理語言的好處了
在我將設計的類javascript語言中
>< 可以用與約定來區分key的書寫方式
大寫開頭的是被約定成變元好還是被約定成函數好呢???
別的語言是如何處理這個問題的??? 區分嗎???
#+begin_src scheme
([:v :can]
      ([:v :can]
            ([:e :v :can]
                  ([:v :can])
                  ([:e :v])))
      ([:e :v :can]
            ([:e :v :can])))


λx.xx
(<graph>
 ([:v λ]
     ([:e --> :v :can <-- λ])
     ([:e --> :v :can <-- λ])))


對與沒有出現:v :e 的地方 或者其後是空值的地方
當約定了默認值時就使用默認值
如果沒有規定默認值就使用無名的點或邊
:e -->在這裏可以被認爲是默認的所以有:

(<graph>
 (:default (:e -->))
 ([:v λ]
     ([:v :can <-- λ])
     ([:v :can <-- λ])))


λx.x(λx.xx)

(λ (x)
  (x (λ (x)
       (x x))))
(<graph>
 (:default (:e -->))
 ([:v λ]
     ([:v :can <-- λ])
     ([:v λ]
        ([:v :can <-- λ])
        ([:v :can <-- λ]))))

下面這個就是另外一個圖了
λx.x(λy.yx)
(<graph>
 (:default (:e -->))
 ([:v λ]
    ([:v :can <-- λ])
    ([:v λ]
       ([:v :can <-- λ])
       ([:v :can <-- <-- λ]))))



使用有向路可以以一點爲基礎來指出另一點的位置
使用有向樹可以以一點爲基礎來指出另外很多點的位置
注意: 當允許邊和點重名時 就有可能出現(語義上)完全不能區分的點或邊
比如在對稱性很強的圖中就是這樣
#+end_src
**** code
這個compiler的將以簡單的方式工作
並且其行爲將符合人們的直覺
即 先構建一個樹 然後再作連接

它只使用到add-vertex和add-edge
#+begin_src scheme

λx.x(λy.yx)
(<graph>
 (:default (:e -->))
 ([:v λ]
     ([:v :can <-- λ])
     ([:v λ]
        ([:v :can <-- λ])
        ([:v :can <-- <-- λ]))))

;; 樹代表支撐樹
;; 支撐樹的葉子是遞歸函數的基本步驟
;; 節點被編譯成``對點的添加'' 此時需要子節點和邊的信息
;; :can中的數據被編譯成``對邊的添加''
;; ``對邊的添加''被作爲副作用在支撐樹構造完成之後進行
;; 輸入的例子:
;; ([:v λ]
;;    ([:v :can <-- λ])
;;    ([:v λ]
;;       ([:v :can <-- λ])
;;       ([:v :can <-- <-- λ])))
;; 返回一個製作好的圖 ???
;; 還是返回編譯好的生成圖的代碼 ???
;; 因爲那些節點是無名的 或者是重名的
;; 所以就算有通過描述兩個點的 對邊的簡單添加
;; 我還是沒辦法寫出下面的初始化
(define init-graph
  (lambda (spanning-tree)
    ;; 每次遞歸處理一個點和它的子節點
    (let ([vertex (car spanning-tree)]
          [subvertex-list (cdr spanning-tree)])
      ()
      ;; 下面是遞歸調用
      (map init-graph subvertex-list)
      ;; 下面是返回值
      ()
      )))
#+end_src
*** - k :: x, digrap是否適合用來實現和研究各種圖論算法???
- x :: 我也不知道
       因爲我現在還不知道digrap是什麼樣的呢
*** ><><>< use small graph to build biger graph
*** ><><>< tree-instruction
to use a tree like instruction
to tell the machine how to change the graph it stored
** ζ-cal
* >< to design a new language
- y :: 對語言學的不斷學習也許在於
       希望我的表達能夠儘量緊跟我的思想
       因爲沒有什麼比有一些想法而難以表達出來更令人痛苦的了
       尤其是學習一門外語(程序語言)的時候
       這種表達與思想之間的脫節是最痛苦的
       同樣也沒有很多事情是比設計一個語言更有趣的了
       當你有能力作出這樣的設計的時候
       你一定會產生很多新的想法
       因爲對思想的表達影響思想本身
- x :: 但是說我們要設計一個新的語言是什麼意思??
       讓我們來更細緻地分析一下這個任務
- y :: 我們可以通過讓我們的所指變得狹隘來具體化我們的表達
- x :: 但是我們不要使用傳統的定義一個程序語言的方式
       看看我們能有什麼有趣的新想法
- y :: 好的
       我知道有很多傳統的描述程序語言的性狀的術語
       比如 函數式 面向對象 模塊系統 類型推到系統 等等
       我們要暫時拋棄這些術語
       而試圖迴歸問題的本質對嗎?
- x :: 沒錯
       並且我想最本質的地方可以沒有一箇中心
       讓我們以``去中心化''的方式儘可能多的描述我們想要尋找的源頭
       比如 說程序語言的產生在於
       1- 爲了使用計算機來計算某些數學問題
       ><><><


------------------------------------------------------
關於scheme中的數據類型
利用wordy-list這個數據結構
約定一個wordy-list中的:type這個key後面跟着對類型的描述就可以了
這樣對類型的描述就沒有任何的限制了
------------------------------------------------------

- y :: 使用一個統一的數據結構(比如lisp的列表)
       減少了理解整個系統工作方式的負擔
       但是會增加人閱讀代碼時的認知負擔
- x :: 沒錯
       我想``認知負擔''這個名詞很恰當地表達處理
       在使用scheme的時候我的某些感受

- 關於語法設計
  我已經擁有的是一種計算模型
  而這種計算模型以什麼樣的方式(語法)被表現出來都是沒有關係的
  當然應該設計出精簡而易讀而易於處理的語法

- 語義的設計
  language-kernelisation as math-formalisation as factoring

- 關於標準化
  create a standard approach to common problems
  like concurrency, threads and os calling
  爲了讓跟多的人接受這個語言
  這些工作是必要的
  但是也許我根本就不想讓很多人都接受這個語言

- 關於對底層操作的保護
  有人認爲作爲一個程序員
  你在什麼抽象層級工作 你就理解這一層次的基礎結構就好
  但是我不這麼認爲
  我必須在每一層次都打開通向更低層次的通道
  當擁有統一的調用和通信接口時
  一段代碼可以用不同的語言寫成
  用一些標記語言就可以把代碼塊解析出來
  因爲這些不同的mode只不過是不同的編譯器或解釋器而已

- 關於類型系統與面向對象
  1) 類型系統的產生在於:
     你發現你在寫一個函數的時候經常先去設計這個函數的類型
     先把這個函數的參數與返回值的類型寫出來作爲註釋
     然後你想 何不把這種東西加入到編譯器中呢?
     這樣編譯器就會更高效
     同時報錯系統何以實現地更加完善
  2) 如果類似的去猜想面向對象的產生的話 那麼就是:
     你發現每次你實現數據類型的時候
     你都先去設計這個數據類型的接口
     你把它們寫成註釋
     然後你想 何不把這些東西加到編譯器中呢?
     於是以後你就同時定義數據類型與接口
     程序的模塊化更強了
     + 節約了命名空間 程序也更好讀了
  可見一個是以函數爲中心 一個是以數據結構爲中心
  去掉堂皇的部分之後發現這兩個都是好主意
  但是衝突在於
  爲了讓機器來處理
  就要限制了設計數據結構和接口的方式
* >< cicada
1. 我發現cicada讓我對lambda-cal的理解產生了變化
   也就是在用函數複合語義來實現lambda-cal的過程中
   因爲表達方式的變化
   而讓我看到了我以前沒有認識到的東西
   比如lambda-term的嵌套
   在cicada中也能形成lambda-term的嵌套
   只不過所使用的語法元素更多了
   也許這讓表達變得繁瑣了
   也許這讓表達變得清晰了
2. 以函數複合語義爲基礎的表達是否適合用來實現digrap ???
   我必須探索一下可能性
   要知道在沒有副作用的λ-cal中每一次計算都是rewrite
   而每次rewriting都是由λ-application引起的
   但是在cicada中現在對λ-cal的實現方式卻很不一樣
   在cicada中需要:
   1) 準備參數
   2) 製作lambda-body
      即 λ-abstraction
   3) apply
      即 λ-application
   每一次計算是由對lambda-body中的一個元素的executing引起的
   是這樣的嗎??
   如何理解cicada中lambda的行爲呢??
   回到純粹的函數複合語義試試
   還是一個word一個word的複合
   但是``( )''或``[ ]''會被看成是一個整體
   不行這一定會破換函數複合語義的
   想一想製作參數的過程就知道了
   如果還堅持那個交換代數的話
   那麼這裏這個交換代數的性質瘋狂地退化了
   與置換羣中的置換相比這裏用來做複合的函數簡直是怪物
3. 其實如果我只使用<lambda>這個數據結構的話
   那麼語義又可以迴歸簡樸
4. 當設計了λ的語法
   然後過了Y的測試之後
   我就給Dan寫郵件
5. 我明白了λ-cal的那種單純性在於之以λ-term爲數據結構
   甚至在scheme中這種單純性也不復存在
   所以cicada沒有什麼好慚愧的
6. cicada在一個lambda-body中保存一段基於棧的計算
   這種性質其實是非常好的
   試想其他基於λ-cal的語言
   在想要引入有別於λ-term的數據結構的時候的困難就知道了
* --------------------------------------------------
* pi-cal
點之間有一條邊相連時
它們之間就可以用這條來傳遞信息
><><>< 在digrap中如何理解這一點
---------------------------------------
lambda-cal可以被看成是
在用一種形式語言來描述某種類型的有向圖
pi-cal更明顯地也可以看成是如此
---------------------------------------
input port & output port
of the so called agent
---------------------------------------
比如考慮對一個lambda-term的reduce
顯然我可以把reduction的不同部分的工作分配給不同的cpu
然後當全算玩之後把結果返回給我
好讓我作最後的處理以返回最終結果
---------------------------------------
output & input actions
---------------------------------------
有很多的``functional-computer''
必須能以明顯地控制參數在它們之間的傳遞方式
讓機器a計算F這個函數
讓它從機器b和機器c那裏拿參數
讓它把返回值返回到機器d
在這個過程中
機器bc對兩個參數的計算可以是同時進行的
而機器a必須等待兩個參數都到齊
參數的傳遞是通過輸入輸出設備來完成的
---------------------------------------
每個機器都有一個獨立的棧
一個機器可以用自己的棧進行計算
也可以pop和push 各種port棧
必須處理``等待''的問題
即``算好了''這條信息的傳遞的問題
* ==================================================
