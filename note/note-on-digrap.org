#+TITLE: note on digrap
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* digrap
  以有向圖爲基本數據結構的語言:
  DIGRAP :== DIrected GRAph Processing

  實現對有向圖而言的各種等詞:
  1. 在以圖爲數據結構編程時
     這些這些等詞是基本工具
  2. 在實現數學形式語言時
     這些等詞是形成命題的基礎

  說對λ-cal還有對rewrite-rules的實現就是對圖(圖的圖)的惰性求值
  這裏這些圖的特點是什麼
  反過來問: 是什麼使得對它們的惰性求值可以用λ-cal或rewrite-rules來描述?

  是對節點和邊的標記系統嗎?(約束變元)
  每個站在一個節點上看看這個節點的標記
  再看看某一條有向邊的標記
  就能知道從這個節點沿着這個有向邊走過去的節點的標記

  這對cayley-graph的使用有什麼啓示

  note about λ-cal:
  我把對λ-cal的實現理解爲對有向圖的惰性求值
  但是這樣作好像並不自然
  不管是在理解方面還是在實現方面都是在倒退
  因爲
  當人對一個有向圖的惰性求值形成了λ-cal這樣的編碼
  他就獲得了更特殊化的語義

  我把一次-sβ->理解爲添加一個節點再刪去一個節點
  而他把一次-sβ->理解爲把一個編碼轉化爲另一個編碼
* misc & remarks
** PLATONISM
*the world of mathematics exists independently of the mind of the mathematician*
*every statement that makes mathematical sense is either true or false*
statement that makes mathematical sense are called proposition
** BROUWER
*the foundation of mathematics is in the intuition of the mathematical intellect*
*proof by contradiction is not an acceptable proof rule*
** ><
`if ... then ...'
is different form
`thus' `therefore' `so' `hence' `since'
in mathematical reasoning (about the rules of inference)

converse and contraposition

bi-tree of proposition
=connectives=>
proposition

open proposition
=quantifiers=>
less-open proposition

quantifiers:
if is there is no set theory at first
how can there be quantifiers ?
by inference-rules of course
and by the following sugar
∃x∈A(...) :=sugar= ∃x(Ax∧...)
∀x∈A(...) :=sugar= ∀x(Ax∧...)
and there are matter of scope
just as in the case of λ-abstraction

function:
f: X -> Y
∀x∈X∃!y∈Y(xfy)
here comes another kind of scope problem
about dependence
∀x∈X∃!y=y(x)∈Y(xfy(x))

scope problem should always solved by graph theory

inference-rules:
(A A→B) ==> B
C→A(x) ==> C→∀xA(x)
A(x)→C ==> ∃xA(x)→C


rewrite-rules are about computation
but inference-rules are not
>< do not have a computational nature ??
>< yes ???

``the quantiers usually range over
an infinite set and therefore one loses decidability''

``Aristotle had already remarked that it is often hard to find proofs
but the verification of a putative one can be done in a relatively easy way''

so i should write something to help to show a math proof

A more eficient way to represent proofs employs typed lambda terms
and is called the propositions-as-types
which maps propositions into types
and proofs into the corresponding inhabitants
>< how about axioms ?

* hacking
** 關於無窮有向圖的惰性求值
1. 對無窮有向圖的處理只能是惰性的
   機器需要知道的是如何在需要的時候到達這個圖中的任何一個節點
   當機器已經有這樣的知識之後
   既然關於這個圖的一切已經蘊含於這些知識當中了
   我如何能表達關於這個圖的一般性質
   我現在只知道對這些性質的表達一定是在一個更高層次的語言中進行的
2. 既然實現一個形式語言被我理解爲
   實現對一個無窮有向圖的惰性求值
   我想最適合用我的語言實現的語言應該是
   一些製作形式語言的工具
   + 首先hott中各種關於語言的實驗在我的語言中就方便多了
3. 更廣泛的
   當我能方便的處理有向圖時
   因爲使用了一個性質更豐富的基礎數據結構
   在使用這個語言的時候對於很多事情都能產生新的想法
   尤其是關於計算的理論
   還有關於數學
** 關於範疇論於運算級
既然我已經給出來了自由代數結構這個基礎
>< 那麼我關於運算級的想法是否可以用範疇論的語言來表達??
+ 不可以
  因爲範疇論不適合用來描述具體的(構造性的)數學結構
  要知道在最開始發展等級理論的時候我就是要發展彌補範疇論的這種弱點的方法
>< 級數的升高惡化着級數升高的條件
使得級數的繼續升高成爲不可能???
** as language
最沮喪的時候
也要知道
hott是關於語言的學問
因爲我已經發現
在回到更傳統的數學活動當中時
我的思考方式和表達方式
已經被λ-cal與類型論完全改變了
我想更深刻的
改變我的認識與方法的是
1. 對形式語言的學習
   增強了我對數學概唸的表達能力之外
   還讓我形成了排斥形而上學的習慣
2. 對計算理論的學習
   現在在方法上面我更注重可構造性和可實現性
** 關於極簡主義
我已經知道該如何去推廣λ-cal以形成一個數學背景
來設計我的語言的語法了
只是還有一兩個問題沒有想通

除此之外對於理論的創造而言有一個重要的哲學觀點需要被我認同
那就是極簡主義
``programming languages should be designed not by piling feature on top of feature
but by removing the weaknesses and restrictions that make additional features appear necessary''
-- R5RS

但是我很難遵循極簡主義
因爲我處理的問題本身的複雜性
但是這只不過是一個藉口而已
``有很多方式可以建立幾何學
但是是歐幾里得說明我們只需要五個公理''
古代的人也許也認爲那種幾何是複雜的呢

那麼我需要作的就是看到有向圖處理的本質

但是也許我的整個計劃就是在違背極簡主義

* ζ-cal
** note
也許最後我會發現我所尋找的解決辦法極其簡單
只不過我一直沒能認清一直就在我眼前的事實而已
abstraction與application的意義本來就是相當廣的
比如λ-abstraction對rewrite的抽象可以是就有向圖而言的
我稱這種廣義的λ-cal爲ζ-cal
ζ-cal == basic-directed-graph-processing
       + ζ-abstraction
       + ζ-application
       + ζ-lazy-eval
** my understanding of λ-cal
λ-ap是對葉節點被自由變元標號了的
分叉數爲2或1的樹(有向圖)的遍歷
其中每次遍歷到λ-ap的時候樹就會按<-β-所描述的規則變化
1) λ-ab的局部性:
   對一個葉節點對的處理並不會影響這個葉節點對之外的圖的其他部分
2) λ-ab的形成的任意性:
   以任意一個term爲基礎
   然後指定一個自由變元
   就可以形成一個λ-ab
   之後這個自由變元就變成約束變元了
** 類比
1) 用鏈表來實現λ-cal
   之後寫出複雜的列表處理的函數就全在於λ-cal了
   此時還需要對rewrite(比如-β->)的實現
   即一個解釋器
   + 此時需要對約束變元作技術性的處理
     要麼用重命名的方法
     要麼用用有向圖來處理
   + 反過來λ-cal可以完成對鏈表的處理
2) 用有向圖處理來實現ζ-cal
   反過來這種ζ-cal可以完成對有向圖的處理
   之後寫出複雜的有向圖處理函數就全在於ζ-cal了
   + 有了這層語義
     就算是對有向圖這種複雜數據結構的處理
     也能使用函數式編程範式了
3) 類比還在於 我能把λ-cal包含在ζ-cal之內
** ζ-cal作爲λ-cal的推廣
下面的理解最重要:
應該把λ-cal也理解爲一個對二叉樹的惰性求值系統
+ 用樹來考慮下面的東西
尤其是考慮到絕對的自由變元時更應該如此
那麼這種惰性求值系統的特點是什麼呢???
有所謂的惰性求值之後就能用有限的元素來表達無窮的結構
那是因爲對與這種圖人們規定了一種特殊的遍歷方式 即-β->
並且要知道 一個term是不是λ-abstraction都沒有關係
對λ-abstraction內部的東西也是可以進行求值的
λ-abstraction並沒有特殊性
+ 難點在於當遍歷到一個λ-application時
  它本身與周圍的圖的鏈接方式是平凡的
  它求值之後所得的東西與周圍的圖的鏈接方式也是平凡的
  但是對與一般的有向圖這一點並不成立
  這裏的複雜性可能是本質的
  也就是說ζ-cal必須描述兩種鏈接方式
  + 但是如果有局部性的話 如何呢?
    整個式子((ζ <body>) <arg>)是以某種方式嵌在一個被遍歷的大的圖中的
    <body>的外圍與外面的大圖的鏈接方式是已知的
    而<arg>被代入<body>所改變的邊並不影響<body>的外圍與大圖的鏈接
    這就是局部性
    但是問題又回來了
    即 這樣就沒法把(ζ <body>)當作一個獨立的東西了
    只有當指明瞭<body>與大圖的鏈接方式的時候(ζ <body>)纔有意義
    或者(ζ <body>)可以被當作獨立的東西
    但是每次被放入大圖中的時候都必須說明<body>中
    沒有被ζ的抽象所影響的部分如何與大圖相鏈接
    沒錯
    這是合理的
    因爲在有向圖處理中擴大一個圖就是去說明一些複雜的鏈接方式
    這樣一個重大的問題就解決了
    + 可以說就幾何直覺而言現在已經沒有任何難點了
    還有一個重要的問題就是形成遞歸
    這將是要在下面提到的
    即 形成具有無窮性的結構(比如遞歸)的本質不在於巧妙的term
    而在於自我引用
在有向圖處理中
在一個需要惰性求值的點處對原圖的其他部分的引用也是可以想像的
+ 畢竟λx.F(xx) λx.F(xx)之所以能形成遞歸對遞歸函數的定義
  是因爲前面的λ-abstraction作用於與自身相同的λ-abstraction
  或者說前面的λ-abstraction在作用於自身
類似於分形的圖是經過無窮次的遞歸得來的
因此就與fixed-point有關
因此也與遞歸有關
+ 考慮Y所生成的遞歸函數作爲無窮二叉樹的性質
  那也是分形
  因爲那是在-β->的特殊指引下自身在引用自身
  這就是分形的本質
  也是那些正規的無窮圖的本質
** 對圖的基本處理
有以下基本操作:(其實ζ-cal本身就也是被基本的有向圖處理實現的)
1. 利用樹來初始化一個圖
2. 將兩個圖用一些新的有向邊相連
3. 刪除某些節點
4. 刪除某些邊
5. 改變某個點或邊中所存放的東西
   點和邊裏是可以存放東西的
   而且沒有類型的限制想存放什麼就存放什麼
   就像lisp的list能夠保存任何類型的數據一樣
   我需要我的有向圖也有能力保存任何東西在裏面
** ζ-abstraction (ζ-ab)
對於一個圖 指定其中的一個基點
1. 以這個基點爲基礎用一棵樹來指明一個有序節點列
   這個有序節點列是爲之後的"擴大"所準備的接口
   當這些接口被拼接時這個圖會被擴大
2. 以這個基點爲基礎用一棵樹來指明一些將被刪除的節點
   這樣會使這個圖縮小
3. ><><>< 那麼其他的對圖的操作如何呢???
   這就是所有的操作嗎???
4. >< 可以變大可以變小我就掌控了所有的變化 ??
5. 所列出來的兩個點列中
   哪些點會被刪除或者哪些點會被鏈接
   都是要等到ζ-application的時候纔會被明確的
6. 整個ζ-abstraction也是一個特殊的圖而已
   只要使用從一點出發的一些有向邊來指明一次抽象中的
   接口節點列和所能刪除的節點列 就行了
   這樣我就可以利用ζ-abstraction把某一類型處理抽象出來
7. 一個ζ-ab作爲一個gexp
   就像一個小機器一樣
   在ζ-cal的語義中它以其中被抽象了的點爲接口
   對於一個ζ-ab(as gexp)我可以實現一些基本的函數來查看它作爲機器的性質
   比如:
   1) 詢問這個ζ-ab中所有被抽象了的點
   2) 詢問一個點的接口點列和可刪除點列
   3) 等等
   4) 這些詢問所返回到的信息應該能直接被ζ-ap中的ζ-con利用
** ζ-application (ζ-ap)
這時候我手上有兩個ζ-ab
就像我知道一個函數(λ-abstraction)的性質一樣
+ 函數的:參數個數與類型 返回值個數與類型
  其中個數不是本質的類型纔是本質的
在這裏我也知道ζ-ab的性質:
1. 它所能刪除的點列
2. 它的接口點列
一次ζ-ap就是:(注意只有兩個ζ-ab才能被作用)
ζ-ap == (ζ-ab ζ-con ζ-ab)
其中ζ-connection是對連接方式的描述
+ 注意這看起來是對稱的
ζ-ap也是用一個圖來表述的
這樣一個ζ-ap的結果就可能是一個新的ζ-ap
+ 對ζ-ab的處理就是一個需要類似於解釋器的東西的地方!!
+ 雖然不是類型系統
  對接口與連接方式的匹配的要求
  同樣也是對函數的輸入與輸出的限制
  也許引入適當的語義
  我就能以這種方式給出一個類型系統的模型
** ζ-lazy-eval
1. 這是很樸素的想法
   即上面的ζ-ap是真正被遍歷到的時候纔會被進行的
   因爲ζ-abstraction也是用一個圖來實現的
   所以這種lazy-eval很容易實現
2. 對於lazy-eval這個詞
   其實還可以有不同的理解
   因爲這裏所描述的惰性
   並不是primitive的惰性
** 關於嵌套與自我引用
1. 其實也很簡單
   ζ-ap的嵌套是自然的
   一個ζ-ap的結果就可能是一個新的ζ-ap
   它使得對某個圖的遍歷方式變得複雜
2. 而自我引用就是沿着新的邊走卻又走回了原來的節點
   這些一起使得可以形成複雜的無窮圖
** 關於透明性
所謂透明性就是把ζ-abstraction於ζ-application都表示成有向圖
這樣我可以完全剔除約束變元
而解釋器對ζ-cal的實現就是有向圖處理
** 再次回到基本操作
1. 顯然只要基本操作不改變ζ-ab中的接口點列中的點
   那麼任何操作都是合法的
   也就是說ζ-ab是可以被基本操作來作用的 它們跟一般的圖沒什麼區別
2. 基本操作甚至可以形成手術
   來改變描述ζ-ab中的接口點列和可以被刪除的節點列的有向邊
   這就是透明性所帶來的好處
   任意一個用圖描述的圖的算法
   都是一個圖而已
   可以很容易的拿出來修改與考察
** >< 關於代數
如果我希望作類比
那麼就應該有更完整的類比
即 λ-cal的代數的一面也應該被類比到
這看似異想天開
因爲一般的代數結構自然的會形成二叉樹
但是這其實並不是不可能
考慮一下高維同論羣就知道了 !!!

考慮跟λ-cal有關的豐富的數學理論:
範疇論 代數拓撲 等等
可想而知ζ-cal這種計算模型的背後所隱含的數學理論是非常新而豐富的

比如我可以嘗試先在λ-cal的圖論意義和λ-cal的代數意義之間建立一種關係
然後再利用這種關係從ζ-cal的圖論找到ζ-cal的代數意義

但是這幾乎是不可能的
因爲在進行一個ζ-ap的時候
我不光只需要那兩個ζ-ab而已
我還需要一個額外的東西來指明這兩個ζ-ab如何相鏈接
這已經出離一般的代數結構之外了

但是也沒有出離的太遠
畢竟這是不過是:
(ζ-ab ζ-con ζ-ab) -> ζ-graph
+ ζ-graph == gexp

既然如此
其實代數意義就已經喪失了

如果只是在遍歷圖的時候其中的一些部分被惰性求值
那麼如何觸發一次ζ-ap的進行??
這一點還沒想清楚
完全的惰性求值就沒有這種顯式的觸發
也許增加一個可以控制ζ-ap的觸發的機制
我就能實現對求值時間的控制

如果我固定一種(或某些)ζ-con
並且將ζ-ab一一定那個的方式封裝起來
我就很容易回到一種代數語義
比如利用上面的方法我可以回到λ-cal
** >< 例子(需要更多的例子)
對那個無窮五星圖
遍歷到中點的鄰點時需要把中點代換爲一個五星
然後把代入的五星與原圖相連
這就是用惰性求值的ζ-ap來實現的
但是完全自我引用就會形成循環
所以對自我引用應該至少提供兩種處理方式
1. 一種會形成真正的新的節點
2. 而另一種不會
對於形成真正的新節點者
自我引用是假的
自我引用只是提供了一個和自己相同的模板來擴大這個圖
** >< 打印
我需要對文件的結構化讀寫 這裏有是一個新的設計領域
>< 打印可以用支撐樹來作嗎?
圖中也許必須包含一些額外的信息來建議如何把一個圖打印出來
** 何謂用圖來表示對圖的操作?
即對圖的遍歷方式有兩類
一類是按語法遍歷
一類是按語義遍歷

按語義遍歷就是說 像((λ ***) ***)節點對一樣被<-β-處理一樣
這樣我就能夠把ζ-abstraction在圖中利用其它ζ-abstraction的作用來代來代去
然後形成ζ-ap
ζ-ap的返回值可能還是ζ-ap
+ 有一步的-ζ->和多步的-ζ->
  即我能控制求值的方式
我的圖的表達式中也要有匹配到某種模式的圖被按語義處理
這需要一些設計 但是簡單的
重點是所有這些必須都用有向圖處理來實現
** 關於編程範式的形成
純粹的(只有變量沒有常量)λ-cal是用list來表示處理list的算法
+ 或者說 是用λ-term來表示處理λ-term的算法
  其實只是代入而已 所以說成是list更確切
增添上常量之後就形成了函數式編程系統
lisp中list的一個特點是 list中可以包含任何其他類型的數據
這些常量就是用來處理這些數據用的
+ 在scheme中:
  atom: 非list類型的數據
  primitive: 處理這類數據的函數

這樣就給了digrap以啓發:
ζ-cal是用directed-graph來表示處理directed-graph的算法
directed-graph的點和邊中可以包含其他類型的數據
對其他類型的數據的處理用primitive來完成

>< 問題是這兩種類型的函數如何相互協調???
在lisp中primitive的作用方式與λ-ab的作用方式是一致的
但是在初步的設計中digrap中ζ-ab的作用方式並不與primitive的作用方式一致
只要解決了這個問題
我就形成了一種新的編程範式
** >< 關於對函數式編程範式的維持
看看一個ζ-ap的樣子:(ζ-ab ζ-con ζ-ab)
就知道我能得到的是比以λ-cal爲核心的函數式編程範式更豐富的一種編程範式

而每個對於gexp的操作(比如一個基本操作或者一個ζ-ab)都可以有兩個版本
一個使用被處理的圖本身(通過地址)
一個使用新複製的一個被處理的圖
這樣一個第二個版本的ζ-ab就可以像數學中的函數一樣
在多次的作用中維持一致的行爲
這就是我所繼承的函數式編程範式的基因

要想形成新的編程範式在於用我所設計的模型來形成各種基本的計算語義

比如:
1. 利用ζ-cal來實現λ-cal
2. 利用ζ-cal來實現遞歸函數
3. 利用ζ-cal來實現類型系統
在作這些工作的時候我一定能發現更多的
對我應該如何設計ζ-cal的啓示

首先既然λ-cal被理解爲是用有向二叉樹表達的對有向二叉樹的操作
那麼用ζ-cal來實現λ-cal是非常簡單的
也就是說ζ-cal的抽象能力顯然比λ-cal更大 但是也更複雜
因爲使用了結構更豐富的數據結構
所以我的計算模型一定可以以更簡單的方式表達一些
利用λ-cal和其他計算模型表達起來更複雜的計算
** ><><>< 什麼是計算???
在我的語言內
計算竟被理解爲用圖表達的對圖的操作
把這個問題追問下去很可能令人陷入瘋狂
** 關於高階函數
在digrap中函數的階的樣子很不一樣
可以把一個gexp中的被抽象了的點的個數定義爲方程的階
但是這些點之間是平行的關係
所以階這個詞所暗示的序關係其實是錯誤的
* implementation
** note & rationale
- h :: 獲得關於一個理論的堅固知識的方式就是去實現它
       這同時也幫一個人考察了他所觀察的理論的可實現性

digrap是嵌入scheme的
嵌入scheme是正確的選擇
並且需要自己寫一個有digrap要求的某些特殊性狀的scheme實現

設計了多個語言層次
每一層次的語言都需要被設計的:
1) 方便編譯器工作
2) 方便人閱讀
用wordy-list來實現每個層次的語法
也許這樣的實現效率不高
但是在我看來處理wordy-list的代碼更可讀
並且所實現的語法也更容易處理
並且注意
在上面的基礎上嘗試優化語法很容易
因爲很容易把字符串解析成用wordy-list表示的語法分析樹

語言層次的描述如下
1. 在scheme中實現一個有向圖的數據結構
   即 設計有向圖的表示
   並 寫出處理以這種表示的有向圖的基本函數
2. 但是之後並不使直接用scheme中所提供的
   closure這種抽象方法來進行對有向圖的處理(儘管不限制你這樣做)
   + 上面的這句話隱含地認同了sicp中對
     primitive-function與the-way-to-make-abstraction之間的關係的理解方式
   而是實現一個新的語法
   然後用一個編譯器把這種語法轉換到scheme中對有向圖的基本操作
3. 然後利用所實現的數據結構與編譯器來實驗ζ-cal這種新的計算模型
4. 研究這種計算模型的數學性質
5. 嘗試以這種計算模型爲中心 設計一個新的編程範式
** draft & misc
#+begin_src scheme
;; 下面這些單個的symbol都可以被當作變量名在設計語法的時候使用
$
@
%
^
&
a.1.b.
#+end_src

#+begin_src scheme
'#0=((vertex-1 #0# ()))

(print-graph #f)

(let ([v '((vertex-1 () ()))])
  (set-car! (cdr (car v)) v)
  v)


;; 下面的兩段測試可以發現ikarus的局部變量的行爲是錯的
(let ([v '((vertex-1 <address> ()))])
  (set-car! (cdar v) v)
  (eq? v (cadar v))
  ;; v
  ;; (cadar v)
  )

(define v
  (let ([v '((vertex-1 <address> ()))])
    (set-car! (cdar v) v)
    v))
(eq? v (cadar v))
#+end_src
** >< 關於lazy-eval
- k :: 什麼是lazy-eval 惰性求值?
- x :: 就是懶得去求值的意思
       比如構造子在構造一個數據結構的時候
       構造子它就像一個函數一樣 它的參數是一些表達式
       這些表達式可以是解釋器能夠解釋的任何複雜的嵌套的東西
       比如一個表達式裏面又有很多構造子對參數的作用等等
       構造子如果是懶惰的
       你讓它構造東西的時候
       它就只作最基本的工作
       它把這些表達式放到該放的地方之後就不管了
       當你之後要需要知道構造子所構造的部分的值的時候
       你會用與構造子對應的詢問子來詢問
       這時候詢問子纔會完成求值的工作
       也就是說構造子是懶惰的
       把活都交給詢問子來幹了
       比如LISP中的的懶惰版本的cons可以叫做zons
       (zons (λi.i λi.i) (λi.i λi.i))
       根本就不會對它的兩個參數求值
       只有當(zar (zons (λi.i λi.i) (λi.i λi.i))) => λi.i
       的時候纔會對它的第一個參數求值 等等
- k :: 那麼
       是不是任何結構化數據的構造子都能變得懶惰 ???
- x :: 其實我也不知道
       你可以嘗試去找找反例
       如果找不到反例
       你可以嘗試形成一個小理論(也許需要補充一些假設什麼的)
       去證明對你的問題的肯定是一個真命題
       但是我懶得這麼作了
- k :: 看來根那些構造子一樣
       你也是懶惰的
- x :: 懶惰也沒什麼不好
       另外我想指出
       對於惰性求值這個術語還能有別的理解方式
       那就是函數的惰性求值
       構造子可以被理解爲函數
       我們正是在這種理解方式下來解釋懶惰的構造子的
       函數也可以被理解爲構造子
       函數的惰性求值也有類似的解釋 我就懶得說了
- k :: 但是至少說一說函數爲什麼是構造子 ???
       這並不顯然
       最好能給我舉一些例子
- x :: 好的
       讓我們來考慮純粹的理論性的λ-cal
       說它是理論性的是因爲
       雖然它能夠用來編碼你能想像到的所有數據結構
       並且它能夠用來表達所有可計算的函數
       但是使用起來並不方便 計算起來也不高效
       但是我們就先來考慮這種簡單的東西 因爲我們想要理解到問題的本質
       首先是它的表達式的集合的歸納定義(或者說遞歸定義):
       #+begin_src bnf
       簡單得寫就是:
       <λ-term> ::= <var> | (<λ-term> <λ-term>) | (λ<var>.<λ-term> <λ-term>)

       分開來可以寫成:
       <λ-term> ::= <var> | <λ-application> | <λ-abstraction>
       <λ-application> ::= (<λ-term> <λ-term>)
       <λ-abstraction> ::= λ<var>.<λ-term>
       <var> :: {一個先驗定義的符號集 與自然數集等勢}
       #+end_src
       先不考慮懶惰不懶惰的問題
       這種表達式其實是二叉樹 你能看出來嗎??
       比如:
       (a (b (λx.[c (x ((x m) n))] (λi.i λi.i))))
       我用[]表示了那個直接跟在λ面的特殊的<λ-term>
- k :: 上面的例子真是構複雜的了
       但是我能理解
       畢竟想要存儲表達式就必須有一個數據結構
       而這裏的數據結構就是二叉樹
       並且我知道
       這個二叉樹只有葉節點是有內容的
       只要使用括號就能用線性的字符串來表達這些二叉樹
       並且我還知道
       是<λ-term> ::= (<λ-term> <λ-term>)這一個歸納定義項在是形成着二叉樹
       但是λ<var>.<λ-term>這個東西我有點不理解
       它好像是二叉樹的簡單語義之外的東西??
- x :: 沒錯
       有了它其實我們得到的就不是單純的二叉樹了
       而是一個有向圖
       這個有向圖的支撐樹是一個二叉樹
       這個支撐樹就是上面你所指出的那個歸納定義項所形成的
       而支撐樹之外的有向邊就是令你迷惑的那個λ<var>.<λ-term>形成的
       只要把λ<var>.<λ-term>中
       <λ-term>裏面與λ後面的<var>相等的<var>鏈接到λ後面的<var>
       你就得到整個有向圖了
       如果我能在黑板上給你畫一下的話
       那麼不用言說你也會明白我的意思
- k :: 我明白了
       我能想像出你所希望描述的有向圖了
       現在給我解釋什麼是函數的惰性求值吧!
- x :: 這樣來想
       在LISP中用構造子cons來構造列表(LISP中的這個構造子是勤快的)
       (cons 1 (cons 2 (cons 3 '())))
       這與直接寫出表達式'(1 2 3)是一樣的
       而在上面我寫出表達式 也與我用構造子來構造這個表達式是一樣的
       這裏我需要懶惰處理的是(λx.[c (x ((x m) n))] (λi.i λi.i))
       因爲這一項就是需要被求值的項
       它求值之後應該得到(c (m n))
       這就是構造子懶得乾的事
       構造子和函數可以以差不多的方式來理解
       也就是說函數也可以是懶惰的
       構造子以參數爲基礎進行構造 就類似於 函數拿到參數然後進行代入
       當函數懶得對參數求值而直接進行代入的時候就是惰性求值
       但是要注意一個參數可能被代入到多個點 就像上面一樣
       這時候如果對一個點的參數求值了 那麼其他的點就都應該知道這個被求值的結果了
       這一點是對惰性求值的實現方面的問題 想要實現這種東西並不困難
- k :: 惰性求值有什麼好處呢??
       哦! 我看到了一種好處
       比如在上面(car (λx.[c (x ((x m) n))] (λi.i λi.i))) => c
       當使用惰性求值的時候詢問子car沒有詢問到的地方就不需要被求值
       因此(λi.i λi.i)根本就沒有被求值
- x :: 沒錯
       更重要的是這種求值方式在λ-cal的理論中具有優越性
       這裏我就需要引用一些別人的書來給你看了!
- k :: 那麼digrap中的惰性求值應該如何實現呢 ???
- x :: 這個留到下次討論吧!
---------------------------------------------
** wordy-lisp (wlist)
*** primer
- lisp ::
  + list processing
  + sexp (or list)
  + λ-cal
- digrap ::
  + directed graph processing
  + gexp
  + ζ-cal
*** k :: Good idea, x!
x :: how about wordy-lisp!
1. associated list processing (or wordy list processing)
2. we can call a exp of it a wexp (or a wlist)
3. <body>中表達式的求值順序可以用顯示規定
   這樣表達式的排版就是自由的
4. 函數的形式參數名稱之外再加一個明顯的說明性標記(或者不加)
   這樣參數的代入順序就可以是自由的
   不用記憶順序(那是死記硬背的)
   只用記住參數的說明性標記(這是理解記憶的)
   可以想像如何可以用很多的說明性標記來標記同一點
   這樣記不住這個還能記住其他的
5. 函數的作用順序也可以是自由的
   當參數不齊全時就形成curry
   這樣就使得對一個函數(尤其是多參數的)的使用變得極爲靈活
6. 類型系統不是問題
   可以保留一個:type關鍵詞
7. OO也不是問題
   通過元素之間的相互克隆
   就可以達到OO的效果
8. 錯誤處理也不是問題
   可以保留一個:error關鍵詞
9. 每個保留的關鍵詞都可以用來形成這種語法的新語義
   對語言的動態擴展也不是問題
   我將得到比scheme更強大的macro系統
   因爲我可以有(至少)兩個層次的macro
   一個是用戶增加一個:key-word中的key-word
   並定義這個key-word影響它所在的表達式的方式
   一個是(更高級的)用戶增加<key>
   並定義對增加的<key>的處理方式
10. 很容易作爲編譯器或語法解析器的目標語言
11. >< 難點是
    編譯或解釋這種語法以形成所需要的語義
    就需要很多的查找和排序工作
    不過那不正是電子計算機擅長的工作嗎!!
*** inductive definition
#+begin_src bnf
<wordy-list>
   ::= '() | <field> | (append <wordy-list> <wordy-list>)

# 下面這個版本的可以保留<wordy-list>內的所有loop
<wordy-list>
   ::= '() | <field> | (append! <wordy-list>[non-null] <wordy-list>)


<field>
   ::= (<key> <non-key-val> ...)
       {這裏的list必須是proper-list}

<key> == <field-name>

<key>
   ::= {所有的以冒號開頭的symbol}

<non-key-val>
   ::= {不是<key>的任何類型的值,特別地可以是一個<wordy-list>}

<atom-relative-to-wordy-list> {簡稱<atom-to-wlist>}
   ::= {所有不是<wordy-list>的東西都是相對於<wordy-list>來說的原子}
# 上面這種相對原子的概唸對每種歸納定義的結構化的數據都適用
# 因爲這些原子將被作爲遞歸函數的基本步驟
#+end_src
這裏對於這個數據類型需要一些分析與解釋
1. 這樣設計數據類型是爲了儘量減少人類認知上的負擔
2. 可以發現這個歸納定義的形式是相當良好的
   有了這樣典型的歸納定義 就可以很方便地寫遞歸函數了
*** some helper-functions
#+begin_src scheme
(define string<-symbol symbol->string)
(define list<-string string->list)

(define not-proper-list?
  (lambda (x)
    (and (pair? x)
         (not (list? x)))))
#+end_src
*** predicates
#+begin_src scheme
(define key?
  (lambda (x)
    (and (symbol? x)
         (eq? #\: (car (list<-string
                        (string<-symbol x)))))))
;; test:
;; (key? 1)
;; (key? ':kkk)
;; (key? '::kkk)
;; (key? '卡夫卡)


(define wordy-list?
  (lambda (x)
    (and (list? x)
         (or (null? x);; can be '() 因爲要作爲遞歸函數的基本步驟
             (key? (car x))))))
;; (wordy-list? '())
;; (wordy-list? '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4 . 1))



(define field?
  (lambda (x)
    (and (list x)
         (not (null? x))
         (key? (car x))
         (not (wordy-list? (cdr x))))))
#+end_src
*** note about wlist-processing
這裏有一個很重要的說明:
在scheme中用副作用來構造帶有loop的list這件事困擾了我很久
我現在明白這是因爲我對我寫的代碼所表達的東西的理解
和機器實際上對我代碼的處理方式之間有一個偏差
這可以說成是一種語義的錯亂
對這一點的解釋如下:
1. 首先要明白當結構化的數據被作爲參數來傳遞的時候自然而然傳遞的是地址
2. 其次要熟悉scheme中的一種編程風格
   這種風格是用遞歸函數處理歸納定義的數據的標準方式
   + 這種標準處理方式在ml這種具有更強類型限制的語言中體現的最爲明顯
   這種風格是:
   1) 函數以輸入的結構化數據爲原材料
      因爲所使用的結構化的數據有良好的遞歸定義
      所以很容易形成遞歸函數去解構這個結構
   2) 然後在這個拆解原料的過程中
      函數會利用拆解所得到部分原料
      並添加一些新的物質
      去構建一個需要被輸出的結構化數據
   3) 重要是 當一個東西被當成原料而傳給某個函數的時候
      做了這樣的重要假設:
      這些原料是以後不需要的了 並且這些原料沒有同時在別的地方被用到
      即 這些原料中的任何部分的地址別人都不知道
      只有當下這個原料所服務於的那個函數知道
   4) 在函數構造需要被輸出的新的結構化數據的時候
      原料的一些部分被用到
      同時原料的另一些部分沒有被用到
      那些沒有被用到的原料的部分當然就是需要被垃圾回收器回收的廢料了
3. scheme中的列表處理函數基本上都是以這種風格寫成的
   這是一種很好的風格
   它使得編程變得清晰簡單而明瞭
4. 但是
   當我需要用副作用來構造帶有loop的list的時候 問題就來了
   因爲上面的那個重要的假設不再被滿足了
   並且
   略微形而上地說
   這裏所處理的東西(至少從表面上來看)不再具有良好的歸納定義了
   這就決定了這種東西不容易使用遞歸函數來處理
   但是這只是表面
   其實我們所定義的數據結構總不是雜亂無章的
   否則就無``結構''可言了
   其實我們所定義的數據結構總是有一定的正規性的
   總是可以使用遞歸函數來處理的
   這種可被遞歸函數處理的性質從某種意義上來說就是``結構''的本質
   這樣
   此時我們就需要新的理解方式與處理風格
   這時遞歸函數的行爲
   不是解構的同時構造
   而是遍歷的同時修改
   或者遍歷的同時記錄需要做修改的地方的信息
   然後遍歷之後一起作修改
   就是用很多副作用去修改原來的值
   然後返回的還是原來的值的地址 只不過原來的值被修改過了
   甚至有時可以不返回值 因爲在別的地方還能引用到原來的數據
   注意這種風格是如何與上面那個重要的假設完全相反的
5. 如何理解這些呢 ???
   這種新的風格
   可能需要我能自由地在函數中引用cons的car和cdr的地址
   scheme並不支持這樣的操作
   這與垃圾回收有衝突嗎???
   不衝突
   因爲在我獲取一個明顯的地址之後這一個cons就被着重標記爲不能被回收的了
   當我進行完對這個地址的副作用之後我可以取消這個着重標記表示允許回收
   也就是說使用兩bits
   一個表示``回收--不回收''
   一個表示``允許回收--不允許回收''
6. 這裏如此多的副作用顯然違背了函數式編程
   但是爲了能更方便的寫出比如digrap這種程序
   語言的這樣的性狀是有利的
   當我發現scheme給digrap的實現造成極大的困難的時候
   我就會自己寫一個類似scheme的LISP
7. 還發現scheme中失誤的一點
   爲了實現digrap中的那個有向圖的數據結構
   wlist中的某些位置需要記錄wlist中其他位置的地址
   但是在scheme中列表與列表的地址是沒有區別的
   >< 也許我可以用一個閉包來記錄這個地址
   這樣就可以有一個僞地址數據類型 並且打印起來也好看
   >< 但是我不這樣作
   因爲這並不是正確的實現方式
   這樣作只是在scheme錯誤的設計上修補而已
   應該更改編譯器本身的設計以實現我的目標
8. 你馬上就發現兩種處理風格並不衝突
   並且常常需要同時使用這兩種處理
   那麼重要的就是
   我應該用上面的兩種風格來規範化自己寫的函數
   並且用上面所指出的揭示函數行爲的特徵來描述函數的行爲
*** wlist-processing
#+begin_src scheme
;; 就接口而言 curry總是可以增加使用上的靈活性
;; 並且簡化對使用方式的理解: 因爲所有的作用都是一元的了

;; (take n) => <taker>
;; (<taker> <field>) => <val>
;;   例如 (take n) will take the key of <field>
(define take
  (lambda (n)
    (lambda (field)
      (letrec ([R (lambda (n lis)
                    (cond [(= n 0)
                           (car lis)]
                          [else
                           (R (sub1 n) (cdr lis))]))])
        (if (>= n (length field))
          (error 'take
            "taker too far!" n (sub1 (length field)) field)
          (R n field))))))
;; ((take 1) '(:kkk))
;; ((take 3) '(:kkk 1 2 3))
;; ((take 4) '(:kkk 1 2 3))


;; (find <key>) => <finder>
;; (<finder> <wordy-list>) => <field> | #f
;;    上面當失敗的時候是否不應該簡單地返回#f
;;    而去返回更多的信息 比如找什麼key的時候失敗了
;;    其實用#f也行 因爲返回值正常的時候返回的都是列表
;;    但是其他的函數的錯誤處理可能就不能這麼草率了
;; 注意:
;;   所返回的是一個新構建的列表
;;   但是列表裏的元素還是老元素
;;   因此對於finder所返回的值要小心地使用副作用
;; 又注意:
;;   所返回的新列表會喪失``在列表內引用列表頭''的性質
;;   所返回的:
;; (:0-dimension-geometry-object-list
;;      #2=[:v vertex-2 :address #2#
;;          :can (:value 222)
;;          :abut-edge-list
;;             (:e edge:2-->3 :address #4#)
;;             (:e edge:3-->2 :address #6#)])
;; 對其中#2#的引用不會喪失``在列表內引用列表頭''的性質
;; 但是如果是(:kkk 1 2 . #0=(:tree 7 8 9 #0#) 4 5 6)
;; 那麼
;; ((find ':tree)
;;  '(:kkk 1 2 . #0=(:tree 7 8 9 #0#)))
;; =>
;; (:tree 7 8 9 #0=(:tree 7 8 9 #0#))
;; 而不是#0=(:tree 7 8 9 #0#)
;; 也就是說返回值喪失了``在列表內引用列表頭''的性質
;; 但是從某種語義上來說
;; (:kkk 1 2 . #0=(:tree 7 8 9 #0#) 4 5 6)中的#0#並不是對列表頭的引用不是嗎?
;; 看你從什麼角度去理解了
;; 但是一定要小心而仔細地分析find這類函數的性質
(define find
  (lambda (key)
    (lambda (wordy-list)
      (letrec ([find-the-key
                (lambda (wordy-list)
                  (cond [(null? wordy-list)
                         #f]
                        [(eq? key (car wordy-list))
                         (cons (car wordy-list)
                               (find-2nd-key (cdr wordy-list)))]
                        [else
                         (find-the-key (cdr wordy-list))]))]
               [find-2nd-key
                (lambda (wordy-list)
                  (cond [(null? wordy-list)
                         wordy-list]
                        [(atom? wordy-list)
                         wordy-list]
                        [(not (key? (car wordy-list)))
                         (cons (car wordy-list)
                               (find-2nd-key (cdr wordy-list)))]
                        [(key? (car wordy-list))
                         '()]
                        ))])
        (cond [(not (key? key))
               (error 'find "inupt must be a key" key)]
              [(null? wordy-list)
               #f]
              [else
               (find-the-key wordy-list)])
        ))))
;; test:

;; ((find ':k0) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((find ':k1) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((find ':k2) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((find ':k4) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))

;; 儘管下面的測試看似正確
;; 但是非proper-list不被看作是wordy-list
;; wordy-list?這個謂詞會幫助判斷
;; 所以需要一個例外處理來處理下面的東西
;; 否則這種形式被(有意或無意地)濫用後 將會帶來麻煩
;; ((find ':k4) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4 . 1))

;; ((find ':k3) '(:k1 1
;;              :k2 2 2 2
;;              :k3 3 (3) ()
;;              :k4))
;; ((find ':can) '[:v :can <-- <-- λ])
;; ((find ':can) '[:v :can (:v-type black :kkk kkk)])



;; ((find ':type)
;; '(:type <<graph>>

;;   :0-dimension-geometry-object-list
;;      #2=[:v vertex-2 :address #2#
;;          :can (:value 222)
;;          :abut-edge-list
;;             (:e edge:2-->3 :address #4#)
;;             (:e edge:3-->2 :address #6#)]

;;      #3=[:v vertex-3 :address #3#
;;          :can (:value 333)
;;          :abut-edge-list
;;             (:e edge:2-->3 :address #4#)
;;             (:e edge:3-->2 :address #6#)]

;;   :1-dimension-geometry-object-list
;;      #4=[:e edge:2-->3 :address #4#
;;          :can (:edge-type black-arrow)
;;          :abut-vertex-list
;;             (:v vertex-2 :address #2#)
;;             (:v vertex-3 :address #3#)]

;;      #6=[:e edge:3-->2 :address #6#
;;          :can (:edge-type black-arrow)
;;          :abut-vertex-list
;;             (:v vertex-3 :address #3#)
;;             (:v vertex-2 :address #2#)]
;;      ))




;; (let ([first-edge-fo-first-vertex-finder
;;        (lambda (a-graph)
;;          ((find ':e)
;;           ((take 1)
;;            ((find ':abut-edge-list)
;;             ((take 1)
;;              ((find ':0-dimension-geometry-object-list) a-graph))))))])
;;   (first-edge-fo-first-vertex-finder
;;    '(:type <<graph>>

;;      :0-dimension-geometry-object-list
;;         #2=[:v vertex-2 :address #2#
;;             :can (:value 222)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;         #3=[:v vertex-3 :address #3#
;;             :can (:value 333)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;      :1-dimension-geometry-object-list
;;         #4=[:e edge:2-->3 :address #4#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-2 :address #2#)
;;                (:v vertex-3 :address #3#)]

;;         #6=[:e edge:3-->2 :address #6#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-3 :address #3#)
;;                (:v vertex-2 :address #2#)]
;;         )
;;    ))



;; (let ([can-of-first-edge-fo-first-vertex-finder
;;        (lambda (a-graph)
;;          ((find ':can)
;;           ((take 1)
;;            ((find ':address)
;;             ((take 1)
;;              ((find ':abut-edge-list)
;;               ((take 1)
;;                ((find ':0-dimension-geometry-object-list) a-graph))))))))])
;;   (can-of-first-edge-fo-first-vertex-finder
;;    '(:type <<graph>>

;;      :0-dimension-geometry-object-list
;;         #2=[:v vertex-2 :address #2#
;;             :can (:value 222)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;         #3=[:v vertex-3 :address #3#
;;             :can (:value 333)
;;             :abut-edge-list
;;                (:e edge:2-->3 :address #4#)
;;                (:e edge:3-->2 :address #6#)]

;;      :1-dimension-geometry-object-list
;;         #4=[:e edge:2-->3 :address #4#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-2 :address #2#)
;;                (:v vertex-3 :address #3#)]

;;         #6=[:e edge:3-->2 :address #6#
;;             :can (:edge-type black-arrow)
;;             :abut-vertex-list
;;                (:v vertex-3 :address #3#)
;;                (:v vertex-2 :address #2#)]
;;         )

;;    ))


;; (address-find <key>) => <address-finder>
;; (<address-finder> <wordy-list>) => <wordy-list>
;; 不構建新列表而直接返回找到的列表的地址
;; 有點像又兩個參數的cdr
;; 第一個參數是<field-name> (即<key>)
;; 第二個參數是<wordy-list>
(define address-find
  (lambda (key)
    (lambda (wordy-list)
      (letrec ([find-the-key
                (lambda (wordy-list)
                  (cond [(null? wordy-list)
                         #f]
                        [(eq? key (car wordy-list))
                         wordy-list]
                        [else
                         (find-the-key (cdr wordy-list))]))])
        (cond [(not (key? key))
               (error 'find "inupt must be a key" key)]
              [(null? wordy-list)
               #f]
              [(eq? key (car wordy-list))
               wordy-list]
              [else
               (find-the-key wordy-list)])
        ))))
;; test:
;; ((address-find ':k0) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k1) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k2) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k3) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))
;; ((address-find ':k4) '(:k1 1 :k2 2 2 2 :k3 3 (3) () :k4))




(define append-two!
  ;; SIDE-EFFECT on wlist-1, 所以append-two!的第一個參數不能是'()
  ;; RETURN-VAL wlist-1
  (lambda (wlist-1 wlist-2)
    (letrec ([R! (lambda (wlist-1)
                   (cond [(null? (cdr wlist-1)) ;; (= 1 (length wlist-1))
                          (set-cdr! wlist-1 wlist-2)]
                         [else
                          (R! (cdr wlist-1))]))])
      (cond [(null? wlist-1)
             (error 'append-two!
               "append-two!'s 1th-arg can not be '()" wlist-1 wlist-2)]
            [(not-proper-list? wlist-1)
             (error 'append-two!
               "append-two!'s 1th-arg can not be a not proper-list"
               wlist-1 wlist-2)]
            ;; [(not (list? wlist-2))
            ;;  (error 'append-two!
            ;;    "append-two!'s 2th-arg must be a list" wlist-1 wlist-2)]
            ;; 上面的一句對類型的控制比較嚴格一點
            [(and (not (pair? wlist-2))
                  (not (null? wlist-2)))
             (error 'append-two!
               "append-two!'s 2th-arg must be a pair or '()" wlist-1 wlist-2)]
            [else
             ;; SIDE-EFFECT
             (R! wlist-1)
             ;; RETURN-VAL
             wlist-1]))))
;; test:
;; (append-two! '(1 2 3) '(kkk))
;; (append-two! '() '(kkk))
;; (append-two! '(1 2 . 3) '(kkk))
;; (let ([kkk '(1 2 3)])
;;   (append-two! kkk '(kkk))
;;   (append-two! kkk '(kkk))
;;   (append-two! kkk '(kkk))
;;   kkk)
;; (let ([kkk '(1 2 3)])
;;   (append kkk '(kkk))
;;   (append kkk '(kkk))
;;   (append kkk '(kkk))
;;   kkk)

(define-syntax append!
  (syntax-rules ()
    [(_)
     (error 'append!
       "append! is a syntax with at least 2 args, not 0 arg !")]
    [(_ anthing)
     (error 'append!
       "append! is a syntax with at least 2 args, not 1 arg !" anthing)]
    [(_ wlist-1 wlist-2)
     (append-two! wlist-1 wlist-2)]
    [(_ wlist-1 wlist-2 wlist-3 ...)
     (append!
      (append-two! wlist-1 wlist-2) wlist-3 ...)]
    ))
;; test:
;; (append! '(1 2 3) '(1 2 3) '(kkk))
;; (append! '(kkk) '() '(kkk))
;; (append! '(0 0 0) '(kkk) '(1 2 . 3))
;; (append! '(0 0 0) '(1 2 . 3) '(kkk))
;; (let ([kkk '(1 2 3)])
;;   (append! kkk '(kkk))
;;   (append! kkk '(kkk))
;;   (append! kkk '(kkk))
;;   kkk)
;; (let ([kkk '(1 2 3)])
;;   (append kkk '(kkk))
;;   kkk)


;; 一個同構變換:
;; 主要的區別是
;; alist中遞增一下就能找到下一個field
;;   而wlist中可能需要很多對key?判斷才能找到下一個field
;; wlist的樣子看起來很簡單括號很少並且更容易理解
;;   而alist看起來很複雜
;; alist在視覺上的的劣勢很容易用一個語法解析器來彌補
;; wlist理解起來還是更簡單

;; 爲了獲得alist的優勢 並不必作同構變換
;; 只要跑一遍wlist 然後增加一個key.address-alist就行了
;; 真正的同構變換會破壞原來的結構化數據的結構
;; 即 第一個field的尾部被一個'()截斷了
;; 但是更重要的是注意這種截斷並不影響wlist中的loop
;; 也就是說不會影響wlist中的某些位置對其他位置的地址的記錄

;; 注意只有當使用同構所節省的時間超過
;; 同構變換所浪費的時間
;; (define alist<-wlist
;;   (lambda (wlist)
;;     ()))

;; (define wlist<-alist
;;   (lambda (alist)
;;     ()))


;; 用副作用刪除和增加field
;; (delete! <key>) => <deleter!>
;; (<deleter!> <wordy-list>) => {WITH-SIDE-EFFECT} <wordy-list> | #f
;; (define delete!
;;   (lambda (key)
;;     (lambda (wordy-list)
;;       需要定義find-next-field
;;       )))

;; (substitute! <field>) => <substituent!>
;; ((<substituent!> <key>) )
;; (define substitute!
;;   (lambda (key)
;;     (lambda (wordy-list)
;;
;;       )))


;; 用副作用刪除和增加field中的值
;; 用副作用更改field的名字




(define insert-val-to-the-2nd-position-of-a-list!
  (lambda (val lis)
    (if (null? lis)
      (error 'insert-val-to-the-2nd-position-of-a-list!
        "input list can not be '() !")
      (set-cdr! lis (append!
                      (list val)
                      (cdr lis))))))


(define insert-a-val-to-a-field-of-a-wlist!
  (lambda (val field-name wlist)
    (insert-val-to-the-2nd-position-of-a-list!
     val ((address-find field-name) wlist))))
;; test:
;; (define kkk '(:kkk))
;; (insert-a-val-to-a-field-of-a-wlist! 1 ':kkk kkk)

;; 發現如果可以自由的改變參數的順序 那將是極好的
;; 在wordy-lisp中就可以做到這一點
;; 我可以直接用macro把wordy-lisp嵌入到scheme中嗎 ???
;; 如果能自動實現動態的curry 就更好了 !!!
;; 太酷了
;; 甚至可以自動變換求值順序形成不同的curry
;; 太酷了 太酷了
(define to-a-field-of-a-wlist--let-us-insert-a-val!
  (lambda (field-name wlist val)
    (insert-val-to-the-2nd-position-of-a-list!
     val ((address-find field-name) wlist))))
#+end_src
*** note about constructor
如果使用wordy-list的明顯的標籤
那麼這些標籤就可以看作是每個結構化對象(數據)的構造子
那麼模式匹配和類型推到當然就不成問題

!!! 上面的兩項其實是錯的
因爲這裏的明顯的標籤雖然用來命名了對象中的一部分
但是並沒有形成對一個集合的歸納定義
而模式匹配是爲了寫遞歸函數處理歸納定義的集合(數據類型)

但是仔細一想其實又是可以的
因爲不論如何它們確實能夠擔當構造子的角色
** representation-of-graph
*** 0.01
#+begin_src scheme
(define <<graph>>?
  (lambda (x)
    (and (list x)
         (not (null? x))
         (eq? (car x) '<<graph>>))))

;; 希望給出比較不平凡的例子作爲測試
;; 以使所有的遞歸在基本的測試中都能被跑到
(define example-graph
  ;; memory == O(|V|+|E|)
  '(<<graph>>
    ;; 約定: 在下面的表示中 每一個點邊元素都用方括號

    ;; vertex-list (0-dimension-geometry-object-list)
    ;; 點中有一個列表 保存着與自己相鄰的所有邊的地址
    ;; 這樣從點出發能夠找到與它相鄰的所有邊
    ;; 這種對地址的保存就實現着點和邊的相鄰關係
    (#2=[(vertex-2 #2# (:value 222))
         (edge:2-->3 #4#) (edge:3-->2 #6#)]
     #3=[(vertex-3 #3# (:value 333))
         (edge:2-->3 #4#) (edge:3-->2 #6#)])

    ;; edge-list (1-dimension-geometry-object-list)
    ;; 邊中有一個列表 保存這與自己相鄰的所有點的地址
    ;; 這樣從邊出發能夠找到與它相鄰的所有點
    ;; 這種對地址的保存就實現着點和邊的相鄰關係
    (#4=[(edge:2-->3 #4# (:edge-type black-arrow))
         ;; 兩個點在下面的列表中儲存的順序
         ;; 體現着這條邊連接它們的方式
         (vertex-2 #2#) (vertex-3 #3#)]
     #6=[(edge:3-->2 #6# (:edge-type black-arrow))
         (vertex-3 #3#) (vertex-2 #2#)])

    ;; 可以發現圖的幾何語義限制了上面的列表的樣子
    ;; 在圖的語義下:
    ;;   2-dim幾何體 能且只能 與兩個1-dim幾何體相連
    ;;        並且其鄰接列表是有序的
    ;;   1-dim幾何體 能 與0個或1個或多個2-dim幾何體相連
    ;;        並且遺忘了其鄰接列表的順序

    ;; 顯然在這裏我們可以進行推廣
    ;; 在這種實現方式下所能得到的最廣泛的推廣是:
    ;;   可以有n-dim幾何體列表
    ;;   幾何體都可以和任意維數的幾何體相連接
    ;; 顯然利用這種實現的推廣
    ;; 只要再向上面一樣添加某先限制條件
    ;; 就能夠形成代數拓撲中的某些復形的語義

    ;; 但是要注意的是限制條件對語義的影響可能是相當微妙的
    ;; 幾何語義的建立 可以幫助我們決定應該實現什麼樣的 基本處理函數
    ;; 基本的觀察 與 基本的幾何想像 總能把人們引向有趣而豐富的理論
    ))
#+end_src
*** 0.02
下面的數據結構可以被視爲是圖論型數據庫的實現
只要
1. 把:0-dimension-geometry-object-list
   替換爲:data
2. 把:1-dimension-geometry-object-list
   替換爲:relation
   並且取消與edge的語義有關的限制
   使得:relation與:data完全對稱
   + 並且 :can of :relation 中
     可以保存對關係的額外描述等等
3. 上面的東西顯然能夠勝任一個數據庫
   它的特點是保存的很簡潔
   插入和刪除還有查詢比較複雜

#+begin_src scheme
(define <<graph>>?
  (lambda (x)
    (and (wordy-list? x)
         (not (null? x))
         (eq? ((take 1)
               ((find ':type)
                x))
              '<<graph>>))))

;; (<<graph>>? example-graph)

;; 下面希望給出比較不平凡的例子作爲測試
;; 以使所有的遞歸在基本的測試中都能被跑到
(define example-graph
  ;; memory == O(|V|+|E|)
  '(:type <<graph>>
    ;; 約定: 在下面的表示中 每一個點邊元素都用方括號

    :0-dimension-geometry-object-list
    ;; 每個點中有一個列表:abut-edge-list
    ;; 保存着與自己相鄰的所有邊的地址
    ;; 這樣從點出發能夠找到與它相鄰的所有邊
    ;; 這種對地址的保存就實現着點和邊的相鄰關係

    #2=[:v vertex-2 :address #2#
        :can (:value 222)
        :abut-edge-list
        ;; 如果一個key的名字說明這一項是list
        ;; 那麼它後面根的常常就是一個list的wordy-list
        ;; 要知道基本的元素在這裏都是用wordy-list來表達的
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]

    #3=[:v vertex-3 :address #3#
        :can (:value 333)
        :abut-edge-list
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]


    :1-dimension-geometry-object-list
    ;; 每個邊中有一個列表:abut-vertex-list
    ;; 保存着與自己相鄰的所有點的地址
    ;; 這樣從邊出發能夠找到與它相鄰的所有點
    ;; 這種對地址的保存就實現着點和邊的相鄰關係

    #4=[:e edge:2-->3 :address #4#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           ;; 兩個點在這個列表中儲存的順序
           ;; 體現着這條邊連接它們的方式
           (:v vertex-2 :address #2#)
           (:v vertex-3 :address #3#)]

    #6=[:e edge:3-->2 :address #6#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           (:v vertex-3 :address #3#)
           (:v vertex-2 :address #2#)]



    ;; 可以發現圖的幾何語義限制了上面的列表的樣子
    ;; 在圖的語義下:
    ;;   1-dim幾何體 能且只能 與兩個0-dim幾何體相連
    ;;        並且其鄰接列表是有序的
    ;;   0-dim幾何體 能 與0個或1個或多個1-dim幾何體相連
    ;;        並且遺忘了其鄰接列表的順序

    ;; 顯然在這裏我們可以進行推廣
    ;; 在這種實現方式下所能得到的最廣泛的推廣是:
    ;;   可以有n-dim幾何體列表
    ;;   幾何體都可以和任意維數的幾何體相連接
    ;; 顯然利用這種實現的推廣
    ;; 只要再向上面一樣添加某先限制條件
    ;; 就能夠形成代數拓撲中的某些復形的語義

    ;; 但是要注意的是限制條件對語義的影響可能是相當微妙的
    ;; 幾何語義的建立 可以幫助我們決定應該實現什麼樣的 基本處理函數
    ;; 基本的觀察 與 基本的幾何想像 總能把人們引向有趣而豐富的理論


    ))
#+end_src
** basic-functions-for-graph
*** note
刪除和添加節點並不是簡單在這個集閤中增加元素
而需要修改圖的各部分 讓圖的各部分對圖的描述保持一致
- add-vertex
- add-edge
- delete-vertex
- delete-edge
其他操作顯然都能用這4個基本操作的複合來完成
*** some helper-functions (not using)
也許這裏的函數應該被作爲另外的lib分離出去
**** 0.01

#+begin_src scheme
;; 下面的add-to-list-end!把x添加到list的末尾
;; 由於scheme的限制 這樣的實現方式最簡單
;; 因爲add-to-list-end!是一個副作用
;; 所以只有有名字能引用到它的參數lis的時候這個函數纔有意義
(define add-to-list-end!
  (lambda (x lis)
    (letrec ([R (lambda (x lis)
                  (cond [(null? (cdr lis))
                         (set-cdr! lis (list x))]
                        [else
                         (R x (cdr lis))]))])
      (if (null? lis)
        (error 'add-to-list-end! "can not add ~s to null list" x)
        (R x lis)))))

;; 非副作用的版本更簡單 但是現在還用不到
;; (define add-to-list
;;   (lambda (x lis)
;;     ))


(define find-address-in-vertex-list-by-name
  (lambda (name vertex-list)
    (cond [(null? vertex-list)
           (error 'find-address-in-vertex-list-by-name "can not find name: ~s in list" name)]
          ;; 想要說出是那個list就要使用call/cc
          [else
           (if (equal? name (caaar vertex-list))
             ;; 使用equal?這樣vertex-name就可以是list或vector了
             (cadaar vertex-list)
             (find-address-in-vertex-list-by-name name (cdr vertex-list)))])))
;; (letrec
;;     ([v '(v v)]
;;      [g '(g g)])
;;   ;; 想要把g中的地址mark到v中
;;   (cons
;;    (let ()
;;      ;; 直接用car與cdr找到需要被mark的g中的地址就可以了
;;      (set-cdr! v (cdr g))
;;      v)
;;    (cons
;;     (let ()
;;       g)
;;     '())))
#+end_src
**** 0.02

#+begin_src scheme
;; 下面的add-to-list-end!把x添加到list的末尾
;; 由於scheme的限制 這樣的實現方式最簡單
;; 因爲add-to-list-end!是一個副作用
;; 所以只有有名字能引用到它的參數lis的時候這個函數纔有意義
(define add-to-list-end!
  (lambda (x lis)
    (letrec ([R (lambda (x lis)
                  (cond [(null? (cdr lis))
                         (set-cdr! lis (list x))]
                        [else
                         (R x (cdr lis))]))])
      (if (null? lis)
        (error 'add-to-list-end! "can not add ~s to null list" x)
        (R x lis)))))

;; 非副作用的版本更簡單 但是現在還用不到
;; (define add-to-list
;;   (lambda (x lis)
;;     ))


(define find-address-in-vertex-list-by-name
  (lambda (name vertex-list)
    (cond [(null? vertex-list)
           (error 'find-address-in-vertex-list-by-name "can not find name: ~s in list" name)]
          ;; 想要說出是那個list就要使用call/cc
          [else
           (if (equal? name (caaar vertex-list))
             ;; 使用equal?這樣vertex-name就可以是list或vector了
             (cadaar vertex-list)
             (find-address-in-vertex-list-by-name name (cdr vertex-list)))])))
;; (letrec
;;     ([v '(v v)]
;;      [g '(g g)])
;;   ;; 想要把g中的地址mark到v中
;;   (cons
;;    (let ()
;;      ;; 直接用car與cdr找到需要被mark的g中的地址就可以了
;;      (set-cdr! v (cdr g))
;;      v)
;;    (cons
;;     (let ()
;;       g)
;;     '())))

;; 下面這個語法關鍵詞不是拿來用的
;; 而是想用來說明 如果能自由的安排<body>中表達式的執行順序
;; 那麼將很有利於提高代碼的可讀性
;; 因爲這樣<body>中代碼的排列順序就可以和執行順序不一樣
;; 這就使得更好的排版方式成爲可能
(define-syntax one-sexp-RETURNED--after-SIDE-EFFECTS-performed
  (syntax-rules ()
    [(_ one-sexp-RETURNED SIDE-EFFECT ...)
     (begin
       SIDE-EFFECT
       ...
       one-sexp-RETURNED)]))
#+end_src
*** add-vertex
**** 0.01

#+begin_src scheme
;; 下面兩個東西給出比較不平凡的例子作爲測試
;; 以使所有的遞歸在基本的測試中都能被跑到
(define syntax-example-of-add-vertex
  '((vertex-1 (:value 111))
    [(edge:1-->2 (:edge-type black-arrow))
     (vertex-2)]
    [(edge:1-->3 (:edge-type black-arrow))
     (vertex-3)]
    [(edge:1-->2 (:edge-type red-arrow))
     (vertex-2)]
    [(edge:1-->3 (:edge-type red-arrow))
     (vertex-3)]
    ))

(define example-graph
  '(<<graph>>

    (#2=[(vertex-2 #2# (:value 222))
         (edge:2-->3 #4#) (edge:3-->2 #6#)]
     #3=[(vertex-3 #3# (:value 333))
         (edge:2-->3 #4#) (edge:3-->2 #6#)])

    (#4=[(edge:2-->3 #4# (:edge-type black-arrow))
         (vertex-2 #2#) (vertex-3 #3#)]
     #6=[(edge:3-->2 #6# (:edge-type black-arrow))
         (vertex-3 #3#) (vertex-2 #2#)])
    ))


(define add-vertex
  (lambda (v g)
    (add-vertex! v (list-copy g))))

(define add-vertex!
  (lambda (v g)
    ;; g = graph
    ;; v = out of graph representation of a vertex for add-vertex
    (let* ([g-vertex-list (cadr g)]
           [g-edge-list (caddr g)]

           ;; 下面生成processed-vertex-head的同時需要:
           ;; 1. 擴充g-vertex-list中的其他點的相鄰邊列表
           ;; 2. 擴充g-edge-list
           [processed-vertex-head
            (letrec ([vertex-head (car v)]
                     [subvertex-list (cdr v)]
                     [processed-vertex-head (fun-to-handle-vertex-head
                                             vertex-head)]

                     [fun-to-handle-vertex-head
                      ;;     (vertex-name . treasury-of-vertex) ==>
                      ;; #0=[(vertex-name #0# treasury-of-vertex) ...]
                      (lambda (vertex-head)
                        (pmatch-who 'add-vertex!:fun-to-handle-vertex-head  vertex-head
                          [`(,vertex-name . ,treasury-of-vertex)
                           (let ([x `[(,vertex-name <address-of-this-vertex> . ,treasury-of-vertex)]])
                             (set-car! (cdar x) x)
                             x)]))]

                     [fun-to-handle-edge-head
                      ;; 除了約束變元的名字以外 與fun-to-handle-vertex-head完全相同
                      ;;     (edge-name . treasury-of-edge) ==>
                      ;; #0=[(edge-name #0# . treasury-of-edge) ...]
                      (lambda (edge-head)
                        (pmatch-who 'add-vertex!:fun-to-handle-edge-head  edge-head
                          [`(,edge-name . ,treasury-of-edge)
                           (let ([x `[(,edge-name <address-of-this-edge> . ,treasury-of-edge)]])
                             (set-car! (cdar x) x)
                             x)]))]

                     [rec-fun-to-run-through-subvertex-list
                      ;; return a processed-subvertex-list
                      (lambda (subvertex-list)
                        (cond [(null? subvertex-list) subvertex-list]
                              [else
                               (cons (pmatch-who 'add-vertex!:rec-fun-to-run-through-subvertex-list
                                         (car subvertex-list)
                                       [`[(,edge-name . ,<treasury-of-edge>)
                                          (,subvertex-name)]
                                        (let ([processed-edge-head (fun-to-handle-edge-head `(,edge-name . ,<treasury-of-edge>))])
                                          (set-cdr! processed-edge-head
                                                    ;; 下面是與這個edge相鄰的兩個vertex的列表
                                                    `((,(caar processed-vertex-head) ,(cadar processed-vertex-head))
                                                      ;; 下面用到了一次對圖的vertex-list的查找
                                                      (,subvertex-name ,(find-address-in-vertex-list-by-name subvertex-name g-vertex-list))))
                                          (add-to-list-end! processed-edge-head g-edge-list)
                                          ;; 在返回值之前還需要把上面安插好的edge添加到與這個邊相鄰的vertex的edge-list中
                                          (add-to-list-end! `(,(caar processed-edge-head) ,(cadar processed-edge-head))
                                                        (cdr (find-address-in-vertex-list-by-name subvertex-name g-vertex-list)))
                                          ;; 下面是這個let的返回值:
                                          ;; 需要返回一個將被添加到processed-vertex-head的相鄰邊列表中的項
                                          ;; (cadar processed-edge-head)是這個edge的地址
                                          `(,edge-name ,(cadar processed-edge-head)))])
                                     (rec-fun-to-run-through-subvertex-list (cdr subvertex-list)))]))])
              (set-cdr! processed-vertex-head
                        (rec-fun-to-run-through-subvertex-list
                         subvertex-list))
              ;; 下面是這個letrec的返回值:
              processed-vertex-head)])

      (add-to-list-end! processed-vertex-head g-vertex-list)
      ;; now! g-vertex-list and g-edge-list are processed
      ;; 下面是let*的返回值 也是這個函數的返回值:
      (list '<<graph>> g-vertex-list g-edge-list)
      )))


;; test:
;; (add-vertex syntax-example-of-add-vertex
;;             example-graph)

;; (define example-graph '(<<graph>> (1) ()))
;; (add-vertex '((vertex-1 (:value 111)))
;;          example-graph)
;; 下面的錯誤來自於add-to-list-end! 它表明在這種實現方式下空圖是沒有意義的
;; 圖的點列表和邊列表都不能是空集
;; 要知道在scheme中add-to-list-end!這種侷限性是本質的
;; (define example-graph '(<<graph>> () ()))
;; (add-vertex '((vertex-1 (:value 111)))
;;             example-graph)
;; (define example-graph '(<<graph>>
;;                   (#2=[(vertex-2 #2# (:value 222))])
;;                   ([(1 2 3)])))
;; (add-vertex '((vertex-1 (:value 111))
;;               [(edge:1-->2 (:edge-type black-arrow))
;;                (vertex-2)])
;;             example-graph)
;; 如果希望以最簡單的方式使用空圖那麼就必須作特殊約定(比如約定每個圖有一個不可見的基礎點)
;; 可以這樣來做:
;; 約定每個圖中至少有兩點以及鏈接這兩點的一邊
;; 這三個幾何元素不是浪費了 而是可以保存一些這個圖的基本信息
;; 但是下面的eval不能正常工作太讓人震驚了
;; 而使用define-syntax又將造成無限循環
;; (define give-me-a-base-graph
;;   (lambda ()
;;     (define kkk
;;       '(<<graph>>
;;         (#1=[(base-vertex-1 #1# (:value 111))
;;              (base-edge:1-->2 #3#)]
;;             #2=[(base-vertex-2 #2# (:value 222))
;;                 (base-edge:1-->2 #3#)])
;;         (#3=[(base-edge:1-->2 #3# (:edge-type base-arrow))
;;              (base-vertex-1 #1#) (base-vertex-2 #2#)])))
;;     kkk))
;; (add-vertex '((vertex-1 (:value 111)))
;;             (give-me-a-base-graph))
#+end_src
**** 0.02

#+begin_src scheme
(define syntax-example-of-add-vertex
  '(:type vertex-representation-for-add-vertex

    :v vertex-1
    :can (:value 111)

    :abut-edge-list-representation-for-add-vertex
       (:e edge:1-->2
        :can (:edge-type black-arrow)
        :abut-vertex-of-this-edge vertex-2)

       (:e edge:1-->3
        :can (:edge-type black-arrow)
        :abut-vertex-of-this-edge vertex-3)

       (:e edge:1-->2
        :can (:edge-type red-arrow)
        :abut-vertex-of-this-edge vertex-2)

       (:e edge:1-->3
        :can (:edge-type red-arrow)
        :abut-vertex-of-this-edge vertex-3)

       ))

(define example-graph
  '(:type <<graph>>


    :0-dimension-geometry-object-list

    #2=[:v vertex-2 :address #2#
        :can (:value 222)
        :abut-edge-list
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]

    #3=[:v vertex-3 :address #3#
        :can (:value 333)
        :abut-edge-list
           (:e edge:2-->3 :address #4#)
           (:e edge:3-->2 :address #6#)]


    :1-dimension-geometry-object-list

    #4=[:e edge:2-->3 :address #4#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           (:v vertex-2 :address #2#)
           (:v vertex-3 :address #3#)]

    #6=[:e edge:3-->2 :address #6#
        :can (:edge-type black-arrow)
        :abut-vertex-list
           (:v vertex-3 :address #3#)
           (:v vertex-2 :address #2#)]


    ))


(define add-vertex
  (lambda (vertex-to-be-processed the-graph)
    (add-vertex! vertex-to-be-processed (list-copy the-graph))))


;; add-vertex!它不是一個遞歸函數
;; add-vertex!完全是一個副作用
;; 返回的是副作用之後的輸入的圖的地址
;; 需要控制求值順序
;; 先作出這個新的點 再把新的點加進圖裏
;; 在製作這個新的點的同時需要:
;; 用遞歸的副作用擴充1-dimension-geometry-object-list
;;           同時擴充0-dimension-geometry-object-list
;; 程序不應該寫成下面這樣
;; 這簡直太可怕了 !!!
(define add-vertex!
  (lambda (vertex-to-be-processed the-graph)
    (let ([processed-vertex
           (let* ([head-of-processed-vertex ((find ':v) vertex-to-be-processed)]
                  [address-of-processed-vertex  head-of-processed-vertex]
                  [list-of-abut-edge-to-be-processed
                   (cdr ((find ':abut-edge-list-representation-for-add-vertex)
                         vertex-to-be-processed))]
                  [insert-a-new-maked-edge-to-the-graph-and-return-it-as-abut-edge
                   ;; 注意: 插入一個邊的同時還需要調整這個邊指向的點
                   (lambda (abut-edge-to-be-processed)
                     (let* ([head-of-new-maked-edge ((find ':e) abut-edge-to-be-processed)]
                            [address-of-new-maked-edge head-of-new-maked-edge])
                       (insert-val-to-a-field-of-a-wlist!
                         (append!
                           head-of-new-maked-edge
                           `(:address ,address-of-new-maked-edge)
                           ((find ':can) abut-edge-to-be-processed)
                           `(:abut-vertex-list
                             (:v ,((take 1) ((find ':v) address-of-processed-vertex))
                                 :address ,address-of-processed-vertex)
                             (:v ,((take 1) ((find ':abut-vertex-of-this-edge) abut-edge-to-be-processed))
                                 :address
                                 ,(let* ;; 去找到地址
                                      ([name-of-this-vertex
                                        ((take 1)
                                         ((find ':abut-vertex-of-this-edge)
                                          abut-edge-to-be-processed))]
                                       [address-of-this-vertex
                                        (letrec
                                            ([R (lambda (vertex-list-of-the-graph)
                                                  (cond [(null? vertex-list-of-the-graph)
                                                         (error 'add-vertex!
                                                           "can not find a vertex in graph" name-of-this-vertex)]
                                                        [(eq? ((take 1)
                                                               ((find ':v)
                                                                (car vertex-list-of-the-graph)))
                                                              name-of-this-vertex)
                                                         ((take 1)
                                                          ((find ':address)
                                                           (car vertex-list-of-the-graph)))]
                                                        [else
                                                         (R (cdr vertex-list-of-the-graph))]))])
                                          (R (cdr ((find ':0-dimension-geometry-object-list)
                                                   the-graph))))])
                                    ;; 在找到的地址裏作副作用
                                    (insert-val-to-a-field-of-a-wlist!
                                      (append
                                       ((find ':e) abut-edge-to-be-processed)
                                       `(:address ,address-of-new-maked-edge))
                                      ':abut-edge-list address-of-this-vertex)
                                    ;; 返回地址
                                    address-of-this-vertex))))
                         ':1-dimension-geometry-object-list the-graph)
                       (append
                        ((find ':e) abut-edge-to-be-processed)
                        `(:address ,address-of-new-maked-edge))))])
             ;; make-a-vertex
             (append!
               head-of-processed-vertex
               `(:address ,address-of-processed-vertex)
               ((find ':can) vertex-to-be-processed)
               `(:abut-edge-list
                 ,(map insert-a-new-maked-edge-to-the-graph-and-return-it-as-abut-edge
                       list-of-abut-edge-to-be-processed))))])
      (insert-val-to-a-field-of-a-wlist!
        processed-vertex ':0-dimension-geometry-object-list the-graph)
      the-graph)))
;; test:
;; (add-vertex syntax-example-of-add-vertex
;;             example-graph)

;; (:type <<graph>>
;;        :0-dimension-geometry-object-list
;;   #0=(:v vertex-1 :address #0# :can (:value 111)
;;        :abut-edge-list
;;        ((:e edge:1-->2 :address
;;           #1=(:e edge:1-->2 :address #1# :can
;;                  (:edge-type black-arrow) :abut-vertex-list
;;                  (:v vertex-1 :address #0#)
;;                  (:v vertex-2 :address
;;                  #2=(:v vertex-2 :address #2# :can
;;                       (:value 222) :abut-edge-list
;;                       (:e edge:1-->2 :address
;;                         #3=(:e edge:1-->2 :address #3# :can
;;                              (:edge-type red-arrow)
;;                              :abut-vertex-list
;;                              (:v vertex-1 :address #0#)
;;                              (:v vertex-2 :address #2#)))
;;                       (:e edge:1-->2 :address #1#)
;;                       (:e edge:2-->3 :address
;;                         #4=(:e edge:2-->3 :address #4# :can
;;                              (:edge-type black-arrow)
;;                              :abut-vertex-list
;;                              (:v vertex-2 :address #2#)
;;                              (:v vertex-3 :address
;;                                #5=(:v vertex-3 :address #5#
;;                                     :can (:value 333)
;;                                     :abut-edge-list
;;                                     (:e edge:1-->3 :address
;;                                       #6=(:e edge:1-->3
;;                                            :address #6# :can
;;                                            (:edge-type
;;                                              red-arrow)
;;                                            :abut-vertex-list
;;                                            (:v vertex-1
;;                                              :address #0#)
;;                                            (:v vertex-3
;;                                              :address #5#)))
;;                                     (:e edge:1-->3 :address
;;                                       #7=(:e edge:1-->3
;;                                            :address #7# :can
;;                                            (:edge-type
;;                                              black-arrow)
;;                                            :abut-vertex-list
;;                                            (:v vertex-1
;;                                              :address #0#)
;;                                            (:v vertex-3
;;                                              :address #5#)))
;;                                     (:e edge:2-->3 :address
;;                                       #4#)
;;                                     (:e edge:3-->2 :address
;;                                       #8=(:e edge:3-->2
;;                                            :address #8# :can
;;                                            (:edge-type
;;                                              black-arrow)
;;                                            :abut-vertex-list
;;                                            (:v vertex-3
;;                                              :address #5#)
;;                                            (:v vertex-2
;;                                              :address #2#)))))))
;;                       (:e edge:3-->2 :address #8#)))))
;;          (:e edge:1-->3 :address #7#)
;;          (:e edge:1-->2 :address #3#)
;;          (:e edge:1-->3 :address #6#)))
;;   #2# #5# :1-dimension-geometry-object-list #6# #3# #7# #1#
;;   #4# #8#)

#+end_src
**** 0.03
#+begin_src scheme
;; (define syntax-example-of-add-vertex
;;   '(:type vertex-representation-for-add-vertex

;;     :v vertex-1
;;     :can (:value 111)

;;     :abut-edge-list-representation-for-add-vertex
;;        (:e edge:1-->2
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-of-this-edge vertex-2)

;;        (:e edge:1-->3
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-of-this-edge vertex-3)

;;        (:e edge:1-->2
;;         :can (:edge-type red-arrow)
;;         :abut-vertex-of-this-edge vertex-2)

;;        (:e edge:1-->3
;;         :can (:edge-type red-arrow)
;;         :abut-vertex-of-this-edge vertex-3)

;;        ))

;; (define example-graph
;;   '(:type <<graph>>


;;     :0-dimension-geometry-object-list

;;     #2=[:v vertex-2 :address #2#
;;         :can (:value 222)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]

;;     #3=[:v vertex-3 :address #3#
;;         :can (:value 333)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]


;;     :1-dimension-geometry-object-list

;;     #4=[:e edge:2-->3 :address #4#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-2 :address #2#)
;;            (:v vertex-3 :address #3#)]

;;     #6=[:e edge:3-->2 :address #6#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-3 :address #3#)
;;            (:v vertex-2 :address #2#)]


;;     ))


(define find-vertex-address-in-vertex-list
  (lambda (name-of-vertex vertex-list-of-the-graph)
    (cond [(null? vertex-list-of-the-graph)
           (error 'find-vertex-address
             "can not find a vertex in graph" name-of-vertex)]
          [(eq? ((take 1) ((find ':v) (car vertex-list-of-the-graph)))
                name-of-vertex)
           ((take 1) ((find ':address) (car vertex-list-of-the-graph)))]
          [else
           (find-vertex-address-in-vertex-list
            name-of-vertex
            (cdr vertex-list-of-the-graph))])))

(define add-vertex
  (lambda (vertex-to-be-processed the-graph)
    (add-vertex! vertex-to-be-processed (list-copy the-graph))))


;; add-vertex!它不是一個遞歸函數
;; 不是遞歸函數就意味着我可以最明顯的平鋪直敘的方式把程序先寫出來
;; 也許正是在這種平鋪直敘中最容易把程序先寫對
;; 也許正是在這種平鋪直敘中最容易找到程序中重複的模式
;;     把這些重複的模式抽象出來就簡化了代碼

;; add-vertex!完全是一個副作用
;; 返回的是副作用之後的輸入的圖的地址

;; 需要控制求值順序
;; 作出這個新的點
;; [1]把新的點加進0-dimension-geometry-object-list裏
;; 在製作這個新的點的同時需要:
;; [2]用遞歸的副作用擴充1-dimension-geometry-object-list
;; [3]          同時調整0-dimension-geometry-object-list中的其他點

(define add-vertex!
  (lambda (vertex-to-be-processed the-graph)
    (let ([list-of-abut-edge-to-be-processed
           (cdr ((find ':abut-edge-list-representation-for-add-vertex)
                 vertex-to-be-processed))])

      ;; SIDE-EFFECT:[1]============================================
      (let* ([head-of-processed-vertex ((find ':v) vertex-to-be-processed)]
             [address-of-processed-vertex  head-of-processed-vertex])
        (to-a-field-of-a-wlist--let-us-insert-a-val!
          ':0-dimension-geometry-object-list the-graph
          (append!
            head-of-processed-vertex
            `(:address ,address-of-processed-vertex)
            ((find ':can) vertex-to-be-processed)
            `(:abut-edge-list
              ,(map
                ;; SIDE-EFFECT-by-map:[2]==========================================
                (lambda (abut-edge-to-be-processed)
                  (let* ([head-of-new-maked-edge ((find ':e) abut-edge-to-be-processed)]
                         [address-of-new-maked-edge head-of-new-maked-edge])
                    ;; let*在上面的好處是 這樣就又更大的scope 返回值的之後也可能引用到這些綁定
                    (to-a-field-of-a-wlist--let-us-insert-a-val!
                      ':1-dimension-geometry-object-list the-graph
                      (append!
                        head-of-new-maked-edge
                        `(:address ,address-of-new-maked-edge)
                        ((find ':can) abut-edge-to-be-processed)
                        `(:abut-vertex-list
                          (:v ,((take 1) ((find ':v) address-of-processed-vertex))
                              :address ,address-of-processed-vertex)
                          (:v ,((take 1) ((find ':abut-vertex-of-this-edge) abut-edge-to-be-processed))
                              :address
                              ;; SIDE-EFFECT:[3]==========================================
                              ,(let* ([name-of-this-vertex
                                       ((take 1)
                                        ((find ':abut-vertex-of-this-edge)
                                         abut-edge-to-be-processed))]
                                      [address-of-this-vertex
                                       (find-vertex-address-in-vertex-list
                                        name-of-this-vertex
                                        (cdr ((find ':0-dimension-geometry-object-list)
                                              the-graph)))])
                                 (to-a-field-of-a-wlist--let-us-insert-a-val!
                                   ':abut-edge-list address-of-this-vertex
                                   (append
                                    ((find ':e) abut-edge-to-be-processed)
                                    `(:address ,address-of-new-maked-edge)))
                                 ;; RETURN-VAL:[3]--------------------------------
                                 address-of-this-vertex)))))
                    ;; RETURN-VAL-by-map:[2]--------------------------------
                    (append
                     ((find ':e) abut-edge-to-be-processed)
                     `(:address ,address-of-new-maked-edge))))
                    list-of-abut-edge-to-be-processed)))))

      ;; RETURN-VAL:[1]--------------------------------
      the-graph)))


;; test:
;; (add-vertex syntax-example-of-add-vertex
;;             example-graph)


;; (:type <<graph>> :0-dimension-geometry-object-list
;;        #0=(:v vertex-1 :address #0# :can (:value 111)
;;               :abut-edge-list
;;               ((:e edge:1-->2 :address
;;                    #1=(:e edge:1-->2 :address #1# :can
;;                           (:edge-type black-arrow) :abut-vertex-list
;;                           (:v vertex-1 :address #0#)
;;                           (:v vertex-2 :address
;;                               #2=(:v vertex-2 :address #2# :can
;;                                      (:value 222) :abut-edge-list
;;                                      (:e edge:1-->2 :address
;;                                          #3=(:e edge:1-->2 :address #3# :can
;;                                                 (:edge-type red-arrow)
;;                                                 :abut-vertex-list
;;                                                 (:v vertex-1 :address #0#)
;;                                                 (:v vertex-2 :address #2#)))
;;                                      (:e edge:1-->2 :address #1#)
;;                                      (:e edge:2-->3 :address
;;                                          #4=(:e edge:2-->3 :address #4# :can
;;                                                 (:edge-type black-arrow)
;;                                                 :abut-vertex-list
;;                                                 (:v vertex-2 :address #2#)
;;                                                 (:v vertex-3 :address
;;                                                     #5=(:v vertex-3 :address #5#
;;                                                            :can (:value 333)
;;                                                            :abut-edge-list
;;                                                            (:e edge:1-->3 :address
;;                                                                #6=(:e edge:1-->3
;;                                                                       :address #6# :can
;;                                                                       (:edge-type
;;                                                                        red-arrow)
;;                                                                       :abut-vertex-list
;;                                                                       (:v vertex-1
;;                                                                           :address #0#)
;;                                                                       (:v vertex-3
;;                                                                           :address #5#)))
;;                                                            (:e edge:1-->3 :address
;;                                                                #7=(:e edge:1-->3
;;                                                                       :address #7# :can
;;                                                                       (:edge-type
;;                                                                        black-arrow)
;;                                                                       :abut-vertex-list
;;                                                                       (:v vertex-1
;;                                                                           :address #0#)
;;                                                                       (:v vertex-3
;;                                                                           :address #5#)))
;;                                                            (:e edge:2-->3 :address
;;                                                                #4#)
;;                                                            (:e edge:3-->2 :address
;;                                                                #8=(:e edge:3-->2
;;                                                                       :address #8# :can
;;                                                                       (:edge-type
;;                                                                        black-arrow)
;;                                                                       :abut-vertex-list
;;                                                                       (:v vertex-3
;;                                                                           :address #5#)
;;                                                                       (:v vertex-2
;;                                                                           :address #2#)))))))
;;                                      (:e edge:3-->2 :address #8#)))))
;;                (:e edge:1-->3 :address #7#)
;;                (:e edge:1-->2 :address #3#)
;;                (:e edge:1-->3 :address #6#)))
;;        #2# #5# :1-dimension-geometry-object-list #6# #3# #7# #1#
;;        #4# #8#)

#+end_src
*** note about add-vertex
- k :: 讓我們來總結一下上面作副作用的方法
       看看我們是不是能夠提取出來一種更具體的代碼風格
- x :: 記得在寫list-copy的時候我們發現了一個可以改進scheme的地方
       我想問的是 這種改進能不能利用我們上面所使用的風格來實現??
       並且 如何實現編譯器才能以明顯地方式使用地址
*** add-edge
#+begin_src scheme
;; (define syntax-example-of-add-edge
;;   '(:type edge-representation-for-add-edge

;;     :e kkk-edge
;;     :can (:value kkk)

;;     :abut-vertex-list-representation-for-add-edge
;;        (:v vertex-2)
;;        (:v vertex-3)

;;        ))

;; (define example-graph
;;   '(:type <<graph>>

;;     :0-dimension-geometry-object-list

;;     #2=[:v vertex-2 :address #2#
;;         :can (:value 222)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]

;;     #3=[:v vertex-3 :address #3#
;;         :can (:value 333)
;;         :abut-edge-list
;;            (:e edge:2-->3 :address #4#)
;;            (:e edge:3-->2 :address #6#)]


;;     :1-dimension-geometry-object-list

;;     #4=[:e edge:2-->3 :address #4#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-2 :address #2#)
;;            (:v vertex-3 :address #3#)]

;;     #6=[:e edge:3-->2 :address #6#
;;         :can (:edge-type black-arrow)
;;         :abut-vertex-list
;;            (:v vertex-3 :address #3#)
;;            (:v vertex-2 :address #2#)]


;;     ))

(define add-edge
  (lambda (edge-to-be-processed the-graph)
    (add-edge! edge-to-be-processed (list-copy the-graph))))

;; 比add-vertex簡單多了
;; 構造新邊
;; [1]加到:1-dimension-geometry-object-list中
;; 構造新邊的過程中需要
;; [2]調整:0-dimension-geometry-object-list中的兩個點
(define add-edge!
  (lambda (edge-to-be-processed the-graph)
    (let ([list-of-abut-vertex-to-be-processed
           (cdr ((find ':abut-vertex-list-representation-for-add-edge)
                 edge-to-be-processed))]
          [vertex-list-of-the-graph
           (cdr
            ((find ':0-dimension-geometry-object-list)
             the-graph))])

      ;; SIDE-EFFECT:[1]==========================================
      (let* ([head-of-processed-edge ((find ':e) edge-to-be-processed)]
             [address-of-processed-edge head-of-processed-edge]
             [name-of-vertex-1
              ((take 1)
               (car list-of-abut-vertex-to-be-processed))]
             [address-of-vertex-1
              (find-vertex-address-in-vertex-list
               name-of-vertex-1
               vertex-list-of-the-graph)]
             [name-of-vertex-2
              ((take 1)
               (cadr list-of-abut-vertex-to-be-processed))]
             [address-of-vertex-2
              (find-vertex-address-in-vertex-list
               name-of-vertex-2
               vertex-list-of-the-graph)])
        (to-a-field-of-a-wlist--let-us-insert-a-val!
          ':1-dimension-geometry-object-list the-graph
          (append!
            head-of-processed-edge
            `(:address ,address-of-processed-edge)
            ((find ':can) edge-to-be-processed)
            `(:abut-vertex-list
              (:v ,name-of-vertex-1
                  :address
                  ,(let ([address-of-this-vertex address-of-vertex-1])
                     ;; SIDE-EFFECT:[2](1)==============================
                     (to-a-field-of-a-wlist--let-us-insert-a-val!
                       ':abut-edge-list address-of-this-vertex
                       (append
                        ((find ':e) edge-to-be-processed)
                        `(:address ,address-of-processed-edge)))
                     ;; RETURN-VAL:[2](1)--------------------------------
                     address-of-this-vertex))
              (:v ,name-of-vertex-2
                  :address
                  ,(let ([address-of-this-vertex address-of-vertex-2])
                     ;; SIDE-EFFECT:[2](2)==============================
                     (to-a-field-of-a-wlist--let-us-insert-a-val!
                       ':abut-edge-list address-of-this-vertex
                       (append
                        ((find ':e) edge-to-be-processed)
                        `(:address ,address-of-processed-edge)))
                     ;; RETURN-VAL:[2](2)--------------------------------
                     address-of-this-vertex)))))))

    ;; RETURN-VAL:[1]--------------------------------
    the-graph))

;; test:
;; (add-edge syntax-example-of-add-edge
;;           example-graph)

;; (:type
;;  <<graph>>
;;  :0-dimension-geometry-object-list
;;  #0=(:v vertex-2 :address #0# :can (:value 222)
;;         :abut-edge-list
;;         (:e kkk-edge :address
;;             #1=(:e kkk-edge :address #1# :can (:value kkk)
;;                    :abut-vertex-list (:v vertex-2 :address #0#)
;;                    (:v vertex-3 :address
;;                        #2=(:v vertex-3 :address #2# :can
;;                               (:value 333) :abut-edge-list
;;                               (:e kkk-edge :address #1#)
;;                               (:e edge:2-->3 :address
;;                                   #3=(:e edge:2-->3 :address #3# :can
;;                                          (:edge-type black-arrow)
;;                                          :abut-vertex-list
;;                                          (:v vertex-2 :address #0#)
;;                                          (:v vertex-3 :address #2#)))
;;                               (:e edge:3-->2 :address
;;                                   #4=(:e edge:3-->2 :address #4# :can
;;                                          (:edge-type black-arrow)
;;                                          :abut-vertex-list
;;                                          (:v vertex-3 :address #2#)
;;                                          (:v vertex-2 :address #0#)))))))
;;         (:e edge:2-->3 :address #3#)
;;         (:e edge:3-->2 :address #4#))
;;  #2# :1-dimension-geometry-object-list #1# #3# #4#)
#+end_src
*** >< delete-vertexa
*** >< delete-edge
** syntax of directed-graph-processing language
*** design the syntax
1. 使用sexp作爲基礎
   單純的是因爲這樣語法分析就很方便
2. 在語法的設計上我決定大量的利用樹
   因爲樹是可以方便的用sexp來表達的
   而sexp是很容易被處理的
*** 關於語法的遞歸定義
用我的語法描述同一個圖的方式顯然不唯一
所以不能用歸納定義良好地定義 然後再被遞歸函數處理
對圖的處理將是那些進行副作用的基本有向圖操作
還有ζ-cal
*** what is needed?
**** by daedalus
1. 通過描述一個只有根節點被標記了的有向樹
   並描述這些樹的節點之間的另外的有向邊的連接關係
   來讓機器初始化一個連通度更高的有向圖
2. 被標記了的節點是這個圖的入口
   我可以沿着有向邊或逆着有向邊行走以遍歷這個圖
   以這種遍歷方式爲基礎我可以實現call-by-need
**** >< by inference-rules
1. 首先是對inference-rules的正確理解
2. 需要不斷的向一個有向圖中引入節點
   新引入的節點有可能以原圖中的節點爲父節點
   或者新引入的節點是一個孤立的點
   等等
3. 必須有一個良好的對有向邊的標記系統
   因爲每個inference-rule的一次出現都必須被獨立標記
**** by cayley-graph
1. why not use cayley-graph to model a group?
   人們以前爲什麼沒有這樣做過?
2. 惰性
   因爲有趣的cayley-graph常常是無窮的
   所以我必須實現一種對圖的惰性構造
**** category theory
範疇論中的論證與實現都是在用一些圖而已
而代數化的理解範疇論更是能聯繫起來更多的問題
**** beyond the needs
1. 我的有向圖處理語言的適用性必須足夠地廣泛
   重要的是
   在我的語言內要同時保證
   對上面所有這些問題的解法
   都可以用簡明的語法描述給機器聽
   如果成功了那麼我的語言就一定還能適用到一些我現在還沒想到的地方
2. 也許需要同時實現對有向圖的各種表示
   比如就圖之間的同構這種拓撲性質而言
   可能需要特殊的對圖的表示
3. 也許實現各種不同的表示之間的快速地同構變換
   還要維護對一個圖的多種表示同時存在的情形
   如果同構變換的速度不夠快的話
   + 爲了作出良好的判斷
     我需要算法分析的知識
   這時可能就要接受兩種表示之間的差異
   讓一個圖的多種表示漸進地改變
   如果真是這樣那實現起來就相當複雜了
**** why need?
1. 使用有向圖處理語言
   而不是字符串或列表處理語言
   可能速度會變慢
   但是這使編程者對代碼的理解更加清晰
   在這方面複雜性的降低所帶來的好處
   完全可以彌補速度變慢所帶來的不足
2. 當使用=α=這種概念來處理約束變元的時候
   實現起來出現了困難
   其實就已經說明這種想法錯了
   而應該改用更清晰的方法來實現所希望的特性
   即使用有向圖
3. 當被引入的關係是等價關係時
   比如=β=
   與其把這種引入理解爲
   對更高一層次的字符串的集合的歸納定義
   還不如直接把等價關係理解爲分類
   然後用與分類有關的算法來實現這些東西也許會好些
   + 算法分析的知識變地越來約迫切了
   這裏能用圖論來理解嗎?
   能
   等價關係就是以歸納定義樹爲基礎
   一個後繼型關系所成的有向圖中的無向路
4. 當被引入的關係是由類後繼關係生成的偏序關係時
   比如-β->爲-sβ->所生成
   與其把這種引入理解爲
   對更高一層次的字符串的集合的歸納定義
   還不如直接把後繼關係理解爲有向圖
   這樣纔是自然的
5. 實現一個形式理論的方式如果和最自然的理解方式相一致
   那當然是最好的
6. 對一個字符串的集合的歸納定義
   其實想定義的是樹
   每個被認爲是元素的表達式其實都是樹
   只不過只有葉節點被標記了
   var ::= v | var'
   term ::= var | (term term) | (λ var . term)
   就是典型的例子
   歸納定義的字符串的集合的時候所使用的括號``()''
   其實是爲了形成樹的語義
   即 如果直接用樹來定義term就沒必要使用括號了
   但是實踐中
   人必須能告訴機器應該怎麼作
   因此想要在這裏省略括號而形成更適合於人類的理解
   人就發現還是得使用括號
   因爲sexp作爲語法已經很簡明瞭

*** init a graph
**** design
現在明白類似javascript的alist處理語言的好處了
在我將設計的類javascript語言中
>< 可以用與約定來區分key的書寫方式
大寫開頭的是被約定成變元好還是被約定成函數好呢???
別的語言是如何處理這個問題的??? 區分嗎???
#+begin_src scheme
([:v :can]
      ([:v :can]
            ([:e :v :can]
                  ([:v :can])
                  ([:e :v])))
      ([:e :v :can]
            ([:e :v :can])))


λx.xx
(<graph>
 ([:v λ]
     ([:e --> :v :can <-- λ])
     ([:e --> :v :can <-- λ])))


對與沒有出現:v :e 的地方 或者其後是空值的地方
當約定了默認值時就使用默認值
如果沒有規定默認值就使用無名的點或邊
:e -->在這裏可以被認爲是默認的所以有:

(<graph>
 (:default (:e -->))
 ([:v λ]
     ([:v :can <-- λ])
     ([:v :can <-- λ])))


λx.x(λx.xx)

(λ (x)
  (x (λ (x)
       (x x))))
(<graph>
 (:default (:e -->))
 ([:v λ]
     ([:v :can <-- λ])
     ([:v λ]
        ([:v :can <-- λ])
        ([:v :can <-- λ]))))

下面這個就是另外一個圖了
λx.x(λy.yx)
(<graph>
 (:default (:e -->))
 ([:v λ]
    ([:v :can <-- λ])
    ([:v λ]
       ([:v :can <-- λ])
       ([:v :can <-- <-- λ]))))



使用有向路可以以一點爲基礎來指出另一點的位置
使用有向樹可以以一點爲基礎來指出另外很多點的位置
注意: 當允許邊和點重名時 就有可能出現(語義上)完全不能區分的點或邊
比如在對稱性很強的圖中就是這樣
#+end_src
**** code
這個compiler的將以簡單的方式工作
並且其行爲將符合人們的直覺
即 先構建一個樹 然後再作連接

它只使用到add-vertex和add-edge
#+begin_src scheme

λx.x(λy.yx)
(<graph>
 (:default (:e -->))
 ([:v λ]
     ([:v :can <-- λ])
     ([:v λ]
        ([:v :can <-- λ])
        ([:v :can <-- <-- λ]))))

;; 樹代表支撐樹
;; 支撐樹的葉子是遞歸函數的基本步驟
;; 節點被編譯成``對點的添加'' 此時需要子節點和邊的信息
;; :can中的數據被編譯成``對邊的添加''
;; ``對邊的添加''被作爲副作用在支撐樹構造完成之後進行
;; 輸入的例子:
;; ([:v λ]
;;    ([:v :can <-- λ])
;;    ([:v λ]
;;       ([:v :can <-- λ])
;;       ([:v :can <-- <-- λ])))
;; 返回一個製作好的圖 ???
;; 還是返回編譯好的生成圖的代碼 ???
;; 因爲那些節點是無名的 或者是重名的
;; 所以就算有通過描述兩個點的 對邊的簡單添加
;; 我還是沒辦法寫出下面的初始化
(define init-graph
  (lambda (spanning-tree)
    ;; 每次遞歸處理一個點和它的子節點
    (let ([vertex (car spanning-tree)]
          [subvertex-list (cdr spanning-tree)])
      ()
      ;; 下面是遞歸調用
      (map init-graph subvertex-list)
      ;; 下面是返回值
      ()
      )))
#+end_src
*** - k :: x, digrap是否適合用來實現和研究各種圖論算法???
- x :: 我也不知道
       因爲我現在還不知道digrap是什麼樣的呢
*** ><><>< use small graph to build biger graph
*** ><><>< tree-instruction
to use a tree like instruction
to tell the machine how to change the graph it stored
** ζ-cal
