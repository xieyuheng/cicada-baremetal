#+TITLE: note on lambda
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* TODO
  整理筆記
* old notes

好的講授方式是先在非形式化的語言下試着描述
以發現對理論的哪部分作嚴格的形式化是有必要的
這正是數學研究的典型過程
數學家正是要在觀察中發現結構 然後通過形式化的描述來增進對問題的認識


scott限制函數與某個拓撲空間上的連續函數集
然後λ-cal的理論就有了拓撲(幾何)解釋
那麼根遞歸函數有關的不動點概唸的幾何意義是什麼呢?


pure λ-calculus

models of λ-calculus are objects in category (of course)
and these categories are cartesian closed
(then non-unary functions can reduced to unary functions)

*λ-calculus studies functions as rules (but not geometry object)*

no matter use λ-term as expression defined by grammars
or λ-post-term as directed graph
one can always captures the concept of ``terms modulo convertibility''
which is the principle object of the study
the following questions need to be studied:
1. λ-definability
   λ-可定義的函數的集合等於遞歸函數的集合
2. the relations between non-convertible terms
   定義一個λ-可定義函數的term要麼是一個要麼有無窮多個
3. the limit of λ-calculus to captures the notion of function
   term的集合上有一個自然的拓撲結構:tree-topology
   term -> Bohm-tree -> scott-topology
   所有的λ-可定義函數都是就這個拓撲而言的連續函數


conversion

all about ``terms modulo convertibility''

use λ-terms to introduce ``terms modulo convertibility''
the set of λ-terms is a set of strings defined inductively by grammars
the theories on this string-level is called syntax
≡ denotes the syntactic equality

[x:=N] is an function act on λ-terms
which is used with rules to define =β=(or just =)(β-convertibility)
this equivalence relation define the theory λ (or λ-calculus)
(when there is rules there is theory)
provability in the theory λ of equation is denoted by λ⊦(M=β=N)
one can say M and N is convertible when λ⊦(M=β=N)
this seems a loop-define
bacause the notion: provability of proof-theory is used
to define the equivalence relation
rules give a partial-order on the set of λ-terms

connectives and quantifiers which can describe propositions
will be used in the discussion about λ-cal

what is equation?
equation in λ-cal is proposition with many quantifiers

* an enlighten
關於類型論
因爲每引入一個新的類型
就可以引入一些相應的referece-rules

所以一次啓蒙在於
類型論讓人認識到
referece-rules並不必以一階邏輯爲中心
而是可以相當任意的創造的

比如
我可以以字符串或者有向圖爲基本數據結構
來實現一個形式理論
那麼對於字符串或者有向圖我都自然有一些基本的``等詞''
對推理規則的引入的自由性就在於:
推理規則中對這些等詞的引入不能違背
這些等詞在基本數據結構中本來的語義
此限之外別無它限

更常見的是
推理規則需要引入
以基本等詞爲基礎在基本數據結構中實現的其它關係
對其它關係的實現本身並不會違背基本等詞
但是引入這些關係的推理規則可能會違背基本等詞
所以需要加上上面的限制

因此首先我要一個直覺性的並且具有可構造性的數學結構
當我用計算機來實現一個數據結構時
很自然地我就得到上面的良好性質
然後我引入一些針對這種數學結構的推理規則
之後我就得到了一個形式語言
用這個語言我可以推導出一些描述這個數學結構的一般性質的命題
這些命題的正確性由推理規則和數學結構的相容性保證
這些命題是具有實在意義的因爲我是一個純粹的形式主義者
+ 關於術語:
  這裏 爲了描述上面的形式語言於數學結構之間的關係
  我通過創造新的術語
  並且把對這些術語的使用只侷限在我在上面所描述的這種關係
  來避免歧義
  稱上面的關係爲
  形式語言捕捉到數學結構
  既然我是在創造一個語言來描述我的幻想
  那麼這個動詞是很生動的
  一組推理規則可能能於一個數學結構相容
  而又於另一個數學結構不容
  即這組推理規則所形成的形式語言
  能夠捕捉到某些數學結構
  而捕捉不到其它數學結構
  + >< 考慮完備性
    我是不是應該更改我的術語
    當形式語言就某個數學結構而言具有完備性的時候
    應該怎麼說??
* >< type-free λ-cal
** notations
formal-language
== 形式語言 == 形式理論

exp == expression == formula
== 表達式

grammar == grammar-formula == BNF
== 形式語法 == 形式語法公式
+ 用來歸納定義一個字符串的子集

等詞
每個等詞都應該與某個類型的數據相聯繫
否則會引起很多歧義
+ 這裏可以看出類型論的一些合理性
  因爲在類型論中對等號的使用正是如此

等號
等號是被濫用最多的數學符號
在定義形式語言的時候一定要小心使用
等號的基本語義:
1. 賦值
3. 基本等詞
2. 等價關係

priori == 先驗的
** inductive definition of the set of exp
var ::= v | var'
term ::= var | (term term) | (λ var . term)
the set of all terms is denoted by Λ

其中括號的使用是爲了形成樹的語義
由遞歸定義
一個term被理解爲一個有根的樹
+ 樹可因根的選取而獲得一個定向
這個有向樹中只有葉節點是被標記了的
用來標記葉節點的是var或者是字符"λ"或"."

用字符串來實現一個形式語言時
字符串之間的相等就是基本等詞
給出兩個字符串時
人們可以區分它們是相同還是不同
+ 這是一個先驗的假設
  但是在計算機上的可實現性增強了這個假設的合理性
  先驗假設的合理性 == 假設中的概念在機器上的可實現性
這樣就得到了就字符串而言的基本的等詞
這個等詞記爲``==''

等詞永遠根所使用的模型有關
** indude-tree(Λ; ∈term-intro1, ∈term-intro2)
term於term之間有引入關係
比如M,N引入(M N)
所以也許可以用推理規則來描述這個歸納定義
用推理規則來描述歸納定義也許具有更大的普遍性

+ 也就是說我統一把這種``類後繼關係''用inference-rules來描述
  這樣在用圖論對整個理論的想像之中
  因爲形成了統一的理解方式
  所以一切都變得簡單了

----- (∈var axiom)
v∈var
這裏v是真正的字符

x∈var
------------ (∈var introduction)
x'∈var
這裏x是字符串的模式匹配中的pattern-variable
'是真正的字符

x∈var
----------- (∈term axiom)
x∈term

M∈term
N∈term
------------- (∈term introduction1)
(M N) ∈term

x∈var
M∈term
------------------- (∈term introduction2)
(λ x . M) ∈term

此時就顯然可以看出term和term之間的引入關係
可以形成一個以Λ中的元素爲節點
以(∈term introduction1)於(∈term introduction2)爲有向邊
的無窮有向樹
記爲:
inductive-definition-tree(Λ;(∈term introduction1),(∈term introduction2))
ID-Tree(Λ; ∈term-intro1, ∈term-intro2)
indude-tree(Λ; ∈term-intro1, ∈term-intro2)

** substitution
這是一個基本的對表達式的集合Λ
中的元素的處理(被參數化的函數)
| M       | M[x:=N]            |
|---------+--------------------|
| x       | N                  |
| y(=/=x) | y                  |
| PQ      | (P[x:=N])(Q[x:=N]) |
| λx.P    | λx.P               |
| λy.P    | λy.(P[x:=N])       |
** the set of free(resp. bound) variables of M, notation FV(M)(resp. BV(M))
*** note
FV與BV都是基本的表達式的集合Λ上的函數
+ 當把集合理解爲
  比如說表達式的有限時
  上面這些集合論中的概念是很容易實現的
  當然這裏又需要一些先驗的假設
  然而同樣因爲在機器上的可實現性
  這些假設是合理的
+ >< 如何理解這裏對等號的使用??
*** FV
FV(x) := {x}
FV(MN) := FV(M)∪FV(N)
FV(λx.M) := FV(M)\{x}
*** BV
BV(x) := ∅
BV(MN) := BV(M)∪BV(N)
BV(λx.M) := BV(M)∪{x}
** =α=
*** =α= introduction
α-conversion

公式 λx.M =α= λy.M[y:=x]
+ y不在M中自由出現
其實是在描述一個pattern-matching
而我用下面的對實現而言更直接的定義

N == M[y:=x]
M == N[x:=y]
-------------------- =α= introduction
λx.M =α= λy.N

*** an example
an affirmation(allegation)(assertion) of the following proposition
λt.tzt =α= λs.szs

1. λx.M pattern-matching λt.tzt
   1) λ == λ, so
      the pattern is matched successfully
   2) pattern-vars binding:
      x -- t
      M -- tzt
2. λy.N pattern-matching λs.szs
   1) λ == λ, so
      the pattern is matched successfully
   2) pattern-vars binding:
      y -- s
      N -- szs
3. performing M[x:=y]
   where:
   M -- tzt
   x -- t
   y -- s
   so performing tzt[t:=s]
   we get: szs
   so N == M[y:=x]
4. performing N[x:=y]
   where:
   N -- szs
   x -- t
   y -- s
   so performing szs[s:=t]
   we get: tzt
   so M == N[x:=y]
5. so λt.tzt =α= λs.szs

*** compatibility
就與Λ的歸納定義的相容性擴展

M =α= N
------------
ML =α= NL
LM =α= LN
λv.M =α= λv.N

*** note
變元只是語法對象 它們的意義只在於
人們想要利用這些語法對象來說明一些語義
*語言是爲了表達*

這個等價關係使得表達式的集合Λ獲得了有向圖的語義
也就是說等價關係的引入可以被看成是對語義的引入
或者在這裏我可以進行一次模型的轉換
去直接用有向圖來實現我想要定義的形式語言
這時Λ就是有向圖的集合而不是字符串的集合
逃離``線性的字符串''這種概唸的限制而使用圖論
+ 然而要明白
  ``線性的字符串''的概唸的重要價值是
  作爲輸入需要被解釋的表達式的工具
  即 作爲人控制機器的方式
  ``線性的字符串''與機器對形式理論的實現之間是有區別的

用有向圖來實現一個形式語言時
有向圖之間的某種相等就是基本等詞
+ 可以想象有向圖之間可以定義各種的相等
給出兩個有向圖時
人們可以區分它們是相同還是不同
+ 同樣這也是一個先驗的假設
  但是在計算機上的可實現性增強了這個假設的合理性
  先驗假設的合理性 == 假設中的概念在機器上的可實現性
這樣就得到了就有向圖而言的基本的等詞
這個等詞記爲``==''或``=α=''
但是要知道此時``=α=''的意義已經完全變了
它不再作爲一個等價關係而被別的基本等詞來引入
而是它本身就是一個基本等詞

對於所有在我希望定義的形式語言裏要使用到的exp
我也可以形成歸納定義
需要更改的是上面的term ::= (λ var . term)這一項
但是因爲所定義的表達式的幾何性質
此時已經不能用一般的形式語法公式來作歸納定義了
因爲這些定義之中還設計到對有向圖的操作
而不是隻涉及到對字符串的簡單操作

但是我可以嘗試用推理規則對term的集合作歸納定義如下:

----- (∈var axiom)
v∈var
+ 這裏v是真正的字符

x∈var
------------ (∈var introduction)
x'∈var
+ 這裏x是字符串的模式匹配中的pattern-variable
  '是真正的字符

x∈var
----------- (∈term axiom)
x∈term

M∈term
N∈term
------------- (∈term introduction1)
(M N) ∈term

x∈var
M∈term
------------------- (∈term introduction2)
(λ . M[free:x := (* --> λ)]) ∈term
+ 這裏M已經是有向圖了
  而它後面的方括號中描述了一個對它的操作
  把x在M中的所有自由出現換成無名節點
  然後把這些無名節點全部都連接到最前面的λ點

** variable convention
+ 當我把有向圖作爲公式來實現我的形式語言的時候
  我其實根本不需要這個技術性處理

assume that the bound and free variables in a situation differ

在用字符串來實現λ-cal這個形式語言時
在一個term中如果需要的話總是重命名約束變元
使得它們不與term中出現的其它任何自由變元相同
這樣在進行substitution的時候就不用考慮那麼多了

** closed λ-term (combinator)
M is called closed λ-term (combinator)
if FV(M) == ∅
the set of closed λ-terms is denoted by Λ°

** >< ``λ-cal as a formal theory of equations between λ-terms''
*** note
``λ-cal as a formal theory of equations between λ-terms''
這句話是什麼意思?
首先提到equation的時候就應該想到代數結構
代數結構總是最豐富而有趣的

*** >< λ-cal as algebra-structure
**** note
我可以試着用我理解代數結構的方式來理解λ-cal
=η=於-sη->的性質我還不熟悉
這也許會讓下面的討論成問題

**** 關於運算律
λ-term的集合
顯然就λ-application構成代數結構
+ λ-abstraction在代數結構中的意義是什麼呢?
  單純地把它作爲對term的遞歸定義嗎?
與羣作爲代數結構的區別在於
這裏的可計算性(或者說可構造性)

***** 在=β=的意義下
****** 沒有交換律:
MN =/β= NM

****** 沒有沒有結合律:
(MN)L =/β= M(NL)

****** 沒有消去律:
LM =β= LN
----><-----
M =β= N

反例是:
L :== K*
K*xy =β= y

***** >< 在添加=η=的意義下
***** 有趣的問題是可不可以形成更高等級的運算
由λ-cal的性質我知道
函數方程的解總是在term的集合Λ中的 !!!
>< 因此沒法就函數方程的解擴充Λ嗎 ???

>< 問題是生麼樣的函數方程的解纔是有意義的呢?
不動點方程顯然是一個
FX =β= X
這個方程描述了
λ-term之間的``X是F的不動點''這種二元關係

***** >< 解方程的重點就是熟悉恆等變換
** -sβ->
*** -sβ-> introduction
β-step-reduction
+ 共軛的有<-sβ-

也就是說公式(λx.M)N -sβ-> M[x:=N]
其實是在描述一個pattern-matching
而我用下面的對實現而言更直接的定義

M* =α= M[x:=N]
-------------------- -sβ-> introduction
(λx.M)N -sβ-> M*

*** an example
an affirmation(allegation)(assertion) of the following proposition
λx.F(xx) λx.F(xx) -sβ-> F(λx.F(xx) λx.F(xx))

1. (λx.M)N pattern-matching λx.F(xx) λx.F(xx)
   1) λ == λ, so
      the pattern is matched successfully
   2) pattern-vars binding:
      x -- x
      M -- F(xx)
      N -- λx.F(xx)
2. performing M[x:=N]
   where:
   x -- x
   M -- F(xx)
   N -- λx.F(xx)
   we get F(λx.F(xx) λx.F(xx))
3. F(λx.F(xx) λx.F(xx)) =α= F(λx.F(xx) λx.F(xx))
   so
   λx.F(xx) λx.F(xx) =β= F(λx.F(xx) λx.F(xx))

*** compatibility
就與Λ的歸納定義的相容性擴展

M -sβ-> N
------------
ML -sβ-> NL
LM -sβ-> LN
λv.M -sβ-> λv.N

** graph(Λ;-sβ->)
如果使用字符串來是實現形式語言的話
一切都是字符串
``(λx.M)N -sβ-> M*''其實也只不過是字符串
只不過比表達式的集合作爲字符串的集合高了一個層次
並且對這個更高層次的字符串的集合的歸納定義也變得複雜了

然而更好的理解方式是於形成更高層次的語義
+ 比如上面對=α=所作的
-sβ->是一個類似於後繼關係的二元關係
這裏以-sβ->爲有向邊
顯然能形成以Λ中的元素爲節點的有向圖
記爲graph(Λ;-sβ->)

在計算機中實現一個能作λ-cal的語言
其實就是實現graph(Λ;-sβ->)的lazy-eval
+ graph(Λ;-sβ->)是一個無窮圖所以需要lazy-eval
每次計算其實就是給出求出局部的graph(Λ;-sβ->)
只不過這裏的局部是極端的
即只有圖中的一個點
可以說λ-cal的理論就可以理解爲對這個無窮有向圖的局部lazy-eval

而證明λ-cal中的定理就是去證明這個無窮有向圖的性質
比如下面的church-rosser theorem所作的

另外
在機器輔助證明系統中
比如在coq中
tactics就可以被看作是對無窮有向圖的惰性求值

** -β->
β-reduction

-sβ->類似於後繼關係
-β->是一個偏序關係

-sβ->就傳遞性生成-β->
這種生成即是用有向路來代替有向邊
因此-β->這個二元關係定義爲:
graph(Λ;-sβ->)中的兩個節點之間是存在有向路

1. 以-sβ->爲基礎
   M -sβ-> N
   ----------
   M -β-> N
2. 添加自反性
   M -β-> M
3. 添加傳遞性
   M -β-> N
   N -β-> L
   ----------
   M -β-> L
** =β=
β-conversion

-β->是一個偏序關係
=β=是等價關係

-β->就對稱性生成=β=
這種生成即是用無向路來代替有向路
因此=β=這個二元關係定義爲:
graph(Λ;-sβ->)中的兩個節點之間是存在無向路
+ path is equality
  -sβ->: 有向邊
  -β->: 有向路
  =β=: 無向路
  構造性的數學中
  數學結構都是歸納定義的
  等價關係自然地被定義爲歸納定義有向樹中的無向路
  + >< 在hott中有的數學結構被稱爲是高階歸納定義的
    比如同倫類
    這是什麼意思???

1. 以-β->爲基礎:
   M -β-> N
   -----------
   M =β= N
2. 添加對稱性
   M =β= N
   ---------
   N =β= M
3. 還要再添加一次傳遞性
   M =β= N
   N =β= L
   ----------
   M =β= L

   + 爲什麼還要多添加一次傳遞性???
     下面錯誤的定義2說明了
     再次添加傳遞性的必要

   + DEFINE2(錯誤的定義):
     M -β-> N
     -----------
     M =β= N

     M <-β- N
     -----------
     M =β= N

     上面這兩個推理規則代替了``或''這個詞
     這樣會有些不好嗎?
     這樣的定義能成嗎?
     能證明對稱性與傳遞性嗎?
     試驗如下:
     因爲
     首先
     M <-β- N
     -----------
     M =β= N
     等價於
     M -β-> N
     -----------
     N =β= M
     所以對稱性的事實是顯然的
     + 我都不想說是證明了
     其次
     M =β= N
     N =β= L
     ----------
     - 有四種引入上面兩個節點的可能性
       我必須說明每種都能推出M =β= L
       1) M -β-> N
          N -β-> L
          ---------
          M -β-> L
          ---------
          M =β= L

       2) N -β-> M
          N -β-> L
          ---------
          此時已經不能推出
          M -β-> L或L -β-> M了
          因此不能推出M =β= L了
          所以這種定義是錯誤的

** belated definitions
*** compatible
集合Λ上的關係-R-被稱爲是與對集合Λ的歸納定義相容的
如果:
1.
   M1 -R- N1    M2 -R- N2
   -----------------------
   (M1 M2) -R- (N1 N2)
   或
   M -R- N
   -----------------
   (M Z) -R- (N Z)
   (Z M) -R- (Z N)

2.
   M -R- N
   -------------------
   (λv.M) -R- (λv.N)

如果用字符串來實現形式理論
那麼-R-可以被實現爲對第二層次的字符串的集合的歸納定義
也就是說對於形式理論來說
引入一個關係其實是在歸納定義一個集合

*** congruence relation
Λ上與Λ的歸納定義相容的關係-R-
如果是等價關係
+ 即 對稱 自反 傳遞
則稱其爲全等關係:congruence
記爲=R=
*** reduction relation
Λ上與Λ的歸納定義相容的關係
如果是偏序關係
+ 即 自反 傳遞
則稱其爲約化關係:reduction
記爲<-R-
因爲沒有對稱性
所以共軛的有-R->
+ 儘管<-sβ-使用了類似的記號
  但是它並不是reduction relation
  但是考慮有向圖就知道使用<-sβ-這種記號是合理的
  + >< 或者我應該設計更好的記號來區分傳遞性???
*** β-redex
(λx.M)N
就是表達式中模式匹配到的λ-abstraction的application
*** β-normal form (β-nf)
λ-term which dose not have any β-redex
as subexpression
這顯然可以通過用模式匹配來寫一個
表達式的集合上的謂詞來實現
*** M has a β-normal form
if ∃N : M =β= N ∧ N is β-normal form
** >< church-rosser theorem
*** aim
實現了 <-β- =β= =α= x:A x∈A 這些關係以後
就可以用謂詞演算所提供連接詞與量詞來形成
關於形式理論的一般性質的命題
比如這裏的這個命題就是如此

>< 這個命題所依賴的推理規則屬於什麼形式語言??
不論如何這個命題都不像某些命題那樣迂腐
而是真正給了我們一些關於形式理論的知識

THEOREM:
∀M,N∈Λ s.t. M =β= N
∃L∈Λ : L <-β- M ∧ L <-β- N

這個定理並沒有它看起來的那麼不平凡
因爲
用公式(λx.M)N :== M[x:=N]去定義-sβ->

=β=其實被定義爲<-β-的交換化
即<-β-然後忽略方向
即<-β-添加對稱性
而<-β-被定義爲<-sβ-從有向邊到有向路的生成

對這個定理的證明就是對
關係-sβ->所形成的有向圖graph(Λ;-sβ->)的性質的觀察

*** lemmas
1. if: M is β-nf
   then:
   M -β-> N
   ---------
   N =α= M
   β-nf 作爲有向圖的葉節點當然有這種性質

2. M -sβ-> M'
   ------------
   M[x:=N] -sβ-> M'[x:=N]
   就引入-sβ->的推理規則作歸納證明即可

*** 回到church-rosser theorem
∀M,N∈Λ s.t. M =β= N
∃L∈Λ : L <-β- M ∧ L <-β- N

即

M =β= N
----------
∃L :
L <-β- M
L <-β- N

這樣寫還是沒能脫離謂詞演算
不過好多了
因爲更接近實現方式了

加強其條件如下:
M <-β- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N
或者按書上的說法:
M -β-> N1
M -β-> N2
--------------
∃N3 :
N1 -β-> N3
N2 -β-> N3

加強的條件中排除了=β=
+ 可以看出這是
  爲了證明命題
  而去在等價變換的前提下加強命題的條件
+ 因爲
  M <-β- Z
  N <-β- Z
  ----------
  M =β= N
  所以
  等價變換只需要考慮一個方向
  即是需要在假設:
  M <-β- Z
  N <-β- Z
  ----------
  ∃L :
  L <-β- M
  L <-β- N
  的正確性的前提下
  按引入=β=的推理規則來分類用歸納法證明:
  M =β= N
  ----------
  ∃L :
  L <-β- M
  L <-β- N

  PROOF:
  1. M -β-> N
     -----------
     M =β= N

     此時引入節點M =β= N的父節點是M -β-> N
     而M -β-> N中不包含``=β=''
     所以這個推理規則被認爲是一個``基礎步驟''
     此時沒有歸納假設
     需要證明:
     ∃L :
     L <-β- M
     L <-β- N
     並且已經有假設成立的定理:
     M <-β- Z
     N <-β- Z
     ----------
     ∃L :
     L <-β- M
     L <-β- N
     了
     顯然此時只要取Z爲M就行了

  2. N =β= M
     ---------
     M =β= N

     此時引入節點M =β= N的父節點是N =β= M
     而N =β= M中包含了``=β=''
     所以這個推理規則被認爲是一個``歸納推步''
     此時有歸納假設:
     N =β= M
     ----------
     ∃L :
     L <-β- N
     L <-β- M
     需要證明:
     ∃L :
     L <-β- M
     L <-β- N
     然後由量詞下面那兩項的交換性這是顯然的
     這並沒有用到已經假設成立了的定理:
     M <-β- Z
     N <-β- Z
     ----------
     ∃L :
     L <-β- M
     L <-β- N

  3. M =β= L
     L =β= N
     ----------
     M =β= N

     此時引入節點M =β= N的父節點是
     M =β= L和L =β= N
     而它們中都包含了``=β=''
     所以這個推理規則被認爲是一個``歸納推步''
     此時有歸納假設:
     1) M =β= L
        ----------
        ∃P1 :
        P1 <-β- M
        P1 <-β- L

     2) L =β= N
        ----------
        ∃P2 :
        P2 <-β- L
        P2 <-β- N

        這兩個約束變元被下面當成
        對所取的一個元素的命名了
     需要證明:
     ∃P :
     P <-β- M
     P <-β- N
     使用已經假設成立了的定理:
     P1 <-β- L
     P2 <-β- L
     ----------
     ∃P :
     P <-β- P1
     P <-β- P2
     由<-β-的性質就知道此時存在的P
     就是
     ∃P :
     P <-β- M
     P <-β- N
     中所需要找的P

     EDN-OF-PROOF.

*** 系
1. if: M has N a β-normal form
   i.e. M =β= N ∧ N is β-normal form
   then:
   M -β-> N

   這是非常好的性質
   它說明如果一個λ-term有β-nf
   按一定的方式rewrite下去就一定能得到這個β-nf
   + 按壞的方式rewrite下去可能無限循環

   PROOF:

   M =β= N
   ---------
   ∃L :
   L <-β- M
   L <-β- N

   N is β-nf
   L <-β- N
   -----------
   L =α= N

   L <-β- M
   L =α= N
   ------------
   N <-β- M

   END-OF-PROOF.

2. a λ-term has at most one β-nf

   PROOF:

   N1 <-β- M
   N2 <-β- M
   -------------------------
   ∃L :
   L <-β- N1
   L <-β- N2

   L <-β- N1
   L <-β- N2
   N1 is β-nf
   N2 is β-nf
   --------------
   N1 =α= N2

   END-OF-PROOF.

   這也是很好的性質
   它說明β-nf的唯一性

*** 例子
1. syntactical consistency
   這是推理規則們的性質

   按照上面所引入的這些推理規則
   沒有=α=關係的一對β-nf
   + 比如常量ture和false
   不可能被推出=β=關係
   即不可能證明
   ture =β= false

   因此``語法一致性''在這裏就是=α=於=β=之間的關係 !!!
   後引入的等價關係不傷害之前的等價關係
   即是一致性(或者說相容性)
   但是爲什麼後引入的等價關係有可能傷害之前的等價關係呢?
   首先要知道
   如果用有向圖來實現形式理論的話
   這裏的=α=根本就是不需要被作爲等價關係而引入的
   有向圖之間的本源``等詞''就夠了
   所以在這裏
   這個``之前引入的等價關係''可以被理解爲是本源等詞
   + 畢竟模型輪中的模型關係是相對的
   這樣推理規則不與本源``等詞''相衝突
   就被認爲是一致性
   + 就數學結構而言
     + 數學結構即指 以集合論爲中心的形式語言系統
     與本源``等詞''有關的實現是一個結構的模型
     而形式理論是這個結構的形式理論
   現在再問``爲什麼會產生衝突?''
   因爲:
   1) 對推理規則的引入是任意的
      推理規則是要去形成有向圖
      而
      反而
      要求被引入的以``等詞''爲語義的節點
      + ``等詞''的語義其實就是命題的語義
        而命題在命題演算中的語義就是布爾代數
        在這個模型的約束下
        推理規則不能同時既推出一個命題真也推出這個命題假
        這纔是數理邏輯中的一致性啊
        我在別的文本中討論的是什麼呢?
        也許問題在於這種一致性對一階邏輯的依賴
        如果同倫類型論於一階邏輯是完全不同的形式語言的話
        那麼同倫類型論中一致性也一定有不同的意義
        兩種一致性之間有什麼關係呢?
        它們都是因爲語義的需要而給推理規則作的限制
        + 不光推理規則是可以自由引入的
          那些產生一致性概唸的``限制''也是可以自由引入的
          到這裏就太形而上了
          因爲追問一個語言的語義
          一個人可以永不停止
      不與本源``等詞''衝突纔是一個附加條件
      + 一個啓蒙也許在於
        可以去想辦法具體地度量這種不一致性
        對不一致性的系統度量一定也能給我們很多知識
   2) 推理規則所能形成的有向圖是複雜的
      + 就這裏的-sβ->而言
        -sβ->有向邊所代表的關係
        -β->是有向路所代表的關係
        =β=是無向路所代表的關係



2. (λx.xx)(λx.xx) has no β-nf

   otherwise:
   (λx.xx)(λx.xx) -β-> N
   N is  β-nf

   but:
   (λx.xx)(λx.xx) -β-> (λx.xx)(λx.xx)
   while
   (λx.xx)(λx.xx) is not β-nf

*** 再次回到church-rosser theorem
現在就可以集中精力證下面的東西了

M <-β- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N

這是關係<-sβ-所形成的有向圖的良好性質
它說分開的東西一定有可能被重新融合

**** main lemma

M <-sβ- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N

the way to proof this is similar to
``radioactive tracing isotopes''
in experimental biology

PROOF:

已知 M <-sβ- Z 具體rewrite了那個 β-redex
又已知 N <-β- Z
通過 N <-β- Z 求的 其對邊 L <-β- M
+ 如果在模仿 N <-β- Z 求的 其對邊 L <-β- M 的過程中
  那個β-redex被消除了
  那麼我作模仿的時候就省略這步消除繼續模仿後面的
然後就發現能自然得到
M <-sβ- Z 的對邊: L <-β- N

END-OF-PROOF.

這個證明其實是給出了尋找
L <-β- M
L <-β- N
的算法

**** after the main lemma
在已知:
M <-sβ- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N
成立的條件下
證明:
M <-β- Z
N <-β- Z
----------
∃L :
L <-β- M
L <-β- N

PROOF:

把M <-β- Z拆開成一步一步的<-sβ-
就發現一個算法是顯然的

END-OF-PROOF.

這就證明完了church-rosser theorem
感覺生麼都沒證明
其實是給出了一個算法而已
當然這個結果確實描述着整個形式理論的性質
*** ><><>< remark
church-rosser theorem
所歸結到的那個有向圖的性質很像

``我先定義自由的代數結構
然後給出代數結構的圖論表示
然後說明這個代數結構中的運算律如何對應於
它的圖論表示的圖的性質
也就是說這個性質很像是運算律''

>< 現在一件很明瞭的事就是
我必須傾儘自己的全力寫一個有向圖處理語言
這簡直太重要了

** >< see and acting
*** fixed point theorem
∀F∈Λ ∃X∈Λ : FX == X
``對每一個函數F都可以構造出它的不動點X''
這當然可以被理解成一個方程了
這樣的對這個方程的可解性的敘述
形成了傳統數學形式語言中的一個命題
但是理解這些需要記號``ͱ''嗎?
先看下面對這個命題的證明再說:
HEURSITIC:
X == FFFFF...(無窮個F作用於自身)
這種東西顯然滿足所給出的方程
F(X) == F(FFFFF...)
== FFFFF... == X
但是這種東西在語法上是不合法的
因此我們定義F*
而F*是那種作用於自身一次就能額外的在外面獲得一個F的那種term
也就是說:F*F* == F(F*F*)
可以說F*對自身的作用就是在形成潛在的FFFFF...
DEFINE:
+ 如何理解這種定義呢?
  這種定義是在另一個變量名的空間找一些名字
  來幫助我們描述我們想描述的東西
F* :== λx.F(xx)
X :== F*F*
然後驗證X就是所求的term:
X == F*F* == λx.F(xx) λx.F(xx)
== F(λx.F(xx) λx.F(xx))
== F(F*F*)
== FX
*** Y combinator
對上面的定理的解法(給出F而構造X的方法)
的抽象(λ-abstraction)
就讓我們得到了Y combinator
∀F∈Λ : F(YF) == YF
只要把term: λx.F(xx) λx.F(xx)中的F
用λ-abstraction抽象出來就行了:
Y == λf.(λx.f(xx) λx.f(xx))
== λfx.f(xx)(λx.f(xx))
*** 關於方程
``λ-cal as a formal theory of equations between λ-terms''
如果我接受∀F∈Λ ∃X∈Λ : FX == X
這種描述方程的方式
那麼我就理解了那句話中的``方程''這個詞的意思

∀F∈Λ ∃X∈Λ : FX == X是謂詞邏輯中的一個邏輯命題
對這個命題的陳述同時還使用了集合論中的概念
這個命題的語義是方程的可解性
其中量詞所引入的F與X都是約束變元

那麼是不是量詞以某種方式給出一些約束變元
然後我用等詞形成這些約束變元之間的等式
這樣所形成的謂詞演算中的邏輯命題就是
一個關於這個等式所對應的方程的可解性的命題
+ 代數就在於方程
  而方程就在於變元的使用
  所以這是當然的
+ 因此我想反過來說更好:
  我先用一些自由變元與等詞形成一個等式
  + 但是這裏變元的類型與等詞的類型都是有待明確的
  然後我在這個等式前面添加量詞
  量詞是擴展了的量詞 即 集合論的語法糖
  當添加適當的量詞 而形成了一個命題時
  我就得到了一個關於
  開始的那個等式的一個方程的可解性的命題

我是通過構造一個解來證明這個命題的
這種構造之所以能形成對這個命題的證明
是因爲我隱含地使用了謂詞演算中的推理規則
現在我試圖把我隱含使用的東西明顯地寫出來
首先∀F∈Λ ∃X∈Λ : FX == X
是(∀F (F∈Λ → ∃X (X∈Λ ∧ (FX == X))))
的語法糖
然後我就不想往下寫了
因爲從這裏就可以看出
一階邏輯與集合論所組成的混雜語
是很不好的 幾乎沒有可用性的形式語言
語法和語義是脫節的
可以用一些抽象層次把這種脫節的現象消除
+ >< 也許在實際對形式語言的應用中
  一個人可以總結出來這樣的一種
  用來彌補脫節現象的形式語言塔

現在我就理解了那句話了
因爲任何一個數學理論
都是一個關於方程的形式理論
只不過 形成方程不一定是等詞而已

並且我還知道了對於任何一個關於方程的理論
重要的是要能``熟練的對等式作恆等形變''
比如``移項''之類的操作
也就是說要``熟悉這種語言的語義''
*** corollary
∀C == C[f,x] ∈Λ
+ 這個等式是對可能存在的依賴關係的明確聲明
  可見等號這個東西是被相當可怕地濫用了的
∃F∈Λ ∀X∈Λ : FX == C[F,X]
+ where C[F,X] == C[f:=F][x:=X]
現在爲了證明這裏給出的方程的可解性
需要構造的是F了 下面給出典型的解法:
+ 根據F所需要滿足的性質來向後計算
+ 熟練的對等式作恆等形變
+ 首先這個解法是以不動點方程的求解公式爲基礎的
  就像解某些代數方程時
  人們可以以二次方程的求根公式爲基礎
  將需要求解的方程轉化爲二次方程
∀X∈Λ : FX == C[F,X]
<== Fx == C[F,x]
<== F == λx.C[F,x]
<== F == (λf.λx.C[f,x])F
+ 上面這步已經化歸成功了
<== F == Y(λf.λx.C[f,x])

APPLICATION:
1. 求F 使得對任意X 有:
   FX == XF
   + 存在和任意X都交換的term T
   此時: C[F,X] == XF
   再寫一遍求解過程作爲練習:
   ∀X : FX == XF
   <== Fx == xF
   <== F == λx.xF
   <== F == (λf.λx.xf)F
   <== F == Y(λf.λx.xf)
2. 求G 使得對任意X,Z 有:
   GXZ == ZG(ZXG)
   + 類似於前面那個一元的交換性
   此時: C[G,X,Z] == ZG(ZXG)
   再寫一遍求解過程作爲練習:
   ∀X,Z : (GX)Z == ZG(ZXG)
   <== (Gx)z == zG(zxG)
   <== G == λx.λz.zG(zxG)
   <== G == (λx.λz.zg(zxg))G
   <== G == Y(λx.λz.zg(zxg))

** >< normalization
一個λ-term可以形成這樣一個邊標記的有向圖
用來標記有向邊的是β-redex
如何形成這個有向圖是顯然的
+ λ-term M 對應的有向圖被記爲DG-β(M)
  被稱爲reduction graph
church-rosser theorem的證明就被歸結爲
對這種單個λ-term所形成的有向圖的性質的證明

*** strongly normalizing
如果DG-β(M)是有窮的
then M is called strongly normalizing

1. DG-β(M)中的兩條路就是
   對M的兩種rewrite方式
   如church-rosser theorem的證明過程所展示的那樣
   兩條路可以用來交織成一個網
   所以每條路就像是有限圖的一個``維度''
   但是兩條路所交織成的一個網
   的幾何結構
   又比平面上整數形成的晶格複雜的多
2. 有可能沿一個維度圖DG-β(M)是有限的
   + M以這種方式rewrite可以找到β-nf
   而沿另一個維度DG-β(M)是無窮的
   所以M是strongly normalizing
   它就一定有β-nf
   但是就算它有β-nf
   它也不一定是strongly normalizing
*** >< leftmost reduction strategy is normalizing
for a proof see:
barendregt[1984],THEOREM:13.2.2
** >< bohm trees and approximation
``bohm trees  is a kind of infinite normal form''
*** lemma
every term in Λ
matchs one of the following two patterns
or another:
1. λx1...xn.yN1...Nm
   + where n,m>=0
     pattern-var y matchs var
     + free or non-free both matched by y
     pattern-var Ni matchs term
2. λx1...xn.(λy.N0)N1...Nm
   + where n>=0, m>=1
就集合Λ的歸納定義證明
*** 一些輔助定義
**** head normal form (hnf)
M is called a head normal form
if M matchs
λx1...xn.yN1...Nm
+ where n,m>=0
which must be an λ-abstraction
例:
ac(bc) is a hnf
bc is a hnf
λabc.ac(bc) is a hnf

and the variable matched by y
is called the head variable of M
**** M has a hnf if M =β= N ∧ N is a hnf
**** head redex
if M matchs
λx1...xn.(λy.N0)N1...Nm
+ where n>=0, m>=1
then (λy.N0)N1 is called the head redex of M
*** some property of tree
1. as partially ordered set
2. there is a root
3. each node(point,joint) has
   finitely many direct successors
4. the set of predecessors of a node
   is finite and is linearly ordered
*** >< bohm tree of term M
notation BT(M)
**** >< lemma
**** BT(M) is well defined and
M =β= N
--------
BT(M) = BT(N)
* >< the system λ->curry (systems of type assigment)
** note about ``ͱ''
推理規則定義表達式的集合
並且給出以這些表達式爲節點
以推理規則爲有向邊的無窮有向圖

上面的type-free λ-cal中的推理規則並不包含``ͱ''
而下面的推理規則包含``ͱ''

此時爲了好的理解還是要去形成圖論的語義
首先要知道
在逐層地構建一個形式語言時
圖的節點一次次地在變化
每次圖的節點都是上次的圖

下面的推理規則所給出的圖的節點是包含``ͱ''的表達式
type-free λ-cal中的推理規則
可以用來處理下面的表達式的``ͱ''的前半部分或後半部分
但是不觸及``ͱ''本身

設計一個以``ͱ''爲核心的語法層次
是爲了做局部的(臨時的)假設
+ 語法上
  假設寫在``ͱ''的前面
  作爲context的內容
也就是爲了在證明的過程中使用``反證法''和``歸納法''等技術

有一些推理規則只不過是在給命題作``恆等變形''
也許是在爲另一些推理規則的使用做準本
+ type-free λ-cal中不觸及``ͱ''的推理規則都是如此
  除此之外還有一些觸及``ͱ''的推理規則也是如此
而另一些推理規則才真正是在``推理''
這裏``恆等變形''值得深入討論
首先這個概念在代數化的看待問題上很有幫助
因爲恆等變形是解任何方程的手段
並且在這裏這個概念就更有意思
因爲有時恆等變形類的推理規則提供的是
同一個語義在不同語法層面上的轉化
明顯地提出這種轉化是否能爲理解這一切提供一個代數的視角??

增加假設 減少結論 會讓ͱ節點變弱
減少假設 增加結論 會讓ͱ節點變強
把ͱ寫成橫線``--------''或者``========''時
ͱ節點就像是分數一樣
可以形成一個正比例函數和一個反比例函數
從代數的角度看
數學論證就是在對這種ͱ節點作恆等變形
如果統一用有向圖來理解代數
那麼這種相似性就是自然的了

** inductive definition of the set of exp
tvar ::= α | tvar'
type ::= tvar | (tvar -> tvar)
the set of all types is denoted by T

var ::= v | var'
term ::= var | (term term) | (λ var . term)
the set of all terms is denoted by Λ
** notations
one writes
ͱ M:σ
to assign type σ∈T to term M∈Λ

1. M is called a *subject*
2. M:σ is called a *statement*
3. as a special statement
   x:σ is called a *declaration*
4. a *basis* is a set of declaration
   with distinct variables as subject

``ͱ'' pronounced ``yields''
the thing on the left-side of ͱ
is called *context*
the thing on the right-side of ͱ
is called *conclusion*
** type assigment
*** inference-rules
a statement M:σ is derivable from a basis Γ
denoted: Γ ͱ M:σ
if Γ ͱ M:σ can be inferenced by the following inference-rules:

+ where the basis Γ is locally presupposed

(x:σ)∈Γ
--------- (axiom)
Γ ͱ x:σ
+ 這個引入表明瞭類型指定可以在局部任意引進
  而下面的``->introduction''
  會把context中臨時引入的類型指定消除

Γ,x:σ ͱ M:τ
------------------- (->introduction)
Γ ͱ (λx.M):(σ->τ)
+ 假設(context)中的類型指定x:σ
  會在這個引入規則中被消除

Γ ͱ M:(σ->τ)
Γ ͱ N:σ
--------------- (->elimination)
Γ ͱ (MN):τ

*** 如果從圖論的角度來理解這種類型系統
那麼節點是帶有``ͱ''的表達式更高一層次的表達式
+ 前面的type-free λ-cal中圖graph(Λ;-sβ->)的節點
  可以看做是省略了``ͱ''的表達式
  因爲在那裏對推理規則的描述還不需要``ͱ''這個記號
基本的``類後繼關係''就來源於上面的兩個推理規則
這就像是在indude-tree(Λ; ∈term-intro1, ∈term-intro2)中的
所有變元節點上釋放一些相同或不同小精靈
沿着有向樹的有向邊旅行時
這些小精靈會按它們路過的有向邊的類型
而在道路的交匯之處於其它的小精靈按規則結成夥伴
+ 上面的推理規則並不能給所有的term附上類型
  比如x:σ,y:τ並不能給出xy的類型
  這是因爲作者簡化了推理規則嗎?

*** 如果我強調λ-abstraction中的約束變元的非本質性
即如果我用有向圖來描述λ-abstraction
那麼
Γ,x:σ ͱ M:τ
------------------- (->introduction)
Γ ͱ (λx.M):(σ->τ)

就需要被改寫爲:
Γ ͱ M:τ
x∈var
σ∈tvar
------------------------------------------ (->introduction)
Γ ͱ (λ:σ.M[free:x := (* --> λ)]) : (σ->τ)
+ 也就是說釋放小精靈的過程也是非本質的
  或者說type assigment的性質基本上就是
  indude-tree(Λ;(∈term introduction1),(∈term introduction2))
  的性質
上面的改寫其實是不對的
因爲它丟失了ͱ的語義

*** examples
1. ͱ (λx.x):(σ->σ)

   ----------- (axiom)
   x:σ ͱ x:σ
   ---------------- (->introduction)
   ͱ (λx.x):(σ->σ)

2. y:σ ͱ (λx.x)y:σ

   ----------- (axiom)
   x:σ ͱ x:σ
   ---------------- (->introduction)
   ͱ (λx.x):(σ->σ)


   --------------------------------- (axiom)
   y:σ ͱ y:σ

   y:σ ͱ (λx.x):(σ->σ)
   y:σ ͱ y:σ
   --------------------------------- (->elimination)
   y:σ ͱ (λx.x)y:σ

*** 這裏我就是在手動實現一個機器輔助證明系統了
都是關於推導規則的
推導規則使用就相當於是在惰性求值一個有向圖
而且 特殊地 這裏的有向圖是一棵有向樹(推理樹)

在實現一個機器輔助證明系統時
在需要的時候一個人可以用show函數之類的東西
打印出易於閱讀的現在的樹是什麼
人機的交流過程 就是單純的對這個樹的操作
推理樹以及其它的底層東西的存儲就是實現者需要設計的了

*** 用對又向圖的操作來理解我使用這個輔助證明系統的方式過程
**** 首先要知道節點是什麼
節點是被``ͱ''連接的東西
``ͱ''的前面是第二層次的若干個表達式的列表
``ͱ''的後面是一個第二層次的表達式

因此節點是第三層次的表達式

要知道``ͱ''的使用是爲了使用複雜的證明技術

**** 基本操作有兩個
1. 引入新節點

2. 根據推理規則i
   從已有的若干個節點:x1,x2,...(在任何位置都行)
   構造一個新的節點:y
   在圖中增添有向邊:
   x1-->y, x2-->y, ...
   也許所有這些有向邊還應該用
   推理規則i的這次使用標記
   + 標記 即是 邊到推理規則的某此使用的映射
   + 注意:
     同一個推理規則的每次使用都是需要被區分的

3. 其實是
   一個無窮的有向圖已經在哪裏了
   我只需要去惰性求值出它的一部分

**** 這樣對每個形式理論的學習就是
1. 對每個具體的推理規則的實現方式的學習
2. 對每個具體的引入節點的規則的實現方式的學習
   比如按規則對
   λx.F(xx) λx.F(xx) =β= F(λx.F(xx) λx.F(xx))
   的肯定
   就是一次對節點的引入

3. 還有對更底層的東西學習
   比如是用:
   + 線性的字符串
   + 有限有向圖
   + 其它的更複雜的數據結構
   來作爲最基本的(或者是某個層次的)表達式

**** 一些哲學話題
1. 什麼數據結構是被形式主義所允許的呢?
   如果只是``線性的字符串''那就太狹隘了
   我想``有限有向圖''是不錯的基礎
   就用機器來實現形式理論而言
   它們二者的基本性是相當的
   對它們的使用
   都可以被理解爲是一個小孩在拿一些積木
   自顧自地做遊戲

2. 應該如何認識一個人可以在這裏所作的選擇呢?
   對於人機的互動而言
   ``線性的字符串''是不可避免的
   或者說只有``線性的字符串''纔是方便的
   但是就人類的理解而言它們又是不方便的

3. 可能對於人了理解來說三維的連續模型是最容易理解的
   對於四維模型人類就無法形成恰當的想像了
   而在一二三維中維數越高越好
   而對於機器來說一維的離散模型是最容易實現的

** >< pragmatics of constants
這個標題讓人想到關於命名系統的問題
除了單純地用λ-abstraction寫出函數然後進行作用之外
一個良好的命名系統對於實現具有可用性的
機器輔助證明系統來說是非常重要的
因此對形式理論來說也是重要的
+ 這裏可以發現一個要點
  那就是
  對於一個邏輯學的研究者或者學習者而言
  時刻把實現一個機器輔助證明系統
  當做目標
  是非常有宜的
  這個機器輔助證明系統也許並不是研究的終極目的
  但是對``實現''的熱切渴望
  使得人對理論的理解上容不得半點兒的馬虎
  這當然是好的
  一個明確的目標把人變勤奮了
但是作者想要在這個標題下介紹的是這個問題嗎?

其實
constants的使用在於在不違背形式主義精神的前提下
增加第一層次表達式的可讀性
否則的話
var只能是:
v
v'
v''
v'''
v''''
這些東西被當做基本的``字符''了
但是顯然用這些字符構造起來的表達式沒有什麼可讀性
constants的使用就是說
人可以隨時以具有較強可讀性的方式引入新的基本``字符''
比如:
+ type-constant:
  nat
+ term-constant:
  0:nat
  suc:(nat->nat)
這些常量不能作爲約束變元在推理規則中使用
使用了其實也沒關係
因爲反正它們都變成約束變元了 只有局部意義
但是這樣會減弱可讀性 這就與引入常量的初衷相悖了

``ML is essentially λ->curry
extended with a constant Y
and type-assignment Y:((σ->σ)->σ) for all σ''
** >< λ->curry的性質
*** 首先定義一個作用於basis的函數:dom
let basis Γ :== {x1:σ1,x2:σ2,...,xn:σn}
+ 也就是說使用記號:==來做命名
  關於命名系統還需要更細緻地討論
DEFINE:
dom(Γ) == {x1,x2,...,xn}
+ 上面這個定義被理解爲對字符串
  (更好地應該說 字符串的列表)的操作
  就像substitution這種東西差不多
  但是這裏顯然是在濫用等號了
DEFINE:
Γ(xi) == σi
Γ as a partial function
這裏類型已經亂了
應該定義
proj(Γ xi) == σi
而把Γ(xi)當做proj(Γ xi)的語法糖
+ 但是不理論如何
  這裏都和上面的函數一樣涉及到了濫用等號的問題
let V0 be a set of variables
DEFINE:
Γ↾V0 == {x:σ | x∈V0 ∧ σ == Γ(x)}
這個東西類似於proj(Γ xi)在
第二個自變元的集合上的重載
但是又有區別
+ 如何形式化地理解這裏這些亂七八雜的定義
DEFINE:
σ[α:=τ]
也就是把文本中出現的類型也定義substitution
這就又真真正正是一個字符串的操作了
*** basis lemma for λ->curry
let Γ be a basis
1. if:
   Γ'⊃Γ
   then:
   Γ ͱ M:σ
   --------
   Γ' ͱ M:σ

   這是推理規則嗎?
   如果是 那麼推理規則就不光可以被先驗地引進
   並且還可以被證明 !!!
   所以這一定不是推理規則吧 !!!
   一定不是
   因爲這裏涉及到了集合論裏的東西
   如何排除這些東西呢?
   排除了它們之後還能作證明嗎?
   不排除它們的時候證明是如何被完成的呢?
   我想純粹的形式主義所構建的形式體系
   至少一定是在集合論的語法之外的
   因爲集合論的語法是
   一階邏輯這種形式語言中的一個形式理論
   既然那裏(構建集合論的形式理論時)可以排除集合論的語法
   那麼這裏爲什麼不行呢?
   畢竟如果不排除它們的話類型就又亂了
   即 我所使用的各種形式語言就交織在一起了
   這也許是合法的
   但是這對於理解而言是不宜的

   也許排除集合論的概唸的方式就是把這裏的集合
   理解爲表達式的有序列表(或許應該遺忘列表的有序性)
   這個列表被維持成其中的表達式不相互重複的狀態

2. Γ ͱ M:σ
   --------
   FV(M)⊂dom(Γ)

   這個引理是關於
   對自由變元的類型指定的引入的

3. Γ ͱ M:σ
   --------
   Γ↾FV(M) ͱ M:σ

   這個引理是關於
   在context中消除對
   引入自由變元的類型聲明沒有貢獻的項的

PROOF:
by induction on the derivation of M:σ
也就是就推理規則對Γ ͱ x:σ之類的斷言的引入方式
+ 即 引入這第三層次表達式的方式
  或推理規則對這第三層次的表達式的歸納定義

(x:σ)∈Γ
--------- (axiom)
Γ ͱ x:σ

Γ,x:σ ͱ M:τ
------------------- (->introduction)
Γ ͱ (λx.M):(σ->τ)

Γ ͱ M:(σ->τ)    Γ ͱ N:σ
-------------------------- (->elimination)
Γ ͱ (MN):τ

1. 下面的分類是按Γ ͱ M:σ被推理規則生成的方式來分的
   Γ ͱ M:σ作爲有向圖中的一個節點
   它被添加入有向圖中的方式只有三種
   1) (axiom)
      這是顯然的
      具體的實現設計到對列表Γ的處理
   2) (->introduction)
      已知Γ ͱ M:σ形如Γ ͱ (λx.M):(σ->τ)
      + 這個``已知''顯然是通過一個模式匹配來實現的
      是被Γ,x:σ ͱ M:τ引入的
      在Γ'⊃Γ的前提下
      引入節點Γ',x:σ ͱ M:τ
      + 這裏需要Γ',x:σ還是一個basis
        即它還表示着一個集合
        即作爲列表的表達式其中的表達式不重複
        即需要x:σ不在Γ'中
        (或者是x不在dom(Γ')中???)
      然後就可以引入節點Γ' ͱ (λx.M):(σ->τ)
   3) (->elimination)
      已知Γ ͱ M:σ形如Γ ͱ (MN):τ
      是被Γ ͱ M:(σ->τ)    Γ ͱ N:σ引入的
      在Γ'⊃Γ的前提下
      用集合論中的推理規則(在這裏被實現爲列表處理)
      引入節點Γ' ͱ M:(σ->τ)    Γ' ͱ N:σ
      然後就可以引入節點Γ' ͱ (MN):τ

      現在總結一下這上面的證明是在作什麼
      首先術語上這些命題被某些作者稱爲是``元語言''中的命題
      ``元語言''是就人的理解方式而言
      具有根本性的東西
      我想這裏的:
      ``字符串處理''
      ``列表處理''
      ``有窮有向圖處理''
      其根本性就在於它們能夠用機器來方便的實現
      或者說其中的基本關係能夠用機器來方便的實現
      比如說對``字符串處理''而言的等詞``==''
      對``列表處理''而言的``∈''
      >< 對``有窮有向圖處理''而言有什麼呢???
2. 類似於1.
3. 類似於1.

我需要這些元語言中的命題
這在於
數學的特點就在於
我去用``證明''的形式對我所觀察與思考的東西
形成一些``一般性的''論斷
+ 這裏就用機器實現而言
  論斷的一般性就在於模式匹配
即 數學是一種想要儘可能一般地描述
人們通過觀察所總結到的規律的語言(或行爲)
而 這種對一般性的追求
可能是人們爲了使人們自己能對所觀察到的東西
形成更``經濟的''理解
或者說``更好的''理解

*** generation lemma for λ->curry
1. Γ ͱ x:σ
   ----------
   (x:σ)∈Γ

2. Γ ͱ MN:τ
   ---------------
   ∃σ(Γ ͱ M:(σ->τ) ∧ Γ ͱ N:σ)

   這個命題其實是說
   有向圖中的每個可以模式匹配到Γ ͱ MN:τ的節點
   在圖中都有模式匹配到Γ ͱ M:(σ->τ)與Γ ͱ N:σ的
   直接父節點
   這就像我說:``我坐在地上玩積木
   我一個一個地把積木摞起來
   那麼要麼最上面的積木的下面一定存在一個積木
   要麼最上面的積木的下面就是地面''
   難道我需要形成一個一階邏輯中的命題來描述這個事實嗎?
   用謂詞演算中的命題來描述這個事實
   反而模糊了這個事實
   這就是有窮有向圖的``本源性''

   這裏用到了謂詞演算
   而且連詞是寫在``ͱ''類的表達式之間的
   這下又不清楚了
   >< 可能我必須先重新構造起來一階邏輯的形式體系
   然後才能作我希望作的討論???
   這是不可能的!!!
   因爲這些討論的目的就是爲了脫離一階邏輯的形式體系
   而建立新的形式體系

3. Γ ͱ λx.M:ρ
   ---------------
   ∃σ,τ(Γ,x:σ ͱ M:τ ∧ ρ == (σ->τ))

   這個迂腐的命題和上面的命題一樣值得被批判
*** >< typability of subterms in λ->curry

*** >< substitution lemma for λ->curry
1.
2.
*** >< subject reduction theorem for λ->curry
the subset of Λ that
having a certain type in λ→
is closed under reduction
* >< the system λ->church
** inductive definition of the set of exp
tvar ::= α | tvar'
type ::= tvar | (tvar -> tvar)
var ::= v | var'
term ::= var | (term term) | (λ var:type . term)

church system與curry system的區別就是
對於church system來說所有的term的集合
的歸納定義變了

** inference-rules
(x:σ)∈Γ
--------- axiom
Γ ͱ x:σ
+ 集合可以看成是有序列表

Γ,x:σ ͱ M:τ
---------------------- ->introduction
Γ ͱ (λx:σ.M):(σ->τ)
+ 這裏是唯一與curry system不同的地方

Γ ͱ M:(σ->τ)
Γ ͱ N:σ
-------------------------- ->elimination
Γ ͱ (MN):τ

** ><>< 從圖論的角度理解上面的推理規則所形成的形式理論
** >< 類型的加入
把類型作爲term的組成部分之後
理論如何變得複雜了?
首先
約束變元是帶類型的
這樣變元的數量就成了一個笛卡爾積嗎?

** >< -sβ->
DEFINE:
(λx:σ.M)N -sβ-> M[x:=N]
如果這裏對N:σ沒有要求
那麼對於-sβ->來說
``(λx:σ.M)''中的``:σ''就成了虛置的部分
因爲在實際用對字符串的操作實現-sβ->時
根本用不到``:σ''
如果``:σ''不是用來限制N:σ的
那麼它還有什麼用呢?

** >< basis lemma for λ->church
let Γ be a basis
+ 即一些先驗的變元對類型的屬於關係的列表

1. if:
   Γ'⊃Γ
   then:
   Γ ͱ M:σ
   --------
   Γ' ͱ M:σ

2. Γ ͱ M:σ
   --------
   FV(M)⊂dom(Γ)

3. >< Γ ͱ M:σ
   --------

** >< original version of λ->
如果寫成:
λx:σ.x:τ
λx:σ.x:τ : σ->τ
那麼:
(λx:σ.x:τ)N:σ -sβ-> ???
N:σ ???
N:τ ???
都不對

實際上所使用的是:
x:σ ͱ x:σ
----------
ͱ (λx:σ.x):(σ->σ)

(λx:σ.x:τ)這種項是不會被引入的

** >< λ-cube

* >< 用一個遺忘函子來把church轉化成curry (即從範疇論的角度來理解)
遺忘函子就是簡單地把所有對約束變元的類型聲明都刪除

* >< classical logic formal language
** note
在學習了這麼多形式語言之後
也許改回顧最初所學習的形式語言
既然我已經有了去對比各種語言之間的差異的能力
那麼我對classical logic formal language的理解一定也可以變得更深刻了

而且對於理解propositions as types來說
經典數理邏輯的知識是必要的

** 回到<<元數學導論>>
模型的方法起初是爲了證明公理的無矛盾性
而且模型的概念具有相對性
這在我想要使用有向圖爲基礎來建立其它形式語言的過程中也可以看出來
因爲我必須還要有一個語言能夠描述有向圖的一般性質
這種對一般性質的描述必然又用到一個形式語言

** 在傳統的以集合論爲中心的數學的形式化基礎中
人們把某些命題當做證明的目的 即結論
來探索對這些結論的論證
人們希望論證的作爲結論的命題有什麼樣的形式?
我想共同點在於它們都是對一些關係的判斷
而關係是定義於集合的
這樣整個形式體系就是以集合論爲中心的
** >< logic of statements recovered via curry-howard
傳統的謂詞演算由curry-howard
在類型論中重新實現 ???

* lecture-by-henk
** readings
#+begin_src emacs-lisp
(eshell-command "ranger ~/learning/lambda-cal/lecture-by-henk/")
#+end_src
[[shell:xpdf ~/learning/lambda-cal/lecture-by-henk/typed-lambda-calculus/readings/introduction-to-type-theory.pdf &][introduction-to-type-theory]]
[[shell:xpdf ~/learning/lambda-cal/lecture-by-henk/typed-lambda-calculus/readings/logical-verification-course-notes.pdf &][logical-verification-course-notes]]
[[shell:xpdf ~/learning/lambda-cal/lecture-by-henk/typed-lambda-calculus/readings/lambda-calculus-with-types.pdf &][lambda-calculus-with-types]]

** type-free-λ-cal
*** symbol
給出兩個symbol
人們可以區分它們是相等還是不相等
這是一個先驗的假設
*** alphabet
一個symbol的有限集合
*** word
只與alphabet有關
*** language
歸納定義一個word組成的集合
然後稱這個集閤中的元素爲formula或expression
formula于歸納定義的方式有關
常用的進行歸納定義的方法是grammar

>< 我想expression的集合可以是有向圖
*** theory
language的子集
根語義有關
*** combinatory logic(CL)作爲一個形式理論
**** alphabet
ΣCL = {I, K, S, x, ', ), (, =}
**** language
constant := I | K | S

variable := x | variable'

term := constant | variable | (term term)

formula := term =β= term
+ 上面這個應該不出現在這裏
  因爲就我的理解而言它們應該屬於第二層次的exp
**** 模式匹配對=β=的引入
***** note
沒有(λx.M)N =β= M[x:= N]
就是說這個形式理論中
有λ-application
但是沒有λ-abstraction
***** 於ISK有關的
即把第二層次的exp的作爲節點引入一個有向圖(一個推理場景)
+ >< 這個課程想把所有λ-term都編譯到ISK嗎???

in the following P,Q,R are pattern-vars

----------(I-axiom)
IP =β= P

-----------(K-axiom)
KPQ =β= P

----------------(S-axiom)
SPQR =β= PR(QR)

***** 其它引入=β=的推理規則

in the following P,Q,R are pattern-vars

--------------(axiom)
P =β= P

P =β= Q
--------(交換性)
Q =β= P

P =β= Q
Q =β= R
------------(傳遞性)
P =β= R

下面的兩個在一起就等價於
=β=與集合language的遞歸定義的相容性

P =β= Q
-----------
PR =β= QR

P =β= Q
-----------
RP =β= RQ

**** >< cool examples
***** >< doubling
下面的等號代表命名
D :== SII

------------
Dx =β= xx
***** >< composition
***** >< self-doubling, life!
*** >< representing algebraic functions in CL
*** λ-cal作爲一個形式理論
**** alphabet
Σ = {x, ', (, ), λ, =}
**** language
variable := x | variable'
term := variable | (term term) | (λ variable term)
formula := term =β= term
***** 主要的引入=β=的模式匹配
模式匹配用下面的等式來表達
DEFINE:
(λx.M)N =β= M[x:= N]

如果M,N在上面的公式所表達的模式匹配下匹配成功
---------------------------------------------
M =β= N
***** 其它引入=β=的推理規則
in the following M,N,L are pattern-vars

--------------(axiom)
M =β= M

M =β= N
--------(交換性)
N =β= M

M =β= N
N =β= L
------------(傳遞性)
M =β= L

下面的兩個在一起就等價於
=β=與集合language的遞歸定義的相容性

M =β= N
-----------
ML =β= NL
LM =β= LN

M =β= N
--------------
λx.M =β= λx.N
**** bureaucracy
***** substitution
| M       | M[x:=N]            |
|---------+--------------------|
| x       | N                  |
| y(=/=x) | y                  |
| PQ      | (P[x:=N])(Q[x:=N]) |
| λx.P    | λx.P               |
| λy.P    | λy.(P[x:=N])       |
***** variable convention
assume that the bound and free variables in a situation differ

在用字符串來實現λ-cal這個形式語言時
在一個term中如果需要的話總是重命名約束變元
使得它們不與term中出現的其它任何自由變元相同
這樣在進行substitution的時候就不用考慮那麼多了

***** The set of free (bound) variables of M , notation FV(M ) (resp. BV(M ))
****** FV
FV(x) = {x}
FV(MN) = FV(M)∪FV(N)
FV(λx.M) = FV(M)\{x}
****** BV
BV(x) = ∅
BV(MN) = BV(M)∪BV(N)
BV(λx.M) = BV(M)∪{x}
**** =η=
λx.Mx -sη-> M
*** exercises
**** in-class problems
***** PROBLEM3:
****** (a)
π :== λxyf.fxy
<M, N> :== π MN
+ it ``packages'' two λ-terms in one single λ-term
  這是一個笛卡爾積的模型
show that there are π1, π2 ∈ λ such that:
π1 <M, N> -β-> M
π2 <M, N> -β-> N

SHOW:

+ 下面出現的那些外在定義的的東西
  應該和理論中的term用=α=相連嗎?
<M, N> =α= λxyf.fxy M N -ssβ-> λf.fMN
有:
(λf.fMN)L -sβ-> LMN
所以:
L :== λxy.x
LMN -ssβ-> M

L :== λxy.y
LMN -ssβ-> N

所以:
π1 :== (λpl.pl)(λxy.x)
π1 <M, N> -sβ-> (λl.(λf.fMN)l)(λxy.x)
-sβ-> (λf.fMN)(λxy.x) -sβ-> (λxy.x)MN -ssβ-> M

π2 :== λpl.lp(λxy.y)
π2 <M, N> -sβ-> (λl.(λf.fMN)l)(λxy.y)
-sβ-> (λf.fMN)(λxy.y) -sβ-> (λxy.y)MN -ssβ-> N

END-OF-THE-SHOW.

****** (b)
show that for F,G∈Λ there exists F^,G*∈Λ such that
F^ <x, y> -β-> F xy
G* xy -β-> G <x, y>

show that there are T-curry,T-uncurry∈Λ such that
+ 即求一個同構變換
T-uncurry F -β-> F^
T-curry G -β-> G*

SHOW:

F xy
<-sβ- (λf.fxy)F
=α= <x, y> F
<-sβ- (λp.pF) <x, y>
so:
F^ :== (λp.pF)
so:
T-uncurry :== (λf.(λp.pf)) =sugar= (λfp.pf)

G <x, y>
=α= G(λf.fxy)
<-sβ- (λxy.G(λf.fxy)) xy
so:
G* :== (λxy.G(λf.fxy))
so:
T-curry :== (λg.(λxy.g(λf.fxy))) =sugar= (λgxy.g(λf.fxy))

END-OF-THE-SHOW.

****** (c)
check whether
+ 即驗證同構變換的性質
T-uncurry (T-curry f) -β-> f
T-curry (T-uncurry f) -β-> f

SHOW:

T-curry (T-uncurry f)
=α= (λgxy.g(λf.fxy)) ((λfp.pf) f)
-sβ-> (λgxy.g(λf.fxy)) (λp.pf)
-sβ-> λxy.(λp.pf)(λf'.f'xy)
-sβ-> λxy.(λf'.f'xy)f
-sβ-> λxy.fxy
就作用於MN而言f與λxy.fxy相同
=η= f
但是T-uncurry (T-curry f) -β-> f其實是不成立的

T-uncurry (T-curry f)
=α= (λfp.pf) ((λg.(λxy.g(λf.fxy))) f)
-sβ-> λp.p((λgxy.g(λf.fxy)) f)
-sβ-> λp.p(λxy.f(λf'.f'xy))
就作用與<M,N>而言f與λp.p(λxy.f(λf'.f'xy))相同
因爲:
λp.p(λxy.f(λf'.f'xy)) <M,N>
-sβ-> (λc.cMN) (λxy.f(λf'.f'xy))
-sβ-> (λxy.f(λf'.f'xy))MN
-sβ-> f(λf'.f'MN)
=α= f <M,N>
但是T-curry (T-uncurry f) -β-> f其實是不成立的

END-OF-THE-SHOW.

從這個習題可以看出類型系統的必要性
沒有類型系統就不能良好地去描述同構於同態

**** >< take-home problems
*** >< lazy-ski (compiler from lambda calculus to ``lazy-combinators'')
*need pmatch.scm*
#+begin_src scheme :result value :session *scheme* :scheme ikarus
(define occur-free?
  (lambda (y exp)
    (pmatch exp
      [`,x
       (guard (symbol? x))
       (eq? y x)]
      [`(lambda (,x) ,e) (and (not (eq? y x)) (occur-free? y e))]
      [`(,rator ,rand) (or (occur-free? y rator) (occur-free? y rand))])))

(define value?
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) #t]
      [`(lambda (,x) ,e) #t]
      [`(,rator ,rand) #f])))

(define app? (lambda (x) (not (value? x))))

(define term-length
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) 0]
      [`(lambda (,x) ,e) (+ 1 (term-length e))]
      [`(,rator ,rand) (+ 1 (term-length rator) (term-length rand))])))

;; call-by-name compiler to S, K, I
(define compile
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) x]
      [`(,M ,N) `(,(compile M) ,(compile N))]
      [`(lambda (,x) (,M ,y))
       (guard (eq? x y) (not (occur-free? x M))) (compile M)]
      [`(lambda (,x) ,y) (guard (eq? x y)) `I]
      [`(lambda (,x) (,M ,N)) (guard (or (occur-free? x M) (occur-free? x N)))
       `((S ,(compile `(lambda (,x) ,M))) ,(compile `(lambda (,x) ,N)))]
      [`(lambda (,x) ,M) (guard (not (occur-free? x M))) `(K ,(compile M))]
      [`(lambda (,x) ,M) (guard (occur-free? x M))
       (compile `(lambda (,x) ,(compile M)))])))

;; call-by-name compiler to S, K, I, B, C
(define compile-bc
  (lambda (exp)
    (pmatch exp
      [`,x (guard (symbol? x)) x]
      [`(,M ,N) `(,(compile-bc M) ,(compile-bc N))]
      [`(lambda (,x) ,y) (guard (eq? x y)) `I]
      [`(lambda (,x) (,M ,y))
       (guard (eq? x y) (not (occur-free? x M))) (compile-bc M)]
      [`(lambda (,x) (,M ,N)) (guard (and (not (occur-free? x M)) (occur-free? x N)))
       `((B ,(compile-bc M)) ,(compile-bc `(lambda (,x) ,N)))]
      [`(lambda (,x) (,M ,N)) (guard (and (occur-free? x M) (not (occur-free? x N))))
       `((C ,(compile-bc `(lambda (,x) ,M))) ,(compile-bc N))]
      [`(lambda (,x) (,M ,N)) (guard (or (occur-free? x M) (occur-free? x N)))
       `((S ,(compile-bc `(lambda (,x) ,M))) ,(compile-bc `(lambda (,x) ,N)))]
      [`(lambda (,x) ,M) (guard (not (occur-free? x M))) `(K ,(compile-bc M))]
      [`(lambda (,x) ,M) (guard (occur-free? x M))
       (compile-bc `(lambda (,x) ,(compile-bc M)))])))



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ski->lanbda converter
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; create gensyms
(define fv
  (let ((n -1))
    (lambda (x)
      (set! n (+ 1 n))
      (string->symbol
       (string-append (symbol->string x) "." (number->string n))))))

;; substitution with free variable capturing avoiding
(define subst
  (lambda (x y exp)
    (pmatch exp
      [`,u (guard (symbol? u)) (if (eq? u x) y u)]
      [`(lambda (,u) ,e)
       (cond
        [(eq? u x) exp]
        [(occur-free? u y)              ; possible capture, switch names
         (let* ([u* (fv u)]
                [e* (subst u u* e)])
           `(lambda (,u*) ,(subst x y e*)))]
        [else
         `(lambda (,u) ,(subst x y e))])]
      [`(,e1 ,e2) `(,(subst x y e1) ,(subst x y e2))]
      [`,exp exp])))


;; combinator definitions
(define com-table
  '((S . (lambda (f) (lambda (g) (lambda (x) ((f x) (g x))))))
    (K . (lambda (x) (lambda (y) x)))
    (I . (lambda (x) x))
    (B . (lambda (f) (lambda (g) (lambda (x) (f (g x))))))
    (C . (lambda (a) (lambda (b) (lambda (c) ((a c) b)))))))

;; substitute combinator with their lambda term definitions
(define sub-com
  (lambda (exp defs)
    (cond
     [(null? defs) exp]
     [else (sub-com (subst (caar defs) (cdar defs) exp) (cdr defs))])))

(define ski->lambda
  (lambda (exp)
    (sub-com exp com-table)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; tests
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define to-number `(lambda (n) ((n (lambda (x) (,add1 x))) 0)))

(interp `(,to-number ,(ski->lambda (compile-bc `(,!-n ,lfive)))))
;; => 120
(term-length `(,! ,lfive))
;; => 93
(term-length (compile `(,! ,lfive)))
;; => 144
(term-length (compile-bc `(,! ,lfive)))
;; => 73
#+end_src
** type-λ-cal
*** church-style
**** grammars
type:
A ::= a | (A -> A)

term:
M ::= x | (M M) | (λ x:A . M)

contexts:
Γ ::= <empty> | Γ, x:A
+ 就是一個list而已

**** note
在形成λ-abstraction的時候
有向圖中不止是要指定帶入點的位置
還需要指出允許被帶入數據的類型

相同的untype λ-abstraction
在指定了不同的類型之後就是相互不同的term了
這些term的類型當然也是不同的

因此用有向圖來實現type λ-cal時
對於λ-abstraction就需要
1. 把需要被帶入的自由變元出現的位置挑出來
   鏈接到λ上
2. 指定一個這種帶入所允許的輸入類型
   並且知道在這些自由變元屬於這個類型的條件下
   整個項的類型是什麼
   即 x:A ͱ M:B 的語義
   然後就可以得到
   ͱ (λ x:A . M) : A->B
   整個這第二點就是推理規則的語義

*** minimal logic
**** note
1. implicational logic
   i.e. only connective is ->

2. intuitionistic
   not classical
   即 推導不出下面的節點
   ͱ ((a->b)->a)->a
   + 它的語義是什麼?
     爲什麼推到不出來它就是非經典邏輯

**** grammar of formulas
A ::= a | (A -> A)
+ 與``類型''的集合的歸納定義完全相同

**** rewrite-rules
***** implication introduction
Γ, A ͱ B
----------
Γ ͱ A -> B

***** implication elimination (modus ponens)
Γ ͱ A
Γ ͱ A -> B
----------
Γ ͱ B

***** example
``if a then it holds that if b then a''
``a implies that b implies a''
a -> b -> a
== a -> (b -> a)

a, b ͱ a
------------
a ͱ b -> a
-----------------
ͱ a -> (b -> a)


in type theory:

x:a, y:b ͱ x:a
----------------------------
x:a ͱ (λ y:b . x) : b -> a
-----------------------------------------
ͱ (λ x:a . (λ y:b . x)) : a -> b -> a

***** BHK interpretation
Luitzen Egbertus Jan Brouwer
Arend Heyting
Andrey Kolmogorov

intuitionistic interpretation of logical connectives:
|-----------------+---------------------------------------|
| proof of A ∧ B  | pair of a proof of A and a proof of B |
| proof of A ∨ B  | either a proof of A or a proof of B   |
| proof of A -> B | mapping of proofs of A to proofs of B |
| proof of ¬A     | proof of A -> 上                      |
| proof of 上     | <does not exist>                      |
| proof of 下     | the unique proof of 下                |
|-----------------+---------------------------------------|
*** styles of logic
**** note
所有這些所謂邏輯風格都應該能簡潔地在grap中實現
因爲它們都是不過是對無窮有向圖的惰性求值而已

**** logic style 1: Hilbert system
***** just one proof rule: modus ponens (MP)
Γ ͱ A
Γ ͱ A -> B
----------
Γ ͱ B

***** axiom schemes
K : A -> B -> A
S : (A -> B -> C) -> (A -> B) -> A -> C

example: proof of a -> a
|---+-------------------------------------------------+--------|
| 1 | (a -> (b -> a) -> a) -> (a -> b -> a) -> a -> a | S      |
| 2 | a -> (b -> a) -> a                              | K      |
| 3 | (a -> b -> a) -> a -> a                         | MP 1,2 |
| 4 | a->b->a                                         | K      |
| 5 | a->a                                            | MP 3,4 |
|---+-------------------------------------------------+--------|
所以I也是可以被推到出來的:SKK =β= I

***** Curry-Howard for Hilbert system
|-------------------+------+---------------------------|
| logic             | <==> | type theory               |
|-------------------+------+---------------------------|
| *Hilbert system*  | <==> | *typed combinatory logic* |
|-------------------+------+---------------------------|
| proof of a -> a   | <==> | SKK =β= I                 |
|-------------------+------+---------------------------|
| deduction theorem | <==> | converting lambda terms   |
|                   |      | to combinatory logic      |
|-------------------+------+---------------------------|

**** logic style 2: sequent calculus
***** notations
sequents:
A1, ..., An ͱ B1, ..., Bm

to be read as:
A1 ∧ ... ∧ An ͱ B1 ∨ ... ∨ Bm

A1, ..., An and B1, ..., Bn are sets, not lists

***** intro/elim versus left/right
for each logical connective *:
- natural deduction:
  intro rules *I (introduction)
  elim rules  *E (elimination)
- sequent calculus:
  left rules  *L
  right rules *R

***** rewrite-rules
1. assumption rule

   ------------- ass
   Γ, A ͱ A, Δ

2. left rule for implication

   Γ ͱ A, Δ
   Γ, B ͱ Δ
   ---------------- ->L
   Γ, A -> B ͱ Δ

3. right rule for implication

   Γ, A ͱ B, Δ
   ---------------- ->R
   Γ ͱ A -> B, Δ

***** example: proof of a -> b -> a
---------- ass
a, b ͱ a
---------- ->R
a ͱ b -> a
---------- ->R
ͱ a -> b -> a

***** cuts
cut rule
Γ ͱ Δ, A    A, Γ ͱ Δ
--------------------- cut
Γ ͱ Δ

但是語義上不是Γ ͱ Δ, A要強過Γ ͱ Δ嗎
這是因爲
如果沒有cut就沒有消去規則了
所以這樣的話
在證明過程中就只能是讓節點的大小遞增
也就是一種不能回頭的證明
而下面的定理說明這種不能回頭的證明總存在

cut elimination theorem:
all provable statements can also be proved with a cut-free proof

***** >< Curry-Howard for sequent calculus
**** logic style 3a: natural deduction, Gentzen-style
***** rewrite-rules
1. assumption rule
   A ∈ Γ
   --------- ass
   Γ ͱ A

2. implication introduction

   Γ, A ͱ B
   ---------------- ->I
   Γ ͱ A -> B

3. implication elimination

   Γ ͱ A -> B
   Γ ͱ A
   ----------------- ->E
   Γ ͱ B

***** example: proof of a -> b -> a
---------- ass
a, b ͱ a
------------- ->I
a ͱ b -> a
--------------- ->I
ͱ a -> b -> a

與前面的minimal logic完全相同

***** intro/elim versus left/right, revisited
1. natural deduction: introduction and elimination rules
   ... ͱ ...
   ----------------- *I
   ... ͱ  ... * ...

   ... ͱ ... * ...
   ----------------- *E
   ... ͱ ...

2. sequent calculus: left and right rules
   ... ͱ ...
   --------------- *L
   ... * ... ͱ ...

   ... ͱ ...
   ---------------- *R
   ... ͱ ... * ...

3. 反正都是要把東西弄到右下角
   ``ͱ'' 與 ``------------''
   其實在兩個不同的語法層次
   提供着相似的語義
   所以在那種語法層次中推進證明都是沒有關係的

4. >< 這帶來了什麼啓示呢?
   我可不可以設計形式語言把不同的語法層次對稱化 ???

***** >< 是否可以列舉出分別易於在intro/elim和left/right中理解的推理的例子
畢竟這些風格被某些人採用正是因爲它們可以方便的用來表達出易於理解的推理過程
***** Curry-Howard for natural deduction
在例子中體會:

---------- ass
a, b ͱ a
------------- ->I
a ͱ b -> a
--------------- ->I
ͱ a -> b -> a

----------------
x:a, y:b ͱ x:a
----------------------------
x:a ͱ (λ y:b . x) : b -> a
----------------------------------------
ͱ (λ x:a . (λ y:b . x)) : a -> b -> a

與前面的minimal logic中所作的對比完全相同

**** >< logic style 3b: natural deduction, Jaskowsky/Fitch-style
這種推理風格的發明
是爲了探索``ͱ''的語義

>< 即當以以``ͱ''爲核心的表達式爲有向圖的節點時
對那些推理規則所形成的節點之間的關係的直觀理解是什麼???

這裏使用了更高維數的模型來理解這一切
太酷了

不過本質上還是樹結構
因爲下面的模型是等價的:
1. tree
2. sexp
3. 圈圈
4. 泡泡

*** >< detour elimination
*** >< consistency
