#+TITLE: note on cicada
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* TODO
  1. >< ANF ???
  2. 完成關於 數據分配器 的筆記
  3. 整理對 scheme 的批判
  4. 關於 結合代數 變形 與 優化
  5. 關於多棧的新語法的設計
  6. 關於類型系統的新語法的設計
  7. 虛擬機的設計
* TODO old
** better string reading support
** better string writing support
** better number writing support
** write a better meet-undefined-word
   1. 如果我想要在 cicada 的代碼中重寫這個函數
      那麼 只要用一個變量
      讓這個函數調用這個變量中所保存的函數就行了
      這樣我就能以相當精確的方式 重新設置處理未定義的位置的函數了
   2. 另外的使得對某個函數的動態改變稱爲可能的方式是
      直接從 symbol 找到找新的 symbol 所對應的 函數值
      當更新 一個 symbol 所對應的函數之後
      就能 重新設置處理未定義的位置的函數了
      但是這種方式並不是很精確
   3. 那麼我需不需要在 cicada 的代碼中重寫這個函數呢 ??
      也許是需要的
      並且在 不同的 語言核下
      所希望使用的 處理函數可能是不同的
   4. 但是這種全局變量的使用可能並不是很好到的編程實踐
** redesign the debuger
   1. as the "debuger" is defined in cicada code
      it is hard to do good error handling in assembly code
      這是因爲我沒法在出錯的時候即使調用 debuger 來報錯
      - 比如 通常的函數類型的錯誤
        我應該 及時的 調用 debuger 來報告錯誤
        而在不利的條件下 我必須 返回一個出錯碼
        來表示函數 所接受的數據類型不對
** re-writing garbage-collectior
   1. ??? 對於新的 define 要更改 GC
      整個 GC 都應該被重寫了嗎 ???
** make good use of indentation
   1. for wodili 應該 在 wodili 的已有的 解析器 的基礎上
      增加一個 好好 利用 indentation 的解析器
      兩種解析器各自有各自的用處
   2. 把 利用"支撐樹" 來進行相對引用的 性質加到 yaml 中
      就能 形成 我想要的 digrap 的語法
** write a cross compiler
   1. 從最簡單 的 babystep 開始
   2. 編譯 bootloader
   3. 注意要保持設計的靈活性
      或者直接從 文檔開始
      用中文寫文檔 以加快速度
   -----------------------------
   1. 需要 cicada-assembler 的理由:
      1) 統一 命名規則
      2) 讓我 能夠探索一些關於編譯的技術
      3) 有些 小的 CPU 並沒有 類似 fasm 的 合適的編譯器的
         當我有 cicada-assembler 的時候
         我就能不受限制於這個事實了
      4) 當我調整代碼的結構
         以讓我方便地 維護兩個彙編版本的時候
         我就發現 其中有很多重複的部分
         想要消除這些重複
         我可以通過 更多的 把文件 分開來實現
         但是如果我想保持
         我的 類文學編程 組織代碼的風格的話
         也許 創造一些新的東西來支持 我的風格就是必須的了
   2. 不需要 cicada-assembler 的理由:
      1) 一個人認爲 一個語言需要這種東西
         可能只是因爲 當這個語言的編譯器能夠自己編譯自己的時候
         看起來很 cool 而已
      2) 爲了 實現 一個 x86-64 的彙編器
         有太多的 關於 CPU 的底層細節需要 被掌握
** erlang's bit syntax
   在於讓人方便地處理 bit fields
   這在於 能 用模式匹配
** about UI
   我可以把那幾個 核心的棧 的圖示 放在 左邊的一個窗口裏
   在這之後 我就能設計 debuger 的更好的使用方式
   但是一個問題是 當我的界面不再是一個簡單的解釋器的時候
   我就不能 直接利用 emacs 了
   也就是必須 要先寫自己的 文本編輯器
   之後才能考慮窗口 之類的問題
** learn from isforth
   ??? switch from fasm back to nasm ???
   for better linux support
** word boundary
   1. ><><>< the note about word boundary is wrong ???
** branch
   1. 是否對 branch 給更好的支持 ?
      用 label 來計算 offset ???
** english-core
   1. use hash-table to lookup dictionary
      then mutually recursive call
   2. 用hash-table來find
      這些不必實現在彙編代碼中
      因爲 list還是必要的
      因爲這樣就能保持對字典的靈活控制
      所以 需要寫一些函數把
      字典重新加載到 hash-table 中
   3. need to redesign the way to do test
      should tangle test to separated file
      for i do not have my org-mode now
   4. wodyli processing
      then digrap in cicada
   5. tab completion in the REPL
      (or in text editor)
   6. let functions in assembly-code
      be able to call functions in cicada-style-assembly-code
   7. >< 實現對多種實現技術的定製
   8. >< 重新思考某些術語和命名方式
   9. cicada should design it's own abstractions of IO
      this can help cicada to be portable
      現在 有的只是 read-char 和 write-char 兩個基礎的東西而已
      這樣太貧乏了
   10. memory allocation
   11. flow-point number
   12. >< maybe substitute word to execute in lambda-body
   13. >< maybe syntax-check
   14. >< modern pattern-match  HOW ???
   15. better interface for debuger
   16. TAIL-CALL-OPTIMIZATION in apply lambda-body
   17. more protection on allocated memory
       maybe use paging
   18. cicada-assembler
   19. cicada-editor
   20. APL-like array-processing
   21. needs better sexp-reader&write
       design a better way
       to use local-label to from list-with-circuit
** baremetal
   1. 作爲一個使用純粹釋性語言
      我應該 重新 思考 對 公共的 函數庫的使用方式
   2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
   3. SMP support
      作爲一個以棧爲基礎的語言
      我應該重新思考 利用 多核 的方式
   4. learn more from baremetal-OS
   5. convert the code about storage & BMFS from old-asm to forth-like-asm
      to examine the bug of "readsectors"
   6. fix "bye"
   7. design game-like UI in text mode
   8. rewrite cicada to make it standard and portable
      (this will always be TODO)
   9. to allow executables to dynamically access external functionality at run time
      and thereby reduce their overall memory footprint
      在我的操作系統中 我可以以我的方式來完成上面的這種特性
      我只需要一個 "need" 函數 來聲明 某段被解釋的代碼 所需要的 sub-dictionary
      我還需要一些 處理 sub-dictionary 的函數
      sub-dictionary 的性質 是 :
      - 它可以有很多個
      - 並且它所佔用的 內存可以被回收的
      - 內存的回收 可以用 類似字符串的 垃圾回收器 來完成
      - 當全面地使用 hash 來實現 dictionary 時
        內存的回收 也可以用 類似鏈表的 垃圾回收器 來完成
** cicada-idea
   1. cicada-idea 本身是一種開源硬件
      它是專門爲 編碼者 和 開源硬件hacker 而設計的 編程終端
      有專門爲 控制和編碼開源硬件 而設計的 硬件接口
   2. 作爲開源硬件 對 cicada-idea 的銷售和重新設計 不需要被 我 授權
      我 作爲 開源硬件的銷售商之一 而盈利
   3. cicada-idea 擁有 開源的 基於結構化文本編輯器的 操作系統界面
      cicada-idea 以 cicada language 爲主要的編程語言
      cicada-idea 有 以 cicada language 爲主要語言 而開發的 編碼環境
* 記
** 蟬語之優
   1. 某些性質被我認爲是優點
      然而 同樣的性質 在不同的人看來可能是缺點
   2. 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
      這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
      這個性質是我最喜歡的
      就算是對於 scheme 和 smalltalk 這種設計良好而簡潔的語言來說
      這種對整個系統的直觀理解也是不行的
      因爲 這兩種語言的 簡潔性 是以很高的抽象性爲代價的
      而 蟬語 的設計就是要在 保持這種 被簡單而直觀的理解的可能性的同時
      去實驗某些性狀 以達到 不比 scheme 和 smalltalk 弱的抽象能力
** 蟬語之劣
   1. 某些性質被我認爲是缺點
      然而 同樣的性質 在不同的人看來可能是優點
   2. threaded-code 的侷限性
      主要在於 這種風格的機器碼很可能 難以優化
      但是其實只有在具體的測試和實驗之後
      才能得出真正的結論
** 簡體繁體
   1. 簡體 繁體 西文 和所謂也 ?
      聲韻形態皆思之載體
      過分追究表達方式之異同之人
      未嘗得道也
   2. 在蟬語中 以傳統漢語爲主要表達方式
      而在命名規則和別名系統的幫助下
      我可以讓 簡體 繁體 西文 並存
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
** 設計決策
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** 正確的设计
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** >< 函數組
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** >< 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
** 以名釋性
   1. 在全面地貫徹類型系統之後
      以名釋性 的方式就改變了
      此時需要強調的就是命名規則了
   2. 以名釋性
      的目的還是減輕代碼的閱讀者在認知上的負擔
** bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** 代碼的閱讀者的認知上的負擔
   集成開發環境 是爲了 通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來 獲知 詞 的語義
   與命名規則一樣 這一切都是爲了
   減輕 代碼的閱讀者的認知上的負擔
** 蟬語中的命名規則
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** 編程範式
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** 對 OO 的支持必須被放棄
   1. 因爲 所想要實現的 OO 系統中
      參數與方法之間的對應 只有在運行時才能確定
      這對效率來說是個打擊
   2. 因爲 OO 與 對函數的靈活使用是相互衝突的
      在我看來 不同的編程範式 代表了不同的思考方式
      而對多範式的支持 只能帶來混亂
   3. 對於 "作用" 來說這種面向對象的技巧能夠節省命名空間
      但是對於 "函數複合來說" 則不然
      在蟬語中我經常需要把函數複合起來
      以定義新的函數
      如果所有的函數都被保護到類型的內部了
      之後找到相應類型的值的時候才能調用到這個函數
      那麼我就沒法方便的做函數的複合了
   4. 其他的語言中是用參數名和類型推導
      來解決上面這個問題的
   5. 而在蟬語中 我可以通過一個 一致的命名規則來解決這個問題
      但是這樣就把函數的命名規程化了
      在我看來少了很多靈活性和樂趣
   6. 綜上所述
      對 OO 的支持必須被放棄
** smalltalk 中對函數的命名
   1. smalltalk 中函數的命名是非常靈活的
      函數的命名變成了
      對象之間傳遞消息的協議
      這種特性正是爲了解決命名問題
   2. 我把這種特性理解爲
      - 把函數名 分散爲部分
        每部分匹配一個參數
        而約束變元
      - 而在 蟬語 中
        函數命名將被限制與一個詞
        在 蟬語 的 lambda 中
        是約束變元的名字在被用來匹配參數
        在函數作用的時候
        lambda 的約束變元的名稱 可以幫助增加代碼的可讀性
        儘管這些約束變元的名字並不出現在 函數的名字當中
   3. 但是
      在 smalltalk 中
      函數的使用可能並不靈活
      函數不可能被作爲一等公民來對待
   4. 但是
      有代碼塊可用
      並且 也較爲良好的代入語義
      所以 也許與 lambda 等價的東西是存在的
      然而
      就算 代碼塊 的語義能夠用來實現
      與 lambda 等價的東西
      對這些東西的使用也是不方便的
   5. 那麼
      如何說 cicada 中的函數是一等公民呢 ?
      這在於 ><
** >< 語義重載現象
   1. 在蟬語中現在還有一個語義重載現象
      那就是 函數 既可以是 一個詞典中的動詞
      也可以是一個 lambda-term
* 實現
** 記
   1. 我先把所有的設計都寫成文檔
      然後再着手實現
      否則當實現到了後面
      如果發現了某些設計需要更改
      就必須更改很多前面的代碼
   2. 我能這樣做
      只是因爲
      第一個版本已經被實現好了
      我已經知道在實現過程中可能遇到的技術難題是什麼了
** 虛擬機
   1. 這次是我在濫用術語了
      當我考慮是否要使用一個虛擬機還有鏡像文件來實現蟬語的時候
      我才發現這一點
   2. 要知道虛擬機和處理器
      都是指令集編碼的簡單的解釋器
   3. 我之前所說的可擴展的虛擬機
      即 內部解釋器
      於一個虛擬機非常相似
      我應該利用這種相似之處
      而實現一個更符合虛擬機這個屬於傳統意義的虛擬機
   4. 也就是說讓整個詞典可以靜態地存在於一個鏡像文件中
      這類似於設計一個可執行文件格式
   5. 詞典中的每一部分都可能依賴於詞典中的其他部分
      並且可能有相互的依賴
      在把鏡像文件中的詞典中的一部分加載到內存中的時候
      相互的依賴關係需要被處理
** 另一種實現方式
   1. 我可以在這裏辨別出兩種實現方式
      1) 用詞表達的可執行文件
         被蟬語的解釋器加載並解釋
      2) 用八位組碼表達的可執行文件
         被一個單純的 threaded-code 解釋器加載並解釋
   2. 它們的優劣分別分析如下
      |      | 一 | 二 |
      |------+----+----|
      | 層次 | 少 | 多 |
      | 加載 | 慢 | 快 |
      | 大小 | 大 | 小 |
   3. let the dictionary be a loadable linkable executable format
      parts of the dictionary could be linked to be the whole
      runtime changes from "a word interpreter" to
      "a dictionary loader and linker"
      plus "a threaded-code interpreter"
      in the last case, no string input is needed
      while a REPL is still can be provided
   4. 第二種方式最大的好處是
      我可以實驗自己設計指令集
      與指令集的編碼方式
   5. 更大的好處是
      在虛擬機的幫助下
      移植的方便性就達到了最高
   6. 這種 作爲虛擬機的 threaded-code 解釋器 是一定能實現的
      問題是 詞典這個數據結構如何設計
      如果發現這樣的設計在加載的效率上還不如對字串的處理
      那麼就失去意義了
   7. 虛擬機之重要性在於
      我所使用的彙編器中所能實現的宏限制了我對詞典這個數據結構的設計
** 改良
   1. 我需要的性狀是
      在可以把代碼編譯成 bytecode
      以讓虛擬機 加載並解釋
      而這並不影響 REPL 的存在
   2. Exit 應該被編譯器處理爲
      而不應該被解釋器處理
      也就是說 尾調用優化 應該被編譯器來做
      而不應該被解釋器來做
      但是 ITC 阻止了這種編譯時期的優化
      STC 倒是可以
      也就是要區分 call 和 tail-call 兩個指令
      並且把它們寫到函數體內
      函數體內所保存的就直接是可以被執行的指令
      其實在這裏我還是能夠使用 "間接"
      把函數體和函數頭分開
      並且當使用虛擬技術的時候
      我的指令集是可以針對我的目的而優化的
      這樣 literal 和 branch
      就可以被實現爲和 call 還有 tail-call 等同的東西了
      call 這個指令本身就可以有各種 間接的版本
      這才是正確的實現方式
      也就是去用空間來換時間
* 學文記
** 方法
   1. 蒐集古典例句
      查而辨其結構
   2. 語言有一奇妙特性
      在於 它能被用來描述它自身
      正是因爲這一特性
      寫一篇辨析語言結構的文章才成爲可能
   3. 在辨析結構之時
      需謹記 因 語言成於人與人之間的交流
      故 重任交談之場景 反映於語言之結構中
** 界說
   - 詞類 ::
   - 名詞 :: 名詞爲本
   - 動詞 :: 動詞以述名詞之行也
             不可獨解
             解時 需助之以名詞或代詞
   - 形容詞 :: 以形名詞之容也 不可獨解
               但是上面的界說是有問題的
               因爲 數 應該被視爲形容詞
               但是 數 又被當作抽象的名詞來被處理
               並且形容詞所形容之性狀通常都是可以被量化的
               所以 形容詞對名詞之限定 與數之結構息息相關
               並且所謂用來形容動詞的狀詞亦可以被量化
               但是 其實作爲限定詞 它們也有簡單的限定分類之用
               未必階爲狹義的量化
   - 數學結構 :: 動詞是這些性質就時間而言的變化
                 然而要點是
                 語言的語義就 對話場景
                 還有 時 空 二量 而 優化了
                 這種優化可用關於演化的理論來解釋
   - 更細的特點 :: 我其實是在類比數學語言與自然語言
   - 句讀 :: 句讀者 語法解析 也
** 判斷
   1. 判斷句
      不用 "是"
      而並兩個名詞短語然後加後綴 "也"
   2. 這就使得中文看起來像是沒有語法的語言
      做語法解析需要憑藉對語義的理解
      而"相對"正確的語法解析
      又是得到"更"正確的語義的前提
      所以我們的大腦中處理漢語意義的模塊像是一個迭代函數
      我想
      讓這個"迭代函數"發散的點是存在的
* 句式
  1. 以 主 謂 賓 爲基礎語順
     施 句式 以變
     1) 使成
        主 謂 賓 成 : 燒燭短 引杯長
        主 謂 成 賓 : 折斷 吹散
     2) 被動
        賓 爲 主 所 謂
        賓 被 主 謂
     3) 把
        主 把 賓 謂
  2. 而蟬語的特點是
     在大多數情況下 動詞後置
     並且似乎沒有主語
     或主語爲隱含的 我
  3. 凡 []
     [] 者 曰 []
     [] 者 曰 []
     用以描述大類下的小類
  4. 語法其實就是一個樹狀結構
     需要設計的是如何把這個樹狀表示出來
  5. (名 體*) 動詞也
     (名 體* 詞性) 而 編撰入詞典
     (名 體* 詞性) 也
     (體* 詞性 名) 也
     蓋 體* 詞性 名 者 也
     #+begin_src cicada
     蓋 (* n -- n! *)
     復 一乎 則 已矣
     再 復 1 減 階乘 乘 已矣
     動詞 階乘 者 也
     #+end_src
     "也" 簡單地由 "而 編撰入詞典" 就語法優化而來
     一個字符串 接受到 "編撰入詞典" 這個信息的時候
     會調用一個處理函數
     這個處理函數
     會把字符串語法解析了
     然後把一個詞的定義編撰入詞典
* 語法特點總結
  1. 我現在理解爲什麼 lisp 直接使用語法解析樹爲語法了
     這樣就避免了去在語法設計上耽誤時間
     而對 蟬語 而言
     語法的特點 其實並非完全地是 後綴表達式
     全局是後綴的 但是局部可以是任意的
     總結一下對輸入的[函數定義]處理
  2. 以前後標識 定界一個字符串
     這個字符串被入棧之後
     一個[字符串的]處理函數[詞的製造者]會被用來處理它
     儘管 函數體是被允許嵌套的 但是這個函數卻不是遞歸函數
     這個處理函數會以相對線性的方式來語法解析這個函數體
     1) 遇到最一般的詞的時候
        會寫[call word-address]到內存中
     2) 遇到數字會寫[number n]到內存中
     3) 等等
     4) 遇到語法關鍵詞時會調用那些語法關鍵詞來處理
        調用結束之後會再返回主要的循環中
        這個 主要的循環就代表了 "全局之後綴性"
        而對個別語法關鍵詞的調用就代表了 "局部之任意性"
  3. 詞典編撰者作爲一個字符串處理函數
     會一個詞一個詞地遍歷這個字符串
     同時 被寫入的內存區域[詞典]的地址 之指針
     作爲一個隱含的參數被 詞典編撰者所查看
     這在於 當需要的時候
     已經 在對前部字符串做處理時 編入詞典中的東西
     在對后部字符串做處理時 被改寫
     尤其是對數據類型系統的優化需要用到這個性質
  4. 關於類型系統
     我提供 "之" 和 "而" 這兩個可以被以最靈活的方式使用的虛詞作爲關鍵詞
     當 詞典編撰者遇到 "之[或而] <function>" 時
     他會看 當前函數體指針 之前的一個位置 是什麼類型的值
     1) 如果是一個函數調用
        那麼 就 編譯一個動態的消息傳遞式的函數調用
        [<symbol>] [call function-zhi]
     2) 如果是一個值
        就看它的類型
        然後 依據消息 找到登記到這個類型下的函數
        要知道 在新的類型系統被加入之後
        每個函數都包含信息 來表明 這個函數可否在編譯期被作用
        現在就需要用到這些信息
        [需要設計一致的註釋格式來完成這一點]
        來看一看所找到的這個函數能不能在編譯時期被作用
        [注意這裏還要檢查 是否除了主要參數之外 其他的參數都齊備]
        典型的能夠在編譯時期被作用的函數是
        那些對參數棧之外無副作用的[純粹]函數
  5. 這樣就使得
     在 "之[而]" 後面的詞的意義是上下文相關的
  6. 是否 規定
     這種使用 "之[而]" 的對函數的調用 爲 唯一的調用函數的方式呢 ???
     原來的 沒有全面地引入類型系統的時候的函數調用方式是否要保留呢 ???
     是需要保留的
     考慮那些零參數的函數就知道了
* 多棧
  1. 所有的棧都能用來傳遞參數
     但主要用主棧來傳遞參數
  2. 主棧能形成僞局部變量語義
     副棧能形成真局部變量語義
  3. 直接把對多棧的支持添加到虛擬機中
     以減輕 語法編撰者 的工作負擔
     需要設計一個指令集
     這個指令集需要編碼各個棧
  4. 多棧是爲了實現 有限個局部變量 的語義
     我可不可以把機制設計地更靈活一點
     而不限於局部變量這一種使用方式
     這就要求了每個棧必須有自己的名字
     甲 乙 丙 丁
     而我所能做的是在每個函數體內臨時重新命名這些棧
     並同時改變操作這些棧的函數名
     這樣在使用局部變量的時候 在語法上可能就比較羅嗦
     要知道 如果要設計靈活的使用方式的話
     就需要能夠選擇在命名一個新的棧的時候是否初始化它
     並且這裏對棧的操作也應該相對完整
     而不像之前那樣 只實現對主棧的操作
     也就是說這每個棧都是一個數據結構不是嗎 ?
     對這些數據結構的一致地使用方式 就實現了局部變量這個效果
  5. 這裏的局部變量
     如何與 lambda 中的局部變量相調和呢 ?
     讓這兩種實現局部變量的方式完全正交就行了
     這就要求要設計出區別足夠大的語法來使用這兩種語義
  6. 這裏的 "暫時改名" 這個語義很有意思
     這種改名只有在編譯時期才有效
     這種編譯時期的處理
     可以被看成是 編譯時期對 "1 2 +" 的處理一樣
     也就是說 也就是說我已經有了
     一致地 讓某些運算在編譯時期被處理的方式
     但是需要注意的是 這種東西也許應該被以明顯的方式聲明
     因爲 某些帶有副作用的函數 就算 它們的參數已經在棧中了
     這些函數還是應該被在運行時作用
     我給出機制 來幫助用戶明顯地控制這些東西
  7. 也許在這些新的語義被加入之後
     我已經不能說蟬語是很簡單的語言了
  8. 對多棧的處理是由 詞典編撰者 完成的
     #+begin_src cicada
     蓋
        甲棧 爲 計數棧
        乙棧 爲 長度棧
        丙棧 爲 地址棧
     註 (* [入 地址棧] [入 長度棧] [入 計數棧] --  *)
     已矣
     動詞 <某> 者 也
     #+end_src
     假使
     甲棧 乙棧 等等
     都是棧類型的值
     那麼
     "甲棧 而 名 計數棧"
     [可以被優化爲 "甲棧 爲 計數棧"]
     就是一個在編譯時期被處理的函數調用
     這種別名信息應該被保存在 函數體內
     因爲這些信息可以作爲動態的文檔被調用
     但是 如何保存呢 ?
     給函數頭增加一個域
     然後 使用一個類似 函數體的數組
     用來保存 編譯時期需要用到的信息
     [當然 這些信息也可以被作爲文檔來 查詢]
     這樣就行了
     [使用 <symbol> 或者 使用 <string> 都沒有關係]
     [有時 對於 <symbol> 的使用 我還有些疑慮 有些擔心散列函數的穩定性]
* 優化語法
  1. 我保持 上面所描述的統一的編譯語義
     並且我提供一個簡單的優化語法的方式
     即
     "而 名" -> "爲"
     "而 編撰入詞典" -> "也"
     只要把 "爲" 和 "也" 這類詞定義爲一類特殊的語法關鍵詞
     就行了
  2. 另一種優化
     就像在中文中
     當時形成排比時 就可以省略一些重複的助詞一樣
     在sexp中當形成排比時也能省略一些括號
     [比如 cond 就是典型的情形 shen 做到了對語法的優化 而 scheme 沒有]
* 註釋的格式
  1. 要設計 關於多棧的新語法
     其實是要設計 一種新的 註釋的格式
     把註釋的格式完全固定下來
     類似於一個類型聲明系統
     在之前 對棧的操作的註釋是被忽略的
     也就是說 編碼者 辛辛苦苦鍵入的信息被愚蠢的機器忽略了
     我現在就設計新的 註釋的格式 來修正這一錯誤
  2. 要求這個 註 中所能包含的信息有
     1) 副作用 類型
        包括 編譯到內存的信息
        還有輸入輸出信息等等
        仔細想像 副作用的類型其實 十分有限
        這些信息必須足以讓 詞典編撰者 推導出
        這個函數的作用能否在編譯時期被處理
        如果這裏有困難
        那就直接把 這個性質變成一個明顯的聲明好了
     2) 參數類型
        其實在這裏也是能夠形成像 ocaml 中一樣的類型推導系統的
        這種系統之有趣在於 兩點
        1. 擁有一等公民函數可以使用
           這一點在沒有 lambda 的時候 在蟬語中也是有的
        2. 擁有匿名函數可以使用
           這一點 只有在 lambda 之後才能擁有
           但是 其實不是的 ><><><
     3) 參數的局部變量初始化
* 關於匿名函數
  1. 爲什麼匿名函數要求鏈表處理 ?
     因爲
     1) 匿名函數需要被垃圾回收
     2) 爲了 call/cc 嗎 ??
        其實跟 call/cc 沒關係
  2. 用鏈表處理實現的函數體
     運行起來比用數組實現的函數體慢
     特點是它可以被靈活的改寫
     但是這後一種性狀其實是不常用到的
     誰也不會想要經常改變一個已經定義好的函數體
  3. 而 call/cc 需要的不是函數體被 用鏈表處理實現
     而是 返回棧 被用鏈表處理實現
     [除非使用 CPS 之類的編譯技術]
     這也會使得函數調用變慢
  4. 有什麼額外的選擇嗎 ???
     記得 call/cc 也有它的侷限性
     即它所得到的 cc 是一個一元函數
     但是對與 蟬語中的函數來說 一元和多元根本就沒有本質的區別
     那麼 call/cc 在蟬語中是否能是多元的呢 ???
     這樣就比 scheme 還牛逼了
  5. 回憶一下 call/cc
     它的一元性顯現與下面的兩個一元函數之上
     (... (call/cc (lambda (cc) <body>)) ...)
     這個表達式出現的地方是一個"空"
     這個控形成了一個一元函數 它代表了當前的計算狀態
     call/cc 所作用於的必須也是一個一元函數
     這個函數的參數將是 是上面那個空所形成的一元函數
* 數據
** 類型
*** 目的
    1. 使得蟬語能夠更好地處理 數組樣子的數據結構
       並且 對鏈表樣子的數據結構 也將有統一的處理
    2. 一個對象在內存中的存在方式需要被指定
       有可能用到 GC 也可能是在 詞典 中的靜態數據
    3. 消除同時在語言中允許有類型的值和無類型的值時
       產生的語義過載現象
    4. 把處理某種類型的函數都登記於這個類型下面
       以節省命名空間
       並且使得所有的函數都不必檢查其參數
*** 可行性
    1. 只要在語法方面不影響表達的簡潔性
       那麼在運行時多入一個 數據類型標籤 到棧裏也是可以接受的
       "一個量" 佔參數棧中的兩個單元
    2. 不把函數 限制在某個類型內
       否則就將與函數範式相互衝突了
       必須把所有函數都暴露出來
       使得對它們的複合能夠被以簡潔的方式進行
    3. 在定義一個類型的時候
       最好不要初始化
       直接把所有對結構還有函數的定義都分散
       這樣就可以隨時添加處理函數到某個數據類型中去了
*** 類型之間的關係
    1. 一個類型由其數據域和其處理函數來表示
       所以類型之間的關係其實就是具體集合論中集合之間的關係
    2. 有某些算子[即 函數]和關係[即 謂詞]可以用來抽象 "具體集合" 這個數學結構
       比如 "含於" 這個關係
       比如 "上下确界" 這個算子
       但是我直接使用最具體而平凡的方式就可以了
       這些算子和關係可以在之後定義
    3. 在定義個類型的時候
       我提供語法以使你能夠指明其 數據域 和 處理函數
       我提供語法能使你直接聲明
       1) 這個類型的 以這個符號爲名的 處理函數
          和 那個個類型的 以那個符號爲名的 處理函數
          相同
       2) 這個類型的 以這個符號爲名的 數據域
          和 那個個類型的 以那個符號爲名的 數據域
          相同
       這就是我所說的 "具體而平凡的方法"
    4. 這種實現方式要求 函數內部關於接受參數還有形成返回值的部分
       必須對數據類型保持無知狀態
       必須沒有類型檢查 這樣一個函數才能夠被多個類型的數據類型使用
*** 數學結構
    1. 每一個類型[type]代表着一個具體的數學結構
       而在蟬語的基礎部分中
       並不去實現 抽象的 符合某些公理的 數學結構[class]
       這是因爲程序語言中所實現的數學結構
       都是具體的用來做計算的數學結構
       而數學中的抽象的數學結構
       是用來在探查滿足某些公理的數學結構的一般性質的
       除非是在實現一個輔助證明系統之後
       否則生硬地把抽象的數學結構還有範疇論中的概念
       引入程序語言中來 在我看來是不合適的
*** 類型推導
    1. 類型推導變得有趣而有用
       當且僅當 函數是一等公民的時候
       但是在蟬語中 作爲一等公民的函數
       是在實現了鏈表處理之後
       利用鏈表處理來實現的
    2. 也就是說在蟬語的核心部分的基礎上
       可以構建起各種計算系統
       比如 lambda-calculus 和 digrap
*** 初始化
    1. 在定義一個數據類型的時候
       必須指定一個用來初始化一個這個類型的數據的函數
       這個函數可能有參數 比如 對 詞 這個數據類型來說就是如此
       而也可能沒有參數 比如對與 cons 來說就是如此
       這個用來初始化數據的函數
       可以從棧中 cons 的數組中取 內存
       也可以從詞典中取內存 或者從數據段中取 內存
       - 比如編撰一個詞到詞典中的過程就是如此
       這樣就解決了 靜態的動態的問題
       並且 原子性的數字類型的量是在 參數棧中去內存的
    2. 可以發現 從語法的角度看
       對 上面的三種類型的 數據的初始化
       是非常不同的
       1) : kkk 1 2 3 . . . Exit ; define-function
          此時有一個名字被分配給了這個對象
          參數棧 中沒有留下東西
       2) cons
          此時沒有名字
          參數棧 中有地址
       3) 7
          此時沒有名字
          參數棧 中有值
*** 多餘的信息
    1. 儘管於一個帶有類型的量來說
       當它被入棧的時候一個類型標籤已將被入棧了
       但是我還是要求
       如果這個量是非原子性的量
       那麼它的地址下面就一定要有一個域用來儲存類型
*** 對別名的支持
    1. 詞典中的同一個定義
       應該能夠擁有兩個名字 這樣 英文 漢文 異體字 就方便多了
       這樣在詞典這個數據結構中 單向鏈接的鏈表的功能就喪失了
       因爲沒法依據這個鏈表來查找詞了
       這個功能本身我也沒用過
       也許我應該好好設計然後在取實現
       這樣就能有個大局觀
*** 實現
    1. 在開始實現基本的 名詞和動詞之時
       需要很多基礎設施
    2. 類型系統需要用更豐富的數據結構來實現了
       並且在實現它的時候還沒有類型系統
*** 術語
    1. 型[type] 類[class]
       結構[structure] 範疇[category]
       我應該如何使用這些術語呢 ?
    2. 目前我只使用 型[type] 這個術語
       用來表示一個具體的數學結構
** 具體
*** 詞
    #+begin_src cicada
    詞 静
      名 我希望這是被內化的串 即符號
      大小
      性
      詮釋者
      定義

    用來初始化 詞 的函數 會把詞分配到 詞區[詞典]中
    也就是說每個[某些]數據類型會有自己的區
    #+end_src
    1. 初始化
       先看 在舊的 依賴於外部的匯編器 依賴於解釋語義的 實現方式中
       初始化 是如何實現的
       1. 首先在匯編中
          定義之外的部分用一個宏實現
          定義就是簡單地把地詮釋者的地址留在匯編代碼中
          也就是說
          爲了形成一種寫匯編代碼的風格
          詞這個數據的結構被限制了
       2. 在解釋器中
          讀一個串
          把這個串解析成詞
          第一個詞爲 名
          以之後的詞 找對應的詞的詮釋者 以爲定義
       故 初始化之語法 類似於
       夫 <某> 者 <某> 也
       或
       夫 <某> 者 動詞 而 編撰入詞典
       如果 想 保留 也 這個詞 那麼就需要一種語法糖機制
       因爲 否則 就破壞了召喚函數的統一性
       但是這種統一性也許是需要被破壞的
       考慮 cons 就知道了
       名詞 和 動詞 是兩種類型
    2. 處理
       並沒有很多的處理函數
       對這個函數的處理都是散列表和名之間的互動
       可以說 散列表和詞 一同構成了詞典
    3. 統一性
       定義一個數據類型的語法是統一的
       帶有類型標籤的量在參數棧中的存在方式是統一的
       取非原子性的數據的域的方式是統一的 :: <型> 之 <域>
       召喚處理某種類型的函數的方式是統一的 :: <型> 而 <函數>
       統一性僅此而已
    4. 不統一性
       也就是說用來初始化各種數據類型的值的語法是不統一的
       數據類型存在於內存中的方式也是不統一的
    5. 型 類似於 名詞
       夫 詞 <某> 者 名詞 而 編入詞典
       設計何種語法才能把對型的 域 和 處理函數 的描述
       置於型的定義之外 ?
       這是不合理的
       對型的 域 的描述不應該被置於型的定義之外
    6. 所謂的之和而其實是相同的
       之 也是在召喚函數而已
       這樣就獲得了純粹的動態性
       之 <某> 會被編譯成 [某符號] [之]
    7. 某個數據類型的所有的處理函數
       都在類型的定義之外聲明
       其實就是把這些函數登記在這個類型下面
       並且我必須提供語法
       使得用戶能夠方便地把一批函數一起登記
    8. 只要做了下面所述的優化
       那麼以一致的方式來實現對數據域的處理也就可以了
    9. 不去定義標準的初始化一個數據類型的域的方式
       就能夠 保持 使用類型系統時候的靈活性
       好的 factoring 能夠保持 表達方式的精簡
    10. "而 編撰入詞典" 到 "也" 這種對語法的優化
        其實可以以一致的方式系統地使用
    11. 我說 ruby 識別出了一種 使用 lambda 的模式
        並且就這個模式優化了自己的語法
        器關鍵在於把 顯式的參數 變成 隱式的參數
        蟬語的語法必須具有 "可以做類似優化" 這種性質
        蟬語保持平凡的核心語法
        而在蟬語中對語法的優化 是由核心語法所提供的語義來完成的
        也就是我必須設計一種 讓用戶去優化語法的機制
    12. 可以看出在 有類型系統的 函數式範式中
        只要
        調整調用函數的前綴或後綴表達式爲順序爲中綴表達式
        然後在加上把某些 顯式的參數 優化成 隱式的參數
        就形成面向對象了
        而 我想 面向對象 所增加的認知上的負擔是很重的
        所以我放棄對 面向對象 系統的實現
    13. 蟬語所實現的東西 與一般的OO範式所不同的是
        1. 最重要的是沒有提供一致的方式來初始化類型
        2. 法上保持 後綴表達式
    14. 那麼定義一個類型的語法應該是如何的呢?
        我應該提供語法來幫助用戶
        在定義類型之初就指明有那些函數需要登記
        >< 我還希望能夠該處一致的方式在 定義好了一個類型之後
        再在其中登記 一個或多個 函數
        我希望登記 一個或多個 函數 的語法能夠一致
    15. 我甚至還能夠提供 所謂的 Class Variables
        因爲 這種 "把函數登記到類型中" 的解決問題的方式
        是非常靈活的
*** 關於優化
    1. 如果 在把 之 或 而 編譯到動詞的定義當中時
       如果能夠證明 這個函數被調用時 棧頂的數據的類型是固定的
       那麼就能夠把查找的過程在編譯期完成
       從而優化運行期的效率
    2. 最顯然的可以證明的情形是
       當它前面被編譯的是一個原子性的數據的時候
    3. 對於取非原子性數據的域的函數
       這種優化可以更進一步
    4. 可以發現這裏所謂的優化
       就是簡單把某些計算在編譯時期進行而已
       那麼
       如果在編譯時期遇到 1 2 + 這樣的函數體
       是否也要計算出這些結果呢
       答案是肯定的
       如果我總是保證在編譯期能做的計算都在編譯期被算完
       那麼顯然我就能證明
       就從這個角度的優化而言 我的編譯器達到了最優
    5. 但是
       lambda 如何呢 ?
       在 lambda 的函數提中如何呢 ?
       純粹地動態嗎 ?
       沒錯
       其函數體也是可以以類似方式優化的
       因爲我可能要歲 lambda 做手術
       所以 對於實現與否
       我把決策放在以後在做
*** 符號
*** 定義
*** 棧
*** 整數
*** 八位組
*** 字
*** 八位組串
    #+begin_src cicada
    八位組串
      蟬語者說
    ------------
    #+end_src
*** 單鏈
    #+begin_src cicada
    (* bra-ket *)
    { Mark-McGwire Sammy-Sosa Ken-Griffey }

    (* indentation *)
    ======
    - Mark-McGwire
    - Sammy-Sosa
    - Ken-Griffey
    ======
    #+end_src
*** 雙鏈
    #+begin_src cicada
    (* bra-ket *)
    [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

    (* indentation *)
    ======
    * Mark-McGwire
    * Sammy-Sosa
    * Ken-Griffey
    ======
    #+end_src
*** 名鏈
    #+begin_src cicada
    (* bra-ket *)
    ( :hr 65 :avg 0.278 :rbi 147 )

    (* indentation *)
    ======
    :hr 65
    :avg 0.278
    :rbi 147
    ======


    ( :american
        Boston Detroit New-York
      :national
        New-York Chicago Atlanta )

    ======
    :american
      - Boston
      - Detroit
      - New-York
    :national
      - New-York
      - Chicago
      - Atlanta
    ------
    :1 "-" for list element
    :2 "*" for dali element
    :3 ":" for wodi (* wodili element *)
    ======
    #+end_src
* 計算的方法
** 木答演算 [lambda-calculus]
** 有向圖處理 [digrap]
* 計算的方向
  1. 使用明顯的 參數棧 與 返回棧
     對於使 call/cc 的語義變清晰來說
     很有幫助
  2. "沒有祕密,就沒有泄密"
     "沒有抽象,就沒有抽象的泄漏"
  3. 在形成一個 cc 的時候
     應該可以以明確地方式說出所使用的是哪段計算
     這樣 call/cc 的語義就不會再令人迷惑了
  4. 如果我能以明顯的方式把各段運算
     以隱式抽象成函數
     然後隨意地組合它們
     然後在根據常用情況優化其語法
     那麼我就得到比 call/cc 更好的東西了
  5. 好像 call/cc 無論如何都需要複製參數棧
  6. call/cc 的難點在於
     必須使用動態地方式來分配 函數返回地址 和 函數參數 的內存
     然而它們會大大加重 GC 的負擔
  7. call-with-* 其實是改變了 函數作用的基本語法的
     (call-with-* <function>)
     它讓函數作用於一個約定的參數
     而不是使用
     (<function> <約定的參數>)
     爲什麼如此呢 ???
* 矛盾
  1. 高階與低階
     如果使用自己定製的虛擬機
     並且把 GC 實現在虛擬機中
     那麼 蟬語 之簡單性所帶來的對機器底層的控制能力就喪失了
     除非虛擬機的可擴展性非常強
     這樣在需要某些新的底層功能時
     就可以通過擴展虛擬機而完成
     也就是說
     虛擬機知道自己是一個虛擬機
     並且它提供通向更底層真實硬件的接口
  2. 特性之意義的喪失
     所保留下來的特性還有什麼 ?
     [如果 獨特之處 全然喪失 那麼我就應該回到 scheme 社區了]
     1) 以明顯方式使用的棧
        [函數語義的具體化]
        後綴表達式
        [達到與CPS同樣的效果][避免複雜的語法解析]
        無傳統意義上的局部變量
        [就函數複合而優化[同時使得對函數作用的表達變得羅嗦]]
        [也就沒有因局部變量的大量使用所帶來的認識上的負擔[但是引入了其他類型的額外的負擔]]
        這些特性 使得
        1. 蟬語是一個非常適合教學的語言
           比如
           犧牲效率而換取設計的一致性
           不做優化而換取實現的簡單性
        2. 在學會使用蟬語的同時 基本上就學會實現蟬語了
     2) 漢語本位
     3) digrap
     上面就是我能想到的全部了
     如果再強行描述其他的特點或優點 那就是不實的廣告了
* 對鏈表的排斥
  1. 人們先驗地認爲鏈表處理速度慢
     但是這是用速度來買靈活性的時候
     [看看minikanren就是全然用鏈表處理實現的]
     [而digrap將來也將全然使用鏈表處理來實現]
     [我想coq也是如此]
     [既然它們都是如此 那麼鏈表也就沒有什麼不可接受的了]
     所以我不再排斥鏈表處理了
* 空間換時間
  1. 通過把 function-address
     豐富爲 call function-address
     就做到了 在需要做判斷[形成很多分支]的時候
     避免判斷
     從而用空間來買時間
     這種想法可能在很多地方都適用
     [比如下面]
  2. >< 把函數體保存在鏈表中
     與把函數體保存在數組中
     這兩種存儲方式是否能夠相容??
     也許使用上面的技術就可以了
  3. 還有很多地方都可以這樣做
     比如 其他需要判斷是否到達數組的末端的地方
     都可以使用類似上面的技巧
     這優點類似於面向對象中
     把處理函數封裝到數據結構中一樣
     封裝之後
     我就可以把
     [判斷+調用]-優化爲->[調用]
  4. 以這種技巧
     我就能在棧中插入鏈表
     假裝鏈表是棧的一部分
     從而實現 明顯定界的 continuation
  5. 只要用標籤來標記有可能需要被捕捉的地方
     然後 當標籤都被處理完了之後
     在從使用 鏈表 轉回到 使用 棧 就行了
* 不同類型數據的分離
  1. chicken scheme 把所有的數據都分配到棧中
     而蟬語會儘量把所有不同類型的數據分離分配
     尤其是 有 參數棧 和 返回棧 之分
* 數據分配器
** 正名
   我不使用 垃圾回收器 這個術語
   而 使用 數據分配器 這個術語
   這在於
   1. 前者是消極的短語
      後者是積極的短語
   2. 可以被重複利用的 內存空間 如何被發現[所謂垃圾回收]
      其實並不是用戶所關心的
      用戶所關心的是
      在需要的時候 用來實現數據結構的 內存空間如何被分配於用戶
      關於 "分配" 的函數
      纔是這類動態內存管理系統的接口
      而關於 "回收" 的函數不是
** 標記 式 數據分配器
   1. 一個數組被作爲 數據分配器 的對象
      數組之元素被稱爲 點
   2. 點 之間有一個離散的全序關係
      點的集合形成一個離散的一維線性空間
   3. 每個 點 中有 某些 域
      可以用來存儲數據
      通過在一個點的 域 中保存其他點的地址
      點與點之間就能形成聯繫
      點的全體 與 它們之間的關係 就是一個有向圖
      [這個有向圖是受某些性質限制的]
      [比如每個點所發出的有向邊只能有有限條]
      [即 有限叉有向圖]
   4. 數據分配器
      的唯一職責是給用戶分配 點
      唯一接口是 cons 這個函數
      所需要達到的效果是
      給人以有無限個 點 可以被使用的假象
   5. 標記 式 數據分配器
      產生這種假象的方式是
      首先它順着 一維離散空間 取 點
      當取完之後
      某些被用戶用過的點
      現在就又可以被重新使用了
      此時只要能夠判斷出
      那些點是可以被[安全地]重新使用的就行了
   6. 那個靜態的 長度固定的 一維數組
      提示着我們需要去給 數據分配器 一個 工作週期 的概念
      一個工作週期的開始和結束都是在
      cons 把 空間中最後一個點返回之後
      [當然 除了第一個工作週期之外]
   7. 有三個部分 相互配合 來完成工作
      它們分別是
      marking finding cleaning
      其中 cleaning 的工作是伴隨 finding 而進行的
   8. marking
      標記出下一個週期中將被認爲是不自由的點
      在下一個週期中 這些點 將不能被 finding 找到
   9. 也就是說 每個點上面需要有一個[一些]可以用來進行標記的域
      有三個這樣的域
      分別爲 marking域 finding域 cleaning域
   10. finding
       利用了 離散一位線性空間的全序關係
       也就是說 找下一個點的時候會順着這個序關係來找
       沒有被上一個週期的 marking 標記爲 "將不能被 finding 找到" 的點
       就是在需要返回一個點的時候 能夠被 finding 使用的點
   11. 需要定義 什麼是 "將不能被 finding 找到" 的
       定義 "在下一個週期中將不能被 finding 找到的點"
       即 "在下一個週期中還能夠以被引用到的點"
       而 "一個點 能夠以被引用到"
       被定義爲 "從根節點出發沿有向圖的有向邊能夠走到這個點"
       而 "根節點就所有全局變量和局部變量[即參數棧]"
   12. 每當一個點被賦值給全局變量的時候
       或一個點被賦值給一個已知是能夠被引用到的點的時候
       那麼在進入下一個週期的時候
       這個點就有可能是 能夠被引用到的點
       也有可能是不能被用到的
       [考慮一些使從根節點出發的有向路斷裂的副作用就知道了]
       但是重要的性質在於
       如果讓 marking 去標記所有這些可能是 能夠被引用到的點
       那麼所有 能夠被引用到的點 一定就都被標記了
       並且還可能有很多 其實並不是 能夠被引用到的點 也被標記了
       這個性質確保了 數據分配器 的正確性
   13. 如果 在一個工作週期結束的時候 啓動 marking
       那麼它就會從根節點出發
       去進行一個有向圖的深度有限的遍歷
       從而把所有的 能夠被引用到的點 都標記出來
       在下一個工作週期開始時
       所有 marking域 沒有被標記的點
       就是可以被 finding 找到的點
   14. 而 數據分配器 的漸進性在於
       不必讓 marking 在工作週期結束之時才開始工作
       只要保證它在 在工作週期結束之時才完成工作
       就可以了
       所以它可以時不時地去做一些標記工作
       然後休息一會兒
       只要它記住在遍歷有向圖的路程中自己已經走到哪個地方了
       就行了
       [當然每當需要做這種記憶的時候其實就是需要一個棧而已]
   15. 每個點中分別有 爲 marking finding cleaning 而準備的三個域
       每個工作週期結束的時候 三個域會進行一個置換
       所進行的置換 將是三階置換羣中的兩個三循環置換之一
       具體情況如下
       1) 本次 工作週期中的 marking域 所標記好的域
          是給 下一個工作週期的 finding域 使用的
       2) 隨着 finding 遍歷 整個一維離散線性空間
          cleaning 在本次工作週期結束的時候 清空所有點的 cleaning域
          而 本次 工作週期中的 cleaning域
          是給 下一個工作週期的 marking域 用的
          在下個工作週期開始
          marking 所得到的應該是被清空的 域
       3) 本次 工作週期中的 finding域
          在本次工作週期結束之後 其使命就結束了
          它們 將會作爲下一個工作週期 cleaning域
   16. marking 和 finding 的工作是相互獨立的
   17. 這種以 標記而形成的反證法
       來證明那些 那些點在下一個週期可以被使用的
       的方式
       決定了 finding 必須要有一個
       "檢查標記" 以尋找沒有被標記的點的 尋找過程
       這個過程必須 跑遍整個離散線性空間
       從而使得理論上的時間複雜度變大了
** 標記 式 數據分配器 對與 所佔空間大小不確定的數據 的分配
   1. 可以用壓縮式的垃圾回收器來實現對字符串的動態內存管理
      因爲 string 的長度可變
      所以簡單的 marking-gc 是不適用的
   2. 其實單就這一個技術上的不一致之處
      就足以說明 標記 式 數據分配器 是不可取的了
      因爲
      這種設計上的不一致性 將會給維護和擴展帶來很大麻煩
      並且很多意想不到的技術問題可能隨時冒出來
      這都是因爲對於 沒有一致性的設計
      人們很難形成良好的理解所致
   3. 在 marking 工作的時候 如果看見 <string>
      就更改引用點 並且複製字符串
      + makeing 是知道引用點是哪個的
   4. 如果 string 的堆比 pair 的堆先耗盡
      這時就必須重啓 gc
      所以應該把 string 的堆設置的充分大 以避免這種情況
** 標記 式 數據分配器 的缺點
   1. 其時間複雜度在理論上劣於
      複製-壓縮 式 數據分配器
   2. 有可能影響漸進性的情況是
      finding 遲遲找不到一個沒有被標記的點
      當有很多的被標記的點 充斥着那個一維離散線性空間時
      這種情況會經常發生
   3. 沒法以一致的方式處理
      所佔空間大小不確定的數據
      即 此時又必須用到 複製-壓縮 式 數據分配器
** 標記 式 數據分配器 合理性
   1. 如果要求 所佔空間大小不確定的數據 之間不能形成複雜的相互引用
      那麼 這種處理方式就避免了 複製-壓縮 式 數據分配器
      在處理這種 情況時所將會遇到的困難
      即 "更新困難"
      [注意 這種 "更新困難" 只有當要求 數據分配器 的漸進性的時候纔會發生]
** >< 複製-壓縮 式 數據分配器
   1. 這種類型的 數據分配器 只專注於 所能夠被引用到的點
      而不理會不能被引用到的點
      它摒除了 標記 式 數據分配器 中的 finding
   2. 每當把一個cons從一個heap複製到另一個heap
      所有引用這個cons的cons都需要被更新
      做這種更新的方式是
   3. 在每個 cons 中使用一個 標記域
      每當把一個 cons 從 堆甲 複製到 堆乙 時
      標記這個 cons 是已經被複製過了的
   4. 當一個 cons 已經被複製好了之後
      這個 cons 就
      [注意這裏需要使用一些技巧來保存臨時變變量]
** >< 數據類型的分離
   之前分離數據類型是因爲想要用 數組 而不想用 數據堆
   既然 現在使用 複製-壓縮 數據分配器了
   那麼所有的東西就都能夠在一個堆裏了
** >< 更新困難
   1. "更新困難"
      也許可以用 "同步" 來解決
      就是說 去複雜化所有數據的接口
      兩個棧之間相應的數據被認爲是等同
      並且當在接口中初次遇到需要更新的兩個點時就更新它們
      這樣就獲得了漸進性
   2. 每次 遇到一個 點 的時候
      都必須檢查這個點是否更新
      這頗爲不合理
   3. 而 "三染色算法的進行"
      其實是與 數據分配器 這兩種分類沒有關係的
   4. 可不可以這樣
      在做標記的同時 也做 copy
      但是我並不急着使用 被 copy 好的數據
      而只有當 第一個 離散線性空間被耗盡了的時候
      才轉而去 使用被 copy 好的數據
   5. 每個局部變量中也有兩個也可以有兩個域 置換使用
   6. 但是遍歷所有被使用過的點才能找到下一個自由點
      和複製所有被使用的點 才能找到下一個自由點
      不是一樣嗎 ?
      爲什麼說 後者的時間複雜性優於前者呢
      這在於前者需要知道整個一維線性空間有多大
      而後者根本就不需要知道整個一維線性空間有多大
      但是這其實是假的
      但是每當分配一個 cell 的時候
      都必須去檢查是否到達了 線性空間的邊界
      這是否影響複雜度的因子呢?
** 漸進性的缺點
** 最終的設計決策
   1. 我之前使用的是 標記 式 數據分配器
      並且我還發展了一些小技巧來 增加它的漸進性
      但是現在經過考量後
      我決定要轉而使用具有更好的一致性的 複製-壓縮 式 數據分配器
   2. 我想出了結合兩種算法的優勢的方式
   3. 不用擔心
      因爲 數據分配器 的實現是在 虛擬機中完成的
      所以它無論如何不影響語言本身
      因此我可以嘗試多種算法
      並且在不同是情況下讓用戶選擇
      尤其是 我會把漸進性 實現成一個可選擇的性狀
   4. 也就是說
      我希望
      用兩種可選性狀
      "漸進性與否"
      "標記式 還是 複製-壓縮式"
      來形成四種 數據分配器
   5. 但是可能會有困難
      因爲 複製-壓縮式 可以很方便地處理 任意大小的向量和字符串
      但是 標記式 就不行了
      必須有一個額外的 複製-壓縮式 數據分配器 的幫助
      所以我可能只把 "漸進性與否" 提供 爲可選性狀
   6. 現在
      我相信我找到了最好的算法
      我的算法將使得 在使用 複製-壓縮式 數據分配器 的時候
      [即[理論上]更優的時間複雜度]
      也能獲得漸進性
      並且正確處理 循環引用[所謂的指針運算][native pointers]
      作爲一個 具有漸進性的 數據分配器
      在最壞的時候 它也能證自己的正確性
   7. 要知道 詞典目前還不是用 數據分配器 來處理的
      也就是 蟬語 中某些數據類型被 數據分配器
      但是 另外也有靜態的數據
** 遍歷方式
   1. 注意 當使用 單向鏈接的鏈表的時候
      以 cdr 開始遍歷可能是最好的
      而當使用其他模式的數據的時候
      遍歷方式也應該跟着改變
      其目的在於 把相近的東西放到一起
      因爲 CPU cache 的存在
      如果 相近的定西 在同一個 cache line 中
      那麼引用的時候速度對提高很多
** 永遠不關機的系統
   1. 之前我說過
      要實現 對詞典的 動態內存管理
      也許現在就是實現的時候了
      如果實現了對詞典的 動態內存管理
      [不論是作爲數組還是鏈表]
      那麼我就能實現別的語言想都不敢想的穩定性了
* 雙向鏈接的鏈表
  1. 也許我應該直接以雙向鏈表爲基本數據結構
     因爲 它能夠被當作 單向鏈表來使用
     這樣就增強了設計的一致性
     我可以把鏈表單元的實現
     從 [car cdr] -優化爲-> [data <- ->]
  2. 這也能成蟬語的另一個特點[賣點]
     即 極端[不顧成本的]富的數據結構
* 對古典 scheme 的批判
** 返回值
   1. 在古典的 scheme 中
      每當構造子 cons 構造完一個 pair 之後
      都只有且只有一次機會來引用所構造的 pair
      那就是在嵌套的sexp中調用cons的那個位置上
      那個位置上返回的值就是所構造的pair
      #+begin_src scheme
      ;; 除非命名它
      (let ([c (cons '() '())])
        (set-car! c ><)
        (set-cdr! c ><))
      #+end_src
      比如 如果我要編譯一個類 scheme 的語言到 cicada 的話
      我會設計類似下面的語法
      在下面的兩個 <sexp> 中
      也可以引用到這個 cons 將要構建好的 pair
      #+begin_src scheme
      (cons :set-address-to xxx
            :car <sexp>
            :cdr <sexp>)
      #+end_src
   2. 也就是說與蟬語相比
      返回值的更強的可引用性
      只能用利用明顯地命名來達到
      這在語法上是不理想的
      [在 scheme 中也許可以用 macro 來解決這個語法的問題]
   3. 也就是說在蟬語中
      因爲使用了明顯的參數棧
      所以函數的返回值的可引用性很強
** 核心語義
   就觀念而言
   對蟬語中函數作用的理解[靈活地]有兩種
   1) 函數作用於在棧中爲這個函數準備好的參數[古典的理解]
   2) 函數的參數是整個棧[joy所引入的理解]
** 前綴表達式
   1. 後綴表達式的優越性在於
      它更好的反映了程序的運行方式
   2. 比如 CPS 和 monad
      就是兩個 從前綴表達式向後綴表達式轉化的例子
** 數據類型
   - y :: 使用一個統一的數據結構(比如lisp的列表)
          減少了理解整個系統工作方式的負擔
          但是會增加人閱讀代碼時的認知負擔
   - x :: 沒錯
          我想 "認知負擔" 這個名詞很恰當地表達處理
          在使用 scheme 的時候我的某些感受
   - x :: 儘管 scheme 中使得用戶能夠自己定義數據類型的機制並不好用
          但是很容易在 scheme 內部解決這個問題
          [正如很多人利用 lisp 語法所做的實驗所證實的一樣]
          比如
          利用 wordy-list 這個數據結構
          約定一個 wordy-list 中的 :type 這個 key
          讓它後面跟着對類型的描述就可以了
          這樣對類型的描述就沒有任何的限制了
** 衍生
   1. 有很多 scheme[或lisp] 的崇拜者
      把其他語言的語法 lisp 化了
   2. >< 值得對這些系統做一個總結
      並看看它們有沒有什麼值得借鑑的地方
      和需小心的地方 以避免重複它們的錯誤
* 函數複合 與 變換
  1. 應該以 函數複合 爲基礎來組織語言的基礎語義的數學基礎
     想要找一個數學基礎的原因是[且只是]
     爲了能夠得到一套規則來對代碼的表達式進行推導
  2. 複合的時候對參數有一個檢查是合理的
     但是又是困難的
     因爲參數的入棧和出棧是可以很靈活的
     把參數用一個名字打包 就能形成一個對參數的額外聲明
     也許這種技巧能夠解決 推導與變換 的問題
* 優化與變形
  1. 具有局部變量和以函數作用爲主而實現的 lambda 演算中
     可以看到
     利用對 lambda-term 的變形
     可以對程序做出很有趣的觀察
     這些觀察和變換可以用來優化程序
     這都是因爲 lambda 演算 的良好的數學性質所導致
  2. 而
     在蟬語這種以函數複合爲主的語言中
     如果仔細甄選原子性函數[如joy所做的那樣]
     那麼就也能達到有趣而良好的數學性質
     這裏所謂的良好其實是說
     利用這些性質我們能對一段函數做很多的恆等變形
     就像是對一個數學公式所做的那樣
     這樣就也達到了 lambda 演算 的優點
     [這些是組合邏輯的課題]
  3. 關於高階
     只有當這些變換能夠對某些高階的函數而進行的時候
     才會有用
  4. 把運算在編譯時期來做就是了
     但是理論上能夠在編譯時期做的運算可能是非常多的
     >< 這裏需要一個分析
  5. 當我純粹在使用函數複合的時候
     所謂的變換
     就是以個複雜的 代數 而已
     只要研究這個代數的性質
     我就能獲知 那些變換是可能的
     [我想在這裏 我能得到很多數學上的支持]
     [也許我還能反過來給數學一些新的啓發]
* 關於表達式的形態
  1. 對於被當作二元運算的二元函數來說
     只有當這種二元運算滿足結合律的時候使用infix纔是令人滿意的
     + 比如: + * max min gcd `函數的複合' `字符串的並聯' 等等
     這正是joy所想要表達的
  2. 對二元運算的結合性的證明 可以被轉化爲對一種特殊的交換性的證明
     #+begin_src
     (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
     或者:
     (p + q) + r  ==  p + (q + r)  <==>
     p q + r +    ==  p q r + +    <==>
     + r +        ==  r + +
     #+end_src
  3. 再考慮一下別的運算律 簡直有趣極了
     #+begin_src
     分配律(或者說對某種同態變換的描述):
     中綴表達式: (a+b)*c == (a*c)+(b*c)  <==>
     後綴表達式: ab+c* == ac*bc*+  <==>  ???
     但是至少我知道 +(c*) =/= (c*)+
     要想填上上面的問號 可能就需要 λ-abstraction 的抽象性
     否則我根本沒法描述某些東西

     交換律:
     a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

     +* =/= *+
     abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
     #+end_src
  4. 把後綴表達式考慮爲對棧的操作是自然的
     並且這樣的理解方式所帶來的一個很大的好處就是實在性
     這就又回到了哪個``小孩玩積木''的比喻了
     比如我的十三歲的弟弟可以問我"那個函數的參數是從哪來的?"
     我就告訴他是從棧裏拿出來了
     "那個函數的結果去哪了?"
     我就告訴他結果放回到棧裏了
     數學 和 編程 就都像一個小孩在玩積木一樣
     對了 他還可以問我這個函數是從哪裏來的
     我就說是從詞典裏找來的
* 結合代數
  1. 蟬語 是最有趣的結合代數
     利用這個結合代數似乎可以模擬任何代數結構
     [甚至是非結合代數]
     1) 比如上面對函數作用的模擬
        [儘管函數的作用不是結合的]
     2) 又比如我可以把兩個矩陣入棧
        然後一個矩陣乘法函數可以像 "*" 乘兩個數一樣
        爲我返回矩陣的積
        [儘管矩陣乘法不是結合的]
     3) 又比如列表處理可以用來實現 digrap
        而 digrap 已經出離代數的範疇之外了
        但是它還是能夠被forth的結合代數所模擬
  2. 但是僅僅 "是" 一個結合代數
     這個性質太弱了
     我所需要的是能夠形成 "運算律"
     以對 "代數表達式" 進行 "形變"
     這可能就非常難了
  3. 要知道
     當你所處的範疇越大
     你所能獲得的特殊性質就越少
     而 "運算律" 正是依賴於這些特殊性質的存在的
  4. ><><>< 也並不是不可能
     但是可能需要全新的技巧了
* 語法擴展機制
  1. 目前在蟬語中我能提供的語法擴展機制都是相當樸素的
  2. 我能想到的更複雜的語法擴展機制
     就只是 去提供一些 用於 語法解析的基礎函數而已
  3. 我想
     我並不能實現 類似 scheme 的模式匹配的 語法擴展機制
     因爲 模式匹配的是 sexp
     它已經是豐富額樹狀結構了
     而我只有字符串而已
  4. 只要有良好的設計
     我就能在我所提供的 關於語法解析的 底層基礎設施上
     實現類似的模式匹配機制
     並且嘗試新的有趣的技術
  5. 重點是我要求
     沒有額外的語法擴展期
     只有編譯期和執行期
     在語法擴展在編譯期進行
  6. 也就是說
     每個語法關鍵詞 都爲自己負責
     而不是由一個全局的 處理器 在分配並處理這些語法關鍵詞
  7. 我想正式上面這個性質使得
     我能夠把語法擴展放到編譯期進行
* 優化
** 對變量的靜態類型聲明在於
   1. 每次在使用這個變量的時候
      都可以決定應該調用的函數的類型了
      但是種情況在蟬語中好像不存在
      因爲根本就沒有局部變量
   2. 實是存在的
      因爲有僞局部變量
   3. 如果對於爲局部變量
      很多函數也能在編譯期被作用那就好了
** 還有一種極端的優化是
   爲了在編譯期獲知某些信息
   而在編譯器就執行某些應該在執行期進行的函數[到一定的限度]
** 我在這方面的知識還很欠缺
   不能說更多了
   但是沒有局部變量這個特性
   可能會對優化的程度有影響
* 教學
** 具體語義的優越性
   比如對 monad 這個概念
   在 scheme 中解釋它
   要比在 haskell 中解釋它
   更容易理解的多
** 具體語義的缺點
   這在於 用抽象 來形成對複雜性的控制
   少了抽象就少了控制
   也就是放任的複雜性
* 函數作用的羅嗦的新語法
** 記
   考慮新的語法
   即我在 lambda-calculus 中設計的語法
   這種語法是很好的
   在用鏈表來實現函數體時
   它的語義很容易被實現
   >< 但是當使用向量來實現函數體時
   這種語義就不一定能很好的實現了
** 多次引用
   只要限制所能使用的約束變元的數量
   就能夠用棧來處理它們
   需要注意的是對棧的 pop 應該如何做
   是明顯的 pop
   還是隱含的 pop
   還是提供豐富的語法來做靈活的控制
** 同名約束變元的作用域
   如果這裏根本沒有函數提的嵌套
   那麼也就沒有這個計算作用域的問題了
   函數體的嵌套
   是在需要匿名函數的時候才需要的
   所以那些可以留給鏈表語義來處理
** 語法糖的提供
   可以提供語法糖
   在沒有在作用中指明函數參數名的時候
   以默認的方式去取參數以作用
** 效率問題
   這所有的考量都來自於語言的很強的動態性
   其實某些之前所想到的優化在這裏也是可以進行的
   並且可能能夠被進行的更好
   因爲此時在代碼中提供的信息更豐富了
** 關於多棧的語法設計
   也就是說
   方針上
   有了一個很大的改變
   即 把編碼信息的負擔分開了
   一部分在函數體內
   一部分在函數作用的語法中[即在函數體外]
** 與古典的棧處理的相容性
   也許不能相容了
   但是如果設計豐富的處理方式就又能相容了
   但是缺點是對簡潔性的傷害
** 就語義的疑問
   一個函數體內
   所表示的是很多函數的複合
   在使用了新的羅嗦的語法之後
   這些函數的複合方式 能夠如何豐富呢 ?
   即使沒有嵌套的幫助
   在同一個函數體內
   通過擺弄棧中的參數
   複雜的函數複合也是可以實現的
** 圖示
   |----------------------------------------+--------------------------------------------|
   | 帶名字的三角                           | 參數                                       |
   | [小三角 名字可以寫在三角附近]          | 小三角指向一個小黑點                       |
   |                                        | 就代表把這個小黑點從這個吸入口吸入到函數內 |
   |----------------------------------------+--------------------------------------------|
   | 帶名字的圓圈                           | 函數                                       |
   | [大圓圈 名字可以寫在圓圈裏面]          |                                            |
   |----------------------------------------+--------------------------------------------|
   | 小黑點                                 | 棧中的數據                                 |
   |                                        | 函數的返回值                               |
   | [沒有名字的]                           | [每個函數可以輸出多個小黑點]               |
   |----------------------------------------+--------------------------------------------|
   | 還可以用小白點表示 中間的過度參數      |                                            |
   | 這些參數剛被函數輸出之後就被吸走了     |                                            |
   |----------------------------------------+--------------------------------------------|
   | 線                                     | 函數的複合方式                             |
   | [鏈接線的過程就是擺弄棧中的數據的過程] |                                            |
   |----------------------------------------+--------------------------------------------|
** 關於圖示的疑問
   1. if else then 所形成的分支應該怎麼畫出來呢 ?
   2. 被吸入的數據如何被處理呢 ?
   3. 就語法的設計而言
      如果我要求所有的以這種方式作用的函數
      都必被圓括號括起來 (function)
      那麼就更像是圓圈了
      這樣我就允許了別的形式的函數的存在
      比如 function 以默認方式作用
      而 (function) 以這種有趣的方式作用
   4. 是不是所有的語法都能系統地對應到這個圖中來呢 ?
      如果是的話 這個個圖示系統就太適合教學使用了
      1) 函數定義怎麼辦 ?
      2) lambda 怎麼辦 ?
         lambda 就是函數定義嗎 ?
      3) 是否在代碼方面 棄用文本性的東西 而改用特殊符號 ?
   5. 注意如果還是想用登記函數的技巧的話
      那麼這裏圓圈中的函數[消息]名必須在找到相應的數據的時候
      才能被確定下來是那個函數
      但是要知道 因爲使用了明顯的 參數名[小三角]
      所以這裏編譯器所知道的信息更多了
      因此
      編譯器有可能 能夠對代碼 作出更好的分析
** 與約束變元的區別
   1. 這裏是在函數作用的語法中增加對參數的明顯命名
      這與約束變元的性質完全不同
      這中命名相當於加長了函數的名字
   2. 而這裏對應於約束變元的是
      :x 而 不是 <:x
* 組合子
  1. 在 scheme 中組合子也是經常被用到的
     也就是說
  2. 組合子 之集合的有限性
     還有其實現的簡單性
     [相比 lambda 演算而言]
     可以用來形成 對嵌入式系統的函數式編程
* 代數性質的退化
  1. 如果考慮整個結合代數整體
     它作爲代數的性質是嚴重退化了的
     與置換羣中的置換相比這裏用來做複合的函數簡直是怪物
  2. 重點在於不要考慮整體
* 什麼是程序語言
  - y :: 對語言學的不斷學習也許在於
         希望我的表達能夠儘量緊跟我的思想
         因爲沒有什麼比有一些想法而難以表達出來更令人痛苦的了
         尤其是學習一門外語(程序語言)的時候
         這種表達與思想之間的脫節是最痛苦的
         同樣也沒有很多事情是比設計一個語言更有趣的了
         當你有能力作出這樣的設計的時候
         你一定會產生很多新的想法
         因爲對思想的表達影響思想本身
  - x :: 但是說我們要設計一個新的語言是什麼意思??
         讓我們來更細緻地分析一下這個任務
  - y :: 我們可以通過讓我們的所指變得狹隘來具體化我們的表達
  - x :: 但是我們不要使用傳統的定義一個程序語言的方式
         看看我們能有什麼有趣的新想法
  - y :: 好的
         我知道有很多傳統的描述程序語言的性狀的術語
         比如 函數式 面向對象 模塊系統 類型推到系統 等等
         我們要暫時拋棄這些術語
         而試圖迴歸問題的本質對嗎?
  - x :: 沒錯
         並且我想最本質的地方可以沒有一箇中心
         讓我們以 "去中心化" 的方式
         儘可能多的描述我們想要尋找的源頭
         ><
