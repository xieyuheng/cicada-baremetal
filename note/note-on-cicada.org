#+TITLE: note on cicada
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* TODO new
  1. 讀更多的 joy 的代碼
     以求靈感
  2. 設計新的定義函數的語法
  3. 設計語法以把有向圖使用爲主要的數據類型
     並且使得這種數據類型和 可愛圖 對算法的表達結合起來
  4. 使用 solresol 所帶來的啓示
     重新考慮對些東西的命名方式
  5. 可以去總結一下之前對 <the little schemer> 的筆記
     以成爲一個介紹語言的範例[介紹遞歸函數的]
     看看在 蟬語 的語義下我能如何改變教學的策略
  6. 我發現重要的一點是在設計之初就把
     並行 包管理 除錯器 觀察器 文本編輯器 等等
     都設計好
     因爲要知道 上面的這些問題
     都被其他語言的設計者們 以各種方式解決過了
     我只需要融會各家之思路
     來設計出最好的解法就行了
  7. 完成關於 數據分配器 的筆記
  8. 關於 結合代數 變形 與 優化
  9. 關於多棧的新語法的設計
  10. 關於類型系統的新語法的設計
  11. 虛擬機的設計
* TODO old
** better string reading support
** better string writing support
** better number writing support
** write a better meet-undefined-word
   1. 如果我想要在 cicada 的代碼中重寫這個函數
      那麼 只要用一個變量
      讓這個函數調用這個變量中所保存的函數就行了
      這樣我就能以相當精確的方式 重新設置處理未定義的位置的函數了
   2. 另外的使得對某個函數的動態改變稱爲可能的方式是
      直接從 symbol 找到找新的 symbol 所對應的 函數值
      當更新 一個 symbol 所對應的函數之後
      就能 重新設置處理未定義的位置的函數了
      但是這種方式並不是很精確
   3. 那麼我需不需要在 cicada 的代碼中重寫這個函數呢 ??
      也許是需要的
      並且在 不同的 語言核下
      所希望使用的 處理函數可能是不同的
   4. 但是這種全局變量的使用可能並不是很好到的編程實踐
** redesign the debuger
   1. as the "debuger" is defined in cicada code
      it is hard to do good error handling in assembly code
      這是因爲我沒法在出錯的時候即使調用 debuger 來報錯
      - 比如 通常的函數類型的錯誤
        我應該 及時的 調用 debuger 來報告錯誤
        而在不利的條件下 我必須 返回一個出錯碼
        來表示函數 所接受的數據類型不對
** re-writing garbage-collectior
   1. ??? 對於新的 define 要更改 GC
      整個 GC 都應該被重寫了嗎 ???
** make good use of indentation
   1. for wodili 應該 在 wodili 的已有的 解析器 的基礎上
      增加一個 好好 利用 indentation 的解析器
      兩種解析器各自有各自的用處
   2. 把 利用"支撐樹" 來進行相對引用的 性質加到 yaml 中
      就能 形成 我想要的 digrap 的語法
** write a cross compiler
   1. 從最簡單 的 babystep 開始
   2. 編譯 bootloader
   3. 注意要保持設計的靈活性
      或者直接從 文檔開始
      用中文寫文檔 以加快速度
   -----------------------------
   1. 需要 cicada-assembler 的理由:
      1) 統一 命名規則
      2) 讓我 能夠探索一些關於編譯的技術
      3) 有些 小的 CPU 並沒有 類似 fasm 的 合適的編譯器的
         當我有 cicada-assembler 的時候
         我就能不受限制於這個事實了
      4) 當我調整代碼的結構
         以讓我方便地 維護兩個彙編版本的時候
         我就發現 其中有很多重複的部分
         想要消除這些重複
         我可以通過 更多的 把文件 分開來實現
         但是如果我想保持
         我的 類文學編程 組織代碼的風格的話
         也許 創造一些新的東西來支持 我的風格就是必須的了
   2. 不需要 cicada-assembler 的理由:
      1) 一個人認爲 一個語言需要這種東西
         可能只是因爲 當這個語言的編譯器能夠自己編譯自己的時候
         看起來很 cool 而已
      2) 爲了 實現 一個 x86-64 的彙編器
         有太多的 關於 CPU 的底層細節需要 被掌握
** erlang's bit syntax
   在於讓人方便地處理 bit fields
   這在於 能 用模式匹配
** about UI
   我可以把那幾個 核心的棧 的圖示 放在 左邊的一個窗口裏
   在這之後 我就能設計 debuger 的更好的使用方式
   但是一個問題是 當我的界面不再是一個簡單的解釋器的時候
   我就不能 直接利用 emacs 了
   也就是必須 要先寫自己的 文本編輯器
   之後才能考慮窗口 之類的問題
** learn from isforth
   ??? switch from fasm back to nasm ???
   for better linux support
** word boundary
   1. ><><>< the note about word boundary is wrong ???
** branch
   1. 是否對 branch 給更好的支持 ?
      用 label 來計算 offset ???
** english-core
   1. use hash-table to lookup dictionary
      then mutually recursive call
   2. 用hash-table來find
      這些不必實現在彙編代碼中
      因爲 list還是必要的
      因爲這樣就能保持對字典的靈活控制
      所以 需要寫一些函數把
      字典重新加載到 hash-table 中
   3. need to redesign the way to do test
      should tangle test to separated file
      for i do not have my org-mode now
   4. wodyli processing
      then digrap in cicada
   5. tab completion in the REPL
      (or in text editor)
   6. let functions in assembly-code
      be able to call functions in cicada-style-assembly-code
   7. >< 實現對多種實現技術的定製
   8. >< 重新思考某些術語和命名方式
   9. cicada should design it's own abstractions of IO
      this can help cicada to be portable
      現在 有的只是 read-char 和 write-char 兩個基礎的東西而已
      這樣太貧乏了
   10. memory allocation
   11. flow-point number
   12. >< maybe substitute word to execute in lambda-body
   13. >< maybe syntax-check
   14. >< modern pattern-match  HOW ???
   15. better interface for debuger
   16. TAIL-CALL-OPTIMIZATION in apply lambda-body
   17. more protection on allocated memory
       maybe use paging
   18. cicada-assembler
   19. cicada-editor
   20. APL-like array-processing
   21. needs better sexp-reader&write
       design a better way
       to use local-label to from list-with-circuit
** baremetal
   1. 作爲一個使用純粹釋性語言
      我應該 重新 思考 對 公共的 函數庫的使用方式
   2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
   3. SMP support
      作爲一個以棧爲基礎的語言
      我應該重新思考 利用 多核 的方式
   4. learn more from baremetal-OS
   5. convert the code about storage & BMFS from old-asm to forth-like-asm
      to examine the bug of "readsectors"
   6. fix "bye"
   7. design game-like UI in text mode
   8. rewrite cicada to make it standard and portable
      (this will always be TODO)
   9. to allow executables to dynamically access external functionality at run time
      and thereby reduce their overall memory footprint
      在我的操作系統中 我可以以我的方式來完成上面的這種特性
      我只需要一個 "need" 函數 來聲明 某段被解釋的代碼 所需要的 sub-dictionary
      我還需要一些 處理 sub-dictionary 的函數
      sub-dictionary 的性質 是 :
      - 它可以有很多個
      - 並且它所佔用的 內存可以被回收的
      - 內存的回收 可以用 類似字符串的 垃圾回收器 來完成
      - 當全面地使用 hash 來實現 dictionary 時
        內存的回收 也可以用 類似鏈表的 垃圾回收器 來完成
** cicada-idea
   1. cicada-idea 本身是一種開源硬件
      它是專門爲 編碼者 和 開源硬件hacker 而設計的 編程終端
      有專門爲 控制和編碼開源硬件 而設計的 硬件接口
   2. 作爲開源硬件 對 cicada-idea 的銷售和重新設計 不需要被 我 授權
      我 作爲 開源硬件的銷售商之一 而盈利
   3. cicada-idea 擁有 開源的 基於結構化文本編輯器的 操作系統界面
      cicada-idea 以 cicada language 爲主要的編程語言
      cicada-idea 有 以 cicada language 爲主要語言 而開發的 編碼環境
* 記
** 蟬語之優
   1. 某些性質被我認爲是優點
      然而 同樣的性質 在不同的人看來可能是缺點
   2. 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
      這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
      這個性質是我最喜歡的
      就算是對於 scheme 和 smalltalk 這種設計良好而簡潔的語言來說
      這種對整個系統的直觀理解也是不行的
      因爲 這兩種語言的 簡潔性 是以很高的抽象性爲代價的
      而 蟬語 的設計就是要在 保持這種 被簡單而直觀的理解的可能性的同時
      去實驗某些性狀 以達到 不比 scheme 和 smalltalk 弱的抽象能力
   3. 獲得關於一個理論的堅固知識的方式就是去實現它
      這同時也幫一個人考察了他所觀察的理論的可實現性
** 蟬語之劣
   1. 某些性質被我認爲是缺點
      然而 同樣的性質 在不同的人看來可能是優點
   2. threaded-code 的侷限性
      主要在於 這種風格的機器碼很可能 難以優化
      但是其實只有在具體的測試和實驗之後
      才能得出真正的結論
** 簡體繁體
   1. 簡體 繁體 西文 和所謂也 ?
      聲韻形態皆思之載體
      過分追究表達方式之異同之人
      未嘗得道也
   2. 在蟬語中 以傳統漢語爲主要表達方式
      而在命名規則和別名系統的幫助下
      我可以讓 簡體 繁體 西文 並存
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
** 設計決策
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** 正確的设计
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** >< 函數組
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** >< 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
** 以名釋性
   1. 在全面地貫徹類型系統之後
      以名釋性 的方式就改變了
      此時需要強調的就是命名規則了
   2. 以名釋性
      的目的還是減輕代碼的閱讀者在認知上的負擔
** bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** 代碼的閱讀者的認知上的負擔
   集成開發環境 是爲了 通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來 獲知 詞 的語義
   與命名規則一樣 這一切都是爲了
   減輕 代碼的閱讀者的認知上的負擔
** 蟬語中的命名規則
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** 編程範式
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** 對 OO 的支持必須被放棄
   1. 因爲 所想要實現的 OO 系統中
      參數與方法之間的對應 只有在運行時才能確定
      這對效率來說是個打擊
   2. 因爲 OO 與 對函數的靈活使用是相互衝突的
      在我看來 不同的編程範式 代表了不同的思考方式
      而對多範式的支持 只能帶來混亂
   3. 對於 "作用" 來說這種面向對象的技巧能夠節省命名空間
      但是對於 "函數複合來說" 則不然
      在蟬語中我經常需要把函數複合起來
      以定義新的函數
      如果所有的函數都被保護到類型的內部了
      之後找到相應類型的值的時候才能調用到這個函數
      那麼我就沒法方便的做函數的複合了
   4. 其他的語言中是用參數名和類型推導
      來解決上面這個問題的
   5. 而在蟬語中 我可以通過一個 一致的命名規則來解決這個問題
      但是這樣就把函數的命名規程化了
      在我看來少了很多靈活性和樂趣
   6. 綜上所述
      對 OO 的支持必須被放棄
** smalltalk 中對函數的命名
   1. smalltalk 中函數的命名是非常靈活的
      函數的命名變成了
      對象之間傳遞消息的協議
      這種特性正是爲了解決命名問題
   2. 我把這種特性理解爲
      - 把函數名 分散爲部分
        每部分匹配一個參數
        而約束變元
      - 而在 蟬語 中
        函數命名將被限制與一個詞
        在 蟬語 的 lambda 中
        是約束變元的名字在被用來匹配參數
        在函數作用的時候
        lambda 的約束變元的名稱 可以幫助增加代碼的可讀性
        儘管這些約束變元的名字並不出現在 函數的名字當中
   3. 但是
      在 smalltalk 中
      函數的使用可能並不靈活
      函數不可能被作爲一等公民來對待
   4. 但是
      有代碼塊可用
      並且 也較爲良好的代入語義
      所以 也許與 lambda 等價的東西是存在的
      然而
      就算 代碼塊 的語義能夠用來實現
      與 lambda 等價的東西
      對這些東西的使用也是不方便的
   5. 那麼
      如何說 cicada 中的函數是一等公民呢 ?
      這在於 ><
** >< 語義重載現象
   1. 在蟬語中現在還有一個語義重載現象
      那就是 函數 既可以是 一個詞典中的動詞
      也可以是一個 lambda-term
* 實現
** 記
   1. 我先把所有的設計都寫成文檔
      然後再着手實現
      否則當實現到了後面
      如果發現了某些設計需要更改
      就必須更改很多前面的代碼
   2. 我能這樣做
      只是因爲
      第一個版本已經被實現好了
      我已經知道在實現過程中可能遇到的技術難題是什麼了
** 虛擬機
   1. 這次是我在濫用術語了
      當我考慮是否要使用一個虛擬機還有鏡像文件來實現蟬語的時候
      我才發現這一點
   2. 要知道虛擬機和處理器
      都是指令集編碼的簡單的解釋器
   3. 我之前所說的可擴展的虛擬機
      即 內部解釋器
      於一個虛擬機非常相似
      我應該利用這種相似之處
      而實現一個更符合虛擬機這個屬於傳統意義的虛擬機
   4. 也就是說讓整個詞典可以靜態地存在於一個鏡像文件中
      這類似於設計一個可執行文件格式
   5. 詞典中的每一部分都可能依賴於詞典中的其他部分
      並且可能有相互的依賴
      在把鏡像文件中的詞典中的一部分加載到內存中的時候
      相互的依賴關係需要被處理
** 另一種實現方式
   1. 我可以在這裏辨別出兩種實現方式
      1) 用詞表達的可執行文件
         被蟬語的解釋器加載並解釋
      2) 用八位組碼表達的可執行文件
         被一個單純的 threaded-code 解釋器加載並解釋
   2. 它們的優劣分別分析如下
      |      | 一 | 二 |
      |------+----+----|
      | 層次 | 少 | 多 |
      | 加載 | 慢 | 快 |
      | 大小 | 大 | 小 |
   3. let the dictionary be a loadable linkable executable format
      parts of the dictionary could be linked to be the whole
      runtime changes from "a word interpreter" to
      "a dictionary loader and linker"
      plus "a threaded-code interpreter"
      in the last case, no string input is needed
      while a REPL is still can be provided
   4. 第二種方式最大的好處是
      我可以實驗自己設計指令集
      與指令集的編碼方式
   5. 更大的好處是
      在虛擬機的幫助下
      移植的方便性就達到了最高
   6. 這種 作爲虛擬機的 threaded-code 解釋器 是一定能實現的
      問題是 詞典這個數據結構如何設計
      如果發現這樣的設計在加載的效率上還不如對字串的處理
      那麼就失去意義了
   7. 虛擬機之重要性在於
      我所使用的彙編器中所能實現的宏限制了我對詞典這個數據結構的設計
** 改良
   1. 我需要的性狀是
      在可以把代碼編譯成 bytecode
      以讓虛擬機 加載並解釋
      而這並不影響 REPL 的存在
   2. Exit 應該被編譯器處理爲
      而不應該被解釋器處理
      也就是說 尾調用優化 應該被編譯器來做
      而不應該被解釋器來做
      但是 ITC 阻止了這種編譯時期的優化
      STC 倒是可以
      也就是要區分 call 和 tail-call 兩個指令
      並且把它們寫到函數體內
      函數體內所保存的就直接是可以被執行的指令
      其實在這裏我還是能夠使用 "間接"
      把函數體和函數頭分開
      並且當使用虛擬技術的時候
      我的指令集是可以針對我的目的而優化的
      這樣 literal 和 branch
      就可以被實現爲和 call 還有 tail-call 等同的東西了
      call 這個指令本身就可以有各種 間接的版本
      這才是正確的實現方式
      也就是去用空間來換時間
* 學文記
** 方法
   1. 蒐集古典例句
      查而辨其結構
   2. 語言有一奇妙特性
      在於 它能被用來描述它自身
      正是因爲這一特性
      寫一篇辨析語言結構的文章才成爲可能
   3. 在辨析結構之時
      需謹記 因 語言成於人與人之間的交流
      故 重任交談之場景 反映於語言之結構中
** 界說
   - 詞類 ::
   - 名詞 :: 名詞爲本
   - 動詞 :: 動詞以述名詞之行也
             不可獨解
             解時 需助之以名詞或代詞
   - 形容詞 :: 以形名詞之容也 不可獨解
               但是上面的界說是有問題的
               因爲 數 應該被視爲形容詞
               但是 數 又被當作抽象的名詞來被處理
               並且形容詞所形容之性狀通常都是可以被量化的
               所以 形容詞對名詞之限定 與數之結構息息相關
               並且所謂用來形容動詞的狀詞亦可以被量化
               但是 其實作爲限定詞 它們也有簡單的限定分類之用
               未必階爲狹義的量化
   - 數學結構 :: 動詞是這些性質就時間而言的變化
                 然而要點是
                 語言的語義就 對話場景
                 還有 時 空 二量 而 優化了
                 這種優化可用關於演化的理論來解釋
   - 更細的特點 :: 我其實是在類比數學語言與自然語言
   - 句讀 :: 句讀者 語法解析 也
** 判斷
   1. 判斷句
      不用 "是"
      而並兩個名詞短語然後加後綴 "也"
   2. 這就使得中文看起來像是沒有語法的語言
      做語法解析需要憑藉對語義的理解
      而"相對"正確的語法解析
      又是得到"更"正確的語義的前提
      所以我們的大腦中處理漢語意義的模塊像是一個迭代函數
      我想
      讓這個"迭代函數"發散的點是存在的
* 句式
  1. 以 主 謂 賓 爲基礎語順
     施 句式 以變
     1) 使成
        主 謂 賓 成 : 燒燭短 引杯長
        主 謂 成 賓 : 折斷 吹散
     2) 被動
        賓 爲 主 所 謂
        賓 被 主 謂
     3) 把
        主 把 賓 謂
  2. 而蟬語的特點是
     在大多數情況下 動詞後置
     並且似乎沒有主語
     或主語爲隱含的 我
  3. 凡 []
     [] 者 曰 []
     [] 者 曰 []
     用以描述大類下的小類
  4. 語法其實就是一個樹狀結構
     需要設計的是如何把這個樹狀表示出來
  5. (名 體*) 動詞也
     (名 體* 詞性) 而 編撰入詞典
     (名 體* 詞性) 也
     (體* 詞性 名) 也
     蓋 體* 詞性 名 者 也
     #+begin_src cicada
     蓋 (* n -- n! *)
     復 一乎 則 已矣
     再 復 1 減 階乘 乘 已矣
     動詞 階乘 者 也
     #+end_src
     "也" 簡單地由 "而 編撰入詞典" 就語法優化而來
     一個字符串 接受到 "編撰入詞典" 這個信息的時候
     會調用一個處理函數
     這個處理函數
     會把字符串語法解析了
     然後把一個詞的定義編撰入詞典
* 語法特點總結
  1. 我現在理解爲什麼 lisp 直接使用語法解析樹爲語法了
     這樣就避免了去在語法設計上耽誤時間
     而對 蟬語 而言
     語法的特點 其實並非完全地是 後綴表達式
     全局是後綴的 但是局部可以是任意的
     總結一下對輸入的[函數定義]處理
  2. 以前後標識 定界一個字符串
     這個字符串被入棧之後
     一個[字符串的]處理函數[詞的製造者]會被用來處理它
     儘管 函數體是被允許嵌套的 但是這個函數卻不是遞歸函數
     這個處理函數會以相對線性的方式來語法解析這個函數體
     1) 遇到最一般的詞的時候
        會寫[call word-address]到內存中
     2) 遇到數字會寫[number n]到內存中
     3) 等等
     4) 遇到語法關鍵詞時會調用那些語法關鍵詞來處理
        調用結束之後會再返回主要的循環中
        這個 主要的循環就代表了 "全局之後綴性"
        而對個別語法關鍵詞的調用就代表了 "局部之任意性"
  3. 詞典編撰者作爲一個字符串處理函數
     會一個詞一個詞地遍歷這個字符串
     同時 被寫入的內存區域[詞典]的地址 之指針
     作爲一個隱含的參數被 詞典編撰者所查看
     這在於 當需要的時候
     已經 在對前部字符串做處理時 編入詞典中的東西
     在對后部字符串做處理時 被改寫
     尤其是對數據類型系統的優化需要用到這個性質
  4. 關於類型系統
     我提供 "之" 和 "而" 這兩個可以被以最靈活的方式使用的虛詞作爲關鍵詞
     當 詞典編撰者遇到 "之[或而] <function>" 時
     他會看 當前函數體指針 之前的一個位置 是什麼類型的值
     1) 如果是一個函數調用
        那麼 就 編譯一個動態的消息傳遞式的函數調用
        [<symbol>] [call function-zhi]
     2) 如果是一個值
        就看它的類型
        然後 依據消息 找到登記到這個類型下的函數
        要知道 在新的類型系統被加入之後
        每個函數都包含信息 來表明 這個函數可否在編譯期被作用
        現在就需要用到這些信息
        [需要設計一致的註釋格式來完成這一點]
        來看一看所找到的這個函數能不能在編譯時期被作用
        [注意這裏還要檢查 是否除了主要參數之外 其他的參數都齊備]
        典型的能夠在編譯時期被作用的函數是
        那些對參數棧之外無副作用的[純粹]函數
  5. 這樣就使得
     在 "之[而]" 後面的詞的意義是上下文相關的
  6. 是否 規定
     這種使用 "之[而]" 的對函數的調用 爲 唯一的調用函數的方式呢 ???
     原來的 沒有全面地引入類型系統的時候的函數調用方式是否要保留呢 ???
     是需要保留的
     考慮那些零參數的函數就知道了
* 多棧
  1. 所有的棧都能用來傳遞參數
     但主要用主棧來傳遞參數
  2. 主棧能形成僞局部變量語義
     副棧能形成真局部變量語義
  3. 直接把對多棧的支持添加到虛擬機中
     以減輕 語法編撰者 的工作負擔
     需要設計一個指令集
     這個指令集需要編碼各個棧
  4. 多棧是爲了實現 有限個局部變量 的語義
     我可不可以把機制設計地更靈活一點
     而不限於局部變量這一種使用方式
     這就要求了每個棧必須有自己的名字
     甲 乙 丙 丁
     而我所能做的是在每個函數體內臨時重新命名這些棧
     並同時改變操作這些棧的函數名
     這樣在使用局部變量的時候 在語法上可能就比較羅嗦
     要知道 如果要設計靈活的使用方式的話
     就需要能夠選擇在命名一個新的棧的時候是否初始化它
     並且這裏對棧的操作也應該相對完整
     而不像之前那樣 只實現對主棧的操作
     也就是說這每個棧都是一個數據結構不是嗎 ?
     對這些數據結構的一致地使用方式 就實現了局部變量這個效果
  5. 這裏的局部變量
     如何與 lambda 中的局部變量相調和呢 ?
     讓這兩種實現局部變量的方式完全正交就行了
     這就要求要設計出區別足夠大的語法來使用這兩種語義
  6. 這裏的 "暫時改名" 這個語義很有意思
     這種改名只有在編譯時期才有效
     這種編譯時期的處理
     可以被看成是 編譯時期對 "1 2 +" 的處理一樣
     也就是說 也就是說我已經有了
     一致地 讓某些運算在編譯時期被處理的方式
     但是需要注意的是 這種東西也許應該被以明顯的方式聲明
     因爲 某些帶有副作用的函數 就算 它們的參數已經在棧中了
     這些函數還是應該被在運行時作用
     我給出機制 來幫助用戶明顯地控制這些東西
  7. 也許在這些新的語義被加入之後
     我已經不能說蟬語是很簡單的語言了
  8. 對多棧的處理是由 詞典編撰者 完成的
     #+begin_src cicada
     蓋
        甲棧 爲 計數棧
        乙棧 爲 長度棧
        丙棧 爲 地址棧
     註 (* [入 地址棧] [入 長度棧] [入 計數棧] --  *)
     已矣
     動詞 <某> 者 也
     #+end_src
     假使
     甲棧 乙棧 等等
     都是棧類型的值
     那麼
     "甲棧 而 名 計數棧"
     [可以被優化爲 "甲棧 爲 計數棧"]
     就是一個在編譯時期被處理的函數調用
     這種別名信息應該被保存在 函數體內
     因爲這些信息可以作爲動態的文檔被調用
     但是 如何保存呢 ?
     給函數頭增加一個域
     然後 使用一個類似 函數體的數組
     用來保存 編譯時期需要用到的信息
     [當然 這些信息也可以被作爲文檔來 查詢]
     這樣就行了
     [使用 <symbol> 或者 使用 <string> 都沒有關係]
     [有時 對於 <symbol> 的使用 我還有些疑慮 有些擔心散列函數的穩定性]
* 優化語法
  1. 我保持 上面所描述的統一的編譯語義
     並且我提供一個簡單的優化語法的方式
     即
     "而 名" -> "爲"
     "而 編撰入詞典" -> "也"
     只要把 "爲" 和 "也" 這類詞定義爲一類特殊的語法關鍵詞
     就行了
  2. 另一種優化
     就像在中文中
     當時形成排比時 就可以省略一些重複的助詞一樣
     在sexp中當形成排比時也能省略一些括號
     [比如 cond 就是典型的情形 shen 做到了對語法的優化 而 scheme 沒有]
* 註釋的格式
  1. 要設計 關於多棧的新語法
     其實是要設計 一種新的 註釋的格式
     把註釋的格式完全固定下來
     類似於一個類型聲明系統
     在之前 對棧的操作的註釋是被忽略的
     也就是說 編碼者 辛辛苦苦鍵入的信息被愚蠢的機器忽略了
     我現在就設計新的 註釋的格式 來修正這一錯誤
  2. 要求這個 註 中所能包含的信息有
     1) 副作用 類型
        包括 編譯到內存的信息
        還有輸入輸出信息等等
        仔細想像 副作用的類型其實 十分有限
        這些信息必須足以讓 詞典編撰者 推導出
        這個函數的作用能否在編譯時期被處理
        如果這裏有困難
        那就直接把 這個性質變成一個明顯的聲明好了
     2) 參數類型
        其實在這裏也是能夠形成像 ocaml 中一樣的類型推導系統的
        這種系統之有趣在於 兩點
        1. 擁有一等公民函數可以使用
           這一點在沒有 lambda 的時候 在蟬語中也是有的
        2. 擁有匿名函數可以使用
           這一點 只有在 lambda 之後才能擁有
           但是 其實不是的 ><><><
     3) 參數的局部變量初始化
* 關於匿名函數
  1. 爲什麼匿名函數要求鏈表處理 ?
     因爲
     1) 匿名函數需要被垃圾回收
     2) 爲了 call/cc 嗎 ??
        其實跟 call/cc 沒關係
  2. 用鏈表處理實現的函數體
     運行起來比用數組實現的函數體慢
     特點是它可以被靈活的改寫
     但是這後一種性狀其實是不常用到的
     誰也不會想要經常改變一個已經定義好的函數體
  3. 而 call/cc 需要的不是函數體被 用鏈表處理實現
     而是 返回棧 被用鏈表處理實現
     [除非使用 CPS 之類的編譯技術]
     這也會使得函數調用變慢
  4. 有什麼額外的選擇嗎 ???
     記得 call/cc 也有它的侷限性
     即它所得到的 cc 是一個一元函數
     但是對與 蟬語中的函數來說 一元和多元根本就沒有本質的區別
     那麼 call/cc 在蟬語中是否能是多元的呢 ???
     這樣就比 scheme 還牛逼了
  5. 回憶一下 call/cc
     它的一元性顯現與下面的兩個一元函數之上
     (... (call/cc (lambda (cc) <body>)) ...)
     這個表達式出現的地方是一個"空"
     這個控形成了一個一元函數 它代表了當前的計算狀態
     call/cc 所作用於的必須也是一個一元函數
     這個函數的參數將是 是上面那個空所形成的一元函數
* 類型
** 目的
   1. 使得蟬語能夠更好地處理 數組樣子的數據結構
      並且 對鏈表樣子的數據結構 也將有統一的處理
   2. 一個對象在內存中的存在方式需要被指定
      有可能用到 GC 也可能是在 詞典 中的靜態數據
   3. 消除同時在語言中允許有類型的值和無類型的值時
      產生的語義過載現象
   4. 把處理某種類型的函數都登記於這個類型下面
      以節省命名空間
      並且使得所有的函數都不必檢查其參數
** 可行性
   1. 只要在語法方面不影響表達的簡潔性
      那麼在運行時多入一個 數據類型標籤 到棧裏也是可以接受的
      "一個量" 佔參數棧中的兩個單元
   2. 不把函數 限制在某個類型內
      否則就將與函數範式相互衝突了
      必須把所有函數都暴露出來
      使得對它們的複合能夠被以簡潔的方式進行
   3. 在定義一個類型的時候
      最好不要初始化
      直接把所有對結構還有函數的定義都分散
      這樣就可以隨時添加處理函數到某個數據類型中去了
** 類型之間的關係
   1. 一個類型由其數據域和其處理函數來表示
      所以類型之間的關係其實就是具體集合論中集合之間的關係
   2. 有某些算子[即 函數]和關係[即 謂詞]可以用來抽象 "具體集合" 這個數學結構
      比如 "含於" 這個關係
      比如 "上下确界" 這個算子
      但是我直接使用最具體而平凡的方式就可以了
      這些算子和關係可以在之後定義
   3. 在定義個類型的時候
      我提供語法以使你能夠指明其 數據域 和 處理函數
      我提供語法能使你直接聲明
      1) 這個類型的 以這個符號爲名的 處理函數
         和 那個個類型的 以那個符號爲名的 處理函數
         相同
      2) 這個類型的 以這個符號爲名的 數據域
         和 那個個類型的 以那個符號爲名的 數據域
         相同
      這就是我所說的 "具體而平凡的方法"
   4. 這種實現方式要求 函數內部關於接受參數還有形成返回值的部分
      必須對數據類型保持無知狀態
      必須沒有類型檢查 這樣一個函數才能夠被多個類型的數據類型使用
** 數學結構
   1. 每一個類型[type]代表着一個具體的數學結構
      而在蟬語的基礎部分中
      並不去實現 抽象的 符合某些公理的 數學結構[class]
      這是因爲程序語言中所實現的數學結構
      都是具體的用來做計算的數學結構
      而數學中的抽象的數學結構
      是用來在探查滿足某些公理的數學結構的一般性質的
      除非是在實現一個輔助證明系統之後
      否則生硬地把抽象的數學結構還有範疇論中的概念
      引入程序語言中來 在我看來是不合適的
** 類型推導
   1. 類型推導變得有趣而有用
      當且僅當 函數是一等公民的時候
      但是在蟬語中 作爲一等公民的函數
      是在實現了鏈表處理之後
      利用鏈表處理來實現的
   2. 也就是說在蟬語的核心部分的基礎上
      可以構建起各種計算系統
      比如 lambda-calculus 和 digrap
** 初始化
   1. 在定義一個數據類型的時候
      必須指定一個用來初始化一個這個類型的數據的函數
      這個函數可能有參數 比如 對 詞 這個數據類型來說就是如此
      而也可能沒有參數 比如對與 cons 來說就是如此
      這個用來初始化數據的函數
      可以從棧中 cons 的數組中取 內存
      也可以從詞典中取內存 或者從數據段中取 內存
      - 比如編撰一個詞到詞典中的過程就是如此
      這樣就解決了 靜態的動態的問題
      並且 原子性的數字類型的量是在 參數棧中去內存的
   2. 可以發現 從語法的角度看
      對 上面的三種類型的 數據的初始化
      是非常不同的
      1) : kkk 1 2 3 . . . Exit ; define-function
         此時有一個名字被分配給了這個對象
         參數棧 中沒有留下東西
      2) cons
         此時沒有名字
         參數棧 中有地址
      3) 7
         此時沒有名字
         參數棧 中有值
** 多餘的信息
   1. 儘管於一個帶有類型的量來說
      當它被入棧的時候一個類型標籤已將被入棧了
      但是我還是要求
      如果這個量是非原子性的量
      那麼它的地址下面就一定要有一個域用來儲存類型
** 對別名的支持
   1. 詞典中的同一個定義
      應該能夠擁有兩個名字 這樣 英文 漢文 異體字 就方便多了
      這樣在詞典這個數據結構中 單向鏈接的鏈表的功能就喪失了
      因爲沒法依據這個鏈表來查找詞了
      這個功能本身我也沒用過
      也許我應該好好設計然後在取實現
      這樣就能有個大局觀
** 實現
   1. 在開始實現基本的 名詞和動詞之時
      需要很多基礎設施
   2. 類型系統需要用更豐富的數據結構來實現了
      並且在實現它的時候還沒有類型系統
** 術語
   1. 型[type] 類[class]
      結構[structure] 範疇[category]
      我應該如何使用這些術語呢 ?
   2. 目前我只使用 型[type] 這個術語
      用來表示一個具體的數學結構
* 具體
** 詞
   #+begin_src cicada
   詞 静
     名 我希望這是被內化的串 即符號
     大小
     性
     詮釋者
     定義

   用來初始化 詞 的函數 會把詞分配到 詞區[詞典]中
   也就是說每個[某些]數據類型會有自己的區
   #+end_src
   1. 初始化
      先看 在舊的 依賴於外部的匯編器 依賴於解釋語義的 實現方式中
      初始化 是如何實現的
      1. 首先在匯編中
         定義之外的部分用一個宏實現
         定義就是簡單地把地詮釋者的地址留在匯編代碼中
         也就是說
         爲了形成一種寫匯編代碼的風格
         詞這個數據的結構被限制了
      2. 在解釋器中
         讀一個串
         把這個串解析成詞
         第一個詞爲 名
         以之後的詞 找對應的詞的詮釋者 以爲定義
      故 初始化之語法 類似於
      夫 <某> 者 <某> 也
      或
      夫 <某> 者 動詞 而 編撰入詞典
      如果 想 保留 也 這個詞 那麼就需要一種語法糖機制
      因爲 否則 就破壞了召喚函數的統一性
      但是這種統一性也許是需要被破壞的
      考慮 cons 就知道了
      名詞 和 動詞 是兩種類型
   2. 處理
      並沒有很多的處理函數
      對這個函數的處理都是散列表和名之間的互動
      可以說 散列表和詞 一同構成了詞典
   3. 統一性
      定義一個數據類型的語法是統一的
      帶有類型標籤的量在參數棧中的存在方式是統一的
      取非原子性的數據的域的方式是統一的 :: <型> 之 <域>
      召喚處理某種類型的函數的方式是統一的 :: <型> 而 <函數>
      統一性僅此而已
   4. 不統一性
      也就是說用來初始化各種數據類型的值的語法是不統一的
      數據類型存在於內存中的方式也是不統一的
   5. 型 類似於 名詞
      夫 詞 <某> 者 名詞 而 編入詞典
      設計何種語法才能把對型的 域 和 處理函數 的描述
      置於型的定義之外 ?
      這是不合理的
      對型的 域 的描述不應該被置於型的定義之外
   6. 所謂的之和而其實是相同的
      之 也是在召喚函數而已
      這樣就獲得了純粹的動態性
      之 <某> 會被編譯成 [某符號] [之]
   7. 某個數據類型的所有的處理函數
      都在類型的定義之外聲明
      其實就是把這些函數登記在這個類型下面
      並且我必須提供語法
      使得用戶能夠方便地把一批函數一起登記
   8. 只要做了下面所述的優化
      那麼以一致的方式來實現對數據域的處理也就可以了
   9. 不去定義標準的初始化一個數據類型的域的方式
      就能夠 保持 使用類型系統時候的靈活性
      好的 factoring 能夠保持 表達方式的精簡
   10. "而 編撰入詞典" 到 "也" 這種對語法的優化
       其實可以以一致的方式系統地使用
   11. 我說 ruby 識別出了一種 使用 lambda 的模式
       並且就這個模式優化了自己的語法
       器關鍵在於把 顯式的參數 變成 隱式的參數
       蟬語的語法必須具有 "可以做類似優化" 這種性質
       蟬語保持平凡的核心語法
       而在蟬語中對語法的優化 是由核心語法所提供的語義來完成的
       也就是我必須設計一種 讓用戶去優化語法的機制
   12. 可以看出在 有類型系統的 函數式範式中
       只要
       調整調用函數的前綴或後綴表達式爲順序爲中綴表達式
       然後在加上把某些 顯式的參數 優化成 隱式的參數
       就形成面向對象了
       而 我想 面向對象 所增加的認知上的負擔是很重的
       所以我放棄對 面向對象 系統的實現
   13. 蟬語所實現的東西 與一般的OO範式所不同的是
       1. 最重要的是沒有提供一致的方式來初始化類型
       2. 法上保持 後綴表達式
   14. 那麼定義一個類型的語法應該是如何的呢?
       我應該提供語法來幫助用戶
       在定義類型之初就指明有那些函數需要登記
       >< 我還希望能夠該處一致的方式在 定義好了一個類型之後
       再在其中登記 一個或多個 函數
       我希望登記 一個或多個 函數 的語法能夠一致
   15. 我甚至還能夠提供 所謂的 Class Variables
       因爲 這種 "把函數登記到類型中" 的解決問題的方式
       是非常靈活的
** 關於優化
   1. 如果 在把 之 或 而 編譯到動詞的定義當中時
      如果能夠證明 這個函數被調用時 棧頂的數據的類型是固定的
      那麼就能夠把查找的過程在編譯期完成
      從而優化運行期的效率
   2. 最顯然的可以證明的情形是
      當它前面被編譯的是一個原子性的數據的時候
   3. 對於取非原子性數據的域的函數
      這種優化可以更進一步
   4. 可以發現這裏所謂的優化
      就是簡單把某些計算在編譯時期進行而已
      那麼
      如果在編譯時期遇到 1 2 + 這樣的函數體
      是否也要計算出這些結果呢
      答案是肯定的
      如果我總是保證在編譯期能做的計算都在編譯期被算完
      那麼顯然我就能證明
      就從這個角度的優化而言 我的編譯器達到了最優
   5. 但是
      lambda 如何呢 ?
      在 lambda 的函數提中如何呢 ?
      純粹地動態嗎 ?
      沒錯
      其函數體也是可以以類似方式優化的
      因爲我可能要歲 lambda 做手術
      所以 對於實現與否
      我把決策放在以後在做
** 符號
** 定義
** 棧
** 整數
** 八位組
** 字
** 八位組串
   #+begin_src cicada
   八位組串
     蟬語者說
   ------------
   #+end_src
** 單鏈
   #+begin_src cicada
   (* bra-ket *)
   { Mark-McGwire Sammy-Sosa Ken-Griffey }

   (* indentation *)
   ======
   - Mark-McGwire
   - Sammy-Sosa
   - Ken-Griffey
   ======
   #+end_src
** 雙鏈
   #+begin_src cicada
   (* bra-ket *)
   [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

   (* indentation *)
   ======
   * Mark-McGwire
   * Sammy-Sosa
   * Ken-Griffey
   ======
   #+end_src
** 名鏈
   #+begin_src cicada
   (* bra-ket *)
   ( :hr 65 :avg 0.278 :rbi 147 )

   (* indentation *)
   ======
   :hr 65
   :avg 0.278
   :rbi 147
   ======


   ( :american
       Boston Detroit New-York
     :national
       New-York Chicago Atlanta )

   ======
   :american
     - Boston
     - Detroit
     - New-York
   :national
     - New-York
     - Chicago
     - Atlanta
   ------
   :1 "-" for list element
   :2 "*" for dali element
   :3 ":" for wodi (* wodili element *)
   ======
   #+end_src
* 計算的方法
** 木答演算 [lambda-calculus]
** 有向圖處理 [digrap]
* 計算的方向
  1. 使用明顯的 參數棧 與 返回棧
     對於使 call/cc 的語義變清晰來說
     很有幫助
  2. "沒有祕密,就沒有泄密"
     "沒有抽象,就沒有抽象的泄漏"
  3. 在形成一個 cc 的時候
     應該可以以明確地方式說出所使用的是哪段計算
     這樣 call/cc 的語義就不會再令人迷惑了
  4. 如果我能以明顯的方式把各段運算
     以隱式抽象成函數
     然後隨意地組合它們
     然後在根據常用情況優化其語法
     那麼我就得到比 call/cc 更好的東西了
  5. 好像 call/cc 無論如何都需要複製參數棧
  6. call/cc 的難點在於
     必須使用動態地方式來分配 函數返回地址 和 函數參數 的內存
     然而它們會大大加重 GC 的負擔
  7. call-with-* 其實是改變了 函數作用的基本語法的
     (call-with-* <function>)
     它讓函數作用於一個約定的參數
     而不是使用
     (<function> <約定的參數>)
     爲什麼如此呢 ???
* 矛盾
  1. 高階與低階
     如果使用自己定製的虛擬機
     並且把 GC 實現在虛擬機中
     那麼 蟬語 之簡單性所帶來的對機器底層的控制能力就喪失了
     除非虛擬機的可擴展性非常強
     這樣在需要某些新的底層功能時
     就可以通過擴展虛擬機而完成
     也就是說
     虛擬機知道自己是一個虛擬機
     並且它提供通向更底層真實硬件的接口
  2. 特性之意義的喪失
     所保留下來的特性還有什麼 ?
     [如果 獨特之處 全然喪失 那麼我就應該回到 scheme 社區了]
     1) 以明顯方式使用的棧
        [函數語義的具體化]
        後綴表達式
        [達到與CPS同樣的效果][避免複雜的語法解析]
        無傳統意義上的局部變量
        [就函數複合而優化[同時使得對函數作用的表達變得羅嗦]]
        [也就沒有因局部變量的大量使用所帶來的認識上的負擔[但是引入了其他類型的額外的負擔]]
        這些特性 使得
        1. 蟬語是一個非常適合教學的語言
           比如
           犧牲效率而換取設計的一致性
           不做優化而換取實現的簡單性
        2. 在學會使用蟬語的同時 基本上就學會實現蟬語了
     2) 漢語本位
     3) digrap
     上面就是我能想到的全部了
     如果再強行描述其他的特點或優點 那就是不實的廣告了
* 對鏈表的排斥
  1. 人們先驗地認爲鏈表處理速度慢
     但是這是用速度來買靈活性的時候
     [看看minikanren就是全然用鏈表處理實現的]
     [而digrap將來也將全然使用鏈表處理來實現]
     [我想coq也是如此]
     [既然它們都是如此 那麼鏈表也就沒有什麼不可接受的了]
     所以我不再排斥鏈表處理了
* 空間換時間
  1. 通過把 function-address
     豐富爲 call function-address
     就做到了 在需要做判斷[形成很多分支]的時候
     避免判斷
     從而用空間來買時間
     這種想法可能在很多地方都適用
     [比如下面]
  2. >< 把函數體保存在鏈表中
     與把函數體保存在數組中
     這兩種存儲方式是否能夠相容??
     也許使用上面的技術就可以了
  3. 還有很多地方都可以這樣做
     比如 其他需要判斷是否到達數組的末端的地方
     都可以使用類似上面的技巧
     這優點類似於面向對象中
     把處理函數封裝到數據結構中一樣
     封裝之後
     我就可以把
     [判斷+調用]-優化爲->[調用]
  4. 以這種技巧
     我就能在棧中插入鏈表
     假裝鏈表是棧的一部分
     從而實現 明顯定界的 continuation
  5. 只要用標籤來標記有可能需要被捕捉的地方
     然後 當標籤都被處理完了之後
     在從使用 鏈表 轉回到 使用 棧 就行了
* 不同類型數據的分離
  1. chicken scheme 把所有的數據都分配到棧中
     而蟬語會儘量把所有不同類型的數據分離分配
     尤其是 有 參數棧 和 返回棧 之分
* 數據分配器
** 正名
   我不使用 垃圾回收器 這個術語
   而 使用 數據分配器 這個術語
   這在於
   1. 前者是消極的短語
      後者是積極的短語
   2. 可以被重複利用的 內存空間 如何被發現[所謂垃圾回收]
      其實並不是用戶所關心的
      用戶所關心的是
      在需要的時候 用來實現數據結構的 內存空間如何被分配於用戶
      關於 "分配" 的函數
      纔是這類動態內存管理系統的接口
      而關於 "回收" 的函數不是
** 標記 式 數據分配器
   1. 一個數組被作爲 數據分配器 的對象
      數組之元素被稱爲 點
   2. 點 之間有一個離散的全序關係
      點的集合形成一個離散的一維線性空間
   3. 每個 點 中有 某些 域
      可以用來存儲數據
      通過在一個點的 域 中保存其他點的地址
      點與點之間就能形成聯繫
      點的全體 與 它們之間的關係 就是一個有向圖
      [這個有向圖是受某些性質限制的]
      [比如每個點所發出的有向邊只能有有限條]
      [即 有限叉有向圖]
   4. 數據分配器
      的唯一職責是給用戶分配 點
      唯一接口是 cons 這個函數
      所需要達到的效果是
      給人以有無限個 點 可以被使用的假象
   5. 標記 式 數據分配器
      產生這種假象的方式是
      首先它順着 一維離散空間 取 點
      當取完之後
      某些被用戶用過的點
      現在就又可以被重新使用了
      此時只要能夠判斷出
      那些點是可以被[安全地]重新使用的就行了
   6. 那個靜態的 長度固定的 一維數組
      提示着我們需要去給 數據分配器 一個 工作週期 的概念
      一個工作週期的開始和結束都是在
      cons 把 空間中最後一個點返回之後
      [當然 除了第一個工作週期之外]
   7. 有三個部分 相互配合 來完成工作
      它們分別是
      marking finding cleaning
      其中 cleaning 的工作是伴隨 finding 而進行的
   8. marking
      標記出下一個週期中將被認爲是不自由的點
      在下一個週期中 這些點 將不能被 finding 找到
   9. 也就是說 每個點上面需要有一個[一些]可以用來進行標記的域
      有三個這樣的域
      分別爲 marking域 finding域 cleaning域
   10. finding
       利用了 離散一位線性空間的全序關係
       也就是說 找下一個點的時候會順着這個序關係來找
       沒有被上一個週期的 marking 標記爲 "將不能被 finding 找到" 的點
       就是在需要返回一個點的時候 能夠被 finding 使用的點
   11. 需要定義 什麼是 "將不能被 finding 找到" 的
       定義 "在下一個週期中將不能被 finding 找到的點"
       即 "在下一個週期中還能夠以被引用到的點"
       而 "一個點 能夠以被引用到"
       被定義爲 "從根節點出發沿有向圖的有向邊能夠走到這個點"
       而 "根節點就所有全局變量和局部變量[即參數棧]"
   12. 每當一個點被賦值給全局變量的時候
       或一個點被賦值給一個已知是能夠被引用到的點的時候
       那麼在進入下一個週期的時候
       這個點就有可能是 能夠被引用到的點
       也有可能是不能被用到的
       [考慮一些使從根節點出發的有向路斷裂的副作用就知道了]
       但是重要的性質在於
       如果讓 marking 去標記所有這些可能是 能夠被引用到的點
       那麼所有 能夠被引用到的點 一定就都被標記了
       並且還可能有很多 其實並不是 能夠被引用到的點 也被標記了
       這個性質確保了 數據分配器 的正確性
   13. 如果 在一個工作週期結束的時候 啓動 marking
       那麼它就會從根節點出發
       去進行一個有向圖的深度有限的遍歷
       從而把所有的 能夠被引用到的點 都標記出來
       在下一個工作週期開始時
       所有 marking域 沒有被標記的點
       就是可以被 finding 找到的點
   14. 而 數據分配器 的漸進性在於
       不必讓 marking 在工作週期結束之時才開始工作
       只要保證它在 在工作週期結束之時才完成工作
       就可以了
       所以它可以時不時地去做一些標記工作
       然後休息一會兒
       只要它記住在遍歷有向圖的路程中自己已經走到哪個地方了
       就行了
       [當然每當需要做這種記憶的時候其實就是需要一個棧而已]
   15. 每個點中分別有 爲 marking finding cleaning 而準備的三個域
       每個工作週期結束的時候 三個域會進行一個置換
       所進行的置換 將是三階置換羣中的兩個三循環置換之一
       具體情況如下
       1) 本次 工作週期中的 marking域 所標記好的域
          是給 下一個工作週期的 finding域 使用的
       2) 隨着 finding 遍歷 整個一維離散線性空間
          cleaning 在本次工作週期結束的時候 清空所有點的 cleaning域
          而 本次 工作週期中的 cleaning域
          是給 下一個工作週期的 marking域 用的
          在下個工作週期開始
          marking 所得到的應該是被清空的 域
       3) 本次 工作週期中的 finding域
          在本次工作週期結束之後 其使命就結束了
          它們 將會作爲下一個工作週期 cleaning域
   16. marking 和 finding 的工作是相互獨立的
   17. 這種以 標記而形成的反證法
       來證明那些 那些點在下一個週期可以被使用的
       的方式
       決定了 finding 必須要有一個
       "檢查標記" 以尋找沒有被標記的點的 尋找過程
       這個過程必須 跑遍整個離散線性空間
       從而使得理論上的時間複雜度變大了
** 標記 式 數據分配器 對與 所佔空間大小不確定的數據 的分配
   1. 可以用壓縮式的垃圾回收器來實現對字符串的動態內存管理
      因爲 string 的長度可變
      所以簡單的 marking-gc 是不適用的
   2. 其實單就這一個技術上的不一致之處
      就足以說明 標記 式 數據分配器 是不可取的了
      因爲
      這種設計上的不一致性 將會給維護和擴展帶來很大麻煩
      並且很多意想不到的技術問題可能隨時冒出來
      這都是因爲對於 沒有一致性的設計
      人們很難形成良好的理解所致
   3. 在 marking 工作的時候 如果看見 <string>
      就更改引用點 並且複製字符串
      + makeing 是知道引用點是哪個的
   4. 如果 string 的堆比 pair 的堆先耗盡
      這時就必須重啓 gc
      所以應該把 string 的堆設置的充分大 以避免這種情況
** 標記 式 數據分配器 的缺點
   1. 其時間複雜度在理論上劣於
      複製-壓縮 式 數據分配器
   2. 有可能影響漸進性的情況是
      finding 遲遲找不到一個沒有被標記的點
      當有很多的被標記的點 充斥着那個一維離散線性空間時
      這種情況會經常發生
   3. 沒法以一致的方式處理
      所佔空間大小不確定的數據
      即 此時又必須用到 複製-壓縮 式 數據分配器
** 標記 式 數據分配器 合理性
   1. 如果要求 所佔空間大小不確定的數據 之間不能形成複雜的相互引用
      那麼 這種處理方式就避免了 複製-壓縮 式 數據分配器
      在處理這種 情況時所將會遇到的困難
      即 "更新困難"
      [注意 這種 "更新困難" 只有當要求 數據分配器 的漸進性的時候纔會發生]
** >< 複製-壓縮 式 數據分配器
   1. 這種類型的 數據分配器 只專注於 所能夠被引用到的點
      而不理會不能被引用到的點
      它摒除了 標記 式 數據分配器 中的 finding
   2. 每當把一個cons從一個heap複製到另一個heap
      所有引用這個cons的cons都需要被更新
      做這種更新的方式是
   3. 在每個 cons 中使用一個 標記域
      每當把一個 cons 從 堆甲 複製到 堆乙 時
      標記這個 cons 是已經被複製過了的
   4. 當一個 cons 已經被複製好了之後
      這個 cons 就
      [注意這裏需要使用一些技巧來保存臨時變變量]
** >< 數據類型的分離
   之前分離數據類型是因爲想要用 數組 而不想用 數據堆
   既然 現在使用 複製-壓縮 數據分配器了
   那麼所有的東西就都能夠在一個堆裏了
** >< 更新困難
   1. "更新困難"
      也許可以用 "同步" 來解決
      就是說 去複雜化所有數據的接口
      兩個棧之間相應的數據被認爲是等同
      並且當在接口中初次遇到需要更新的兩個點時就更新它們
      這樣就獲得了漸進性
   2. 每次 遇到一個 點 的時候
      都必須檢查這個點是否更新
      這頗爲不合理
   3. 而 "三染色算法的進行"
      其實是與 數據分配器 這兩種分類沒有關係的
   4. 可不可以這樣
      在做標記的同時 也做 copy
      但是我並不急着使用 被 copy 好的數據
      而只有當 第一個 離散線性空間被耗盡了的時候
      才轉而去 使用被 copy 好的數據
   5. 每個局部變量中也有兩個也可以有兩個域 置換使用
   6. 但是遍歷所有被使用過的點才能找到下一個自由點
      和複製所有被使用的點 才能找到下一個自由點
      不是一樣嗎 ?
      爲什麼說 後者的時間複雜性優於前者呢
      這在於前者需要知道整個一維線性空間有多大
      而後者根本就不需要知道整個一維線性空間有多大
      但是這其實是假的
      但是每當分配一個 cell 的時候
      都必須去檢查是否到達了 線性空間的邊界
      這是否影響複雜度的因子呢?
** 漸進性的缺點
** 最終的設計決策
   1. 我之前使用的是 標記 式 數據分配器
      並且我還發展了一些小技巧來 增加它的漸進性
      但是現在經過考量後
      我決定要轉而使用具有更好的一致性的 複製-壓縮 式 數據分配器
   2. 我想出了結合兩種算法的優勢的方式
   3. 不用擔心
      因爲 數據分配器 的實現是在 虛擬機中完成的
      所以它無論如何不影響語言本身
      因此我可以嘗試多種算法
      並且在不同是情況下讓用戶選擇
      尤其是 我會把漸進性 實現成一個可選擇的性狀
   4. 也就是說
      我希望
      用兩種可選性狀
      "漸進性與否"
      "標記式 還是 複製-壓縮式"
      來形成四種 數據分配器
   5. 但是可能會有困難
      因爲 複製-壓縮式 可以很方便地處理 任意大小的向量和字符串
      但是 標記式 就不行了
      必須有一個額外的 複製-壓縮式 數據分配器 的幫助
      所以我可能只把 "漸進性與否" 提供 爲可選性狀
   6. 現在
      我相信我找到了最好的算法
      我的算法將使得 在使用 複製-壓縮式 數據分配器 的時候
      [即[理論上]更優的時間複雜度]
      也能獲得漸進性
      並且正確處理 循環引用[所謂的指針運算][native pointers]
      作爲一個 具有漸進性的 數據分配器
      在最壞的時候 它也能證自己的正確性
   7. 要知道 詞典目前還不是用 數據分配器 來處理的
      也就是 蟬語 中某些數據類型被 數據分配器
      但是 另外也有靜態的數據
** 遍歷方式
   1. 注意 當使用 單向鏈接的鏈表的時候
      以 cdr 開始遍歷可能是最好的
      而當使用其他模式的數據的時候
      遍歷方式也應該跟着改變
      其目的在於 把相近的東西放到一起
      因爲 CPU cache 的存在
      如果 相近的定西 在同一個 cache line 中
      那麼引用的時候速度對提高很多
** 永遠不關機的系統
   1. 之前我說過
      要實現 對詞典的 動態內存管理
      也許現在就是實現的時候了
      如果實現了對詞典的 動態內存管理
      [不論是作爲數組還是鏈表]
      那麼我就能實現別的語言想都不敢想的穩定性了
* 雙向鏈接的鏈表
  1. 也許我應該直接以雙向鏈表爲基本數據結構
     因爲 它能夠被當作 單向鏈表來使用
     這樣就增強了設計的一致性
     我可以把鏈表單元的實現
     從 [car cdr] -優化爲-> [data <- ->]
  2. 這也能成蟬語的另一個特點[賣點]
     即 極端[不顧成本的]富的數據結構
* 對古典 scheme 的批判
** 返回值
   1. 在古典的 scheme 中
      每當構造子 cons 構造完一個 pair 之後
      都只有且只有一次機會來引用所構造的 pair
      那就是在嵌套的sexp中調用cons的那個位置上
      那個位置上返回的值就是所構造的pair
      #+begin_src scheme
      ;; 除非命名它
      (let ([c (cons '() '())])
        (set-car! c ><)
        (set-cdr! c ><))
      #+end_src
      比如 如果我要編譯一個類 scheme 的語言到 cicada 的話
      我會設計類似下面的語法
      在下面的兩個 <sexp> 中
      也可以引用到這個 cons 將要構建好的 pair
      #+begin_src scheme
      (cons :set-address-to xxx
            :car <sexp>
            :cdr <sexp>)
      #+end_src
   2. 也就是說與蟬語相比
      返回值的更強的可引用性
      只能用利用明顯地命名來達到
      這在語法上是不理想的
      [在 scheme 中也許可以用 macro 來解決這個語法的問題]
   3. 也就是說在蟬語中
      因爲使用了明顯的參數棧
      所以函數的返回值的可引用性很強
** 核心語義
   就觀念而言
   對蟬語中函數作用的理解[靈活地]有兩種
   1) 函數作用於在棧中爲這個函數準備好的參數[古典的理解]
   2) 函數的參數是整個棧[joy所引入的理解]
** 前綴表達式
   1. 後綴表達式的優越性在於
      它更好的反映了程序的運行方式
   2. 比如 CPS 和 monad
      就是兩個 從前綴表達式向後綴表達式轉化的例子
** 數據類型
   - y :: 使用一個統一的數據結構(比如lisp的列表)
          減少了理解整個系統工作方式的負擔
          但是會增加人閱讀代碼時的認知負擔
   - x :: 沒錯
          我想 "認知負擔" 這個名詞很恰當地表達處理
          在使用 scheme 的時候我的某些感受
   - x :: 儘管 scheme 中使得用戶能夠自己定義數據類型的機制並不好用
          但是很容易在 scheme 內部解決這個問題
          [正如很多人利用 lisp 語法所做的實驗所證實的一樣]
          比如
          利用 wordy-list 這個數據結構
          約定一個 wordy-list 中的 :type 這個 key
          讓它後面跟着對類型的描述就可以了
          這樣對類型的描述就沒有任何的限制了
** 衍生
   1. 有很多 scheme[或lisp] 的崇拜者
      把其他語言的語法 lisp 化了
   2. >< 值得對這些系統做一個總結
      並看看它們有沒有什麼值得借鑑的地方
      和需小心的地方 以避免重複它們的錯誤
** 對副作用的需要
   1. 這裏有一個很重要的說明
      在scheme中用副作用來構造帶有loop的list這件事困擾了我很久
      我現在明白這是因爲我對我寫的代碼所表達的東西的理解
      和機器實際上對我代碼的處理方式之間有一個偏差
      這可以說成是一種語義的錯亂
      對這一點的解釋如下
   2. 首先要明白
      當結構化的數據被作爲參數來傳遞的時候
      自然而然傳遞的是地址
      [這樣效率更高]
   3. 其次要熟悉 scheme 中的一種編程風格
      這種風格是用遞歸函數處理歸納定義的數據的標準方式
      這種標準處理方式在 ml 這種具有更強類型限制的語言中
      體現的最爲明顯
      這種風格是
      1) 函數以輸入的結構化數據爲原材料
         因爲所使用的結構化的數據有良好的遞歸定義
         所以很容易形成遞歸函數去解構這個結構
      2) 然後在這個拆解原料的過程中
         函數會利用拆解所得到部分原料
         並添加一些新的物質
         去構建一個需要被輸出的結構化數據
         [注意這裏重點是 拆解所得到部分原料 被重新使用了]
      3) 重要是
         當一個東西被當成原料而傳給某個函數的時候
         做了這樣的重要假設
         即 這些原料是以後不需要的了
         並且這些原料沒有同時在別的地方被用到
         即 這些原料中的任何部分的地址別人都不知道
         只有當下這個原料所服務於的那個函數知道
      4) 在函數構造需要被輸出的新的結構化數據的時候
         原料的一些部分被用到
         同時原料的另一些部分沒有被用到
         那些沒有被用到的原料的部分
         當然就是需要被垃圾回收器回收的廢料了
   4. scheme 中的列表處理函數基本上都是以這種風格寫成的
      這是一種很好的風格
      它使得編程變得清晰簡單而明瞭
   5. 但是
      當我需要用副作用來構造帶有 loop 的 list 的時候
      問題就來了
      因爲上面的那個重要的假設不再被滿足了
      並且
      略微形而上地說
      這裏所處理的東西
      [至少從表面上來看]
      不再具有良好的歸納定義了
      這就決定了這種東西不容易使用遞歸函數來處理
      但是這只是表面
      其實我們所定義的數據結構總不是雜亂無章的
      否則就無 "結構" 可言了
      其實我們所定義的數據結構總是有一定的正規性的
      總是可以使用遞歸函數來處理的
      [遞歸函數就在於能夠高效地捕捉正規性]
      這種可被遞歸函數處理的性質
      從某種意義上來說就是 "結構" 的本質
      這樣
      此時我們就需要新的理解方式與處理風格
      這時遞歸函數的行爲
      不是 解構的同時構造
      而是 遍歷的同時修改 [必要的時候複製]
      或者遍歷的同時記錄需要做修改的地方的信息
      然後遍歷之後一起作修改
      - 上面的這個 "或者" 是因 scheme 中
        運算的順序不好控制而致的
      就是用很多副作用去修改原來的值
      然後返回的還是原來的值的地址
      只不過原來的值被修改過了
      甚至有時可以不返回值
      因爲在別的地方還能引用到原來的數據
   6. 注意這種風格是如何與上面那個重要的假設完全相反的
      這在與
      這種新的風格
      可能需要我能自由地在函數中引用
      cons 的 car 和 cdr 的地址
      scheme 並不支持這樣的操作
   7. 這裏如此多的副作用顯然違背了函數式編程
      但是爲了能更方便的寫出比如 digrap 這種程序
      - 否則
        如果改一個圖中的某一個小地方也要複製整個圖
        那麼效率就太低了
        而一個對圖有大更改的操作
        正是由很多對圖的小的操作複合而成的
      語言的這樣的性狀是有利的
      這種性狀類似於 OO
      每個數據[圖]
      接受信息以調用合適的函數作用與自己
      而函數對自己的作用就是改變圖的樣子本身
      - 所以說其實這裏我所需要的就是 OO 而已
        這也讓我學到了不能去排斥其他的編程範式
        因爲不同的範式適合解決不同的問題
   8. 你馬上就發現兩種處理風格並不衝突
      並且常常需要同時使用這兩種處理
      那麼重要的就是
      1) 用上面所指出的 揭示函數行爲的 特徵
         來描述函數的行爲
      2) 把兩種風格的使用分別規範化
** 不能自己定義類型
   1. 還發現 scheme 中失誤的一點
      比如
      爲了實現 digrap 中的那個有向圖的數據結構
      wlist 中的某些位置需要記錄 wlist 中其他位置的地址
      但是在 scheme 中列表與列表的地址是沒有區別的
      沒有數據類型的區分只能用鏈表在作僞地址數據類型
      這顯然是錯誤的
** 類型構造子即標籤
   1. 如果使用 wordy-list 的明顯的標籤
      那麼這些標籤就可以看作是每個結構化對象[數據]的構造子
      那麼模式匹配和類型推到當然就不成問題
      - 類似 ml 的 type 關鍵詞
   2. 上面的兩項看似是錯的
      因爲這裏的明顯的標籤雖然用來命名了對象中的一部分
      但是並沒有形成對一個集合的歸納定義
      而模式匹配是爲了寫遞歸函數
      以處理歸納定義的集合[數據類型]
   3. 但是仔細一想其實又是可以的
      因爲不論如何它們確實能夠擔當構造子的角色
      其實 ml 中的 type 肯定是在用歸納定義來自動生成謂詞
      並且作爲對數據的定義
      在 wordy-list 中
      其語法與函數的作用將被明顯分開
      而在 ml 中兩者是相混的
      是用 首字母大寫 這種命名規則
      [以及相關的 語法高亮]
      來幫助區分語義的
* 函數複合 與 變換
  1. 應該以 函數複合 爲基礎來組織語言的基礎語義的數學基礎
     想要找一個數學基礎的原因是[且只是]
     爲了能夠得到一套規則來對代碼的表達式進行推導
  2. 複合的時候對參數有一個檢查是合理的
     但是又是困難的
     因爲參數的入棧和出棧是可以很靈活的
     把參數用一個名字打包 就能形成一個對參數的額外聲明
     也許這種技巧能夠解決 推導與變換 的問題
* 優化與變形
  1. 具有局部變量和以函數作用爲主而實現的 lambda 演算中
     可以看到
     利用對 lambda-term 的變形
     可以對程序做出很有趣的觀察
     這些觀察和變換可以用來優化程序
     這都是因爲 lambda 演算 的良好的數學性質所導致
  2. 而
     在蟬語這種以函數複合爲主的語言中
     如果仔細甄選原子性函數[如joy所做的那樣]
     那麼就也能達到有趣而良好的數學性質
     這裏所謂的良好其實是說
     利用這些性質我們能對一段函數做很多的恆等變形
     就像是對一個數學公式所做的那樣
     這樣就也達到了 lambda 演算 的優點
     [這些是組合邏輯的課題]
  3. 關於高階
     只有當這些變換能夠對某些高階的函數而進行的時候
     才會有用
  4. 把運算在編譯時期來做就是了
     但是理論上能夠在編譯時期做的運算可能是非常多的
     >< 這裏需要一個分析
  5. 當我純粹在使用函數複合的時候
     所謂的變換
     就是以個複雜的 代數 而已
     只要研究這個代數的性質
     我就能獲知 那些變換是可能的
     [我想在這裏 我能得到很多數學上的支持]
     [也許我還能反過來給數學一些新的啓發]
* 關於表達式的形態
  1. 對於被當作二元運算的二元函數來說
     只有當這種二元運算滿足結合律的時候使用infix纔是令人滿意的
     + 比如: + * max min gcd `函數的複合' `字符串的並聯' 等等
     這正是joy所想要表達的
  2. 對二元運算的結合性的證明 可以被轉化爲對一種特殊的交換性的證明
     #+begin_src
     (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
     或者:
     (p + q) + r  ==  p + (q + r)  <==>
     p q + r +    ==  p q r + +    <==>
     + r +        ==  r + +
     #+end_src
  3. 再考慮一下別的運算律 簡直有趣極了
     #+begin_src
     分配律(或者說對某種同態變換的描述):
     中綴表達式: (a+b)*c == (a*c)+(b*c)  <==>
     後綴表達式: ab+c* == ac*bc*+  <==>  ???
     但是至少我知道 +(c*) =/= (c*)+
     要想填上上面的問號 可能就需要 λ-abstraction 的抽象性
     否則我根本沒法描述某些東西

     交換律:
     a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

     +* =/= *+
     abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
     #+end_src
  4. 把後綴表達式考慮爲對棧的操作是自然的
     並且這樣的理解方式所帶來的一個很大的好處就是實在性
     這就又回到了哪個``小孩玩積木''的比喻了
     比如我的十三歲的弟弟可以問我"那個函數的參數是從哪來的?"
     我就告訴他是從棧裏拿出來了
     "那個函數的結果去哪了?"
     我就告訴他結果放回到棧裏了
     數學 和 編程 就都像一個小孩在玩積木一樣
     對了 他還可以問我這個函數是從哪裏來的
     我就說是從詞典裏找來的
* 結合代數
  1. 蟬語 是最有趣的結合代數
     利用這個結合代數似乎可以模擬任何代數結構
     [甚至是非結合代數]
     1) 比如上面對函數作用的模擬
        [儘管函數的作用不是結合的]
     2) 又比如我可以把兩個矩陣入棧
        然後一個矩陣乘法函數可以像 "*" 乘兩個數一樣
        爲我返回矩陣的積
        [儘管矩陣乘法不是結合的]
     3) 又比如列表處理可以用來實現 digrap
        而 digrap 已經出離代數的範疇之外了
        但是它還是能夠被forth的結合代數所模擬
  2. 但是僅僅 "是" 一個結合代數
     這個性質太弱了
     我所需要的是能夠形成 "運算律"
     以對 "代數表達式" 進行 "形變"
     這可能就非常難了
  3. 要知道
     當你所處的範疇越大
     你所能獲得的特殊性質就越少
     而 "運算律" 正是依賴於這些特殊性質的存在的
  4. ><><>< 也並不是不可能
     但是可能需要全新的技巧了
* 語法擴展機制
  1. 目前在蟬語中我能提供的語法擴展機制都是相當樸素的
  2. 我能想到的更複雜的語法擴展機制
     就只是 去提供一些 用於 語法解析的基礎函數而已
  3. 我想
     我並不能實現 類似 scheme 的模式匹配的 語法擴展機制
     因爲 模式匹配的是 sexp
     它已經是豐富額樹狀結構了
     而我只有字符串而已
  4. 只要有良好的設計
     我就能在我所提供的 關於語法解析的 底層基礎設施上
     實現類似的模式匹配機制
     並且嘗試新的有趣的技術
  5. 重點是我要求
     沒有額外的語法擴展期
     只有編譯期和執行期
     在語法擴展在編譯期進行
  6. 也就是說
     每個語法關鍵詞 都爲自己負責
     而不是由一個全局的 處理器 在分配並處理這些語法關鍵詞
  7. 我想正式上面這個性質使得
     我能夠把語法擴展放到編譯期進行
* 優化
** 對變量的靜態類型聲明在於
   1. 每次在使用這個變量的時候
      都可以決定應該調用的函數的類型了
      但是種情況在蟬語中好像不存在
      因爲根本就沒有局部變量
   2. 實是存在的
      因爲有僞局部變量
   3. 如果對於爲局部變量
      很多函數也能在編譯期被作用那就好了
** 還有一種極端的優化是
   爲了在編譯期獲知某些信息
   而在編譯器就執行某些應該在執行期進行的函數[到一定的限度]
** 我在這方面的知識還很欠缺
   不能說更多了
   但是沒有局部變量這個特性
   可能會對優化的程度有影響
* 教學
** 具體語義的優越性
   比如對 monad 這個概念
   在 scheme 中解釋它
   要比在 haskell 中解釋它
   更容易理解的多
** 具體語義的缺點
   這在於 用抽象 來形成對複雜性的控制
   少了抽象就少了控制
   也就是放任的複雜性
* 函數作用的羅嗦的新語法
** 記
   考慮新的語法
   即我在 lambda-calculus 中設計的語法
   這種語法是很好的
   在用鏈表來實現函數體時
   它的語義很容易被實現
   >< 但是當使用向量來實現函數體時
   這種語義就不一定能很好的實現了
** 多次引用
   只要限制所能使用的約束變元的數量
   就能夠用棧來處理它們
   需要注意的是對棧的 pop 應該如何做
   是明顯的 pop
   還是隱含的 pop
   還是提供豐富的語法來做靈活的控制
** 同名約束變元的作用域
   如果這裏根本沒有函數提的嵌套
   那麼也就沒有這個計算作用域的問題了
   函數體的嵌套
   是在需要匿名函數的時候才需要的
   所以那些可以留給鏈表語義來處理
** 語法糖的提供
   可以提供語法糖
   在沒有在作用中指明函數參數名的時候
   以默認的方式去取參數以作用
** 效率問題
   這所有的考量都來自於語言的很強的動態性
   其實某些之前所想到的優化在這裏也是可以進行的
   並且可能能夠被進行的更好
   因爲此時在代碼中提供的信息更豐富了
** 關於多棧的語法設計
   也就是說
   方針上
   有了一個很大的改變
   即 把編碼信息的負擔分開了
   一部分在函數體內
   一部分在函數作用的語法中[即在函數體外]
** 與古典的棧處理的相容性
   也許不能相容了
   但是如果設計豐富的處理方式就又能相容了
   但是缺點是對簡潔性的傷害
** 就語義的疑問
   一個函數體內
   所表示的是很多函數的複合
   在使用了新的羅嗦的語法之後
   這些函數的複合方式 能夠如何豐富呢 ?
   即使沒有嵌套的幫助
   在同一個函數體內
   通過擺弄棧中的參數
   複雜的函數複合也是可以實現的
** 圖示
   |----------------------------------------+--------------------------------------------|
   | 帶名字的三角                           | 參數                                       |
   | [小三角 名字可以寫在三角附近]          | 小三角指向一個小黑點                       |
   |                                        | 就代表把這個小黑點從這個吸入口吸入到函數內 |
   |----------------------------------------+--------------------------------------------|
   | 帶名字的圓圈                           | 函數                                       |
   | [大圓圈 名字可以寫在圓圈裏面]          |                                            |
   |----------------------------------------+--------------------------------------------|
   | 小黑點                                 | 棧中的數據                                 |
   |                                        | 函數的返回值                               |
   | [沒有名字的]                           | [每個函數可以輸出多個小黑點]               |
   |----------------------------------------+--------------------------------------------|
   | 還可以用小白點表示 中間的過度參數      |                                            |
   | 這些參數剛被函數輸出之後就被吸走了     |                                            |
   |----------------------------------------+--------------------------------------------|
   | 線                                     | 函數的複合方式                             |
   | [鏈接線的過程就是擺弄棧中的數據的過程] |                                            |
   |----------------------------------------+--------------------------------------------|
** 關於圖示的疑問
   1. if else then 所形成的分支應該怎麼畫出來呢 ?
   2. 被吸入的數據如何被處理呢 ?
   3. 就語法的設計而言
      如果我要求所有的以這種方式作用的函數
      都必被圓括號括起來 (function)
      那麼就更像是圓圈了
      這樣我就允許了別的形式的函數的存在
      比如 function 以默認方式作用
      而 (function) 以這種有趣的方式作用
   4. 是不是所有的語法都能系統地對應到這個圖中來呢 ?
      如果是的話 這個個圖示系統就太適合教學使用了
      1) 函數定義怎麼辦 ?
      2) lambda 怎麼辦 ?
         lambda 就是函數定義嗎 ?
      3) 是否在代碼方面 棄用文本性的東西 而改用特殊符號 ?
   5. 注意如果還是想用登記函數的技巧的話
      那麼這裏圓圈中的函數[消息]名必須在找到相應的數據的時候
      才能被確定下來是那個函數
      但是要知道 因爲使用了明顯的 參數名[小三角]
      所以這裏編譯器所知道的信息更多了
      因此
      編譯器有可能 能夠對代碼 作出更好的分析
   6. 在這種語法下
      函數的複雜的複合也不必使用嵌套的表達式來表示
      需要使用嵌套的表達式的
      只是跟 高階函數 有關的東西
      除了用 代碼塊 以外
      [如果你不想命名的話]
      對這種東西的表示似乎沒有更好的辦法了
   7. 這種特性某種程度上說明了 類似 letrec 的語法關鍵詞 的必要
      但是 其實是不對的
      因爲在 scheme 中
      我已經體驗過因爲使用很多的局部變量
      而讓代碼變得不可讀的例子了
      很多局部變量綁定到了相互調用關係複雜的 lambda 上面
   8. 也就是說
      我必須在某種意義上排斥以古典的方式對局部變元的使用
      而保留某些 "爲局部變元" 的良好性質
      但是在設計語法和語義的時候一定要保持靈活性
      因爲
      所遇到的實際問題可能是多種多樣
      其形式無可預料
      靈活性纔是獲得更強表達能力的關鍵
      而
      爲了以更簡潔的方式而表達對某些語義
      所設計出來的針對性的語法
      之重要性是不能與靈活性本身像比的
** 與約束變元的區別
   1. 這裏是在函數作用的語法中增加對參數的明顯命名
      這與約束變元的性質完全不同
      這中命名相當於加長了函數的名字
   2. 而這裏對應於約束變元的是
      :x 而 不是 <:x
* 組合子
  1. 在 scheme 中組合子也是經常被用到的
     也就是說
  2. 組合子 之集合的有限性
     還有其實現的簡單性
     [相比 lambda 演算而言]
     可以用來形成 對嵌入式系統的函數式編程
* 代數性質的退化
  1. 如果考慮整個結合代數整體
     它作爲代數的性質是嚴重退化了的
     與置換羣中的置換相比這裏用來做複合的函數簡直是怪物
  2. 重點在於不要考慮整體
* 什麼是程序語言
  - y :: 對語言學的不斷學習也許在於
         希望我的表達能夠儘量緊跟我的思想
         因爲沒有什麼比有一些想法而難以表達出來更令人痛苦的了
         尤其是學習一門外語(程序語言)的時候
         這種表達與思想之間的脫節是最痛苦的
         同樣也沒有很多事情是比設計一個語言更有趣的了
         當你有能力作出這樣的設計的時候
         你一定會產生很多新的想法
         因爲對思想的表達影響思想本身
  - x :: 但是說我們要設計一個新的語言是什麼意思??
         讓我們來更細緻地分析一下這個任務
  - y :: 我們可以通過讓我們的所指變得狹隘來具體化我們的表達
  - x :: 但是我們不要使用傳統的定義一個程序語言的方式
         看看我們能有什麼有趣的新想法
  - y :: 好的
         我知道有很多傳統的描述程序語言的性狀的術語
         比如 函數式 面向對象 模塊系統 類型推到系統 等等
         我們要暫時拋棄這些術語
         而試圖迴歸問題的本質對嗎?
  - x :: 沒錯
         並且我想最本質的地方可以沒有一箇中心
         讓我們以 "去中心化" 的方式
         儘可能多的描述我們想要尋找的源頭
         ><
* applicative & compositive
  1. 以 空格 爲函數作用
     那麼所形成的符號體系 就很代數非常不同
     比如 SKI
  2. 複合語義 與 作用語義
     是想通的
     組合子並不對 複合語義 有特殊的價值
     組合子 的意義在於
     有限性
     有限個組合子以奇異的方式[指可讀性差的]複合
     而不同於傳統的 lambda
     用一個靈活的方式構建出無限的函數[包括組合子]
* 作爲新的計算模型 digrap 能否用來解決 "不能解決的問題"
  1. 比如組合子正規性的不可判斷性
     但是事實是 任意給出一個具體的組合子
     我都能[用某些奇技淫巧]判斷它是否是正規的
     所以這 "組合子正規性的不可判斷性" 個名命題
     高次方程 "不可解" 這個命題
  2. 那麼我能否給出類似 golais 的方法呢 ?
* 類型
  1. 類型 lambda-term 在於把類型信息放到函數體內
     但是我的函數提內沒有類型信息
     類型是在函數作用的時候才彰顯出來的
* 試試
  #+begin_src cicada
  (* 需要 好好研究一下配色
   * 因爲現在的語法高亮真是太難看了
   *)

  (* for named functions and there applications *)
    function2
  <:arg2-of-function1
    100
  <:arg1-of-function1
  (function1)

  (* 下面的語法可以形成一次 curry
   * 即它將入棧一個匿名函數
   *)

  | 100
  <:arg1-of-function1
  (function1)



  (* for non-named functions and there applications *)

  (* 匿名函數 作爲一個數據結構
   * [我想說的是一個數據類型]
   * [我想用雙向鏈接的鏈表來實現這個數據類型]
   * 因該具有一套完整而特殊的處理函數的
   * apply 就是其中最重要的一個
   *)

    function2
  <:arg2
    100
  <:arg1
  [ :arg1
    :arg2
     ...
    <function-body> ] apply

  (* 匿名函數一般都會有約束變元 *)



  (* 匿名函數 作爲一個數據結構
   * 其初始化 必須與定義數的方式相一致
   * 也就是說它必須有相當的完備性
   * 有完整的註釋性的信息
   * [關於 關於默認的作用方式]
   * [關於 棧中重命名]
   * [關於 副作用]
   * [關於 到數據類型的註冊]
   * [等等 等等]
   * [也就是說 我在這裏需要提供設計良好的 註釋格式]
   * 所以下面這種簡單的函數作用是 不存在的
   *)

  [ function2 ] apply

  (* 而應該是
   * 即使在定義零元函數的時候
   * 也應該有註釋性的信息以說明
   *)



  function2 call (* 動態的 比如剛出某棧的 符號 可以被動態地調用 *)
  ==
  (function2)    (* 相對靜態的 *)
  #+end_src
* 融會
  1. 現在
     我可不可以把 對 digrap 的設計 融會進來
     讓兩者的語法有共通性
  2. 我想這是很難的
     因爲
     驅動現有的語法的語義
     是侷限性很強
     並且基本上被研究透徹了的
     [我指函數作用]
     而 digrap 的語義甚至都是不明的
  3. 當這種融會達成了的時候
     我的語言就真正獨特了
     兩個獨特的性質在於
     1) 我設計出了最好的使用函數複合的語法
     2) 我的語言以有向圖爲基本數據結構
     3) 甚至不只是有向圖而是更高維的東西
* 對鏈表複製的優化
* 對新的語法的理解
  1. 這裏其實是有和 digrap 的共同點的
     在 digrap 中 考慮 gexp <...> gexp
     其中 <...> 作爲一個中綴的運算
     [只不過這個運算不是單一的一個函數 而是被參數化了的]
     [有結合律的話 就應該使用 中綴表達式 這被看成是語法上的一種優化]
     而在 cicada 中 <:arg 之類的東西
     對參數的表達就像是上面的中綴一樣
  2. 啓發有二
     1) cicada 中的函數複合和圖的複合類似
     2) digrap 中爲了用線性的代碼描述兩個圖之間的複雜鏈接方式
        可以使用類似 "棧處理" 的技巧
* 關於對語法的優化
  1. 即使全局的語義是相同的
     不同的語言的語法
     也可以是
     就不同方面的語義而優化的
  2. 這樣
     每種語言的設計者
     就是在用自己的設計決策
     來鼓勵用戶對某子語義的使用
  3. 也許對子語義的鼓勵不是有意爲之
     而只是簡單地想要看看換一種表達方式之後
     理解起來會有什麼新的角度
* 關於 神語
  1. 其中我我很喜歡的一個特性是
     關於 symbol 這個數據類型的語法 被優化了
     這樣就鼓勵了程序員對 symbol 的使用
* 還有很多重要的東西需要在 蟬語 的設計之處就被計劃好
  1. 模式匹配
     模式匹配 在兩個地方有用
     一是 對結構化數據的賦值
     一是 在定義函數時 對局部變量賦值
     如何在蟬語中使用模式匹配呢 ??
     模式匹配 所形成的代碼的強大表達能力
     說明了局部變元是重要的
  2. 我所常吹捧的
     就是 蟬語 中數據結構的豐富性
     既然有 性質最豐富的 數據結構
     那麼模式匹配對它來說就越加重要
     對於有向圖[還有雙向鏈接的鏈表]而言
     爲了獲得精簡的表達 下面的想法是重要的
     1) 以某一點爲基礎
        而用相對位置來形成
        對書角結構的其他部分引用
     2) 郵箱樹[支撐樹]的使用
     3) 模式匹配的使用
        我可以把模式匹配設計的非常靈活
        看我現在所使用的進行函數作用的方式就知道了
        現在我進行函數作用的語義已經是非常靈活的了
        參數的順序都是不重要的
        而用來達到對順序的不依賴性的技巧
        也可以用來實現靈活的
        [可擴展性極強的]
        [作用非常複雜的數據結構上面的]
        模式匹配
  3. 錯誤處理
  4. 並行計算
  5. 函數庫管理
* 關於大小寫
  1. 不能利用 [拉丁字母的] 大小寫 區別來區分語義
     這一點 已經變成了 語法設計中的 一個重要原則
     因爲 漢語 沒有大小寫之分
  2. 比如 我不能用 SWAP 來代替 (swap)
     但是
     又確實能夠區分出
     這類 操作棧的函數 和 其他函數之間的區別
     那麼如何在語法中體現這寫區別呢 ?
     只能利用 詞的 特殊的 前綴後綴
     或者 前置後置 的語法關鍵詞了
     其實這就說明了 根本不應該從語法上去區別他們
     文本編輯器
     在做語法高亮的時候
     應該能夠根據語義來分別高亮他們
     但是這也許非常難
     [可能性是肯定的 因爲所有的信息都在文本當中了]
     效率上可能是不能接受的
     [如何設計文本編輯器的構架 以達到可以接受的效率呢?]
* 關於多棧於局部變量
  1. 首先 如果函數體用鏈表來實現的話
     那麼我已經有處理局部變量的存在範圍的算法了
  2. 而當 堅持使用數組來實現函數體的時候
     這種變量的存在範圍有沒有可能被正確地實現呢 ?
     此時又有兩種選擇
     1) 用 棧 來實現局部變量
     2) 用 鏈表 來實現局部變量
     如果考慮對 call/cc 的支持的話
     好像根本就沒有什麼可猶豫的
     必須用鏈表來實現一切
     哦
     這一點我之前討論過了
     兩種實現方式可以交互使用
     以減輕 數據分配器 的壓力
     [要知道被分配在堆中的數據 是一定是要被數據分配器複製的]
     [否則就相當於把兩種類型的數據分配器交叉使用了 會引出很多問題]
  3. 也就是說匿名的函數體在堆中[爲鏈表]
     而有名的函數體在詞典中[爲數組]
  4. 當沒有 cc 出現的時候
     用數組來實現參數棧
     當有 cc 出現的時候
     用鏈表來實現參數棧
  5. 還有一個問題就是
     有名函數之函數體
     之內有匿名函數的時候
     應該如何處理約束變元的綁定範圍
  6. 比如
     這個有名函數返回的值是一個經過代入約束變元而構造的匿名函數
     [每次必須返回一個新的函數體 [需要複製][而不能簡單返回引用]]
     是否應該支持兩種 返回方式呢 ?
     一種是複製 一種是引用 ??
  7. 又比如
     這個有名函數中只是簡單的使用匿名函數的函數體來形成語法解析樹
     [此時 其內的匿名函數體 所需要佔用的內存 靜態地分配到數組中就可以了]
  8. ><><>< ??? 上面這兩種區別應該怎麼處理呢 ?
     [這還沒說到如何處理約束變元呢~!]
  9. 還是有一個 env 的概念
     也就是約束的局部變元的綁定
     [其實在用鏈表所形成的簡單有向圖的時候 並不需要 env 的概念]
     其實這種有向圖處理可以運用在上面那兩種情形上
     如果這樣實現的話
     那麼每次數有新的作用的時候
     約束變元的綁定就會被更新
     如果在情形1中 不返回複製的話
     那麼局部變量的值就要亂變了
     所以必須複製 以返回
     [被綁定的東西是在 葉節點 這些 葉節點 被複製之後語義就對了]
  10. 在理解上
      這種 複製與否 的問題在 scheme 中給用戶帶來很大的困難
      [尤其是當實現方式不同時 不同的解釋器的行爲不同]
      那麼我如何設計以解決這個認知障礙呢 ?
      我保持返回引用的可能
      並且強調 如果需要的時候 必須明顯地使用 複製
      在理解上
      考慮 三角和圓圈 的圖就性了
      每個圖上的所展現的實體都有其在內存中的實際存在
      而複製的過程就是
      照着當時[指做了某些約束邊緣的綁定之後的那個時間]
      那個圖的樣子再畫一個圖出來
  11. 如果我的設計無力消除難點
      我就明顯的把這個難點向用戶指出來
* 關於垃圾回收
  1. 當大的數組被分配到堆上
     而需要複製他們的時候
     簡單的算法的劣勢就顯現出來了
     [其實這種劣勢一只存在 只不過當有大的數組時很明顯而已]
     所能想到的解決式是
     使用明顯的語法把某些 數組 和 鏈表 放在靜態的內存中
     比如
     有名函數 和 無名函數 其實已經展現出這種分類處理了
     其他的時候也一樣
     這種東西 一定要被實現爲變量的類型
     也就是說還是需要區分常量和變量
     但是要知道
     當編撰好一個詞[靜態的數組]之後
     還是可以重命名這個數組的
     此時字典中 對這個詞的 舊的定義
     已經沒法被[以正常的方式]引用到了
     那麼這些舊的定以所棧的內存就無以被回收
     [因爲其實這些舊的定義還是能夠被非正常的手段被引用到的]
     那麼
     也就是說
     常量 就像這些 有明函數一樣
     1) 他們的值還是能夠被改寫的
        就像詞典中的詞一樣
        [所以不如說他們是 "靜量"]
        但是不能給出接口以改寫這些名所對應的值
        因爲否則的話 就可能把一個 被分配在堆裏的值賦值給它了
        或者像對待詞典中的詞一樣
        只要設計一個 專門對它的賦值語法
        那麼就能夠讓它們的行爲完全與詞典中的詞一致了
        這樣
        名詞就有 恆詞 和 變詞 之分
        [因爲 "動詞" 的緣故 而不能使用 靜 和 動 這兩個術語]
     2) 被定義給常量的
        數組 和 鏈表 不被分配在堆上
        而被分配到靜態的[類似詞典的][永存的]數據段中
     3) 數據分配器 不會把這些變量當作是遍歷時的根節點
        這樣就減輕了 數據分配器 的壓力
        其實我想說 這樣纔是正確的實現方式
        因爲當你知道一個量會長存的時候
        就不應讓數據回收器對它做無用功
  2. 注意 恆詞 所綁定的靜態的數組和鏈表
     其中都不能引用到堆中的地址
     這是顯然的
     這樣基本上就要求了 這些數組和鏈表是絕對靜態的
     [然而 堆上的數據當然能夠 反過來 引用他們]
     [這就要求 數據分配器 要能夠辨別各種地方的 數組和鏈表]
  3. 可怕一點是
     上面的設計給了變量 三種類型了
     再進一步 我的變量就要帶有類型了
     這樣合理嗎 ???
     數據和變量都有類型 ???
     單純爲了 數據分配器 的效率
     這樣的設計也是必須的 !!!
* array & list
  1. to use array wherever possible
     to use list only where necessary
  2. 就名詞的分類而言
     上面的設計原則已經彰顯出來了
  3. 而別需要考慮這個設計原則的地方是
     1) 有名 與 無名 函數 的函數體
        [無名 的時候 使用鏈表]
     2) 返回棧 和 參數棧
        [當需要 cc 的時候使用鏈表]
* 幾何的遊戲
  1. 錯
     更
     不用有向圖
     而恰當地選取更高維的幾何流形爲基本數據結構[基本數據類型]
  2. 在拓撲復型中找
  3. 數據結構的可表示性有什麼侷限嗎 ?
     比如說
     list 的拓撲有什麼侷限嗎?
     要知道當用它來表示有向圖的時候
     根本就不用做編碼
     而它直接就能獲得某些跟有向圖有關的語義
     那麼當用它來表示高維的幾何體的時候
     是否就一定需要編碼了呢 ?
     不編碼的優良狀態能被推進到何種地步 ?
  4. 在引入我的理解方式之後
     lambda 作爲一個媒介
     鏈接了邏輯和幾何
     那麼
     邏輯中的經典命題的幾何意義是什麼 ?
* 高維不行
  1. [至少在初期]我根本就不能使用高維幾何體來作爲設計計算模型的對象
     因爲 高維的幾何體不像[由點和線組正的]有向圖一樣
     很容易在紙上畫出來
     這樣
     對高維的幾何體的線性編碼[代碼]
     就會與高維幾何體本身在認知上的形狀相脫節
     也就很難它們來設計 計算模型
  2. 並不是說不可能
     只是說這是一個很大的困難而已
     最初的幾個版本的蟬語
     必須避免在這個問題上糾纏
     [需要考慮的問題已經很多了]
* 語法設計
  1. 我可以利用
     文件和路徑之類的就實現而言的自然屬性
     類比到圖的幾何中
     就像 erlang 把文件和 module 等同一樣
     這樣能方便用戶的理解
  2. module system 的所用是 [考慮 erlang]
     1) 每個 module 都有名
        在一個 module 之內
        調用之外的函數須前綴[module 名]
        調用之內的函數無須前綴
        其 須前綴 者
        相當於規定了一種命名規則
        其 無須前綴 者
        相當於簡化了使用這種命名規則的方式
        [即在可能的時候省略某些前綴]
     2) 分開編譯
  3. erlang 的 module system 是以函數爲中心的
     我想
     在使用 OO 或 type[像蟬語一樣把函數登記到類型中]
     的語言中
     module 系統是以 數據[數據類型]爲中心的
     1) 在我的設想中
        爲了實現相似的命名規則的效果
        類型名 充當了 模塊名
        [爲此可能需要額外的動態性[即需要犧牲效率]]
     2) ><><><
* 語義設計
  1. 很多阻礙語義被以正確的方式實現之處
     只在因考慮效率問題而放棄了性質更豐富的數據結構而已
     我應該避免這一點
     在尋求 語義的豐富性 和 實現的高效性 之間的平衡之時
     我傾向於 語義的豐富性
* 把函數在編譯時期作用掉或者在編譯時期找好[而不進行動態的調用]
  1. 當沒有約束變元時
     這樣做很簡單
     但是當有局部變元時
     爲了找到合適的需要被作用的函數
     就一定需要動態的調用
     [因爲被代入的參數的類型是不知道的]
     但是
     因爲 明顯的參數名會提供更多的信息給編譯器
     所以 這裏也許可以做一個優化
     可以嗎 ?
     因爲查詢消息所登記的函數只是在某個數據類型之內進行的
     所以其實沒有什麼可優化的
  2. 可以提供一個可選的聲明類型的機制
     [就像 shen 一樣]
     以幫助編譯器來提前找到需要作用的函數
  3. 但是
     上面的在類型內的查找因該怎麼實現 ?
     想要用到 hash-table
     但是 hash-table 又不能被放在每個類型之內
     [因爲 太浪費內存了]
     所以只能通過在全局的 hash-table 上做手腳
     來實現快速的查找
* 謊言
  1. 我可以騙人
     說
     我的現在的語法只是另外一個編譯器的後端
     [就像 lisp 所說的那樣]
     只不過我在直接使用這個後端而已
  2. 我可以騙人
     說
     我設計這種語法是爲了讓編譯器能夠
     以相對線性的方式來處理被編譯的代碼
     [而不是去處理 語法解析數]
     這樣編譯器的編譯狀態就更容易被理解與檢查
     這樣我們在使用的時候就能觀察到更多東西
     能觀察到更多的東西 我們就能 等等 等等
* wordy-list
  1. 其全部重點就是給語法做一個簡單的優化
     ( ( :key-1 value-1 ) ( :key-1 value-1 ) )
     ==>
     ( :key-1 value-1 :key-1 value-1 )
     因爲既然約束了 :key-1 作爲 symbol 的形態
     就可以利用這種約束來簡化語法了
     僅此而已
  2. 其實還有一點
     那就是再利用 縮進 來優化語法
     以以更直觀的方式表達嵌套的 wordy-list
     這些想法來自 yaml
* wordy-list scheme 的例子 [以對比]
  #+begin_src scheme
  (define example-graph
    '(:type <<graph>>
      :0-dimension-geometry-object-list
      #2=[:v vertex-2 :address #2#
          :can (:value 222)
          :abut-edge-list
             (:e edge:2-->3 :address #4#)
             (:e edge:3-->2 :address #6#)]
      #3=[:v vertex-3 :address #3#
          :can (:value 333)
          :abut-edge-list
             (:e edge:2-->3 :address #4#)
             (:e edge:3-->2 :address #6#)]
      :1-dimension-geometry-object-list
      #4=[:e edge:2-->3 :address #4#
          :can (:edge-type black-arrow)
          :abut-vertex-list
             (:v vertex-2 :address #2#)
             (:v vertex-3 :address #3#)]
      #6=[:e edge:3-->2 :address #6#
          :can (:edge-type black-arrow)
          :abut-vertex-list
             (:v vertex-3 :address #3#)
             (:v vertex-2 :address #2#)]))
  #+end_src
* 縮進規則
** 單鏈
   #+begin_src cicada
   bra-ket
   { Mark-McGwire Sammy-Sosa Ken-Griffey }

   indentation
   ======
   - Mark-McGwire
   - Sammy-Sosa
   - Ken-Griffey
   ======

   ====== 的使用是爲了把縮進對齊
   #+end_src
** 雙鏈
   #+begin_src cicada
   bra-ket
   [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

   indentation
   ======
   * Mark-McGwire
   * Sammy-Sosa
   * Ken-Griffey
   ======
   #+end_src
** 名鏈
   #+begin_src cicada
   bra-ket
   ( :hr 65 :avg 0.278 :rbi 147 )

   indentation
   ======
   :hr 65
   :avg 0.278
   :rbi 147
   ======


   ( :american
       Boston Detroit New-York
     :national
       New-York Chicago Atlanta )

   ======
   :american
     - Boston
     - Detroit
     - New-York
   :national
     - New-York
     - Chicago
     - Atlanta
   ------
   :1 "-" for list element
   :2 "*" for dali element
   :3 ":" for wodi (* wodili element *)
   ======

   所以 單鏈 的 單鏈
   -
     - Boston
     - Detroit
     - New-York
   -
     - New-York
     - Chicago
     - Atlanta
   最好不要使用 縮進
   而直接使用 括號
   #+end_src
* wordy-list 的例子 縮進
  1. 下面可以顯然得看出縮進的好處
  2. 但是我必須這幾機制
     以允許其二者的混合使用
     以保持靈活性
  3. 下面的例子中 :abut-edge-list 被用來表達
     點邊相連之關係
     這個 :field 是爲每個幾何體所擁有的
  4. 爲了正確地解析
     必須規定每個 :kkk 後都一定要換行
  5. 我先試着寫出我能夠理解的語法
     然後看看能不能讓機器也理解它
     如果機器不能理解它 爲什麼 ?
  6. 注意到並排寫成的東西
     是第一次語法優化的結果
     如果使用縮進的話好像根本就沒法利用這種優化了
  7. 一個 :key 中
     保存 兩個 wlist 的時候
     有問題
     比如下面 :0-dimension-geometry-object-list 下
     並不是一個單一的 wlist
     而是一個 list 的 wlist
     這就是問題所在
     這種 list 和 wlist 的混合導致了難點
     但是 無名者是需要的
     因爲否則就太羅嗦了
     通過添加 "*" 可以解決這個問題
     並且需要放棄 單鏈 而全部使用 雙鏈
     否則就太複雜了
  8. 可以發現圖的幾何語義限制了上面的列表的樣子
     1-dim幾何體 能且只能 與兩個0-dim幾何體相連
     並且其鄰接列表是有序的
     0-dim幾何體 能 與0個或1個或多個1-dim幾何體相連
     並且遺忘了其鄰接列表的順序
  9. 這種限制並沒有在我的表示中被表達出來
     這代表兩點
     1) 我的表示並沒有利用這些特殊性狀
        而如果利用這些特殊性狀的話就可以簡化編碼方式
     2) 我的表達方式有被以一種更廣義的方式理解的可能
  10. 推廣在於
      可以有n-dim幾何體列表
      幾何體都可以和任意維數的幾何體相連接
  11. 但是
      可笑指出在於
      高維幾何體之間的鏈接方式並不是這裏的鏈接方式這麼簡單的
      這裏我就找到了侷限性的本質
      這在於
      這裏表達幾何體之間關係的編碼方式是
      在一個幾何體中保存另一個幾何體的地址
      - 並且
        此處還需要同步 兩個相鄰的幾何體內 所保存的數據
        因爲相鄰關係是相互的
      除非我讓編碼方式更豐富
      否則就沒法使用高維幾何體
      想要形成代數拓撲中的某些復形的語義
      並沒有那麼容易
  12. 但是其實也相當接近了
      因爲拓撲變換是非常極端的
  13. 考慮對二位拓撲流形的分類
      就知道編碼的難度了[這還沒有考慮有邊流行]
      哦
      編碼其實不難
      畢竟分類問題已經解決了
      但是我需要的不是能夠解決分類問題的編碼
      而是需要
      使得對幾何體的豐富的處理方式之表達成爲可能
      的編碼
  14. 並且有向圖根本就不是流形
  15. 可以發現下面的新語法
      是沒有歧義的
      機器也能理解了
      只要記住
      :argx 1 :argy 2
      和
      :argx 1
      :argy 2
      是同樣的就行了
      即
      並排者 和 並列者
      爲同一層次的 key
  16. 例如
      :abut-vertex-list
      中
      兩個點在這個列表中儲存的順序
      可以用來體現
      這條邊連接它們的方式
  #+begin_src cicada
  example-graph
  ===========
  type: <graph>
  zero-dimension-geometry-object-list:
    ,* #2=
      v: vertex-2 address: #2#
      can: [ value: 222 ]
      abut-edge-list:
         ,* e: edge:2-->3 address: #4#
         ,* e: edge:3-->2 address: #6#
    ,* #3=
      v: vertex-3 address: #3#
      can: [ value: 333 ]
      abut-edge-list:
         ,* e: edge:2-->3 address: #4#
         ,* e: edge:3-->2 address: #6#
  one-dimension-geometry-object-list:
    ,* #4=
      e: edge:2-->3 address: #4#
      can: [ edge-type: black-arrow ]
      abut-vertex-list:
         ,* v: vertex-2 address: #2#
         ,* v: vertex-3 address: #3#
    ,* #6=
      e: edge:3-->2 address: #6#
      can: [ edge-type: black-arrow ]
      abut-vertex-list:
         ,* v: vertex-3 address: #3#
         ,* v: vertex-2 address: #2#
  ===========
  (* 所謂把 digrap[關於新的計算模型的語義]
   ,* 在設計之處直接融合到 cicada 中
   ,* 現在對我來說還太難了
   ,* 現在
   ,* 我只把 有向圖處理 的基本部分融合到 cicada 中
   * 其實就是一個標記語言
   *)
  #+end_src
* 箭頭 與 利用相對位置來找到某個東西
  1. 像 <:arg 這種東西
     直接把棧頂的東西包裹起來
     而成爲一個可以被對應的約束變元處理的數據類型
     那麼
     可不可以豐富這個箭頭
     使得
     在嵌套所形成的樹裝結構中
     引用別的[嵌套]層次的東西成爲可能 ???
* 有向圖處理語言的需要
** daedalus
   1. 通過描述
      一個只有根節點被標記了的 有向樹
      和 這些樹上的 額外的 用來形成圈的 有向邊
      就可以實現 lambda-term 這個數據結構
   2. 被標記了的節點是這個圖的入口
      我可以沿着有向邊
      或逆着有向邊行走
      以遍歷這個圖
      以這種遍歷方式爲基礎我可以實現 call-by-need
** inference-rules
   1. 首先是對 inference-rules 的正確理解
      - 這裏在有向邊上的行走被視爲是推導過程
   2. 需要不斷的向一個有向圖中引入節點
      新引入的節點有可能以原圖中的節點爲父節點
      或者新引入的節點是一個孤立的點
      等等
   3. 必須有一個良好的對有向邊的標記系統
      因爲每個 inference-rule 的一次出現
      都必須被獨立標記
** cayley-graph
   1. why not use cayley-graph to model a group ?
      人們以前爲什麼沒有這樣做過 ?
   2. 惰性
      因爲有趣的 cayley-graph 常常是無窮的
      所以我必須實現一種對圖的惰性構造
** category theory
   1. 範疇論中的論證與實現都是在用一些圖而已
      而代數化地理解範疇論更是能聯繫起來更多的問題
      - 我忘了 "代數化地理解範疇論" 是什麼意思了
   2. 範疇論跟 haskell 這種語言息息相關
      但是 haskell 把自己限制在了線性的表示方式中
** beyond
   1. 我的有向圖處理語言的適用性必須足夠地廣泛
      在我的語言內
      要同時保證
      對上面所有這些問題的解法
      都可以用簡明的語法描述出來
      並且被有效實現
   2. 也許需要同時實現對有向圖的各種表示
   3. 也許實現各種不同的表示之間的快速地同構變換
      還要維護對一個圖的多種表示同時存在的情形
      如果同構變換的速度不夠快的話
      這時可能就要接受兩種表示之間的差異
      讓一個圖的多種表示漸進地改變
      即 需要數據的同步
** ending note
   1. 使用有向圖處理語言
      而不是字符串或列表處理語言
      可能速度會變慢
      但是這使編程者對代碼的理解更加清晰
      在這方面的 複雜性的降低 所帶來的好處
      完全可以彌補速度變慢所帶來的不足
   2. 當使用 =α= 這種概念來處理約束變元的時候
      實現起來出現了困難
      其實就已經說明這種想法錯了
      而應該改用更清晰的方法來實現所希望的特性
      即使用有向圖
   3. 當被引入的關係是等價關係時
      比如 =β=
      與其把這種引入理解爲
      對更高一層次的字符串的集合的歸納定義
      還不如直接把等價關係理解爲分類
      - 要知道等價關係本來就是分類
        這是不過是在強調要回到原處的簡單理解方式而已
      然後用與分類有關的算法來實現這些東西也許會好些
      這裏能用圖論來理解嗎 ?
      等價關係就是 一個後繼型關系所成的有向圖中 的無向路
      - 那麼對等價關係所代表的二元謂詞的具體實現
        就變成了一個在兩點之間尋找邊的過程
        如果真的以這種方式去做實現
        那麼效率肯定是低下的
   4. 當被引入的關係是由類後繼關係生成的偏序關係時
      比如 -β-> 爲 -sβ-> 所生成
      - "-sβ->" 中的 "s" 指 step
      與其把這種引入理解爲
      對更高一層次的字符串的集合的歸納定義
      還不如直接把後繼關係理解爲有向圖
      這樣纔是自然的
   5. 實現一個形式理論的方式如果和最自然的理解方式相一致
      那當然是最好的
   6. 去以歸納定義的方式
      定義一個字符串的集合
      其實 意在定義一個樹
      每個被認爲是有效的表達式者
      其實都是樹
      只不過只有葉節點被標記了
      var ::= v | var'
      term ::= var | (term term) | (λ var . term)
      就是典型的例子
      歸納定義的字符串的集合的時候所使用的括號 "()"
      其實是爲了形成樹的語義
      即 如果直接用樹來定義 term 就沒必要使用括號了
      但是實踐中
      機器只能處理線性的代碼
      因此想要在這裏省略括號
      就必須改變機器
      讓它能理解二維的表達式
* digrap 的 來自 lisp 的語法
  1. lisp 的經歷讓我知道
     在線性的文本中很容易形成樹的結構
     可以以這個樹爲支撐樹
     然後在這個支撐樹的基礎上構造起整個圖
  2. 其好處是
     支撐樹中包含了所有的點
     剩下的就只是邊需要被說明了
  3. 另外
     還想要用 樹 來編碼操作有向圖的指令
  4. 最初的設想中
     只有點元素是被明確給出的
     就像 sexp 一樣
     然後
     每一個點元素中可以保存一些信息
     這些信息可以描述
     1) 支撐樹之外的從這個點出發的有向邊
     2) 這些有向邊是如何與圖的其他部分相鏈接的
     3) 對圖的其他部分的位置的明指
        就利用在支撐樹中的相對位置來表示
     這種設計的可行性可以通過初步的思想實驗的檢驗
     但是這種設計並不令聞滿意
  5. 這與 lisp 中形成帶有 圈 的 sexp 的語法之間的區別
     就僅僅是 在那裏使用了全局的標記
     而在這裏 我使用了局部的相對路徑
     而已
     我能描述的東西確實豐富了很多
     但是還是不能說這是很好的設計
* digrap 的 來自 cicada 的語法
  1. cicada 的經歷讓我知道了
     可以在線性的代碼中嵌入一些做副作用的小精靈
     讓小精靈來幫忙形成複雜的圖的語義
  2. 給出點
     然後讓小精靈去把這些點以各種方式鏈接起來
  3. 觀念上的一個轉變是
     雖然代碼還是作爲線性的文本被提交給機器
     但是對線性的東西可以有非線性的理解
     - 這是 postfix notation 所帶來的啓示
     被線性的展示給機器的數據就像是一個無序集一樣
  4. 這種觀念上的轉變
     完全得益於對明顯的參數棧的使用
  5. 可行性在於
     我發現了
     儘管 我所設計的新的關於函數作用的語法是畫在紙上的二維圖形
     但是 只要規定一些簡單的規則
     - 提供一些簡單的小精靈
     那麼 這些二維的圖形就可以很容易地被翻譯成一維的表達
     反之 看見一維的表達 也很容易想像出二維的圖形
  6. 可以發現
     支撐樹 的好處被保留了
     - 要知道 postfix notation 和 sexp 的性質是一樣的
       只不過沒有括號而已
     而 單純地使用 支撐樹 所帶來的侷限性被消除了
* 標記語言 與 文本性編程接口的性質之匱乏
  1. 標記語言 要有一般性
     在能夠初始化 λ 的同時
     還必須能夠初始化一般的有向圖
  2. 但是 想要設計一種線性的語法
     以令人[令我]滿意的方式表達有向圖
     那真是太難了
     可能理論上就是不可能的
     想要以簡單的方式表達由樹生成的有向圖[正像λ這種]
     還是可以想像的
     因爲做了很多約定
     方才讓這種類型的圖得以
     被某種語法簡潔的表示
     然而
     一種語法 + 一種約定 == 一種特殊的有向圖
     不可能有萬能的語法能夠以簡潔的方式表達所有的有向圖
  3. 如果如此需要有向圖處理語言
     那麼就應該用手繪的點線圖來設計相關的
     初始化語法
     還有處理函數的語法
     否則根本不能令人滿意
* 一些關於明顯參數的嚴重問題
  1. 在使用明顯參數的時候
     既然
     函數都是登記在數據類型中的
     那麼
     我還是必須通過指明一個主要參數
     因爲找到一個數據類型 是找到函數的前提
     如果我默認而視棧頂的第一個參數爲主要參數
     那麼我就必須得把這個主要參數調整到棧頂來
     這樣就還是需要指明參數的順序
     這樣就與 "明顯的參數名以消除參數的順序"
     這個初衷相左了
     所以
     我必須這幾一個語法
     - 增加 詞的修飾符 或 語法關鍵詞
     以明顯地指出哪個參數是主要參數
     - 我想 新增一個 語法關鍵詞 會好些
  2. 我應該怎麼利用 <:x 和 x:>
     後者應該被如何使用 ??
     專門用來引入特殊的語法關鍵詞 ??
* ----------------------
* >< 邏輯之引
** 記
   1. 古典的 形式邏輯學家
      們把自己的表達方式限制爲了線性的文本
      我將袪除這種限制
      而把形式邏輯的本體 定爲
      高維的拓撲流形 和 有向圖 等等 更豐富的結構
   2. 邏輯學所對應的原始虛妄是
      人類的可控之物之安全感
      只要我的理論也能提供這種安全感
      我就能易羣之所趨
** 有向圖
   1. 從有向圖開始
      而有向圖中各元素所形成的維數關係
      很容易被推廣到高維
** 對組合邏輯的反思
   1. 組合邏輯在於去除 約束變元
      但是
      使用大量的約束變元 正是代數等式的意義所在
   2. 觀點是
      約束變元的使用是爲了
      讓人對思考的本體有一個印象
      這種印象能夠揭示本體的某些性質
   3. 本體是函數[運算]
      而做想要表達的性質是函數方程[運算律]
      用來形成函數方程之方程者亦是函數[算子]
   4. 使用很多約束變元
      就隱匿了本體
      所以是不好的
      [其不好在於 會引起人們思考時的混亂]
   5. 注意這裏對交換律的表達
      需要 curry
      即需要 函數一元化
      所以一元化是好的
   6. 注意對函數方程的證明
      ??? 還是需要約束變元的
      爲什麼 ?
      什麼是 證明 ??
      把邏輯也視爲算數試試
   7. 對函數的定義
      如何定義一個函數 ?
      給出這個函數的計算方式 ???
   8. 不用約束變元
      如何表達 加法交換律  ???
      我需要一個基本的
      用來表達函數的參數之間的對稱關係的東西
      然後才能表達出 類似 加法交換律 之類的方程
      比如 λxy.Mxy == λxy.Myx
      然後再把兩邊的約束變元消去
      [這種消去顯然太複雜了根本不值我演算一遍]
      重點是
      我可以給將要推導出來的組合子以名字
      然後就使用它們就行了
      k和s的意義就在於
      讓我從理論上知道了 我想要的任何的組合子都是存在的
      理解到這一點非常重要
      k和s並不爲以純粹地方式在實際的編程中被使用
      而在於用來證明
      在理論上
      有限個組合子就能代替關於代入的推演規則
      [要知道 後者敘述起來是很複雜的]
   9. 也就是我需要用一個 組合子 來捕捉這種對約束變元的使用
      [比如如果有逆運算算子的幫忙]
   10. 所以組合邏輯
       是一種[不同於最顯而易見的函數作用的]觀看問題的角度
       作爲一種新的觀察角度
       當這種角度被發現時
       發現它的人自然就有希望[野心]
       想要去觀察出別人以別的方式沒有觀察出來的東西
       當某些希望被別的學者證明是虛妄的時候
       haskell 只好辯解說 自己繼續對這個領域做研究是因爲興趣
       但是
       其實 haskell 還是沒有悟出來根本的道理
       那就在於
       去得到不同的觀察角度 這件事本身就是意義所在
       如果從很多的角度去觀察自然的某一個特性的時候
       自然的這個特性都是如此
       那麼自然的特性就是如此而已
   11. 我發現
       我可以以 "對函數的理解爲中心"
       而演繹一下各個理論的歷史
* >< 算數之引
** 記
** 運算之級
* 正名
  1. digrap == directed graph processing
     即 以有向圖爲基本數據結構的語言
  2. 實現對有向圖而言的各種等詞
     1) 在以圖爲數據結構編程時
        這些這些等詞是基本工具
     2) 在實現數學形式語言時
        這些等詞是形成命題的基礎
  3. 說對 λ-cal 還有對 rewrite-rules 的實現
     等價與 對圖[圖的圖]的惰性求值
     這裏這些圖的特點是什麼
     反過來問
     是什麼使得對它們的惰性求值
     可以用 λ-cal 或 rewrite-rules 來描述 ?
     是對節點和邊的標記系統嗎 ?
     [約束變元]
     每個站在一個節點上看看這個節點的標記
     再看看某一條有向邊的標記
     就能知道從這個節點沿着這個有向邊走過去的節點的標記
     [這對 cayley-graph 的使用有什麼啓示 ???]
  4. note about λ-cal
     我把對 λ-cal 的實現理解爲對有向圖的惰性求值
     但是這樣作好像並不自然
     不管是在理解方面還是在實現方面都是在倒退
     因爲
     當人對一個有向圖的惰性求值形成了 λ-cal 這樣的編碼
     他就獲得了更特殊化的語義
  5. 但是一般性的分析
     也許更夠引出同源的理論
  6. 我把一次 -sβ-> 理解爲添加一個節點再刪去一個節點
     而他把一次 -sβ-> 理解爲把一個編碼轉化爲另一個編碼
* 記
** platonism [理想主義]
   the world of mathematics exists independently of the mind of the mathematician
   every statement that makes mathematical sense is either true or false
   [statement that makes mathematical sense are called proposition]
** brouwer [直覺主義]
   the foundation of mathematics is in the intuition of the mathematical intellect
   proof by contradiction is not an acceptable proof rule
   [因爲 用反證法所正名的存在性 有時並不能[樸素的]直覺所[容易地]察知]
** 數學語言
   1. 數學只不過是語言而已
      它也有自己的演變
   2. 最沮喪的時候 也要知道
      hott 是關於語言的學問
      因爲我已經發現
      在回到更傳統的數學活動當中時
      我的思考方式和表達方式
      已經被 λ-cal 與類型論完全改變了
      我想更深刻的改變我的認識與方法的是
   3. 對形式語言的學習
      增強了我對數學概唸的表達能力之外
      還讓我 排斥形而上的傾向
   4. 對計算理論的學習
      現在在方法上面我更注重可構造性和可實現性
** 範疇論於運算級 與 範疇論的弱點
   1. 既然我已經給出來了自由代數結構這個基礎
      那麼我關於運算級的想法是否可以用範疇論的語言來表達
      不可以
      因爲範疇論不適合用來描述具體的[構造性的]數學結構
      這就是範疇論的弱點
      [這就是 範疇論 被成爲 抽象廢話 的原因]
      要知道在最開始發展等級理論的時候
      我就是要發展彌補範疇論的這種弱點的方法
   2. 級數的升高惡化着級數升高的條件
      [使得級數的繼續升高成爲不可能 ???]
** 無窮有向圖的惰性求值
   1. 對無窮有向圖的處理只能是惰性的
      機器需要知道的是如何在需要的時候到達這個圖中的任何一個節點
      當機器已經有這樣的知識之後
      既然關於這個圖的一切已經蘊含於這些知識當中了
      我如何能表達關於這個圖的一般性質
      我現在只知道對這些性質的表達一定是在一個更高層次的語言中進行的
   2. 既然實現一個形式語言被我理解爲
      實現對一個無窮有向圖的惰性求值
      我想最適合用我的語言實現的語言應該是
      一些製作形式語言的工具
      + 首先 hott 中各種關於語言的實驗在我的語言中就方便多了
   3. 更廣泛的
      當我能方便的處理有向圖時
      因爲使用了一個性質更豐富的基礎數據結構
      在使用這個語言的時候對於很多事情都能產生新的想法
      尤其是關於計算的理論
      還有關於數學
** 設計之極簡主義
   1. 我已經知道該如何去推廣λ-cal以形成一個數學背景
      來設計我的語言的語法了
      只是還有一兩個問題沒有想通
   2. 除此之外對於理論的創造而言有一個重要的哲學觀點需要被我認同
      那就是極簡主義
   3. R5RS
      programming languages
      should be designed
      not by piling feature on top of feature
      but by removing the weaknesses and restrictions
      that make additional features appear necessary
   4. 但是我很難遵循極簡主義
      因爲我處理的問題本身的複雜性
      但是這只不過是一個藉口而已
   5. 有很多方式可以建立幾何學
      但是是歐幾里得說明我們只需要五個公理
      古代的人也許也認爲那種幾何是複雜的呢
   6. 那麼我需要作的就是看到有向圖處理的本質
   7. 但是也許我的整個計劃就是在違背極簡主義
** 關於 lazy-eval
   - k :: 什麼是lazy-eval 惰性求值?
   - x :: 就是懶得去求值的意思
          比如構造子在構造一個數據結構的時候
          構造子它就像一個函數一樣 它的參數是一些表達式
          這些表達式可以是解釋器能夠解釋的任何複雜的嵌套的東西
          比如一個表達式裏面又有很多構造子對參數的作用等等
          構造子如果是懶惰的
          你讓它構造東西的時候
          它就只作最基本的工作
          它把這些表達式放到該放的地方之後就不管了
          當你之後要需要知道構造子所構造的部分的值的時候
          你會用與構造子對應的詢問子來詢問
          這時候詢問子纔會完成求值的工作
          也就是說構造子是懶惰的
          把活都交給詢問子來幹了
          比如 LISP 中的的懶惰版本的 cons 可以叫做 zons
          (zons (λi.i λi.i) (λi.i λi.i))
          根本就不會對它的兩個參數求值
          只有當 (zar (zons (λi.i λi.i) (λi.i λi.i)))
          => λi.i
          的時候纔會對它的第一個參數求值
          等等
   - k :: 那麼
          是不是任何結構化數據的構造子都能變得懶惰 ???
   - x :: 其實我也不知道
          你可以嘗試去找找反例
          如果找不到反例
          你可以嘗試形成一個小理論
          [也許需要補充一些假設什麼的]
          去證明對你的問題的肯定是一個真命題
          但是我懶得這麼作了
   - k :: 看來根那些構造子一樣
          你也是懶惰的
   - x :: 懶惰也沒什麼不好
          另外我想指出
          對於惰性求值這個術語還能有別的理解方式
          那就是函數的惰性求值
          構造子可以被理解爲函數
          我們正是在這種理解方式下來解釋懶惰的構造子的
          函數也可以被理解爲構造子
          函數的惰性求值也有類似的解釋 我就懶得說了
   - k :: 但是至少說一說函數爲什麼是構造子 ???
          這並不顯然
          最好能給我舉一些例子
   - x :: 好的
          讓我們來考慮純粹的理論性的 λ-cal
          說它是理論性的是因爲
          雖然它能夠用來編碼你能想像到的所有數據結構
          並且它能夠用來表達所有可計算的函數
          但是使用起來並不方便 計算起來也不高效
          但是我們就先來考慮這種簡單的東西
          因爲我們想要理解到問題的本質
          首先是它的表達式的集合的歸納定義
          [或者說遞歸定義]
          #+begin_src bnf
          簡單得寫就是:
          <λ-term> ::= <var> | (<λ-term> <λ-term>) | (λ<var>.<λ-term> <λ-term>)

          分開來可以寫成:
          <λ-term> ::= <var> | <λ-application> | <λ-abstraction>
          <λ-application> ::= (<λ-term> <λ-term>)
          <λ-abstraction> ::= λ<var>.<λ-term>
          <var> :: {一個先驗定義的符號集 與自然數集等勢}
          #+end_src
          先不考慮懶惰不懶惰的問題
          這種表達式其實是二叉樹 你能看出來嗎??
          比如:
          (a (b (λx.[c (x ((x m) n))] (λi.i λi.i))))
          我用 [] 表示了那個直接跟在 λ 面的特殊的 <λ-term>
   - k :: 上面的例子真是構複雜的了
          但是我能理解
          畢竟想要存儲表達式就必須有一個數據結構
          而這裏的數據結構就是二叉樹
          並且我知道
          這個二叉樹只有葉節點是有內容的
          只要使用括號就能用線性的字符串來表達這些二叉樹
          並且我還知道
          是 <λ-term> ::= (<λ-term> <λ-term>)
          這一個歸納定義項在是形成着二叉樹
          但是 λ<var>.<λ-term> 這個東西我有點不理解
          它好像是二叉樹的簡單語義之外的東西 ??
   - x :: 沒錯
          有了它其實我們得到的就不是單純的二叉樹了
          而是一個有向圖
          這個有向圖的支撐樹是一個二叉樹
          這個支撐樹就是上面你所指出的那個歸納定義項所形成的
          而支撐樹之外的有向邊
          就是令你迷惑的那個 λ<var>.<λ-term> 形成的
          只要把 λ<var>.<λ-term> 中
          <λ-term> 裏面
          與 λ 後面的 <var> 相等的 <var>
          鏈接到 λ 後面的 <var>
          你就得到整個有向圖了
          如果我能在黑板上給你畫一下的話
          那麼不用言說你也會明白我的意思
   - k :: 我明白了
          我能想像出你所希望描述的有向圖了
          現在給我解釋什麼是函數的惰性求值吧!
   - x :: 這樣來想
          在 LISP 中用構造子 cons 來構造列表
          [LISP中的這個構造子是勤快的]
          (cons 1 (cons 2 (cons 3 '())))
          這與直接寫出表達式 '(1 2 3) 是一樣的
          而在上面我寫出表達式
          也與我用構造子來構造這個表達式是一樣的
          這裏我需要懶惰處理的是
          (λx.[c (x ((x m) n))] (λi.i λi.i))
          因爲這一項就是需要被求值的項
          它求值之後應該得到 (c (m n))
          這就是構造子懶得乾的事
          構造子和函數可以以差不多的方式來理解
          也就是說函數也可以是懶惰的
          構造子以參數爲基礎進行構造
          就類似於 函數拿到參數然後進行代入
          當函數懶得對參數求值而直接進行代入的時候就是惰性求值
          但是要注意一個參數可能被代入到多個點
          [就像上面一樣]
          這時候如果對一個點的參數求值了
          那麼其他的點就都應該知道這個被求值的結果了
          [這就叫做 call-by-need]
          這一點是對惰性求值的實現方面的問題
          想要實現這種東西並不困難
   - k :: 惰性求值有什麼好處呢 ??
          哦
          我看到了一種好處
          比如在上面
          (car (λx.[c (x ((x m) n))] (λi.i λi.i)))
          => c
          當使用惰性求值的時候
          詢問子 car
          沒有詢問到的地方就不需要被求值
          因此 (λi.i λi.i) 根本就沒有被求值
   - x :: 沒錯
          這就是 call-by-need 這個術語的由來
          更重要的是這種求值方式在 λ-cal 的理論中具有優越性
          這裏我就需要引用一些別人的書來給你看了!
   - k :: 那麼 digrap 中的惰性求值應該如何實現呢 ???
   - x :: 這個留到下次討論吧 !
* 簡言之
  1. 對於幾何體
     1) 編碼
     2) 編碼 以使 處理 爲可能
     3) 處理 以成 形變 之義
     4) 形變 以成 計算 之義
  2. 我發現最重要的一點是
     去找到什麼幾何體適合用來形成計算模型
     這種 幾何體 需要具備的性質就是
     1) 具有較優良的可編碼性
     2) 其變換能夠被表達
        並且有豐富的性質
  3. cicada 所進行的是 前兩個
     [之所以要實現 cicada]
     [是因爲沒有別的語言適合用來實現 digrap]
     digrap 所進行的是 後兩個
     也就是說這裏有倆各個層次
     其中
     第二個層次中的算法
     是用對有向圖的形變來表達的
     然而
     第一個層次中也要表達算法
     此時的算法是用
     代入語義 外加 函數複合[threaded-code] 來表達的
  4. 按現在的設來說
     在第一個層次中我已經實現了對圖的表達
     表達本身還是線性的
     只不過描述圖之間的鏈接關係的是一些小精靈
     而且這裏的 "鏈接關係" 在實現上與 digrap 中不同
     那麼 應該如何區分呢 ?
* ζ-cal
** 記
   1. 也許最後我會發現我所尋找的解決辦法極其簡單
      只不過我一直沒能認清一直就在我眼前的事實而已
   2. abstraction 與 application 的意義本來就是相當廣的
      對一個 λ-application 的計算
      在 "形式" 上 需要遵循 推演規則
      推演規則應該如何施行
      其信息是被編碼在 λ-abstraction 中的
      可以說 λ-abstraction 是對 rewrite 的抽象
      一個有向圖 當這個有向圖和它的參數融合的時候
      這個 有向圖就依照編碼於這個有限圖內的信息而變化
      這種意義上的 rewrite 也可以是就更一般的有向圖而言的
   3. 我稱這種廣義的 λ-cal 爲 ζ-cal
      ζ-cal == basic-directed-graph-processing
            + ζ-abstraction
            + ζ-application
            + ζ-lazy-eval
** λ 之我見
   λ-ap 是對葉節點被自由變元標記了的
   分叉數爲2或1的樹 [有向圖]
   的遍歷
   [傳統的術語中 各種不同的遍歷方式 就被稱爲各種化簡策略]
   其中每次遍歷到 λ-ap 的時候樹就會按 <-β- 所描述的規則變化
   1) λ-ab 的形成的任意性:
      以任意一個 term 爲基礎
      然後指定一個自由變元
      就可以形成一個 λ-ab
      之後這個自由變元就變成約束變元了
      去形成一個 λ-ab
      就是去指出一個點[一個位置]
      並且聲明 這個位置的點
      將來要被換成另外的有向圖
   2) λ-ab 的局部性:
      對一個葉節點對的處理
      並不會影響這個葉節點對之外的圖的其他部分
      在推廣的過程中
      這種局部性
      是這樣被捕捉的
      即
      爲了做一個變換
      描述中 必須以被代換的點爲基準
      對別的點的指明
      都通過就這一基準點的相對位置而完成
** 類比
   1. 用鏈表來實現 λ-cal
      之後寫出複雜的列表處理的函數就全在於 λ-cal 了
      此時還需要對 rewrite [比如 -β->] 的實現
      即 一個解釋器
      [即 爲了讓 λ-ab 中能夠編碼一個代入]
      [而需要明確編碼的方式]
      + 此時需要對約束變元作技術性的處理
        要麼用重命名的方法
        要麼用用有向圖來處理
      + 反過來 λ-cal 可以完成對鏈表的處理
   2. 用有向圖處理來實現 ζ-cal
      反過來這種 ζ-cal 可以完成對有向圖的處理
      之後寫出複雜的有向圖處理函數就全在於 ζ-cal 了
      + 有了這層語義
        就算是對有向圖這種複雜數據結構的處理
        也能使用函數式編程範式了
   3. 類比還在於
      我能把 λ-cal 包含在 ζ-cal 之內
** ζ-cal 作爲 λ-cal 的推廣
   1. 下面的理解最重要
      應該把 λ-cal 也理解爲一個對二叉樹的惰性求值系統
      [用樹來考慮下面的東西]
      尤其是考慮到絕對的自由變元時更應該如此
   2. 那麼這種惰性求值系統的特點是什麼呢 ???
      有所謂的惰性求值之後
      就能用有限的元素來表達無窮的結構
      [這種性狀最令人感興趣]
      這是因爲對與這種圖
      人們規定了一種特殊的遍歷方式 即 -β->
   3. 並且要知道 一個 term 是不是 λ-abstraction 都沒有關係
      對 λ-abstraction 內部的東西也是可以進行求值的
      λ-abstraction 並沒有特殊性
   4. 難點在於
      當遍歷到一個 λ-application 時
      它本身與周圍的圖的鏈接方式是平凡的
      它求值之後所得的東西與周圍的圖的鏈接方式也是平凡的
      但是對與一般的有向圖這一點並不成立
   5. 這裏的複雜性可能是本質的
      也就是說 ζ-cal 必須描述兩種鏈接方式
   6. 但是如果有局部性的話
      如何呢 ?
      整個式子 ((ζ <body>) <arg>)
      是以某種方式嵌在一個被遍歷的大的圖中的
      <body> 與外面的大圖的鏈接方式是已知的
      而 <arg> 被代入 <body> 所改變的東西
      邊並不影響 <body> 與大圖的鏈接
      這就是局部性
   7. 但是又回來了
      即 這樣就沒法把 (ζ <body>) 當作一個獨立的東西了
      只有當指明了 <body> 與大圖的鏈接方式的時候
      (ζ <body>) 纔有意義
      或者 (ζ <body>) 可以被當作獨立的東西
      但是每次被放入大圖中的時候都必須說明 <body> 中
      沒有被 ζ 的抽象所影響的部分如何與大圖相鏈接
      沒錯
      這是合理的
      因爲
      在有向圖處理中
      擴大一個圖就是去說明一些複雜的鏈接方式
      這樣一個重大的問題就解決了
      [可以說就幾何直覺而言現在已經沒有任何難點了]
      還有一個重要的問題就是形成遞歸
      這將是要在下面提到的
      即 形成具有無窮性的結構[比如遞歸]
      其本質不在於巧妙的 term
      而在於自我引用
   8. 在有向圖處理中
      在一個需要惰性求值的點處對原圖的其他部分的引用也是可以想像的
      + 畢竟λx.F(xx) λx.F(xx)之所以能形成遞歸對遞歸函數的定義
        是因爲前面的λ-abstraction作用於與自身相同的λ-abstraction
        或者說前面的λ-abstraction在作用於自身
      類似於分形的圖是經過無窮次的遞歸得來的
      因此就與fixed-point有關
      因此也與遞歸有關
      + 考慮Y所生成的遞歸函數作爲無窮二叉樹的性質
        那也是分形
        因爲那是在-β->的特殊指引下自身在引用自身
        這就是分形的本質
        也是那些正規的無窮圖的本質
** 對圖的基本處理
   有以下基本操作
   [其實 ζ-cal 本身就也是被基本的有向圖處理實現的]
   1. 利用樹來初始化一個圖
   2. 將兩個圖用一些新的有向邊相連
   3. 刪除某些節點
   4. 刪除某些邊
   5. 改變某個點或邊中所存放的東西
      點和邊裏是可以存放東西的
      而且沒有類型的限制想存放什麼就存放什麼
      就像 lisp 的 list 能夠保存任何類型的數據一樣
      我需要我的有向圖也有能力保存任何東西在裏面
** ζ-abstraction (ζ-ab)
   對於一個圖 指定其中的一個基點
   1. 以這個基點爲基礎
      用一棵樹來指明一個有序節點列
      這個有序節點列是爲之後的 "擴大" 所準備的接口
      當這些接口被拼接時這個圖會被擴大
   2. 以這個基點爲基礎用一棵樹來指明一些將被刪除的節點
      這樣會使這個圖縮小
   3. ><><>< 那麼其他的對圖的操作如何呢???
      這就是所有的操作嗎???
   4. >< 可以變大可以變小我就掌控了所有的變化 ??
   5. 所列出來的兩個點列中
      哪些點會被刪除或者哪些點會被鏈接
      都是要等到ζ-application的時候纔會被明確的
   6. 整個ζ-abstraction也是一個特殊的圖而已
      只要使用從一點出發的一些有向邊來指明一次抽象中的
      接口節點列和所能刪除的節點列 就行了
      這樣我就可以利用 ζ-abstraction
      把某一類 有向圖處理抽象出來
   7. 一個ζ-ab作爲一個gexp
      就像一個小機器一樣
      在ζ-cal的語義中它以其中被抽象了的點爲接口
      對於一個ζ-ab(as gexp)我可以實現一些基本的函數來查看它作爲機器的性質
      比如:
      1) 詢問這個ζ-ab中所有被抽象了的點
      2) 詢問一個點的接口點列和可刪除點列
      3) 等等
      4) 這些詢問所返回到的信息應該能直接被ζ-ap中的ζ-con利用
** ζ-application (ζ-ap)
   這時候我手上有兩個ζ-ab
   就像我知道一個函數(λ-abstraction)的性質一樣
   + 函數的:參數個數與類型 返回值個數與類型
     其中個數不是本質的類型纔是本質的
   在這裏我也知道ζ-ab的性質:
   1. 它所能刪除的點列
   2. 它的接口點列
   一次ζ-ap就是:(注意只有兩個ζ-ab才能被作用)
   ζ-ap == (ζ-ab ζ-con ζ-ab)
   其中ζ-connection是對連接方式的描述
   + 注意這看起來是對稱的
   ζ-ap也是用一個圖來表述的
   這樣一個ζ-ap的結果就可能是一個新的ζ-ap
   + 對ζ-ab的處理就是一個需要類似於解釋器的東西的地方!!
   + 雖然不是類型系統
     對接口與連接方式的匹配的要求
     同樣也是對函數的輸入與輸出的限制
     也許引入適當的語義
     我就能以這種方式給出一個類型系統的模型
** 也就是說 融合 函數 在語法上被優化爲了一個中綴表達式
** >< ζ-lazy-eval
   1. 這是很樸素的想法
      即上面的ζ-ap是真正被遍歷到的時候纔會被進行的
      因爲ζ-abstraction也是用一個圖來實現的
      所以這種lazy-eval很容易實現
** >< 關於嵌套與自我引用
   1. 其實也很簡單
      ζ-ap的嵌套是自然的
      一個ζ-ap的結果就可能是一個新的ζ-ap
      它使得對某個圖的遍歷方式變得複雜
   2. 而自我引用就是沿着新的邊走卻又走回了原來的節點
      這些一起使得可以形成複雜的無窮圖
** >< 關於透明性
   所謂透明性就是把ζ-abstraction於ζ-application都表示成有向圖
   這樣我可以完全剔除約束變元
   而解釋器對ζ-cal的實現就是有向圖處理
** 關於代數
   1. 一般的代數結構自然的會形成二叉樹
      但是這其實並不是不可能
      考慮一下高維同論羣就知道了 !!!
      [其羣也爲代數 但是是變換的複合]
   2. 考慮跟 λ-cal 有關的豐富的數學理論
      範疇論 代數拓撲 等等
      可想而知 ζ-cal 這種計算模型
      其背後所隱含的數學理論是非常新而豐富的
   3. 比如我可以嘗試先在 λ-cal 的圖論意義
      和 λ-cal 的代數意義之間建立一種關係
      然後再利用這種關係從 ζ-cal 的圖論找到 ζ-cal 的代數意義
   4. 其實當說代數意義的時候
      函數的複合 和 函數的作用
      這兩種東西的區別造成了很大的差異
      其實本質上是一樣的
      只不過函數複合直接用 threaded-code 就能實現
      而函數作用還需要複雜的編譯而已
      二者都可以實現 lambda 所代表的代入語義
   5. 但是
      其實
      二者都沒什麼代數可言
      因爲作爲代數它們的性質都太一般了
      [除非作出某些限制]
      然而
      人們已經指出了
      其 與 範疇論 邏輯 拓撲 這三個學科之間
      都有有趣的聯繫
   6. 但是這幾乎是不可能的
      因爲在進行一個 ζ-ap 的時候
      我不光只需要那兩個 ζ-ab 而已
      我還需要一個額外的東西來指明這兩個 ζ-ab 如何相鏈接
      這已經出離一般的代數結構之外了
   7. 其實沒那麼可怕
      因爲在新的代入語義中
      明顯的指明參數名字的過程
      已經類似於一個被參數化的中間元了
   8. 但是也沒有出離的太遠
      畢竟這是不過是
      (ζ-ab ζ-con ζ-ab) -> ζ-graph
      [ζ-graph == gexp]
   9. 但是
      既然如此
      其實代數意義就已經喪失了
   10. 如果只是在遍歷圖的時候其中的一些部分被惰性求值
       那麼如何觸發一次 ζ-ap 的進行 ??
       這一點還沒想清楚
       完全的惰性求值就沒有這種顯式的觸發
       也許增加一個可以控制 ζ-ap 的觸發的機制
       我就能實現對求值時間的控制
   11. 如果我固定一種[或某些] ζ-con
       並且將 ζ-ab 一一定那個的方式封裝起來
       我就很容易回到一種代數語義
       [所以這是代數的推廣]
       [只不過算數元素之間的 "乘法" 在這裏被豐富了很多]
       比如利用上面的方法我可以回到 λ-cal
   12. 上面的行爲
       就像是去約定一個默認的函數作用順序一樣
** 再次回到基本操作
   1. 顯然只要基本操作不改變ζ-ab中的接口點列中的點
      那麼任何操作都是合法的
      也就是說ζ-ab是可以被基本操作來作用的
      它們跟一般的圖沒什麼區別
   2. 基本操作甚至可以形成手術
      來改變描述ζ-ab中的接口點列和可以被刪除的節點列的有向邊
      這就是透明性所帶來的好處
      任意一個用圖描述的圖的算法
      都是一個圖而已
      可以很容易的拿出來修改與考察
** 新編程範式
   1. lisp 的特點是
      用鏈表處理 實現 lambda-演算
      而 lambda-演算
      很適合反過來 用來實現對複雜的鏈表處理函數
   2. 其實
      lambda-演算之語義 與 其實現方式 是無關的
      比如
      只有包含約束變元的 lambda-term [組合子]
      就單單表達一個作用於 lambda-term 的算法而已
      當 增加原子性的 數據類型 和處理函數的時候
      含有自由變元的 lambda-term 就可以
      用來處理各種 數據類型 的數據
      lisp 找到了完美的平衡點而已
   3. 這對 digrap 的啓示在於
      ζ-cal 是用 directed-graph 這個數據類型
      來表示處理 directed-graph 的算法
      directed-graph 的點和邊中可以包含其他類型的數據
      對其他類型的數據的處理用 原子性的 primitive 函數 來完成
   4. 問題是這兩種類型的函數如何相互協調
      在 lisp 中 primitive 的作用方式與 λ-ab 的作用方式是一致的
      慶幸的是
      新的 爲 cicada 而設計的 函數作用的語法
      其作爲將來的 [相對 digrap 而言的] primitive 函數
      已經具有相當一致的作用方式了
   5. 其實在這裏我已經形成了一個
      比 以 λ-cal 爲核心的函數式編程範式
      更 豐富的一種編程範式
   6. 看看一個 ζ-ap 的樣子 (ζ-ab ζ-con ζ-ab)
   7. 而每個對於 gexp 的操作
      [比如一個基本操作或者一個 ζ-ab]
      都可以有兩個版本
      一個使用被處理的圖本身[通過地址]
      一個使用新複製的一個被處理的圖
      這樣一個第二個版本的 ζ-ab 就可以像數學中的函數一樣
      在多次的作用中維持一致的行爲
      這就是我所繼承的函數式編程範式的基因
   8. 去證明我確實形成了新的編程範式
      就在於
      用我所設計的模型
      來表達各種其他的基本的計算模型
      比如
      1) 利用 ζ-cal 來實現 λ-cal
      2) 利用 ζ-cal 來實現遞歸函數
      3) 利用 ζ-cal 來實現類型系統
   9. 首先既然 λ-cal 被理解爲是
      用有向二叉樹表達的對有向二叉樹的操作
      那麼用 ζ-cal 來實現 λ-cal 是非常簡單的
      也就是說 ζ-cal 的抽象能力顯然比 λ-cal 更大
      但是也更複雜
      因爲使用了結構更豐富的數據結構
      所以我的計算模型一定可以
      以更簡單的方式
      去表達一些
      用 λ-cal 和其他計算模型表達起來更複雜的計算
   10. 何爲計算
       在我的語言內
       計算竟被理解爲用圖表達的對圖的操作
       把這個問題追問下去很可能令人陷入瘋狂
   11. 函數的階
       在 digrap 中函數的階的樣子很不一樣
       可以把一個 gexp 中的被抽象了的點的個數定義爲方程的階
       但是這些點之間是平行的關係
       所以 階 這個詞 所暗示的序關係其實是錯誤的
** >< 何謂用圖來表示對圖的操作
   1. 即對圖的遍歷方式有兩類
      一類是按語法遍歷[數據]
      一類是按語義遍歷[運算]
   2. 按語義遍歷就是說 像((λ ***) ***)節點對一樣被<-β-處理一樣
      這樣我就能夠把ζ-abstraction在圖中利用其它ζ-abstraction的作用來代來代去
      然後形成ζ-ap
      ζ-ap的返回值可能還是ζ-ap
      [有一步的-ζ->和多步的-ζ->]
      [即我能控制求值的方式]
      我的圖的表達式中也要有匹配到某種模式的圖被按語義處理
      這需要一些設計 但是簡單的
      重點是所有這些必須都用有向圖處理來實現
** >< 例子 [需要更多的例子]
   對那個無窮五星圖
   遍歷到中點的鄰點時需要把中點代換爲一個五星
   然後把代入的五星與原圖相連
   這就是用惰性求值的ζ-ap來實現的
   但是完全自我引用就會形成循環
   所以對自我引用應該至少提供兩種處理方式
   1. 一種會形成真正的新的節點
   2. 而另一種不會
   對於形成真正的新節點者
   自我引用是假的
   自我引用只是提供了一個和自己相同的模板來擴大這個圖
** >< 打印
   我需要對文件的結構化讀寫 這裏有是一個新的設計領域
   >< 打印可以用支撐樹來作嗎?
   圖中也許必須包含一些額外的信息來建議如何把一個圖打印出來
* ----------------------
* ^-^
** Y
   1. 假 Y
      #+begin_src cicada
      [ [ :x (:x) (::f) ] <x
        ( :x (:x) (::f) ) ]
      #+end_src
   2. 這種語法的特點是
      局部變量的使用方式間的區別變得很搶眼
   3. 而兩種括號的語義在於
      #+begin_src cicada
      (* 有名函數的作用 *)
      (function-name)  ==  function-name (apply)

      (* 匿名函數的定義 [數據結構的初始化] *)
      [ :x (:x) (::f) ]

      (* 匿名函數的作用 *)
      ( :x (:x) (::f) )  ==  [ :x (:x) (::f) ] (apply)
      #+end_src
   4. 也就是說
      用默認的 [ ] 來初始化基本數據的時候
      我提供了一種標記語言來說明局部變元的作用範圍
      1) 這種標記語言是利用 相對位置的
         而 傳統的 表示約束變元作用範圍的 標記語言
         使用的是 label
      2) 使用 label 就相當於
         在進入函數體之前
         對 被認爲是這個層次的 約束變元 進行聲明
         兩種方法個有用處
         所以我設計語法 把它們都實現出來
      3) 想要改變默認的 [ ] 的行爲的話
         就可以 使用
         [ <hiya> ] [ <lazy> ]
         [ <do> ]
         [ <re> ]
         [ <mi> ]
         [ <fa> ]
         [ <sol> ]
         [ <la> ]
         [ <xi> ]
      4) 無名函數的作用也被優化爲了 ( )
         這樣在視覺上就與 (function-name) 一致了
   5. Y 的使用方式是
      #+begin_src cicada
      <f Y apply
      <f (Y)
      #+end_src
   6. 真 Y
      #+begin_src cicada
      [ [ [ ::x (::x) ] (::f) ] <x
        ( [ ::x (::x) ] (::f) ) ]

      [ [ [ ::x (::x) ] (::f) ] <x
       ([ [ ::x (::x) ] (::f) ]) ]

      [ [ [ ::x (::x) ] (::f) ] <x
        [ [ ::x (::x) ] (::f) ] (apply) ]

      (* 對比如下 *)
      [ [ :x (:x) (::f) ] <x
        ( :x (:x) (::f) ) ]
      #+end_src
** 惰性求值
   1. 在理論性的 lambda-calculus 中
      惰性求值是自然的
      而在 蟬語 中
      惰性求值是不自然的
   2. 這就說明 蟬語 的語義
      與 [理論性的]lambda-calculus 的語義
      之間有差別
   3. 這這個差別就在於
      蟬語 對求值順序[運算順序] 有一個明指
** 登記
   1. 關於登記
      不要 簡單的 單一的
      函數小名 到 [一個]數據類型的這種登記了
      而使用複雜的類似數據酷的東西
      每個函數的作用方式被存儲起來 有待匹配和查詢
      [這裏可以實現非常靈活的設計]
      這樣在 使用明顯的參數名做函數作用的時候
      我就能夠簡化語法 ^-^
** >< 關於把 digrap 與 cicada 融合
** 冒號
   1. 前冒號用於標記約束變元
      後冒號用於聲明域
** 默認的函數作用方式
   1. 只要找到一個簡單直觀的方式
      給連在所指定層次的
      所有 約束變元 所組成的集合
      以序關係就行了
   2. 深度優先遍歷這個只有葉節點有名字的樹就行了
      此時約束變元的順序
      就是直觀的順序
** 實現細節
   1. 現在應該討論實現細節了
      因爲我已經明確了語法的設計原則
      即 我所設計的其實是一種標記語言
   2. 在我看來 標記語言之作用在於
      在線性的文本中 表達非線性的結構
      然而
      比如說 去給數據增加屬性標籤
      也稱爲標記語言 但是後者簡單的多了
   3. 我必須推廣我的設計
      使得 對約束變元的處理
      只是這個標記語言的一個應用而已
   4. 如果我使用 label [貼在殼子上面的]
      而又允許 label 重名
      那麼我就又必須去計算 scope
      計算 scope 並沒有什麼不好
      只要有明確而簡單的規則就可以了
   5. 古典的對 scope 的計算
      其實是在用大剪刀修建一個樹
      在每個計算點
      所需要鏈接的點是它的很多的子節點
   6. 現在這裏有一種優越性了
      即 在每個計算點
      所需要鏈接的點只有一個
   7. 那麼我現在能夠把點鏈接到各種殼子了
      但是其實每個有地址的東西都應該可以被相互鏈接
   8. 其實還是形成樹的結構
      但是當某些殼子被命名了之後
      - 其實不光是殼子
        殼子中的東西所自動獲得的序關係
        也可以被利用起來
      我就可以利用這些命名
      來用相對路徑
      形成對位置的指定
      - 這就說明了
        在語法解析的時候
        我必須先把樹建立起來
        然後在遍歷它 以處理約束變元
   9. 可行性已經受到了思想實現的檢驗
      剩下的就是去設計 語法 和 數據結構 了
   10. 語法
       現在能想像到的[有待優化的]對情況的分類爲
       1) 約束變元
          即 鏈接無名的殼子
       2) 鏈接到有名的殼子
          當命名具有唯一性的時候 很好處理
          但是當命名沒有唯一性的時候
          有兩種辦法
          1. 用明顯的路徑語法
          2. 做約定 [像古典的約束變元一樣]
       3) 鏈接到殼子中的東西
          1. 利用序關係
          2. 利用殼子中的東西的名字
   11. 上面的複雜的分類必須被簡化
       必須找到折中的設計
   12. 數據結構
       以雙向鏈接的鏈表爲主
       需要的時候可以增加元數據
   13. 是否以帶名字的雙向鏈接的鏈表爲主呢 ?
       把不帶名字作爲帶名字的特殊情況
   14. 上面的 侷限性在於
       每個點只能夠鏈接到一個殼子
       而一個殼子能夠鏈接到很多點
       這是約束變元的語義所決定的
       但是
       我不應該把這個
       用來初始化有向圖的
       標記語言的性質限制與此種語義
       我應該保持雙向鏈接性
       應該保持對 多點鏈接的處理能力
   15. 但是回來考慮基本的語義
       看看爲什麼這種推廣如此困難
       1) 細胞
       2) 大量的無名邊
          排斥了以前對數據結構的設計
** curry
   1. 區分 (apply) 和 (curry) 就行了
      每次 (curry) 都保證進行一次參數的綁定而返回新的函數
      也就是說只能 (curry) 所返回的
      只能是函數 不能是作用
** >< 細胞語義
   1. 只要在函數的作用條件上做手腳
      我就能實現很有趣的語義
      就像神經細胞一樣
   2. 函數作用的條件可以從參數到齊變爲[更複雜的條件]
   3. 這裏消息傳遞的語義是明顯的
      如果每個函數都有自己的參數棧[細胞液[因爲參數的無序性]]
      參數的製備可以用消息傳遞來實現
      而 (apply) 和 (curry) 也是消息而已
   4. 這裏有本質上的困難嗎 ?
      我記得我之前排除過這種語義
      而現在我又想回到這種語義
** 再 Y
   1. 其實重點在於自我引用
      而難點在於一般的 lambda-calculus 的語義
      並不能直接形成自我引用
      必須藉以更高層次的 組合子
      作用於一個爲了自我引用而模板化了的 lambda-function
      方才能夠形成帶有自我引用的 lambda-function
      這就是典型的
      沒有困難 製造困難 也要上
   2. 我的標記語言應該完全摒除這種弊端
      ::x 是說 這個名字叫 x 的約束變元鏈接到向外的第二層的殼子上
      很容易看出
      相反地 在殼子內引用外層殼子的語法語義也是很容易設計出來的
      並不必使用 Y 之類的東西
   3. 辨 Y 之用
      #+begin_src cicada
      (* 之前是以下面的 Y 作用於 f 的自我引用 而形成一個遞歸函數 *)
      Y
      [ [ [ ::x (::x) ] (::f) ] <x
        ( [ ::x (::x) ] (::f) ) ]

      [ [ [ ::x (::x) ] <rec (::f) ] <x
        ( [ ::x (::x) ] <rec (::f) ) ]

      (* 如此 *)
      f (Y)

      (* 而 f 如此 *)
      [ [ :arg1    <body1>  <arg1
          :arg2    <body2>  <arg2
          (::rec)  <body>
          :arg1 :arg2  <bod3> ] ]

      (* 或可用 curry 來實現 f *)
      #+end_src
      可見 f (Y) 並非 方程 x (f) = x 的解
      這是顯然的
      因爲要知道 f 必須是多元的
      才能用以形成常用的遞歸函數
   4. 而用標記語言
      比如下面的語法就能形成對殼子的引用
      #+begin_src cicada
      [ :arg1  <body1>  <arg1
        :arg2  <body2>  <arg2
        (:)    <body>
        :arg1 :arg2  <bod3> ]
      #+end_src
   5. 其中 :arg1 是從裏面鏈接一條邊到外面的殼子
      但是這條邊的目的和實現方式還是不明白的
      現在我就來明確這裏的實現方式
      也就是設計出這個數據結構
      然後再說明如何在殼子內形成自我引用
      注意 這裏內層的函數作用會進行參數綁定
      而這種參數綁定不能破壞外層的參數綁定
      因爲在最後一個 <body> 中還可能有對之前綁定的參數的引用
   6. 古典的對棧的使用方法能夠解決這個問題
      因爲不用處理參數到名的綁定
      所以非常簡單
   7. 也就是說
      與參數到名的綁定相關的信息
      必定不能被存儲在函數體的內部
      函數體本身所保存的只是算法而已
      但是這樣就不是在用有向圖來實現參數綁定了
   8. 解法是用鏈表來實現棧
      並且給每個函數的每個參數都分配一個棧
   9. 注意主要的參數棧還是存在的
      函數在作用的時候
      還是要從主要參數棧中取參數的
   10. 每個函數操作處理參數的方式是 (apply) 所完全不知道的
       它只是觀看當前的信息
       然後在數據庫中匹配以查找需要調用哪個函數而已
   11. 每個函數有一個函數頭
       這個函數頭就是殼子的語義
       其中保存了別的點鏈接到它的信息
   12. 注意這裏對數據結構的設計必須還要適應別的使用方式
   13. 每次對據的代入只是向主要參數棧中放入一個值而已
   14. 每個函數體中的每個參數都必須用一個棧來實現
   15. 在函數調用的時候
       已經放到棧中的參數應該如何被處理呢
       其中
       1) 需要被入函數的局部棧的
          1. 有名的
          2. 無名的 被以默認方式處理的
       2) 不需要被入函數的局部棧的
          1. 無名的
   16. 也就是說一定要有不需入棧的值存在
       否則就是有名者了
   17. 可以發現
       因爲要維護各種函數作用時處理參數的方式
       所以設計上有很大的不一致性
       這種不一致性給實現帶來了很大困難
   18. 所需要實現的效果是
       在很多情形下
       都能使用類似 forth 的無名方式來處理參數
       而在需要的時候有能力能夠形成有名的約束變量
   19. 先不論 (apply) 如何判斷應該調用哪個數函數
       假設我已經知道了在這種條件下應該調用哪個函數
       那麼當這個函數作用的時候
       假設只有棧的頂端的值才能被認爲是需要被處理爲局部變量的值
       那麼
       也就是說我還是必須擺好棧中的參數
       這並沒有什麼不應該的因爲棧中的參數總是應該被擺好的
       只是在約束變元的幫助下有些參數的順序如何都可以而已
       那麼我就在這裏施加一個重要的限制
       即 需要被綁定爲約束變元的值
       必須被放到棧頂
       它們在函數作用時最先被處理
       而棧中後面的值可以是以古典的 forth 的方式被處理的僞局部變元
       對於每個函數而言
       這前面的需要被綁定的參數的個數必須是固定的
       這樣
       在進行綁定的時候
       因被聲明爲了默認情況
       而可以沒有名字的參數 也就都能被正確處理了
   20. 另外一個可能的限制是
       如果有無名者那麼就必須都是無名者
       而不能混合
       這樣判斷就簡單多了
       只要棧頂是無名參數
       就按默認順序綁定它們
       而如果棧頂是有名參數
       就按參數名字來綁定它們
   21. 除非特殊聲明否則參數順序由深度有限的遍歷計算出來
* 新
  1. 現在工作的重點有二
     1) 在不斷向別的作者學習的同時
        完善這種標記語言之語法本身的設計
     2) 設計用來實現這種語法的數據結構
  2. 後者爲次要
* 喻
  1. 與物質結合而變異的生物體
* 規則
  1. 新的語法已經可以想像了
     但是應該如何介紹其語法規則
     卻不是明顯的
  2. 相當於 lambda 和 apply
     被定義爲了兩個 borderfix notation
     以 [ ] 爲 lambda
     以 ( ) 爲 apply
     不考慮 ( ) 對 ([ ]) 的優化了
     因爲會影響理解
  3. 注意
     x 是 symbol
     (x) 是 symbol 所對應的函數的 apply
     也就是說 apply 能夠作用於兩種數據類型
     一種是 symbol 一種是 lambda
  4. 然而
     ( ) 對 ([ ]) 的優化
     也可以被看成是
     apply 作用於多個 symbol
     這是合理的嗎 ( fun fun ) 之於 (fun) (fun)
     這是不合理的
     因爲在匿名函數的函數體 [ fun fun ] 中
     fun 是 symbol
     而 [ (fun) (fun) ] 中
     才是作用
     所以避免這些優化而回歸到最簡單的語義
  5. 但是要知道
     對 symbol 的單獨使用
     可能根本沒有對函數作用的使用次數多
     那麼這種語法真的是設計良好的嗎 ?
     加之
     括號中所包含的只能是一個 symbol
     且不以 ( ) 來優化對無名函數的直接作用
     即讓 ( ) 成爲只能作用於 symbol 這個數據類型的
     borderfix notation 的 一元函數
* 難點
  1. 函數的返回值是一個函數
     而這個函數需要被直接作用的時候 應該如何 ?
  2. 也就是匿名函數的作用 應該如何 ?
  3. 只要這樣
     #+begin_src cicada
     (* 不用下面的 *)
     [ [ [ ::x (::x) ] (::f) ] <x
       ( [ ::x (::x) ] (::f) ) ]
     (* 而用 *)
     [ [ [ ::x (::x) ] (::f) ] <x
       { [ ::x (::x) ] (::f) } ]
     (* 或用 *)
     [ [ [ ::x (::x) ] (::f) ] <x
       [ [ ::x (::x) ] (::f) ] (apply) ]
     #+end_src
  4. 即
     { } --> [ ] (apply)
     ( ) --> [ ] (apply) (apply)
     即後者是先求值再代入
  5. 但是
     apply 是自戀的
     (apply) --> [ apply ] (apply) (apply) --> apply (apply)
     所以需要說明的是其實只有當多個東西在 ( ) 中時
     才需要 上面的規則
  6. 其實需要對什麼時候使用什麼規則有更細緻的規定
     [ ] (apply)
     就是在進行代入
     而
     symbol (apply)
     當 symbol 是 non-primitive 類型的函數的時候
     又將便會 [ ] (apply)
     當 symbol 是 primitive 類型的函數的時候
     就找到了遞歸的基本步驟
  7. 這樣
     在理論上[理解方式上]
     就把所有 bar-ket 都劃歸到了 [ ]
     而 y (x (K)) = x
     這樣的公式就得到了一致的解釋
  8. 但是這樣就使用了三種邊界
     想要在紙筆畫的圖中區分這三者
     就必須要使用不同的顏色的邊界了
     - 而 之前的設想是使用光滑的邊界和多邊形的邊界
       現在線性的文本中的語法是以 apply 爲核心而推導出來的
       但是其要求是在圖像中根本不出現 apply
  9. 這一切都是因爲 y (x (K)) = x 的出現
     其特點是 K 是純粹 curry 的
     就算用最初設計的圖來表示的話
     圖也將對應爲 y x (K) (apply)
  10. 難道 apply 也應該被實現爲以中綴表達式 ?
      不
  11. ( ) -> [ ] (apply) (apply)
      只對返回值個數爲一的函數體時才有良好的語義
  12. y x (K) (apply)
      x (K) y ()
      即 () = (swap) (apply)
      或
      x (K) y (0)
      即 (0) = (swap) (apply)
      這樣 圖畫 與 線性表達式
      在 性狀上 就統一了[接近了]
      並且注意這裏計算(apply)的兩個參數的順序不同
  13. 並且
      y ( x (K) )
      y [ x (K) ] (apply) (apply)
      y x (K) (apply)
  14. 但是都是對一元函數才好用
      或許可以 不用 (0)
      而區分 (1) (2)
      以代表返回的函數的參數個數[swap所跳過的值的個數]
      x3 x2 x1 (F) (apply) (apply)
      x1 (F) x2 (1) x3 (1)
      這都是在用默認的參數順序來進行處理
      之撐不住的時候
      也可以使用參數名字來打亂順序
  15. 發現了一個特點
      即在圖中
      箭頭和圓圈所能表達的只是單一層次的作用而已
      即 爲了 (F) 而設計的
      ( ) -> [ ] (apply) (apply)
      這種變換在畫圖的時候是絕對用不上的
      這種變換是爲了在線性代碼中
      去表達 返回值是一個函數的函數設計的
  16. 也就是說在畫圖時
      大的圓圈是 {}
      小的只圈住一個 symbol 的圓圈是 ()
      並且這種解釋對於與約束變元 (:x) 也成立
  17. ><><>< (:x) 這個小殼子也算殼子嗎 ?
      如果算的話
      點點就太多了
      #+begin_src cicada
      [ [ [ ::x (:::x) ] (:::f) ] <x
        [ [ ::x (:::x) ] (:::f) ] (apply) ]

      [ [ [ :x (.:x) ] (.:f) ] <x
        [ [ :x (.:x) ] (.:f) ] (apply) ]

      [ [ .x (:x) (.:f) ] <x
        ( .x (:x) (.:f) ) ]
      #+end_src
  18. 那麼
      y (x (K)) 應該被蟬語的線性語法接受嗎 ?
      能接受
      只要寫成 y ( x (K) ) 就行了
  19. 要知道
      所有的組合子都是一元的因此
      上面的爲組合子而設計的語法其用性有限
      在討論組合子的時候發現
      在這種語法下
      1) 等量可替換
      2) 而括號要小心使用
         因爲每個括號都是函數都是函數
      3) 並且空格被作爲了一個
  20. 重要的是
      我可以以棧處理
      還有鏈表這個數據結構
      爲語言的具體模型
      以這個具體的模型爲基礎
      證明對表達式的各種變換的正確性
      並且所有的表達式的語義
      都因我的具體模型而變得顯然
* ----------------------
* 有生命的程序
 * 生命的特點如下
 * body 
   即函數體
 * 新陳代謝[metabolism]
   如果每個函數都有自己的堆和棧的話
   那麼其垃圾回收器[數據分配器]之作用
   就像是機器的新陳代謝
   如果嘗試構建類似生物的程序的話
   對內存的消耗就是對主要資源的消耗
 * 前兩個特點的功能是
   movement & replication
 * 遺傳信息[inheritable infomation]
   每個函數作爲有向圖
   其形態中有固定不變的主要部分
   並且有信息幫助初始化一個與其相似的有向圖
 * 加上這個特點
   就能夠遺傳和變異
 * 但是
   自然選擇所對應的是什麼
 * 所以
   把每個函數都做成一個有獨立時間和空間的進程
   是能夠形成很豐富語義的
   爲了分配時間 也許只要找出好的算法就行了
 * 並且
   如果放棄在每個函數中對新陳代謝的模擬
   讓每個函數的都以全局的鏈表爲自己的數據部分
   那麼就差不多有個模型了
 * 然而
   函數調用的實現方式呢
   如果純粹使用消息傳遞
   那麼參數棧就沒有了
   計算的順序也沒有了
   必須有以維持順序的機制
   線程系統的解釋器和它的 參數棧 和 返回棧
   就作爲一個調度性的協調系統了
   這是可以想像的
   因爲內部解釋器本身利用返回棧來記錄計算位置的方式
   本來就是一種調度
 * 也就是說
   線程碼解釋器本身的地位與其他的函數平等了
   但是
   每個函數都在不停地
   與線程碼解釋器 之間傳遞信息
   這是不合理的
   應該把 線程碼解釋器 的功能內化到每個函數中
   [既然每個函數都被視爲一個有獨立計算能力的機器了]
   每個函數都有用鏈表實現的棧 就行了
   在每個函數體內調用了別的函數的時候
   就是給別的函數傳遞了消息並且等待消息返回
   這樣計算的狀態的編碼就被分散到了各個函數內部
   而不再需要返回棧了 [也沒法實現 call/cc 了]
 * 這種模型能夠適應在 組合子問答集 中
   所發展起來的語義和語法嗎 
   要知道
   對計算順序的明指
   在這裏就體現爲 
   對返回信息的等待的明指
   而 A (F) (G)
   就是語言的用戶接口[REPL]
   在形成一個消息 A
   然後把這個消息傳遞給函數 F
   返回的消息可以
   1. 返回到 REPL 
      然後再順次處理
   2. 在 REPL 把消息 A 傳遞給 F 的時候
      告訴 F 當計算完成之後把結果返回給 G
      並且 G 還必須知道計算完之後 
      結果要最終返回給 REPL
      也就是說整個函數
      都必須編碼在這個函數提所傳遞的參數中
      這是不合理的
   3. REPL 在給 F 傳遞參數的同時
      告訴 G 如果接受到 F 傳來的信息 
      那麼對這個信息的計算結果應該返回給 REPL
      這樣每個函數每次所計算的參數上
      就都帶有[固定大小的]信息
      比如 A 上帶有 [來自: REPL 目的地:G]
      並且每次作用都必須有不同的標籤 以被識別
 * 這些都是可以想像的
   但是我還是先以單線程爲主來實現我的語言
   我想以後再去考慮多線程的版本也不難   
