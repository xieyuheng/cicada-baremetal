#+TITLE: report on cicada language
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 記
** 蟬語之優
   1. 某些性質被我認爲是優點
      然而 同樣的性質 在不同的人看來可能是缺點
   2. 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
      這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
      這個性質是我最喜歡的
      就算是對於 scheme 和 smalltalk 這種設計良好而簡潔的語言來說
      這種對整個系統的直觀理解也是不行的
      因爲 這兩種語言的 簡潔性 是以很高的抽象性爲代價的
      而 蟬語 的設計就是要在 保持這種 被簡單而直觀的理解的可能性的同時
      去實驗某些性狀 以達到 不比 scheme 和 smalltalk 弱的抽象能力
** 蟬語之劣
   1. 某些性質被我認爲是缺點
      然而 同樣的性質 在不同的人看來可能是優點
   2. threaded-code 的侷限性
      主要在於 這種風格的機器碼很可能 難以優化
      但是其實只有在具體的測試和實驗之後
      才能得出真正的結論
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
** 設計決策
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** 正確編程方法
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** >< 函數組
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** >< 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
** 以名釋性
   (string-reference <string> <index>)
   (string-compare <string1> <string2>)
   (string-append <string1> <string2>)
   發現命名是一個問題
   每個動詞比如compare
   可以是 string-compare 或 list-compare
   這就要求在命名上給每個函數加上數據類型的前綴
   作爲特殊的前綴
   也許應該用 string:compare 而不是 string-compare
   這種看來勞神的前綴的需要是因爲
   我不允許函數名的重載
   如果我統一這種對數據類型前綴的使用
   那麼 動態類型的量 和 非動態類型的量
   之間命名規則的衝突也就被化解了
   也許 string-append 應該被叫做 string:^_^
   就像 ^_^ 在 dalin 中的效果一樣
   但是這兩種函數之間又有區別
   重要的區別是
   他們是返回新的數據還是在原來數據的基礎上做副作用
   我還可以用對命名函數的約定來
   讓函數的名字體現更多的函數的性質
   也就是說 cicada 的一個特點是
   ``以名釋性''
   這是實現起來最簡單的
   但是需要設計良好的命名規則
   在給函數取名字的時候
   寫代碼的人也要花一些功夫思考
   才能讓這個名字恰當地體現函數的性質
   同時最重要的是
   這種方案
   可以在最大程度上減輕人們在讀代碼的時候的
   認知上的負擔
   ------------------
   但是有一些重要的函數比如 write
   還是需要取處理不同類型的量
** bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** 代碼的閱讀者的認知上的負擔
   集成開發環境 是爲了 通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來 獲知 詞 的語義
   與命名規則一樣 這一切都是爲了
   減輕 代碼的閱讀者的認知上的負擔
** 蟬語中的命名規則
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** 編程範式
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** 對 OO 的支持必須被放棄
   1. 因爲 所想要實現的 OO 系統中
      參數與方法之間的對應 只有在運行時才能確定
      這對效率來說是個打擊
   2. 因爲 OO 與 對函數的靈活使用是相互衝突的
      在我看來 不同的編程範式 代表了不同的思考方式
      而對多範式的支持 只能帶來混亂
   3. 對於 "作用" 來說這種面向對象的技巧能夠節省命名空間
      但是對於 "函數複合來說" 則不然
      在蟬語中我經常需要把函數複合起來
      以定義新的函數
      如果所有的函數都被保護到類型的內部了
      之後找到相應類型的值的時候才能調用到這個函數
      那麼我就沒法方便的做函數的複合了
   4. 其他的語言中是用參數名和類型推導
      來解決上面這個問題的
   5. 而在蟬語中 我可以通過一個 一致的命名規則來解決這個問題
      但是這樣就把函數的命名規程化了
      在我看來少了很多靈活性和樂趣
   6. 綜上所述
      對 OO 的支持必須被放棄
** smalltalk 中對函數的命名
   1. smalltalk 中函數的命名是非常靈活的
      函數的命名變成了
      對象之間傳遞消息的協議
      這種特性正是爲了解決命名問題
   2. 我把這種特性理解爲
      - 把函數名 分散爲部分
        每部分匹配一個參數
        而約束變元
      - 而在 蟬語 中
        函數命名將被限制與一個詞
        在 蟬語 的 lambda 中
        是約束變元的名字在被用來匹配參數
        在函數作用的時候
        lambda 的約束變元的名稱 可以幫助增加代碼的可讀性
        儘管這些約束變元的名字並不出現在 函數的名字當中
   3. 但是
      在 smalltalk 中
      函數的使用可能並不靈活
      函數不可能被作爲一等公民來對待
   4. 但是
      有代碼塊可用
      並且 也較爲良好的代入語義
      所以 也許與 lambda 等價的東西是存在的
      然而
      就算 代碼塊 的語義能夠用來實現
      與 lambda 等價的東西
      對這些東西的使用也是不方便的
   5. 那麼
      如何說 cicada 中的函數是一等公民呢 ?
      這在於 ><
* ==================================================
* *實現*
* ==================================================
* *數據*
* 貫徹類型系統
** 目的
   1. 引入 對數組型數據結構的更好的處理
      並且 將來對鏈表型數據結構的處理也能以一致的方式被表達
   2. 消除一種語義過載現象
** 可行性
   1. 只要在語法方面不影響表達的簡潔性
      那麼在運行時多入一個數據類型到棧裏也是可以接受的
      所以
      之後 "一個量" 就應該默認地是佔參數棧中的兩個 cell 的了
      所有的函數都必須被重新實現了
   2. 此時
      在開始實現基本的 名詞和動詞之時
      需要很多基礎設施
** 初始化
   1. 在定義一個數據類型的時候
      必須指定一個用來初始化一個這個類型的數據的函數
      這個函數可能有參數 比如 對 詞 這個數據類型來說就是如此
      而也可能沒有參數 比如對與 cons 來說就是如此
      這個用來初始化數據的函數
      可以從棧中 cons 的數組中取 內存
      也可以從字典中取內存 或者從數據段中取 內存
      - 比如編撰一個詞到字典中的過程就是如此
      這樣就解決了 靜態的動態的問題
      並且 原子性的數字類型的量是在 參數棧中去內存的
   2. 可以發現 從語法的角度看
      對 上面的三種類型的 數據的初始化
      是非常不同的
      1) : kkk 1 2 3 . . . Exit ; define-function
         此時有一個名字被分配給了這個對象
         參數棧 中沒有留下東西
      2) cons
         此時沒有名字
         參數棧 中有地址
      3) 7
         此時沒有名字
         參數棧 中有值
** 類型之間的關係
   1. 把類型理解爲集合的話
      它們之間就包含關係等等
   2. 當系統地使用類型這個概念時
      類型時間的關機就必須被處理了
   3. 但是其實類型時間的關係是很簡單的
      一個沒有任何其他結構的偏序集而已
      其偏序關係是 "含於"
   4. 但是在程序語言中
      具體實現這種關係的時候卻又跟抽象的數學概念不同
   5. 儘管每個函數是獨立與類型而定義的
      但是函數會對值的類型做類型檢查
      所以
      所謂類型之間的關係其實就是
      指明哪些函數可以作用於哪些些類型的值
   6. 需要達到的效果是
      1) 我不能在每次添加一個需要被某個函數作用的類型的時候
         都去更改那個函數本身
   7. 那麼
      1) 每個做類型檢查的謂詞都用一個全局的鏈表來實現
         這個全局鏈表中 記錄着 這個函數所能夠作用與的數據類型
      2) 每次定義一個新的類型的時候都去明指 有那些函數可以用來處理它們 ???
         就像 給類定義方法一樣
      3) 那麼每次
         如果想要一個函數作用於一種類型的值
         就必須
         1. 在定義函數時
            在初始化那個全局鏈表的時候把這個類型添加到那個鏈表中
         2. 或者在定義類型時
            把這個類型添加到那個全局鏈表中
      4) 荒唐的是
         如果用這種方式來實現類型檢查
         那麼其對性能的損耗
         無異於在運行時查表來把消息轉化成所應該啓動的方法
      5) 也就是說
         又要用回到剛纔被拋棄的想法了
         在這種想法中所有的函數都沒有類型檢查
      6) 如果要這樣的話
         那麼每次我總能保證
         所使用的一定是合適的用來處理這種類型的值的函數
      7) 如果使用後者
         那麼類型之間的關係如何實現呢???
         ><
** 如果回到剛才被放棄的實現 OO 的方式
   1. 那麼
      就必須把所有函數都作爲一等公民被暴露出來
      "鏈表 之 複製"
      "鏈表 而 複製"
      "鏈表之複製"
      "list-z-copy"
      使得對它們的複合能夠被以簡潔的方式進行
   2. 在定義一個類型的時候
      最好不要初始化
      直接把所有對結構還有函數的定義都分散
      這樣就可以隨時添加處理函數到某個數據類型中去了
   3. 類型之間的所謂關係是不是可以不被處理
      每次定義一個新的類型的時候
      只要直接從別的數據類型取一個處理函數就可以了
      就算是繼承了那個類型了
   4. 也就是說這裏的類型之間的關係
      比數學上抽象的集合之間的偏序關係要豐富而精細的多
      ><
** >< 多餘的信息
   1. 儘管於一個帶有類型的量來說
      當它被入棧的時候一個類型標籤已將被入棧了
      但是我還是要求
      如果這個量是非原子性的量
      那麼它的地址下面就一定要有一個
   2. 這樣就有不一致性
      因爲 比如原子性的數字就沒法添加這個類型頭
** >< 對別名的支持
   1. 詞典中的同一個定義
      應該能夠擁有兩個名字 這樣 英文 漢文 異體字 就方便多了
      這樣在字典這個數據結構中 單向鏈接的鏈表的功能就喪失了
      因爲沒法依據這個鏈表來查找詞了
      這個功能本身我也沒用過
      也許我應該好好設計然後在取實現
      這樣就能有個大局觀
* 對蟬語中數據結構的總結
** note
   1. 我將設計統一的方式來使用
   2. 一個對象在內存中的存在方式需要被指定
      有可能用到 GC 也可能是在 詞典 中的靜態數據
   3. 下面我來分析一下在 蟬語 的實現過程中我已經使用過的數據結構
      看看使用 OO 後能否以更一致的方式來處理它們
   4. 詞典
      - 靜態
      - 定長
      - 很大
      - 其內保存的 詞 形成一個單向鏈接的鏈表
      - 處理這個數據類型的函數有

   5. 詞
      - 靜態
      - 每個詞只有定義部分是變長的 其餘部分都是定長的
      - 存在與 詞典 中
      - 處理這個數據類型的函數有

   6.
** >< number
*** integer
** string
   #+begin_src cicada
   string
      There once was a short man from Ealing
      Who got on a bus to Darjeeling
          It said on the door
          "Please don't spit on the floor"
      So he carefully spat on the ceiling
   ------------
   #+end_src
** list
   #+begin_src cicada
   (* bra-ket *)
   { Mark-McGwire Sammy-Sosa Ken-Griffey }

   (* indentation *)
   ======
   - Mark-McGwire
   - Sammy-Sosa
   - Ken-Griffey
   ======
   #+end_src
** dali
   #+begin_src cicada
   (* bra-ket *)
   [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

   (* indentation *)
   ======
   * Mark-McGwire
   * Sammy-Sosa
   * Ken-Griffey
   ======
   #+end_src
** wodili
   #+begin_src cicada
   (* bra-ket *)
   ( :hr 65 :avg 0.278 :rbi 147 )

   (* indentation *)
   ======
   :hr 65
   :avg 0.278
   :rbi 147
   ======


   ( :american
       Boston Detroit New-York
     :national
       New-York Chicago Atlanta )

   ======
   :american
     - Boston
     - Detroit
     - New-York
   :national
     - New-York
     - Chicago
     - Atlanta
   ------
   :1 "-" for list element
   :2 "*" for dali element
   :3 ":" for wodi (* wodili element *)
   ======
   #+end_src
* ==================================================
* *計算模型*
* 木答演算 [lambda-calculus]
* 有向圖處理 [digrap]
* ==================================================
