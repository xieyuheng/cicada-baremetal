#+TITLE: report on cicada language
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* TODO
  1. 關於多棧的新語法的設計
  2. 關於類型系統的新語法的設計
  3. 虛擬機的設計
* 記
** 蟬語之優
   1. 某些性質被我認爲是優點
      然而 同樣的性質 在不同的人看來可能是缺點
   2. 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
      這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
      這個性質是我最喜歡的
      就算是對於 scheme 和 smalltalk 這種設計良好而簡潔的語言來說
      這種對整個系統的直觀理解也是不行的
      因爲 這兩種語言的 簡潔性 是以很高的抽象性爲代價的
      而 蟬語 的設計就是要在 保持這種 被簡單而直觀的理解的可能性的同時
      去實驗某些性狀 以達到 不比 scheme 和 smalltalk 弱的抽象能力
** 蟬語之劣
   1. 某些性質被我認爲是缺點
      然而 同樣的性質 在不同的人看來可能是優點
   2. threaded-code 的侷限性
      主要在於 這種風格的機器碼很可能 難以優化
      但是其實只有在具體的測試和實驗之後
      才能得出真正的結論
** 簡體繁體
   1. 簡體 繁體 西文 和所謂也 ?
      聲韻形態皆思之載體
      過分追究表達方式之異同之人
      未嘗得道也
   2. 在蟬語中 以傳統漢語爲主要表達方式
      而在命名規則和別名系統的幫助下
      我可以讓 簡體 繁體 西文 並存
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
** 設計決策
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** 正確的设计
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** >< 函數組
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** >< 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
** 以名釋性
   1. 在全面地貫徹類型系統之後
      以名釋性 的方式就改變了
      此時需要強調的就是命名規則了
   2. 以名釋性
      的目的還是減輕代碼的閱讀者在認知上的負擔
** bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** 代碼的閱讀者的認知上的負擔
   集成開發環境 是爲了 通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來 獲知 詞 的語義
   與命名規則一樣 這一切都是爲了
   減輕 代碼的閱讀者的認知上的負擔
** 蟬語中的命名規則
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** 編程範式
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** 對 OO 的支持必須被放棄
   1. 因爲 所想要實現的 OO 系統中
      參數與方法之間的對應 只有在運行時才能確定
      這對效率來說是個打擊
   2. 因爲 OO 與 對函數的靈活使用是相互衝突的
      在我看來 不同的編程範式 代表了不同的思考方式
      而對多範式的支持 只能帶來混亂
   3. 對於 "作用" 來說這種面向對象的技巧能夠節省命名空間
      但是對於 "函數複合來說" 則不然
      在蟬語中我經常需要把函數複合起來
      以定義新的函數
      如果所有的函數都被保護到類型的內部了
      之後找到相應類型的值的時候才能調用到這個函數
      那麼我就沒法方便的做函數的複合了
   4. 其他的語言中是用參數名和類型推導
      來解決上面這個問題的
   5. 而在蟬語中 我可以通過一個 一致的命名規則來解決這個問題
      但是這樣就把函數的命名規程化了
      在我看來少了很多靈活性和樂趣
   6. 綜上所述
      對 OO 的支持必須被放棄
** smalltalk 中對函數的命名
   1. smalltalk 中函數的命名是非常靈活的
      函數的命名變成了
      對象之間傳遞消息的協議
      這種特性正是爲了解決命名問題
   2. 我把這種特性理解爲
      - 把函數名 分散爲部分
        每部分匹配一個參數
        而約束變元
      - 而在 蟬語 中
        函數命名將被限制與一個詞
        在 蟬語 的 lambda 中
        是約束變元的名字在被用來匹配參數
        在函數作用的時候
        lambda 的約束變元的名稱 可以幫助增加代碼的可讀性
        儘管這些約束變元的名字並不出現在 函數的名字當中
   3. 但是
      在 smalltalk 中
      函數的使用可能並不靈活
      函數不可能被作爲一等公民來對待
   4. 但是
      有代碼塊可用
      並且 也較爲良好的代入語義
      所以 也許與 lambda 等價的東西是存在的
      然而
      就算 代碼塊 的語義能夠用來實現
      與 lambda 等價的東西
      對這些東西的使用也是不方便的
   5. 那麼
      如何說 cicada 中的函數是一等公民呢 ?
      這在於 ><
** >< 語義重載現象
   1. 在蟬語中現在還有一個語義重載現象
      那就是 函數 既可以是 一個詞典中的動詞
      也可以是一個 lambda-term
* 實現
** 記
   1. 我先把所有的設計都寫成文檔
      然後再着手實現
      否則當實現到了後面
      如果發現了某些設計需要更改
      就必須更改很多前面的代碼
   2. 我能這樣做
      只是因爲
      第一個版本已經被實現好了
      我已經知道在實現過程中可能遇到的技術難題是什麼了
** 虛擬機
   1. 這次是我在濫用術語了
      當我考慮是否要使用一個虛擬機還有鏡像文件來實現蟬語的時候
      我才發現這一點
   2. 要知道虛擬機和處理器
      都是指令集編碼的簡單的解釋器
   3. 我之前所說的可擴展的虛擬機
      即 內部解釋器
      於一個虛擬機非常相似
      我應該利用這種相似之處
      而實現一個更符合虛擬機這個屬於傳統意義的虛擬機
   4. 也就是說讓整個詞典可以靜態地存在於一個鏡像文件中
      這類似於設計一個可執行文件格式
   5. 詞典中的每一部分都可能依賴於詞典中的其他部分
      並且可能有相互的依賴
      在把鏡像文件中的詞典中的一部分加載到內存中的時候
      相互的依賴關係需要被處理
** 另一種實現方式
   1. 我可以在這裏辨別出兩種實現方式
      1) 用詞表達的可執行文件
         被蟬語的解釋器加載並解釋
      2) 用八位組碼表達的可執行文件
         被一個單純的 threaded-code 解釋器加載並解釋
   2. 它們的優劣分別分析如下
      |      | 一 | 二 |
      |------+----+----|
      | 層次 | 少 | 多 |
      | 加載 | 慢 | 快 |
      | 大小 | 大 | 小 |
   3. let the dictionary be a loadable linkable executable format
      parts of the dictionary could be linked to be the whole
      runtime changes from "a word interpreter" to
      "a dictionary loader and linker"
      plus "a threaded-code interpreter"
      in the last case, no string input is needed
      while a REPL is still can be provided
   4. 第二種方式最大的好處是
      我可以實驗自己設計指令集
      與指令集的編碼方式
   5. 更大的好處是
      在虛擬機的幫助下
      移植的方便性就達到了最高
   6. 這種 作爲虛擬機的 threaded-code 解釋器 是一定能實現的
      問題是 詞典這個數據結構如何設計
      如果發現這樣的設計在加載的效率上還不如對字串的處理
      那麼就失去意義了
   7. 虛擬機之重要性在於
      我所使用的彙編器中所能實現的宏限制了我對詞典這個數據結構的設計
** 改良
   1. 我需要的性狀是
      在可以把代碼編譯成 bytecode
      以讓虛擬機 加載並解釋
      而這並不影響 REPL 的存在
   2. Exit 應該被編譯器處理爲
      而不應該被解釋器處理
      也就是說 尾調用優化 應該被編譯器來做
      而不應該被解釋器來做
      但是 ITC 阻止了這種編譯時期的優化
      STC 倒是可以
      也就是要區分 call 和 tail-call 兩個指令
      並且把它們寫到函數體內
      函數體內所保存的就直接是可以被執行的指令
      其實在這裏我還是能夠使用 "間接"
      把函數體和函數頭分開
      並且當使用虛擬技術的時候
      我的指令集是可以針對我的目的而優化的
      這樣 literal 和 branch
      就可以被實現爲和 call 還有 tail-call 等同的東西了
      call 這個指令本身就可以有各種 間接的版本
      這才是正確的實現方式
      也就是去用空間來換時間
* 學文記
** 方法
   1. 蒐集古典例句
      查而辨其結構
   2. 語言有一奇妙特性
      在於 它能被用來描述它自身
      正是因爲這一特性
      寫一篇辨析語言結構的文章才成爲可能
   3. 在辨析結構之時
      需謹記 因 語言成於人與人之間的交流
      故 重任交談之場景 反映於語言之結構中
** 界說
   - 詞類 ::
   - 名詞 :: 名詞爲本
   - 動詞 :: 動詞以述名詞之行也
             不可獨解
             解時 需助之以名詞或代詞
   - 形容詞 :: 以形名詞之容也 不可獨解
               但是上面的界說是有問題的
               因爲 數 應該被視爲形容詞
               但是 數 又被當作抽象的名詞來被處理
               並且形容詞所形容之性狀通常都是可以被量化的
               所以 形容詞對名詞之限定 與數之結構息息相關
               並且所謂用來形容動詞的狀詞亦可以被量化
               但是 其實作爲限定詞 它們也有簡單的限定分類之用
               未必階爲狹義的量化
   - 數學結構 :: 動詞是這些性質就時間而言的變化
                 然而要點是
                 語言的語義就 對話場景
                 還有 時 空 二量 而 優化了
                 這種優化可用關於演化的理論來解釋
   - 更細的特點 :: 我其實是在類比數學語言與自然語言
   - 句讀 :: 句讀者 語法解析 也
** 判斷
   1. 判斷句
      不用 "是"
      而並兩個名詞短語然後加後綴 "也"
   2. 這就使得中文看起來像是沒有語法的語言
      做語法解析需要憑藉對語義的理解
      而"相對"正確的語法解析
      又是得到"更"正確的語義的前提
      所以我們的大腦中處理漢語意義的模塊像是一個迭代函數
      我想
      讓這個"迭代函數"發散的點是存在的
* 句式
  1. 以 主 謂 賓 爲基礎語順
     施 句式 以變
     1) 使成
        主 謂 賓 成 : 燒燭短 引杯長
        主 謂 成 賓 : 折斷 吹散
     2) 被動
        賓 爲 主 所 謂
        賓 被 主 謂
     3) 把
        主 把 賓 謂
  2. 而蟬語的特點是
     在大多數情況下 動詞後置
     並且似乎沒有主語
     或主語爲隱含的 我
  3. 凡 []
     [] 者 曰 []
     [] 者 曰 []
     用以描述大類下的小類
  4. 語法其實就是一個樹狀結構
     需要設計的是如何把這個樹狀表示出來
  5. (名 體*) 動詞也
     (名 體* 詞性) 而 編撰入詞典
     (名 體* 詞性) 也
     (體* 詞性 名) 也
     蓋 體* 詞性 名 者 也
     #+begin_src cicada
     蓋 (* n -- n! *)
     復 一乎 則 已矣
     再 復 1 減 階乘 乘 已矣
     動詞 階乘 者 也
     #+end_src
     "也" 簡單地由 "而 編撰入詞典" 就語法優化而來
     一個字符串 接受到 "編撰入詞典" 這個信息的時候
     會調用一個處理函數
     這個處理函數
     會把字符串語法解析了
     然後把一個詞的定義編撰入詞典
* 語法特點總結
  1. 我現在理解爲什麼 lisp 直接使用語法解析樹爲語法了
     這樣就避免了去在語法設計上耽誤時間
     而對 蟬語 而言
     語法的特點 其實並非完全地是 後綴表達式
     全局是後綴的 但是局部可以是任意的
     總結一下對輸入的[函數定義]處理
  2. 以前後標識 定界一個字符串
     這個字符串被入棧之後
     一個[字符串的]處理函數[詞的製造者]會被用來處理它
     儘管 函數體是被允許嵌套的 但是這個函數卻不是遞歸函數
     這個處理函數會以相對線性的方式來語法解析這個函數體
     1) 遇到最一般的詞的時候
        會寫[call word-address]到內存中
     2) 遇到數字會寫[number n]到內存中
     3) 等等
     4) 遇到語法關鍵詞時會調用那些語法關鍵詞來處理
        調用結束之後會再返回主要的循環中
        這個 主要的循環就代表了 "全局之後綴性"
        而對個別語法關鍵詞的調用就代表了 "局部之任意性"
  3. 詞典編撰者作爲一個字符串處理函數
     會一個詞一個詞地遍歷這個字符串
     同時 被寫入的內存區域[詞典]的地址 之指針
     作爲一個隱含的參數被 詞典編撰者所查看
     這在於 當需要的時候
     已經 在對前部字符串做處理時 編入詞典中的東西
     在對后部字符串做處理時 被改寫
     尤其是對數據類型系統的優化需要用到這個性質
  4. 關於類型系統
     我提供 "之" 和 "而" 這兩個可以被以最靈活的方式使用的虛詞作爲關鍵詞
     當 詞典編撰者遇到 "之[或而] <function>" 時
     他會看 當前函數體指針 之前的一個位置 是什麼類型的值
     1) 如果是一個函數調用
        那麼 就 編譯一個動態的消息傳遞式的函數調用
        [<symbol>] [call function-zhi]
     2) 如果是一個值
        就看它的類型
        然後 依據消息 找到登記到這個類型下的函數
        要知道 在新的類型系統被加入之後
        每個函數都包含信息 來表明 這個函數可否在編譯期被作用
        現在就需要用到這些信息
        [需要設計一致的註釋格式來完成這一點]
        來看一看所找到的這個函數能不能在編譯時期被作用
        [注意這裏還要檢查 是否除了主要參數之外 其他的參數都齊備]
        典型的能夠在編譯時期被作用的函數是
        那些對參數棧之外無副作用的[純粹]函數
  5. 這樣就使得
     在 "之[而]" 後面的詞的意義是上下文相關的
  6. 是否 規定
     這種使用 "之[而]" 的對函數的調用 爲 唯一的調用函數的方式呢 ???
     原來的 沒有全面地引入類型系統的時候的函數調用方式是否要保留呢 ???
     是需要保留的
     考慮那些零參數的函數就知道了
* 多棧
  1. 所有的棧都能用來傳遞參數
     但主要用主棧來傳遞參數
  2. 主棧能形成僞局部變量語義
     副棧能形成真局部變量語義
  3. 直接把對多棧的支持添加到虛擬機中
     以減輕 語法編撰者 的工作負擔
     需要設計一個指令集
     這個指令集需要編碼各個棧
  4. 多棧是爲了實現 有限個局部變量 的語義
     我可不可以把機制設計地更靈活一點
     而不限於局部變量這一種使用方式
     這就要求了每個棧必須有自己的名字
     甲 乙 丙 丁
     而我所能做的是在每個函數體內臨時重新命名這些棧
     並同時改變操作這些棧的函數名
     這樣在使用局部變量的時候 在語法上可能就比較羅嗦
     要知道 如果要設計靈活的使用方式的話
     就需要能夠選擇在命名一個新的棧的時候是否初始化它
     並且這裏對棧的操作也應該相對完整
     而不像之前那樣 只實現對主棧的操作
     也就是說這每個棧都是一個數據結構不是嗎 ?
     對這些數據結構的一致地使用方式 就實現了局部變量這個效果
  5. 這裏的局部變量
     如何與 lambda 中的局部變量相調和呢 ?
     讓這兩種實現局部變量的方式完全正交就行了
     這就要求要設計出區別足夠大的語法來使用這兩種語義
  6. 這裏的 "暫時改名" 這個語義很有意思
     這種改名只有在編譯時期才有效
     這種編譯時期的處理
     可以被看成是 編譯時期對 "1 2 +" 的處理一樣
     也就是說 也就是說我已經有了
     一致地 讓某些運算在編譯時期被處理的方式
     但是需要注意的是 這種東西也許應該被以明顯的方式聲明
     因爲 某些帶有副作用的函數 就算 它們的參數已經在棧中了
     這些函數還是應該被在運行時作用
     我給出機制 來幫助用戶明顯地控制這些東西
  7. 也許在這些新的語義被加入之後
     我已經不能說蟬語是很簡單的語言了
  8. 對多棧的處理是由 詞典編撰者 完成的
     #+begin_src cicada
     蓋
        甲棧 爲 計數棧
        乙棧 爲 長度棧
        丙棧 爲 地址棧
     註 (* [入 地址棧] [入 長度棧] [入 計數棧] --  *)
     已矣
     動詞 <某> 者 也
     #+end_src
     假使
     甲棧 乙棧 等等
     都是棧類型的值
     那麼
     "甲棧 而 名 計數棧"
     [可以被優化爲 "甲棧 爲 計數棧"]
     就是一個在編譯時期被處理的函數調用
     這種別名信息應該被保存在 函數體內
     因爲這些信息可以作爲動態的文檔被調用
     但是 如何保存呢 ?
     給函數頭增加一個域
     然後 使用一個類似 函數體的數組
     用來保存 編譯時期需要用到的信息
     [當然 這些信息也可以被作爲文檔來 查詢]
     這樣就行了
     [使用 <symbol> 或者 使用 <string> 都沒有關係]
     [有時 對於 <symbol> 的使用 我還有些疑慮 有些擔心散列函數的穩定性]
* 優化語法
  1. 我保持 上面所描述的統一的編譯語義
     並且我提供一個簡單的優化語法的方式
     即
     "而 名" -> "爲"
     "而 編撰入詞典" -> "也"
     只要把 "爲" 和 "也" 這類詞定義爲一類特殊的語法關鍵詞
     就行了
  2. 另一種優化
     就像在中文中
     當時形成排比時 就可以省略一些重複的助詞一樣
     在sexp中當形成排比時也能省略一些括號
     [比如 cond 就是典型的情形 shen 做到了對語法的優化 而 scheme 沒有]
* 註釋的格式
  1. 要設計 關於多棧的新語法
     其實是要設計 一種新的 註釋的格式
     把註釋的格式完全固定下來
     類似於一個類型聲明系統
     在之前 對棧的操作的註釋是被忽略的
     也就是說 編碼者 辛辛苦苦鍵入的信息被愚蠢的機器忽略了
     我現在就設計新的 註釋的格式 來修正這一錯誤
  2. 要求這個 註 中所能包含的信息有
     1) 副作用 類型
        包括 編譯到內存的信息
        還有輸入輸出信息等等
        仔細想像 副作用的類型其實 十分有限
        這些信息必須足以讓 詞典編撰者 推導出
        這個函數的作用能否在編譯時期被處理
        如果這裏有困難
        那就直接把 這個性質變成一個明顯的聲明好了
     2) 參數類型
        其實在這裏也是能夠形成像 ocaml 中一樣的類型推導系統的
        這種系統之有趣在於 兩點
        1. 擁有一等公民函數可以使用
           這一點在沒有 lambda 的時候 在蟬語中也是有的
        2. 擁有匿名函數可以使用
           這一點 只有在 lambda 之後才能擁有
           但是 其實不是的 ><><><
     3) 參數的局部變量初始化
* 關於匿名函數
  1. 爲什麼匿名函數要求鏈表處理 ?
     因爲
     1) 匿名函數需要被垃圾回收
     2) 爲了 call/cc 嗎 ??
        其實跟 call/cc 沒關係
  2. 用鏈表處理實現的函數體
     運行起來比用數組實現的函數體慢
     特點是它可以被靈活的改寫
     但是這後一種性狀其實是不常用到的
     誰也不會想要經常改變一個已經定義好的函數體
  3. 而 call/cc 需要的不是函數體被 用鏈表處理實現
     而是 返回棧 被用鏈表處理實現
     [除非使用 CPS 之類的編譯技術]
     這也會使得函數調用變慢
  4. 有什麼額外的選擇嗎 ???
     記得 call/cc 也有它的侷限性
     即它所得到的 cc 是一個一元函數
     但是對與 蟬語中的函數來說 一元和多元根本就沒有本質的區別
     那麼 call/cc 在蟬語中是否能是多元的呢 ???
     這樣就比 scheme 還牛逼了
  5. 回憶一下 call/cc
     它的一元性顯現與下面的兩個一元函數之上
     (... (call/cc (lambda (cc) <body>)) ...)
     這個表達式出現的地方是一個"空"
     這個控形成了一個一元函數 它代表了當前的計算狀態
     call/cc 所作用於的必須也是一個一元函數
     這個函數的參數將是 是上面那個空所形成的一元函數
* 數據
** 類型
*** 目的
    1. 使得蟬語能夠更好地處理 數組樣子的數據結構
       並且 對鏈表樣子的數據結構 也將有統一的處理
    2. 一個對象在內存中的存在方式需要被指定
       有可能用到 GC 也可能是在 詞典 中的靜態數據
    3. 消除同時在語言中允許有類型的值和無類型的值時
       產生的語義過載現象
    4. 把處理某種類型的函數都登記於這個類型下面
       以節省命名空間
       並且使得所有的函數都不必檢查其參數
*** 可行性
    1. 只要在語法方面不影響表達的簡潔性
       那麼在運行時多入一個 數據類型標籤 到棧裏也是可以接受的
       "一個量" 佔參數棧中的兩個單元
    2. 不把函數 限制在某個類型內
       否則就將與函數範式相互衝突了
       必須把所有函數都暴露出來
       使得對它們的複合能夠被以簡潔的方式進行
    3. 在定義一個類型的時候
       最好不要初始化
       直接把所有對結構還有函數的定義都分散
       這樣就可以隨時添加處理函數到某個數據類型中去了
*** 類型之間的關係
    1. 一個類型由其數據域和其處理函數來表示
       所以類型之間的關係其實就是具體集合論中集合之間的關係
    2. 有某些算子[即 函數]和關係[即 謂詞]可以用來抽象 "具體集合" 這個數學結構
       比如 "含於" 這個關係
       比如 "上下确界" 這個算子
       但是我直接使用最具體而平凡的方式就可以了
       這些算子和關係可以在之後定義
    3. 在定義個類型的時候
       我提供語法以使你能夠指明其 數據域 和 處理函數
       我提供語法能使你直接聲明
       1) 這個類型的 以這個符號爲名的 處理函數
          和 那個個類型的 以那個符號爲名的 處理函數
          相同
       2) 這個類型的 以這個符號爲名的 數據域
          和 那個個類型的 以那個符號爲名的 數據域
          相同
       這就是我所說的 "具體而平凡的方法"
    4. 這種實現方式要求 函數內部關於接受參數還有形成返回值的部分
       必須對數據類型保持無知狀態
       必須沒有類型檢查 這樣一個函數才能夠被多個類型的數據類型使用
*** 數學結構
    1. 每一個類型[type]代表着一個具體的數學結構
       而在蟬語的基礎部分中
       並不去實現 抽象的 符合某些公理的 數學結構[class]
       這是因爲程序語言中所實現的數學結構
       都是具體的用來做計算的數學結構
       而數學中的抽象的數學結構
       是用來在探查滿足某些公理的數學結構的一般性質的
       除非是在實現一個輔助證明系統之後
       否則生硬地把抽象的數學結構還有範疇論中的概念
       引入程序語言中來 在我看來是不合適的
*** 類型推導
    1. 類型推導變得有趣而有用
       當且僅當 函數是一等公民的時候
       但是在蟬語中 作爲一等公民的函數
       是在實現了鏈表處理之後
       利用鏈表處理來實現的
    2. 也就是說在蟬語的核心部分的基礎上
       可以構建起各種計算系統
       比如 lambda-calculus 和 digrap
*** 初始化
    1. 在定義一個數據類型的時候
       必須指定一個用來初始化一個這個類型的數據的函數
       這個函數可能有參數 比如 對 詞 這個數據類型來說就是如此
       而也可能沒有參數 比如對與 cons 來說就是如此
       這個用來初始化數據的函數
       可以從棧中 cons 的數組中取 內存
       也可以從詞典中取內存 或者從數據段中取 內存
       - 比如編撰一個詞到詞典中的過程就是如此
       這樣就解決了 靜態的動態的問題
       並且 原子性的數字類型的量是在 參數棧中去內存的
    2. 可以發現 從語法的角度看
       對 上面的三種類型的 數據的初始化
       是非常不同的
       1) : kkk 1 2 3 . . . Exit ; define-function
          此時有一個名字被分配給了這個對象
          參數棧 中沒有留下東西
       2) cons
          此時沒有名字
          參數棧 中有地址
       3) 7
          此時沒有名字
          參數棧 中有值
*** 多餘的信息
    1. 儘管於一個帶有類型的量來說
       當它被入棧的時候一個類型標籤已將被入棧了
       但是我還是要求
       如果這個量是非原子性的量
       那麼它的地址下面就一定要有一個域用來儲存類型
*** 對別名的支持
    1. 詞典中的同一個定義
       應該能夠擁有兩個名字 這樣 英文 漢文 異體字 就方便多了
       這樣在詞典這個數據結構中 單向鏈接的鏈表的功能就喪失了
       因爲沒法依據這個鏈表來查找詞了
       這個功能本身我也沒用過
       也許我應該好好設計然後在取實現
       這樣就能有個大局觀
*** 實現
    1. 在開始實現基本的 名詞和動詞之時
       需要很多基礎設施
    2. 類型系統需要用更豐富的數據結構來實現了
       並且在實現它的時候還沒有類型系統
*** 術語
    1. 型[type] 類[class]
       結構[structure] 範疇[category]
       我應該如何使用這些術語呢 ?
    2. 目前我只使用 型[type] 這個術語
       用來表示一個具體的數學結構
** 具體
*** 詞
    #+begin_src cicada
    詞 静
      名 我希望這是被內化的串 即符號
      大小
      性
      詮釋者
      定義

    用來初始化 詞 的函數 會把詞分配到 詞區[詞典]中
    也就是說每個[某些]數據類型會有自己的區
    #+end_src
    1. 初始化
       先看 在舊的 依賴於外部的匯編器 依賴於解釋語義的 實現方式中
       初始化 是如何實現的
       1. 首先在匯編中
          定義之外的部分用一個宏實現
          定義就是簡單地把地詮釋者的地址留在匯編代碼中
          也就是說
          爲了形成一種寫匯編代碼的風格
          詞這個數據的結構被限制了
       2. 在解釋器中
          讀一個串
          把這個串解析成詞
          第一個詞爲 名
          以之後的詞 找對應的詞的詮釋者 以爲定義
       故 初始化之語法 類似於
       夫 <某> 者 <某> 也
       或
       夫 <某> 者 動詞 而 編撰入詞典
       如果 想 保留 也 這個詞 那麼就需要一種語法糖機制
       因爲 否則 就破壞了召喚函數的統一性
       但是這種統一性也許是需要被破壞的
       考慮 cons 就知道了
       名詞 和 動詞 是兩種類型
    2. 處理
       並沒有很多的處理函數
       對這個函數的處理都是散列表和名之間的互動
       可以說 散列表和詞 一同構成了詞典
    3. 統一性
       定義一個數據類型的語法是統一的
       帶有類型標籤的量在參數棧中的存在方式是統一的
       取非原子性的數據的域的方式是統一的 :: <型> 之 <域>
       召喚處理某種類型的函數的方式是統一的 :: <型> 而 <函數>
       統一性僅此而已
    4. 不統一性
       也就是說用來初始化各種數據類型的值的語法是不統一的
       數據類型存在於內存中的方式也是不統一的
    5. 型 類似於 名詞
       夫 詞 <某> 者 名詞 而 編入詞典
       設計何種語法才能把對型的 域 和 處理函數 的描述
       置於型的定義之外 ?
       這是不合理的
       對型的 域 的描述不應該被置於型的定義之外
    6. 所謂的之和而其實是相同的
       之 也是在召喚函數而已
       這樣就獲得了純粹的動態性
       之 <某> 會被編譯成 [某符號] [之]
    7. 某個數據類型的所有的處理函數
       都在類型的定義之外聲明
       其實就是把這些函數登記在這個類型下面
       並且我必須提供語法
       使得用戶能夠方便地把一批函數一起登記
    8. 只要做了下面所述的優化
       那麼以一致的方式來實現對數據域的處理也就可以了
    9. 不去定義標準的初始化一個數據類型的域的方式
       就能夠 保持 使用類型系統時候的靈活性
       好的 factoring 能夠保持 表達方式的精簡
    10. "而 編撰入詞典" 到 "也" 這種對語法的優化
        其實可以以一致的方式系統地使用
    11. 我說 ruby 識別出了一種 使用 lambda 的模式
        並且就這個模式優化了自己的語法
        器關鍵在於把 顯式的參數 變成 隱式的參數
        蟬語的語法必須具有 "可以做類似優化" 這種性質
        蟬語保持平凡的核心語法
        而在蟬語中對語法的優化 是由核心語法所提供的語義來完成的
        也就是我必須設計一種 讓用戶去優化語法的機制
    12. 可以看出在 有類型系統的 函數式範式中
        只要
        調整調用函數的前綴或後綴表達式爲順序爲中綴表達式
        然後在加上把某些 顯式的參數 優化成 隱式的參數
        就形成面向對象了
        而 我想 面向對象 所增加的認知上的負擔是很重的
        所以我放棄對 面向對象 系統的實現
    13. 蟬語所實現的東西 與一般的OO範式所不同的是
        1. 最重要的是沒有提供一致的方式來初始化類型
        2. 法上保持 後綴表達式
    14. 那麼定義一個類型的語法應該是如何的呢?
        我應該提供語法來幫助用戶
        在定義類型之初就指明有那些函數需要登記
        >< 我還希望能夠該處一致的方式在 定義好了一個類型之後
        再在其中登記 一個或多個 函數
        我希望登記 一個或多個 函數 的語法能夠一致
    15. 我甚至還能夠提供 所謂的 Class Variables
        因爲 這種 "把函數登記到類型中" 的解決問題的方式
        是非常靈活的
*** 關於優化
    1. 如果 在把 之 或 而 編譯到動詞的定義當中時
       如果能夠證明 這個函數被調用時 棧頂的數據的類型是固定的
       那麼就能夠把查找的過程在編譯期完成
       從而優化運行期的效率
    2. 最顯然的可以證明的情形是
       當它前面被編譯的是一個原子性的數據的時候
    3. 對於取非原子性數據的域的函數
       這種優化可以更進一步
    4. 可以發現這裏所謂的優化
       就是簡單把某些計算在編譯時期進行而已
       那麼
       如果在編譯時期遇到 1 2 + 這樣的函數體
       是否也要計算出這些結果呢
       答案是肯定的
       如果我總是保證在編譯期能做的計算都在編譯期被算完
       那麼顯然我就能證明
       就從這個角度的優化而言 我的編譯器達到了最優
    5. 但是
       lambda 如何呢 ?
       在 lambda 的函數提中如何呢 ?
       純粹地動態嗎 ?
       沒錯
       其函數體也是可以以類似方式優化的
       因爲我可能要歲 lambda 做手術
       所以 對於實現與否
       我把決策放在以後在做
*** 符號
*** 定義
*** 棧
*** 整數
*** 八位組
*** 字
*** 八位組串
    #+begin_src cicada
    八位組串
      蟬語者說
    ------------
    #+end_src
*** 單鏈
    #+begin_src cicada
    (* bra-ket *)
    { Mark-McGwire Sammy-Sosa Ken-Griffey }

    (* indentation *)
    ======
    - Mark-McGwire
    - Sammy-Sosa
    - Ken-Griffey
    ======
    #+end_src
*** 雙鏈
    #+begin_src cicada
    (* bra-ket *)
    [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

    (* indentation *)
    ======
    * Mark-McGwire
    * Sammy-Sosa
    * Ken-Griffey
    ======
    #+end_src
*** 名鏈
    #+begin_src cicada
    (* bra-ket *)
    ( :hr 65 :avg 0.278 :rbi 147 )

    (* indentation *)
    ======
    :hr 65
    :avg 0.278
    :rbi 147
    ======


    ( :american
        Boston Detroit New-York
      :national
        New-York Chicago Atlanta )

    ======
    :american
      - Boston
      - Detroit
      - New-York
    :national
      - New-York
      - Chicago
      - Atlanta
    ------
    :1 "-" for list element
    :2 "*" for dali element
    :3 ":" for wodi (* wodili element *)
    ======
    #+end_src
* 計算的方法
** 木答演算 [lambda-calculus]
** 有向圖處理 [digrap]
* 計算的方向
  1. 使用明顯的 參數棧 與 返回棧
     對於使 call/cc 的語義變清晰來說
     很有幫助
  2. "沒有祕密,就沒有泄密"
     "沒有抽象,就沒有抽象的泄漏"
  3. 在形成一個 cc 的時候
     應該可以以明確地方式說出所使用的是哪段計算
     這樣 call/cc 的語義就不會再令人迷惑了
  4. 如果我能以明顯的方式把各段運算
     以隱式抽象成函數
     然後隨意地組合它們
     然後在根據常用情況優化其語法
     那麼我就得到比 call/cc 更好的東西了
  5. 好像 call/cc 無論如何都需要複製參數棧
  6. call/cc 的難點在於
     必須使用動態地方式來分配 函數返回地址 和 函數參數 的內存
     然而它們會大大加重 GC 的負擔
  7. call-with-* 其實是改變了 函數作用的基本語法的
     (call-with-* <function>)
     它讓函數作用於一個約定的參數
     而不是使用
     (<function> <約定的參數>)
     爲什麼如此呢 ???
* 矛盾
  1. 高階與低階
     如果使用自己定製的虛擬機
     並且把 GC 實現在虛擬機中
     那麼 蟬語 之簡單性所帶來的對機器底層的控制能力就喪失了
     除非虛擬機的可擴展性非常強
     這樣在需要某些新的底層功能時
     就可以通過擴展虛擬機而完成
     也就是說
     虛擬機知道自己是一個虛擬機
     並且它提供通向更底層真實硬件的接口
  2. 特性之意義的喪失
     所保留下來的特性還有什麼 ?
     [如果 獨特之處 全然喪失 那麼我就應該回到 scheme 社區了]
     1) 以明顯方式使用的棧
        [函數語義的具體化]
        後綴表達式
        [達到與CPS同樣的效果][避免複雜的語法解析]
        無傳統意義上的局部變量
        [就函數複合而優化[同時使得對函數作用的表達變得羅嗦]]
        [也就沒有因局部變量的大量使用所帶來的認識上的負擔[但是引入了其他類型的額外的負擔]]
        這些特性 使得
        1. 蟬語是一個非常適合教學的語言
           比如
           犧牲效率而換取設計的一致性
           不做優化而換取實現的簡單性
        2. 在學會使用蟬語的同時 基本上就學會實現蟬語了
     2) 漢語本位
     3) digrap
     上面就是我能想到的全部了
     如果再強行描述其他的特點或優點 那就是不實的廣告了
* 對鏈表的排斥
  1. 人們先驗地認爲鏈表處理速度慢
     但是這是用速度來買靈活性的時候
     [看看minikanren就是全然用鏈表處理實現的]
     [而digrap將來也將全然使用鏈表處理來實現]
     [我想coq也是如此]
     [既然它們都是如此 那麼鏈表也就沒有什麼不可接受的了]
     所以我不再排斥鏈表處理了
* 空間換時間
  1. 通過把 function-address
     豐富爲 call function-address
     就做到了 在需要做判斷[形成很多分支]的時候
     避免判斷
     從而用空間來買時間
     這種想法可能在很多地方都適用
     [比如下面]
  2. >< 把函數體保存在鏈表中
     與把函數體保存在數組中
     這兩種存儲方式是否能夠相容??
     也許使用上面的技術就可以了
  3. 還有很多地方都可以這樣做
     比如 其他需要判斷是否到達數組的末端的地方
     都可以使用類似上面的技巧
     這優點類似於面向對象中
     把處理函數封裝到數據結構中一樣
     封裝之後
     我就可以把
     [判斷+調用]-優化爲->[調用]
  4. 以這種技巧
     我就能在棧中插入鏈表
     假裝鏈表是棧的一部分
     從而實現 明顯定界的 continuation
  5. 只要用標籤來標記有可能需要被捕捉的地方
     然後 當標籤都被處理完了之後
     在從使用 鏈表 轉回到 使用 棧 就行了
* 不同類型數據的分離
  1. chicken scheme 把所有的數據都分配到棧中
     而蟬語會儘量把所有不同類型的數據分離分配
     尤其是 有 參數棧 和 返回棧 之分
* 數據分配器
** >< 標記 式 數據分配器
   1. 一個數組被作爲 數據分配器 的對象
      數組之元素被稱爲 點
   2. 點 之間有一個離散的全序關係
      點的集合形成一個離散的一維線性空間
   3. 每個 點 中有 某些 域
      可以用來存儲數據
      通過在一個點的 域 中保存其他點的地址
      點與點之間就能形成聯繫
      點的全體 與 它們之間的關係 就是一個有向圖
      [這個有向圖是受某些性質限制的]
      [比如每個點所發出的有向邊只能有有限條]
      [即 有限叉有向圖]
   4. 數據分配器 
      的唯一職責是給用戶分配 點
      唯一接口是 cons 這個函數      
      所需要達到的效果是
      給人以有無限個 點 可以被使用的假象
   5. 標記 式 數據分配器
      產生這種假象的方式是
      首先它順着 一維離散空間 取 點
      當取完之後
      某些被用戶用過的點
      現在就又可以被重新使用了
      此時只要能夠判斷出
      那些點是可以被[安全地]重新使用的就行了
   6. 那個靜態的 長度固定的 一維數組 
      提示着我們需要去給 數據分配器 一個 工作週期 的概念      
      一個工作週期的開始和結束都是在
      cons 把 空間中最後一個點返回之後
      [當然 除了第一個工作週期之外]
   7. 有三個部分 相互配合 來完成工作
      它們分別是
      marking finding cleaning
      其中 cleaning 的工作是伴隨 finding 而進行的
   8. marking
      標記出下一個週期中將被認爲是不自由的點
      在下一個週期中 這些點 將不能被 finding 找到
   9. 也就是說 每個點上面需要有一個[一些]可以用來進行標記的域
      有三個這樣的域
      分別爲 marking域 finding域 cleaning域
   10. finding
       利用了 離散一位線性空間的全序關係
       也就是說 找下一個點的時候會順着這個序關係來找
       沒有被上一個週期的 marking 標記爲 "將不能被 finding 找到" 的點
       就是在需要返回一個點的時候 能夠被 finding 使用的點
   11. 需要定義 什麼是 "將不能被 finding 找到" 的
       定義 "在下一個週期中將不能被 finding 找到的點"
       即 "在下一個週期中還能夠以被引用到的點"
       而 "一個點 能夠以被引用到"
       被定義爲 "從根節點出發沿有向圖的有向邊能夠走到這個點"
       而 "根節點就所有全局變量和局部變量[即參數棧]"
   12. 每當一個點被賦值給全局變量的時候
       或一個點被賦值給一個已知是能夠被引用到的點的時候
       那麼在進入下一個週期的時候
       這個點就有可能是 能夠被引用到的點
       也有可能是不能被用到的
       [考慮一些使從根節點出發的有向路斷裂的副作用就知道了]
       但是重要的性質在於
       如果讓 marking 去標記所有這些可能是 能夠被引用到的點
       那麼所有 能夠被引用到的點 一定就都被標記了
       並且還可能有很多 其實並不是 能夠被引用到的點 也被標記了
       這個性質確保了 數據分配器 的正確性
   13. 如果 在一個工作週期結束的時候 啓動 marking
       那麼它就會從根節點出發
       去進行一個有向圖的深度有限的遍歷
       從而把所有的 能夠被引用到的點 都標記出來
       在下一個工作週期開始時
       所有 marking域 沒有被標記的點
       就是可以被 finding 找到的點
   14. 而 數據分配器 的漸進性在於
       不必讓 marking 在工作週期結束之時才開始工作
       只要保證它在 在工作週期結束之時才完成工作
       就可以了
       所以它可以時不時地去做一些標記工作
       然後休息一會兒
       只要它記住在遍歷有向圖的路程中自己已經走到哪個地方了       
       就行了
       [當然每當需要做這種記憶的時候其實就是需要一個棧而已]
   15. ><><><
   16. 所使用的置換顯然是三階置換羣中的兩個三循環置換之一
   17. marking 和 finding 的工作是相互獨立的
   18. 這種以 標記而形成的反證法 
       來證明那些 那些點在下一個週期可以被使用的
       的方式 
       決定了 finding 必須要有一個 
       "檢查標記" 以尋找沒有被標記的點的 尋找過程
       對理論上的時間複雜度而言 這是最大的因子
** >< 標記 式 數據分配器 對與 所佔空間大小不確定的數據 的分配
   1. 可以用壓縮式的垃圾回收器來實現對字符串的動態內存管理
      因爲string的長度可變
      所以簡單的marking-gc是不適用的
   2. 在marking工作的時候 如果看見<string>
      就更改引用點 並且複製字符串
      + makeing是知道引用點是哪個的
   3. 如果string的堆比pair的堆先耗盡
      這時就必須重啓gc
      所以應該把string的堆設置的充分大 以避免這種情況
   4. 一個問題是
      應該如何在 比如說 定義一個詞典中的函數的時候
      在這個定義中使用string-literal還有list-literal
      比如debuger那一節的函數就包含了很多要打印出來的字符串
      如果這些字符串是不被別的地方引用的
      那麼用``defineConstString''來定義它們就是不合理的
   5. 要知道被定義到詞典中的東西是永遠不能被刪除的
      因此也就是不需要被垃圾回收的
      所以讓這gc去mark這些量是不合理的
      所以就像在彙編中一樣
      每個函數中的結構化的literal量 就是這個函數的數據段
      在編譯函數的時候應該把這些數據也寫到詞典裏
   6. 所以 string-literal 和 string-processing
      採用了兩種不同的方式來使用string
      string-processing 中所使用的string必須是動態分配內存的
      ``readStringInToBuffer'' 這個函數所提供的 string buffer
      是一種能力非常有限的動態分配內存的方式
      而這裏的 利用gc來實現的<string> 是一種更好的方式
   7. string[address, length] 之外另一種字符串的表示方式是
      [address, <string>]
      此時address的前面必須保存length
      我用4byte來保存這個length
** 標記 式 數據分配器 的缺點
   1. 其時間複雜度在理論上劣於 
      複製-壓縮 式 數據分配器
   2. 有可能影響漸進性的情況是
      finding 遲遲找不到一個沒有被標記的點
      當有很多的被標記的點 充斥着那個一維離散線性空間時
      這種情況會經常發生
   3. 沒法以一致的方式處理 
      所佔空間大小不確定的數據
      即 此時又必須用到 複製-壓縮 式 數據分配器      
** 標記 式 數據分配器 合理性
   1. 如果要求 所佔空間大小不確定的數據 之間不能形成複雜的相互引用
      那麼 這種處理方式就避免了 複製-壓縮 式 數據分配器      
      在處理這種 情況時所將會遇到的困難
      即 "更新困難"
      [注意 這種 "更新困難" 只有當要求 數據分配器 的漸進性的時候纔會發生]
** >< 複製-壓縮 式 數據分配器
   1. 這種類型的 數據分配器 只專注於 所能夠被引用到的點
      而不理會不能被引用到的點
      它摒除了 標記 式 數據分配器 中的 finding
   2. 每當把一個cons從一個heap複製到另一個heap
      所有引用這個cons的cons都需要被更新
      做這種更新的方式是
   3. 在每個 cons 中使用一個 標記域
      每當把一個 cons 從 堆甲 複製到 堆乙 時
      標記這個 cons 是已經被複製過了的
   4. 當一個 cons 已經被複製好了之後
      這個 cons 就
      [注意這裏需要使用一些技巧來保存臨時變變量]   
** >< 數據類型的分離
   之前分離數據類型是因爲想要用 數組 而不想用 數據堆
   既然 現在使用 複製-壓縮 數據分配器了
   那麼所有的東西就都能夠在一個堆裏了
** >< 更新困難
   1. "更新困難"
      也許可以用 "同步" 來解決
      就是說 去複雜化所有數據的接口
      兩個棧之間相應的數據被認爲是等同
      並且當在接口中初次遇到需要更新的兩個點時就更新它們
      這樣就獲得了漸進性
   2. 而 "三染色算法的進行" 
      其實是與 數據分配器 這兩種分類沒有關係的
** 最終的設計決策
   1. 我之前使用的是 標記 式 數據分配器
      並且我還發展了一些小技巧來 增加它的漸進性
      但是現在經過考量後 
      我決定要轉而使用具有更好的一致性的 複製-壓縮 式 數據分配器
* 雙向鏈接的鏈表
  1. 也許我應該直接以雙向鏈表爲基本數據結構
     因爲 它能夠被當作 單向鏈表來使用
     這樣就增強了設計的一致性
     我可以把鏈表單元的實現
     從 [car cdr] -優化爲-> [data <- ->]
  2. 這也能成蟬語的另一個特點[賣點]
     即 極端[不顧成本的]富的數據結構
* 函數複合 與 變換
  1. 應該以 函數複合 爲基礎來組織語言的基礎語義的數學基礎
     想要找一個數學基礎的原因是[且只是]
     爲了能夠得到一套規則來對代碼的表達式進行推導
  2. 複合的時候對參數有一個檢查是合理的
     但是又是困難的
     因爲參數的入棧和出棧是可以很靈活的
     把參數用一個名字打包 就能形成一個對參數的額外聲明
     也許這種技巧能夠解決 推導與變換 的問題
* 優化與變形
  1. 具有局部變量和以函數作用爲主而實現的 lambda 演算中
     可以看到
     利用對 lambda-term 的變形
     可以對程序做出很有趣的觀察
     這些觀察和變換可以用來優化程序
     這都是因爲 lambda 演算 的良好的數學性質所導致
  2. 而
     在蟬語這種以函數複合爲主的語言中
     如果仔細甄選原子性函數[如joy所做的那樣]
     那麼就也能達到有趣而良好的數學性質
     這裏所謂的良好其實是說
     利用這些性質我們能對一段函數做很多的恆等變形
     就像是對一個數學公式所做的那樣
     這樣就也達到了 lambda 演算 的優點
     [這些是組合邏輯的課題]
  3. 關於高階
     只有當這些變換能夠對某些高階的函數而進行的時候
     才會有用
  4. 把運算在編譯時期來做就是了
     但是理論上能夠在編譯時期做的運算可能是非常多的
     >< 這裏需要一個分析
* 對古典 scheme 的批判
  1. 在古典的lisp中每當構造子cons像上面這樣構造完一個pair之後
     都只有且只有一次機會來引用所構造的pair
     那就是在嵌套的sexp中調用cons的那個位置上
     那個位置上返回的值就是所構造的pair
  2. 而在我的cicada中引用那個cons的方式極爲靈活
  3. 比如 如果我要編譯一個類scheme語言到cicada的話
     我就可以又類似下面的語法
     在下面的兩個<sexp>中也可以引用到這個cons將要構建好的pair
     #+begin_src scheme
     (cons :set-address-to xxx
           :car <sexp>
           :cdr <sexp>)
     #+end_src
  4. >< 但是一個問題是上面的語法用到了局部變量
     不知到局部變量的問題如何在類forth語言中解決 ???
  5. forth是如此靈活以至於我根本沒必要實現common-lisp中的那種廣義引用
     比如爲了實現類似的效果 我複製一下被解構子解構的pair的地址就行了
  6. 在使用scheme的時候我從來沒有想像過對數據結構的使用能夠像在forth中這樣靈活
     但是就目前的實現進度而言與scheme相比我還缺少:
     1) λ-abstraction
     2) 局部變量
     3) 局部變量與λ-abstraction是等價的嗎 ???
        我已經知道用λ-abstraction(closure)就可以實現局部變量了
        反過來也行嗎 ???
     也許我可以在forth中實現這些東西
     因爲我能夠單純地用列表處理來實現整個λ-cal(惰性求值的)
     用列表處理實現λ-cal之後 我只需要實現一個類似apply的函數就行了
     可以說forth的語法是就``函數的複合''而優化的
     而scheme的語法是就``函數的作用''而優化的
     但是兩種語義顯然是能夠互相表示的
     要知道 當把forth中的所有的word都理解爲一棧爲參數的一元函數的時候
     其實那些單純地把一個量入棧的函數 也可以被理解爲參數
     而後面的函數與這些函數的複合可以被理解爲這些函數對參數的作用(當然了,這纔是古典的理解)
     也就是說對forth的理解是非常靈活的
     + 對於被當作二元運算的二元函數來說
       只有當這種二元運算滿足結合律的時候使用infix纔是令人滿意的
       + 比如: + * max min gcd `函數的複合' `字符串的並聯' 等等
       這正是joy所想要表達的
     + 對二元運算的結合性的證明 可以被轉化爲對一種特殊的交換性的證明
       #+begin_src
       (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r+ == r++
       或者:
       (p + q) + r  ==  p + (q + r)  <==>
       p q + r +    ==  p q r + +    <==>
       + r +        ==  r + +
       #+end_src
     + 再考慮一下別的運算律 簡直有趣極了
       #+begin_src
       分配律(或者說對某種同態變換的描述):
       中綴表達式: (a+b)*c == (a*c)+(b*c)  <==>
       後綴表達式: ab+c* == ac*bc*+  <==>  ???
       但是至少我知道 +(c*) =/= (c*)+
       要想填上上面的問號 可能就需要 λ-abstraction 的抽象性
       否則我根本沒法描述某些東西

       交換律:
       a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

       +* =/= *+
       abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
       #+end_src
     + 把後綴表達式考慮爲對棧的操作是自然的
       並且這樣的理解方式所帶來的一個很大的好處就是實在性
       這就又回到了哪個``小孩玩積木''的比喻了
       比如我的十三歲的弟弟可以問我"那個函數的參數是從哪來的?"
       我就告訴他是從棧裏拿出來了
       "那個函數的結果去哪了?"
       我就告訴他結果放回到棧裏了
       數學 和 編程 就都像一個小孩在玩積木一樣
       對了 他還可以問我這個函數是從哪裏來的
       我就說是從詞典裏找來的
  7. forth是最有趣的結合代數
     利用這個結合代數似乎可以模擬任何代數結構(甚至是非結合代數)
     1) 比如上面對函數作用的模擬(儘管函數的作用不是結合的)
     2) 又比如我可以把兩個矩陣入棧
        然後一個矩陣乘法函數可以像"*"乘兩個數一樣爲我返回矩陣的積(儘管矩陣乘法不是結合的)
     3) 又比如列表處理可以用來實現digrap
        而digrap已經出離代數的範疇之外了
        但是它還是能夠被forth的結合代數所模擬
  8. 如果讓我寫scheme編譯器的話 我會讓每個表達式都返回一個值
     正因爲如此 在cicada中
     我才把set!,set-clr!,set-car!,set-cdr!等等函數實現爲它們現在的這種樣子
