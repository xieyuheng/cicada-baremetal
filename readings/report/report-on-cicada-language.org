#+TITLE: report on cicada language
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 記
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
* ==================================================
* 優點
  1. 某些性質被我認爲是優點
     然而 同樣的性質 在不同的人看來可能是缺點
  2. 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
     這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
* 缺點
  1. 某些性質被我認爲是缺點
     然而 同樣的性質 在不同的人看來可能是優點
  2. threaded-code 的侷限性
     主要在於 這種風格的機器碼很可能 難以優化
     但是其實只有在具體的測試和實驗之後
     才能得出真正的結論
* ==================================================
* note
** about decision
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** the right thing
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** about function-group
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
* ==================================================
* english-core
** 以名釋性
   (string-reference <string> <index>)
   (string-compare <string1> <string2>)
   (string-append <string1> <string2>)
   發現命名是一個問題
   每個動詞比如compare
   可以是 string-compare 或 list-compare
   這就要求在命名上給每個函數加上數據類型的前綴
   作爲特殊的前綴
   也許應該用 string:compare 而不是 string-compare
   這種看來勞神的前綴的需要是因爲
   我不允許函數名的重載
   如果我統一這種對數據類型前綴的使用
   那麼 動態類型的量 和 非動態類型的量
   之間命名規則的衝突也就被化解了
   也許 string-append 應該被叫做 string:^_^
   就像 ^_^ 在 dalin 中的效果一樣
   但是這兩種函數之間又有區別
   重要的區別是
   他們是返回新的數據還是在原來數據的基礎上做副作用
   我還可以用對命名函數的約定來
   讓函數的名字體現更多的函數的性質
   也就是說 cicada 的一個特點是
   ``以名釋性''
   這是實現起來最簡單的
   但是需要設計良好的命名規則
   在給函數取名字的時候
   寫代碼的人也要花一些功夫思考
   才能讓這個名字恰當地體現函數的性質
   同時最重要的是
   這種方案
   可以在最大程度上減輕人們在讀代碼的時候的
   認知上的負擔
   ------------------
   但是有一些重要的函數比如 write
   還是需要取處理不同類型的量
** about bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** IDE
   另外還有 IDE
   通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來
   獲知名詞和動詞的語義
   與命名規則一樣
   這一切都是爲了
   減輕``代碼的閱讀者的認知上的負擔''
** the naming conventions in cicada
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** about programming paradigms
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** object-oriented
   其實 利用 list-processing 我可以在 cicada 中加入對 object-oriented (class and message-passing) 的支持
   正如 我用 list-processing 來實現 lambda-calculus 一樣
   並且我想 object-oriented 這種編程範式也許更適合用來實現 digrap
   但是 問題是 新的語法元素必須被引進
   這也許可以通過寫一個不同的 REPL 來實現
* ==================================================
* 貫徹類型系統
  1. 貫徹類型系統
     目的
     1) 引入 對數組型數據結構的更好的處理
        並且 將來對鏈表型數據結構的處理也能以一致的方式被表達
     2) 消除一種語義過載現象
  2. 之後 "一個量" 就應該默認地是佔參數棧中的兩個 cell 的了
     所有的函數都必須被重新實現了
  3. 在開始實現基本的 名詞和動詞之時
     並且需要很多
* 參數到方法的對應只能在 運行時 被決定
  1. 所以我放棄對面向對象的支持 ??
     不是的
     比如 2 而復
     當以 "而" 爲傳遞參數的虛詞時
     可以被寫爲
     2 而 復
     但是這還是命名規則的問題
     因爲 對命名空間的節省
     只有當有有很多類型的量在共享着相同的命名空間的時候
     才能體現出來
  2. 如果不想在運行時決定應該調用哪個方法
     那麼就需要一個類型標籤 [不論以何種鋼方式使用這種標籤]
     比如 2 <整數> 而 復
     與 2 而復 相比 這要難看地多了
     並且也失去節省命名空間的意義了
* OO
  1. 在我看來 OO 的好處在於
     把函數登記在類型中
     從而節省命名空間
  2. OO 通常使用中綴表達式
     這是因爲:
     1) 在設計上
        接近人對數學公式的表達
     2) 在實現上
        從左到右讀參數的順序使得中綴達式成爲最明顯的設計決策
     我放棄中綴表達式
     依然使用 後綴表達式
  3. "之" 這個虛詞 是在編譯時期被處理的
     它的前面必須是某些帶有類型標籤的參數
     通過檢查這些類型標籤
     編譯器找出所需要編譯的函數來
  4. 但是這是不合理的
     因爲這裏類型標籤是多餘的了
     類型標籤不應該在運算中出現在 參數棧 中了
  5. 但是 如果沒有類型標籤
     GC 怎麼辦 ?
     鏈表類型中的 cons 怎麼辦 ?
     只要把 cons 也以一致的方式實現爲帶有類型頭的量就行了
     也就是說 在使用 帶有類型頭的量的時候
     只要把量的地址入棧 就足夠了
     因爲用來處理它的函數是在編譯時期指定好的
     這樣就和基本的棧機相容了
  6. 這樣就完全不會影響函數範式
     但是語法上的簡潔性還需要被檢查
  7. 這樣字典之喻就要被重新考慮了
  8. 如何產生一個帶有類型的量 ?
     每次都用一個特殊的 reader 來讀詞符串嗎 然後初始化這些量麼 ?
     既然類型標籤已將不明顯地在棧中使用了
  9. 是否要求每個值都是帶有類型頭的量呢 ?
     是否以一致的方式來實現所有的數據結構呢 ?
     但是內存分配怎麼辦 ?
     之前的對數字之類的原子性的量的動態內存分配
     是利用 參數棧 來完成的
     而如果一個數字需要一個類型頭
     那麼它的類型頭也必須在 參數棧 中被動態分配內存
  10. 上面的難點是否說明
      我必須把面向對象的使用作爲一種可選的性狀
      而不堅持在所有的需要函數作用的地方都以一致的方式使用它們
  11. 但是這種不一致性顯然是不好的
  12. 在其他語言中這種難點是在編譯時期用更複雜的編譯器來解決的
  13. 也就是說我必須保留類型標籤在參數棧中的出現
      但是這樣非常低效率 不是嗎 ?
  14. 如果 每個 cons 前面都有一個類型頭
      那麼 當 cons 出現在 被動態內存管理的數組之外的時候
      它也能被解釋爲 cons 這其實並沒有浪費內存
      因爲之前 一個 cons == 4 * cell + flag
      而現在 cons == 2 * cell + header + flag
  15. 如果我把數字也都實現在 cons 中
      那麼就能垃圾回收它們了
      就能以一致的方式 使用地址了
      但是這儼然不是所希望的
  16. 類型標籤出現在 參數棧 中
      就代表了非編譯期處理類型的可能性
      所以是必須的
  17. 按現在的想法
      函數還是必須遵循命名規則來定義
      然後被登記到每個類型上
      而所謂的 OO 只是一種 編譯時期的小技巧而已
      它使得使用函數的時候可以節省命名空間
      而定義函數的時候還是必須以原來的方式定義
      這是不合理的
      正確的處理方式是
      在作爲一個 簡化使用函數時 所呼喚的名字的技巧的同時
      這種 OO 還必須 使得在定義函數時能夠保持函數名字之間不相互衝突
      如果不想隱藏某些函數使得它們沒法被以別的方式被調用的話
      那麼使用一種命名規則就可以了
      但是如果希望隱藏函數的話
      就必須再用些技巧
  18. 我還是多回顧一下實際中對數據類型的使用吧
  -----------------------------------
  1. 在定義一個數據類型的時候
     必須指定一個用來初始化一個這個類型的數據的函數
     這個函數可能有參數 比如 對 詞 這個數據類型來說就是如此
     而也可能沒有參數 比如對與 cons 來說就是如此
     這個用來初始化數據的函數
     可以從棧中 cons 的數組中取 內存
     也可以從字典中取內存 或者從數據段中取 內存
     - 比如編撰一個詞到字典中的過程就是如此
     這樣就解決了 靜態的動態的問題
     但是 可否讓這種初始化 數據的函數從 參數棧中取內存呢 ?
  2. 我想是不行的
     因爲這樣就把對一個數字的使用過度地複雜化了
  3. "之" 這個虛詞 的前面必須出現一個帶有類型的參數
     這個參數將被函數視爲是主要參數
  4. 可以發現 從語法的角度看
     對 上面的三種類型的 數據的初始化
     是非常不同的
     1) : kkk 1 2 3 . . . Exit ; define-function
        此時有一個名字被分配給了這個對象
        參數棧 中沒有留下東西
     2) cons
        此時沒有名字
        參數棧 中有地址
     3) 7
        此時沒有名字
        參數棧 中有值
  -----------------------------------
  1. 只要在語法方面不影響表達的簡潔性
     那麼在運行時多入一個數據類型到棧裏也是可以接受的
  2. 如果確定要這樣實現的話
     我必須弄明白
     1) 那些部分需要被重寫
        那些部分將構成新的基礎
     2) 一致的使用 "之" 來調用函數之後
        語法上和語義上會不會產生問題
  -----------------------------------
  1. 不合理之處在於
     對於一個 數據 如果 "之" 這個虛詞後面跟的詞
     只是想要取這個 數據的一個域的地址的話 那麼這就應該在編譯時期被處理
     而不應該在運行時被處理
  2. 如果類型標籤要用 symbol 實現
     那麼 寫 hash-table 的時候就還沒有類型可用
     所以系統的基本部分和整個系統的結構就又該被調整了
  3. 注意現在已經是純粹的編譯語義了
  4. 在最初的時候就使用類型系統有什麼困難之處 ?
     困難之一在於有太多的值在棧中了
     而好處是 取出了一個語義過載現象
  -----------------------------------
  1. 多餘的信息
     如果入棧一個類型標籤
     那麼我是否還應該在地址下面保留類型頭的位置呢 ?
     有何意義呢 ?
     也許根本就沒有意義
     不應該這樣做
     比如原子性的數字就沒法添加這個類型頭
     也許有意義
     那麼之後添加個數據域我想也並不困難
  -----------------------------------
  1. 詞典中的同一個定義
     應該能夠擁有兩個名字 這樣 英文 漢文 異體字 就方便多了
     這樣在字典這個數據結構中 單向鏈接的鏈表的功能就喪失了
     因爲沒法依據這個鏈表來查找詞了
     這個功能本身我也沒用過
     也許我應該好好設計然後在取實現
     這樣就能有個大局觀
  -----------------------------------
  1. 另外這種 登記函數名 的模型 是不是不能捕捉跟繼承有關的概念 ?
  -----------------------------------
* smalltalk 中對函數的命名
  1. smalltalk 中函數的命名是非常靈活的
     函數的命名變成了
     對象之間傳遞消息的協議
     這種特性正是爲了解決命名問題
  2. 而在 cicada 中 
     函數命名將被限制與一個詞
     而 在函數作用的時候 
     lambda 的約束變元的名稱 可以幫助增加代碼的可讀性
     儘管這些約束變元的名字並不出現在 函數的名字當中     
  3. 但是
     在 smalltalk 中
     函數的使用可能並不靈活
     函數不可能被作爲一等公民來對待
  4. 但是
     有代碼塊可用
     並且 也較爲良好的代入語義
     所以 也許與 lambda 等價的東西是存在的
  5. 那麼
     如何說 cicada 中的函數是一等公民呢 ?
     這在於 ><     
* 對象與方法 == 數據與函數
  1. 在兩種理解方式下類型都是類型
     一個常用 類 class 一個常用 型 type
  2. 使用編譯語義之後
     cicada 中對類型的實現方式是否應該更換 ?
     即只留一個地址在棧裏 作爲類型的值
     不更換的話 是否能帶來特殊的靈活性 ?
  3. 一個對象 或 一個結構化的數據
     使用它們的時候是否要用 GC 呢 ?
     有時需要 有時不需要
     一個對象在內存中的存在方式需要被指定
  4. 下面我來分析一下在 蟬語 的實現過程中我已經使用過的數據結構
     看看使用 OO 後能否以更一致的方式來處理它們
  5. 詞典
     - 靜態
     - 定長
     - 很大
     - 其內保存的 詞 形成一個單向鏈接的鏈表
     - 處理這個數據類型的函數有

  6. 詞
     - 靜態
     - 每個詞只有定義部分是變長的 其餘部分都是定長的
     - 存在與 詞典 中
     - 處理這個數據類型的函數有

  7.
* 面向對象的缺點
  1. 對於 "作用" 來說這種面向對象的技巧能夠節省命名空間
     但是對於 "函數複合來說" 則不然
     在蟬語中我經常需要把函數複合來定義新的函數
     如果所有的函數都被保護到類型的內部了
     之後找到相應類型的值的時候才能調用到這個函數
     那麼我就沒法方便的做函數的複合了
  2. 其他的語言中是用參數名和類型推到來解決這個問題的
  3. 而在蟬語中 我可以通過一個 一致的命名規則來解決這個問題
     讓這個命名規則伴隨對數據類型的定義而產生
     並且不保護任何函數名
     函數名之間的不衝突應被命名規則來保證
     也就是一種弱的保護
* 數據類型的名字
  1. 數據類型的名字應該被實現爲什麼 ?
     一個量 這個量的類型 是類型 ?
     還是 一個函數 這個函數初始化這個類型的量 ?
  2. 我想可能是前者
     因爲 畢竟這些詞是名詞
     但是也可能是後者
     因爲 畢竟中文中有名詞活用爲動詞
* 主參數
  1. 面向對象的引入使得 每個函數都有一個主參數
     在作用的時候 通過這個 主參數 還有 "之" 能夠找到這個函數
  2. 其實這是在說參數的順序會決定所調用的是哪個函數
     這個性質是需要的
     除非像在使用 lambda 的時候那樣給每個參數一個名字
* ==================================================
* note
  this report gives a defining description
  of the cicada language.
* ==================================================
* data
** note
   this chapter is about
   how one can type some strings into cicada
   and let cicada parse these strings
   to return different kinds of values into the Return-stack
** >< number
*** integer
** >< string
   #+begin_src yaml
   text: |
      There once was a short man from Ealing
      Who got on a bus to Darjeeling
          It said on the door
          "Please don't spit on the floor"
      So he carefully spat on the ceiling
   ------
   text: >
      Wrapped text
      will be folded
      into a single
      paragraph

      Blank lines  denote
      paragraph breaks
   ------
   #+end_src
** list
   #+begin_src cicada
   (* bra-ket *)
   { Mark-McGwire Sammy-Sosa Ken-Griffey }

   (* indentation *)
   ======
   - Mark-McGwire
   - Sammy-Sosa
   - Ken-Griffey
   ======
   #+end_src
** dali
   #+begin_src cicada
   (* bra-ket *)
   [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

   (* indentation *)
   ======
   * Mark-McGwire
   * Sammy-Sosa
   * Ken-Griffey
   ======
   #+end_src
** wodili
   #+begin_src cicada
   (* bra-ket *)
   ( :hr 65 :avg 0.278 :rbi 147 )

   (* indentation *)
   ======
   :hr 65
   :avg 0.278
   :rbi 147
   ======


   ( :american
       Boston Detroit New-York
     :national
       New-York Chicago Atlanta )

   ======
   :american
     - Boston
     - Detroit
     - New-York
   :national
     - New-York
     - Chicago
     - Atlanta
   ------
   :1 "-" for list element
   :2 "*" for dali element
   :3 ":" for wodi (* wodili element *)
   ======
   #+end_src
* --------------------------------------------------
* lambda-calculus
* ==================================================
