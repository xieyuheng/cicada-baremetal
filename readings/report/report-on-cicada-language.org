#+TITLE: report on cicada language
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 記
** 蟬語之優
   1. 某些性質被我認爲是優點
      然而 同樣的性質 在不同的人看來可能是缺點
   2. 把對 參數棧 和 返回棧 的處理 明顯地暴露給用戶
      這樣就使得 使用者 能夠對系統的整個運行情況有非常具體而直觀的瞭解
      這個性質是我最喜歡的
      就算是對於 scheme 和 smalltalk 這種設計良好而簡潔的語言來說
      這種對整個系統的直觀理解也是不行的
      因爲 這兩種語言的 簡潔性 是以很高的抽象性爲代價的
      而 蟬語 的設計就是要在 保持這種 被簡單而直觀的理解的可能性的同時
      去實驗某些性狀 以達到 不比 scheme 和 smalltalk 弱的抽象能力
** 蟬語之劣
   1. 某些性質被我認爲是缺點
      然而 同樣的性質 在不同的人看來可能是優點
   2. threaded-code 的侷限性
      主要在於 這種風格的機器碼很可能 難以優化
      但是其實只有在具體的測試和實驗之後
      才能得出真正的結論
** 簡體繁體
   1. 簡體 繁體 西文 和所謂也 ?
      聲韻形態皆思之載體
      過分追究表達方式之異同之人
      未嘗得道也
   2. 在蟬語中 以傳統漢語爲主要表達方式
      而在命名規則和別名系統的幫助下
      我可以讓 簡體 繁體 西文 並存
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
** 設計決策
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** 正確編程方法
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** >< 函數組
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** >< 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
** 以名釋性
   1. 在全面地貫徹類型系統之後
      以名釋性 的方式就改變了
      此時需要強調的就是命名規則了
   2. 以名釋性
      的目的還是減輕代碼的閱讀者在認知上的負擔
** bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** 代碼的閱讀者的認知上的負擔
   集成開發環境 是爲了 通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來 獲知 詞 的語義
   與命名規則一樣 這一切都是爲了
   減輕 代碼的閱讀者的認知上的負擔
** 蟬語中的命名規則
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** 編程範式
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** 對 OO 的支持必須被放棄
   1. 因爲 所想要實現的 OO 系統中
      參數與方法之間的對應 只有在運行時才能確定
      這對效率來說是個打擊
   2. 因爲 OO 與 對函數的靈活使用是相互衝突的
      在我看來 不同的編程範式 代表了不同的思考方式
      而對多範式的支持 只能帶來混亂
   3. 對於 "作用" 來說這種面向對象的技巧能夠節省命名空間
      但是對於 "函數複合來說" 則不然
      在蟬語中我經常需要把函數複合起來
      以定義新的函數
      如果所有的函數都被保護到類型的內部了
      之後找到相應類型的值的時候才能調用到這個函數
      那麼我就沒法方便的做函數的複合了
   4. 其他的語言中是用參數名和類型推導
      來解決上面這個問題的
   5. 而在蟬語中 我可以通過一個 一致的命名規則來解決這個問題
      但是這樣就把函數的命名規程化了
      在我看來少了很多靈活性和樂趣
   6. 綜上所述
      對 OO 的支持必須被放棄
** smalltalk 中對函數的命名
   1. smalltalk 中函數的命名是非常靈活的
      函數的命名變成了
      對象之間傳遞消息的協議
      這種特性正是爲了解決命名問題
   2. 我把這種特性理解爲
      - 把函數名 分散爲部分
        每部分匹配一個參數
        而約束變元
      - 而在 蟬語 中
        函數命名將被限制與一個詞
        在 蟬語 的 lambda 中
        是約束變元的名字在被用來匹配參數
        在函數作用的時候
        lambda 的約束變元的名稱 可以幫助增加代碼的可讀性
        儘管這些約束變元的名字並不出現在 函數的名字當中
   3. 但是
      在 smalltalk 中
      函數的使用可能並不靈活
      函數不可能被作爲一等公民來對待
   4. 但是
      有代碼塊可用
      並且 也較爲良好的代入語義
      所以 也許與 lambda 等價的東西是存在的
      然而
      就算 代碼塊 的語義能夠用來實現
      與 lambda 等價的東西
      對這些東西的使用也是不方便的
   5. 那麼
      如何說 cicada 中的函數是一等公民呢 ?
      這在於 ><
** >< 語義重載現象
   1. 在蟬語中現在還有一個語義重載現象
      那就是 函數 既可以是 一個詞典中的動詞
      也可以是一個 lambda-term
* ==================================================
* 實現
** 記
   1. 我先把所有的設計都寫成文檔
      然後再着手實現
      否則當實現到了後面
      如果發現了某些設計需要更改
      就必須更改很多前面的代碼
   2. 我能這樣做
      只是因爲
      第一個版本已經被實現好了
      我已經知道在實現過程中可能遇到的技術難題是什麼了
** 虛擬機
   1. 這次是我在濫用術語了
      當我考慮是否要使用一個虛擬機還有鏡像文件來實現蟬語的時候
      我才發現這一點
   2. 要知道虛擬機和處理器
      都是指令集編碼的簡單的解釋器
   3. 我之前所說的可擴展的虛擬機
      即 內部解釋器
      於一個虛擬機非常相似
      我應該利用這種相似之處
      而實現一個更符合虛擬機這個屬於傳統意義的虛擬機
   4. 也就是說讓整個詞典可以靜態地存在於一個鏡像文件中
      這類似於設計一個可執行文件格式
   5. 詞典中的每一部分都可能依賴於詞典中的其他部分
      並且可能有相互的依賴
      在把鏡像文件中的詞典中的一部分加載到內存中的時候
      相互的依賴關係需要被處理
** 另一種實現方式
   1. 我可以在這裏辨別出兩種實現方式
      1) 用詞表達的可執行文件
         被蟬語的解釋器加載並解釋
      2) 用八位組碼表達的可執行文件
         被一個單純的 threaded-code 解釋器加載並解釋
   2. 它們的優劣分別分析如下
      |      | 一 | 二 |
      |------+----+----|
      | 層次 | 少 | 多 |
      | 加載 | 慢 | 快 |
      | 大小 | 大 | 小 |
   3. let the dictionary be a loadable linkable executable format
      parts of the dictionary could be linked to be the whole
      runtime changes from "a word interpreter" to
      "a dictionary loader and linker"
      plus "a threaded-code interpreter"
      in the last case, no string input is needed
      while a REPL is still can be provided
   4. 第二種方式最大的好處是
      我可以實驗自己設計指令集
      與指令集的編碼方式
   5. 更大的好處是
      在虛擬機的幫助下
      移植的方便性就達到了最高
   6. 這種 作爲虛擬機的 threaded-code 解釋器 是一定能實現的
      問題是 詞典這個數據結構如何設計
      如果發現這樣的設計在加載的效率上還不如對字串的處理
      那麼就失去意義了
   7. 虛擬機之重要性在於
      我所使用的彙編器中所能實現的宏限制了我對詞典這個數據結構的設計
* ==================================================
* 數據
** 類型
*** 目的
    1. 使得蟬語能夠更好地處理 數組樣子的數據結構
       並且 對鏈表樣子的數據結構 也將有統一的處理
    2. 一個對象在內存中的存在方式需要被指定
       有可能用到 GC 也可能是在 詞典 中的靜態數據
    3. 消除同時在語言中允許有類型的值和無類型的值時
       產生的語義過載現象
    4. 把處理某種類型的函數都登記於這個類型下面
       以節省命名空間
       並且使得所有的函數都不必檢查其參數
*** 可行性
    1. 只要在語法方面不影響表達的簡潔性
       那麼在運行時多入一個 數據類型標籤 到棧裏也是可以接受的
       "一個量" 佔參數棧中的兩個單元
    2. 不把函數 限制在某個類型內
       否則就將與函數範式相互衝突了
       必須把所有函數都暴露出來
       使得對它們的複合能夠被以簡潔的方式進行
    3. 在定義一個類型的時候
       最好不要初始化
       直接把所有對結構還有函數的定義都分散
       這樣就可以隨時添加處理函數到某個數據類型中去了
*** 類型之間的關係
    1. 一個類型由其數據域和其處理函數來表示
       所以類型之間的關係其實就是具體集合論中集合之間的關係
    2. 有某些算子[即 函數]和關係[即 謂詞]可以用來抽象 "具體集合" 這個數學結構
       比如 "含於" 這個關係
       比如 "上下确界" 這個算子
       但是我直接使用最具體而平凡的方式就可以了
       這些算子和關係可以在之後定義
    3. 在定義個類型的時候
       我提供語法以使你能夠指明其 數據域 和 處理函數
       我提供語法能使你直接聲明
       1) 這個類型的 以這個符號爲名的 處理函數
          和 那個個類型的 以那個符號爲名的 處理函數
          相同
       2) 這個類型的 以這個符號爲名的 數據域
          和 那個個類型的 以那個符號爲名的 數據域
          相同
       這就是我所說的 "具體而平凡的方法"
    4. 這種實現方式要求 函數內部關於接受參數還有形成返回值的部分
       必須對數據類型保持無知狀態
       必須沒有類型檢查 這樣一個函數才能夠被多個類型的數據類型使用
*** 數學結構
    1. 每一個類型[type]代表着一個具體的數學結構
       而在蟬語的基礎部分中
       並不去實現 抽象的 符合某些公理的 數學結構[class]
       這是因爲程序語言中所實現的數學結構
       都是具體的用來做計算的數學結構
       而數學中的抽象的數學結構
       是用來在探查滿足某些公理的數學結構的一般性質的
       除非是在實現一個輔助證明系統之後
       否則生硬地把抽象的數學結構還有範疇論中的概念
       引入程序語言中來 在我看來是不合適的
*** 類型推導
    1. 類型推導變得有趣而有用
       當且僅當 函數是一等公民的時候
       但是在蟬語中 作爲一等公民的函數
       是在實現了鏈表處理之後
       利用鏈表處理來實現的
    2. 也就是說在蟬語的核心部分的基礎上
       可以構建起各種計算系統
       比如 lambda-calculus 和 digrap
*** 初始化
    1. 在定義一個數據類型的時候
       必須指定一個用來初始化一個這個類型的數據的函數
       這個函數可能有參數 比如 對 詞 這個數據類型來說就是如此
       而也可能沒有參數 比如對與 cons 來說就是如此
       這個用來初始化數據的函數
       可以從棧中 cons 的數組中取 內存
       也可以從詞典中取內存 或者從數據段中取 內存
       - 比如編撰一個詞到詞典中的過程就是如此
       這樣就解決了 靜態的動態的問題
       並且 原子性的數字類型的量是在 參數棧中去內存的
    2. 可以發現 從語法的角度看
       對 上面的三種類型的 數據的初始化
       是非常不同的
       1) : kkk 1 2 3 . . . Exit ; define-function
          此時有一個名字被分配給了這個對象
          參數棧 中沒有留下東西
       2) cons
          此時沒有名字
          參數棧 中有地址
       3) 7
          此時沒有名字
          參數棧 中有值
*** 多餘的信息
    1. 儘管於一個帶有類型的量來說
       當它被入棧的時候一個類型標籤已將被入棧了
       但是我還是要求
       如果這個量是非原子性的量
       那麼它的地址下面就一定要有一個域用來儲存類型
*** 對別名的支持
    1. 詞典中的同一個定義
       應該能夠擁有兩個名字 這樣 英文 漢文 異體字 就方便多了
       這樣在詞典這個數據結構中 單向鏈接的鏈表的功能就喪失了
       因爲沒法依據這個鏈表來查找詞了
       這個功能本身我也沒用過
       也許我應該好好設計然後在取實現
       這樣就能有個大局觀
*** 實現
    1. 在開始實現基本的 名詞和動詞之時
       需要很多基礎設施
    2. 類型系統需要用更豐富的數據結構來實現了
       並且在實現它的時候還沒有類型系統
*** 術語
    1. 型[type] 類[class]
       結構[structure] 範疇[category]
       我應該如何使用這些術語呢 ?
    2. 目前我只使用 型[type] 這個術語
       用來表示一個具體的數學結構
** 具體
*** 符號
*** 詞
    #+begin_src cicada
    夫 詞 者 型也
       名
       大小
       標識
       性
       詮釋者
       定義
    #+end_src
*** 詞典
    #+begin_src cicada
    夫 詞典 者 型也
       名
       大小
    (* 一個數組 數組中的每個元素是 詞 *)
    #+end_src
*** 棧
*** 整數
*** 八位組
*** 字
*** 八位組串
    #+begin_src cicada
    八位組串
      蟬語者說
    ------------
    #+end_src
*** 單鏈
    #+begin_src cicada
    (* bra-ket *)
    { Mark-McGwire Sammy-Sosa Ken-Griffey }

    (* indentation *)
    ======
    - Mark-McGwire
    - Sammy-Sosa
    - Ken-Griffey
    ======
    #+end_src
*** 雙鏈
    #+begin_src cicada
    (* bra-ket *)
    [ Mark-McGwire Sammy-Sosa Ken-Griffey ]

    (* indentation *)
    ======
    * Mark-McGwire
    * Sammy-Sosa
    * Ken-Griffey
    ======
    #+end_src
*** 名鏈
    #+begin_src cicada
    (* bra-ket *)
    ( :hr 65 :avg 0.278 :rbi 147 )

    (* indentation *)
    ======
    :hr 65
    :avg 0.278
    :rbi 147
    ======


    ( :american
        Boston Detroit New-York
      :national
        New-York Chicago Atlanta )

    ======
    :american
      - Boston
      - Detroit
      - New-York
    :national
      - New-York
      - Chicago
      - Atlanta
    ------
    :1 "-" for list element
    :2 "*" for dali element
    :3 ":" for wodi (* wodili element *)
    ======
    #+end_src
* ==================================================
* 計算
** 木答演算 [lambda-calculus]
** 有向圖處理 [digrap]
* ==================================================
