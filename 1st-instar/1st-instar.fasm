include "../include/linux-header.inc"
format elf64 executable 3
entry begin_to_interpret_threaded_code
segment readable executable writeable
;; in fasm, "dup" is a reserved word
dup equ duplicate
bead_size = 8 ;; (byte)
xx equ dq
;; if you want to extend cicada in assembly,
;; the following registers must not be used
;; =================================
define pointer$argument_stack   r15
define pointer$return_stack     r14
;; =================================

macro push_argument_stack register {
   mov [pointer$argument_stack], register
   add pointer$argument_stack, bead_size
   }
macro pop_argument_stack register {
   sub pointer$argument_stack, bead_size
   mov register, [pointer$argument_stack]
   }

macro push_return_stack register {
   mov [pointer$return_stack], register
   add pointer$return_stack, bead_size
   }
macro pop_return_stack register {
   sub pointer$return_stack, bead_size
   mov register, [pointer$return_stack]
   }
current_free_address$un_initialized_memory = address$un_initialized_memory

labeling  equ = current_free_address$un_initialized_memory
preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
current_free_address$primitive_string_heap = address$primitive_string_heap
exit = 0
macro next {
   ;; 1. 移動 return_stack 中的第一串珠珠一次
   ;; 2. 如果 遇到珠珠的末尾
   ;;         把這串珠珠抽出
   ;;    否則 不抽出
   ;; 3. 去尋求被移出的一顆珠的意義
local at_the_end_of_jojo
   pop_return_stack rbx
   mov rax, qword[rbx] ;; 記錄被移出的一顆珠
   add rbx, bead_size
   cmp dword[rbx], exit
   je at_the_end_of_jojo
   push_return_stack rbx ;; 把珠珠放回 就代表不抽出
at_the_end_of_jojo:
   ;; 去尋求被移出的一顆珠的意義
   ;; 因爲 對其意義的詮釋方式 被記錄在其地址下
   ;; 所以需要一次 間接跳
   ;; 跳過去之後 rax 保存的是被移出的一顆珠
   jmp qword[rax]
   }
;; initial link to point to 0 (as null)
link = 0
JO_TYPE__function = 0
JO_TYPE__primitive_function = 1
JO_TYPE__variable = 2
macro make_name_string string {

virtual at 0
.start$string:
   db string
.end$string:
   dd (.end$string - .start$string)
   load .length word from (.end$string)
end virtual
store word .length at (current_free_address$primitive_string_heap)

current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

repeat .length
   virtual at 0
      db string
      load .char byte from (% - 1)
   end virtual
   store byte .char at (current_free_address$primitive_string_heap)
   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
end repeat

}
macro define_function string, jo {

define_function__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

type__#jo:
   xx JO_TYPE__function

jo:
   xx explain$function

   ;; 後面跟着作爲 function 的函數體的一串珠珠

   }
macro define_primitive_function string, jo {

define_primitive_function__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

type__#jo:
   xx JO_TYPE__primitive_function

jo:
   xx assembly_code__#jo

assembly_code__#jo:
   ;; 後面跟着作爲 primitive_function 的函數體的匯編代碼

   }
macro define_variable string, jo {

define_variable__#jo:

name__#jo:
   xx current_free_address$primitive_string_heap

   make_name_string string

link__#jo:
   xx link
   link = link__#jo

type__#jo:
   xx JO_TYPE__primitive_function

jo:
   xx explain$variable

   ;; 後面跟着作爲 全局變元之值的 bead_size 大小的數值
   ;; 只能有一個值

   }
size$primitive_string_heap = 100 * 1024 ;; (byte)

address$primitive_string_heap:
   times size$primitive_string_heap db 0
explain$function:
   add rax, bead_size
   push_return_stack rax
   next
explain$variable:
   add rax, bead_size
   mov rbx, [rax]
   push_argument_stack rbx
   next
begin_to_interpret_threaded_code:

   cld ;; set DF = 0, then rsi and rdi are incremented

   mov pointer$argument_stack,  address$argument_stack
   mov pointer$return_stack,    address$return_stack

   mov rax, first_jojo
   push_return_stack rax
   next

first_jojo:
   xx little_test
address$argument_stack labeling
   preserve 1024 * 1024 * bead_size
address$return_stack labeling
   preserve 1024 * 1024 * bead_size
define_function "little_test", little_test
   xx V__little_test_number
   xx exit_with_TOS
   xx exit

define_variable "*little-test-number*", V__little_test_number
   xx 7

define_primitive_function "exit-with-TOS", exit_with_TOS
   pop_argument_stack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall
size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

segment readable writeable
address$un_initialized_memory:
    rb size$un_initialized_memory
