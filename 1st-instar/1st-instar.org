#+TITLE:  1st-instar of cicada-nymph
#+AUTHOR: 謝宇恆 / XIE Yuheng
#+EMAIL:  xyheme@gmail.com

* todo
* ===================================
* note notation
** jo & jojo
   * use "jo" to denote bead
     and use "jojo" to denote a thread of beads
     [which reads like "珠珠" in Chinese]
** naming convention in assembly code
   1. using underline to compose big word from small words
   2. using "$" as prefix and postfix separator
   3. for jo name
      * prefix "V__" for variable
** naming convention in cicada-nymph code
   1. for jo name
      [maybe]
      * borderfix "*" for variable
      * borderfix "+" for constant
* -----------------------------------
* prolog
** include linux header
   #+begin_src fasm :tangle 1st-instar.fasm
   include "../include/linux-header.inc"
   #+end_src
** format header
   #+begin_src fasm :tangle 1st-instar.fasm
   format elf64 executable 3
   #+end_src
** entry
   #+begin_src fasm :tangle 1st-instar.fasm
   entry begin_to_interpret_threaded_code
   segment readable executable writeable
   #+end_src
* -----------------------------------
* macro
** misc
   #+begin_src fasm :tangle 1st-instar.fasm
   ;; in fasm, "dup" is a reserved word
   dup equ duplicate
   #+end_src
** bead_size
   * 64-bits
   #+begin_src fasm :tangle 1st-instar.fasm
   bead_size = 8 ;; (byte)
   xx equ dq
   #+end_src
** argument_stack & return_stack
   * when doing "push"
     a stack-pointer moves to lower address
   * note that another style is that
     when doing "push"
     a stack-pointer moves to higher address
   * the stack-pointer
     always stores the address of current-free-address of the stack
   * note that another style is that
     under the stack-pointer
     there always stores the value of the-top-of-the-stack
   #+begin_src fasm :tangle 1st-instar.fasm
   ;; if you want to extend cicada in assembly,
   ;; the following registers must not be used
   ;; =================================
   define pointer$argument_stack   r15
   define pointer$return_stack     r14
   ;; =================================

   macro push_argument_stack register {
      mov [pointer$argument_stack], register
      add pointer$argument_stack, bead_size
      }
   macro pop_argument_stack register {
      sub pointer$argument_stack, bead_size
      mov register, [pointer$argument_stack]
      }

   macro push_return_stack register {
      mov [pointer$return_stack], register
      add pointer$return_stack, bead_size
      }
   macro pop_return_stack register {
      sub pointer$return_stack, bead_size
      mov register, [pointer$return_stack]
      }
   #+end_src
** memory allocation in un_initialized_memory
   * implemented as a memory map
   #+begin_src fasm :tangle 1st-instar.fasm
   current_free_address$un_initialized_memory = address$un_initialized_memory

   labeling  equ = current_free_address$un_initialized_memory
   preserve  equ current_free_address$un_initialized_memory = current_free_address$un_initialized_memory +
   #+end_src
** current_free_address$primitive_string_heap
   #+begin_src fasm :tangle 1st-instar.fasm
   current_free_address$primitive_string_heap = address$primitive_string_heap
   #+end_src
** exit
   #+begin_src fasm :tangle 1st-instar.fasm
   exit = 0
   #+end_src
** next
   #+begin_src fasm :tangle 1st-instar.fasm
   macro next {
      ;; 1. 移動 return_stack 中的第一串珠珠一次
      ;; 2. 如果 遇到珠珠的末尾
      ;;         把這串珠珠抽出
      ;;    否則 不抽出
      ;; 3. 去尋求被移出的一顆珠的意義
   local at_the_end_of_jojo
      pop_return_stack rbx
      mov rax, qword[rbx] ;; 記錄被移出的一顆珠
      add rbx, bead_size
      cmp dword[rbx], exit
      je at_the_end_of_jojo
      push_return_stack rbx ;; 把珠珠放回 就代表不抽出
   at_the_end_of_jojo:
      ;; 去尋求被移出的一顆珠的意義
      ;; 因爲 對其意義的詮釋方式 被記錄在其地址下
      ;; 所以需要一次 間接跳
      ;; 跳過去之後 rax 保存的是被移出的一顆珠
      jmp qword[rax]
      }
   #+end_src
** link
   #+begin_src fasm :tangle 1st-instar.fasm
   ;; initial link to point to 0 (as null)
   link = 0
   #+end_src
** JO_TYPE encoding
   #+begin_src fasm :tangle 1st-instar.fasm
   JO_TYPE__function = 0
   JO_TYPE__primitive_function = 1
   JO_TYPE__variable = 2
   #+end_src
** make_name_string
   * 2 bytes for length of name_string
   * note that
     the following is using local label
   #+begin_src fasm :tangle 1st-instar.fasm
   macro make_name_string string {

   virtual at 0
   .start$string:
      db string
   .end$string:
      dd (.end$string - .start$string)
      load .length word from (.end$string)
   end virtual
   store word .length at (current_free_address$primitive_string_heap)

   current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 2

   repeat .length
     virtual at 0
        db string
        load .char byte from (% - 1)
     end virtual
     store byte .char at (current_free_address$primitive_string_heap)
     current_free_address$primitive_string_heap = current_free_address$primitive_string_heap + 1
   end repeat

   }
   #+end_src
** define_function
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_function string, jo {

   define_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   type__#jo:
      xx JO_TYPE__function

   jo:
      xx explain$function

      ;; 後面跟着作爲 function 的函數體的一串珠珠

      }
   #+end_src
** define_primitive_function
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_primitive_function string, jo {

   define_primitive_function__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   type__#jo:
      xx JO_TYPE__primitive_function

   jo:
      xx assembly_code__#jo

   assembly_code__#jo:
      ;; 後面跟着作爲 primitive_function 的函數體的匯編代碼

      }
   #+end_src
** define_variable
   * no constant
     only variable
   * when a variable jo in the jojo
     it push the value of the variable to argument_stack
   * when wish to change a variable's value
     use key_word "address" to get the address of the variable
   #+begin_src fasm :tangle 1st-instar.fasm
   macro define_variable string, jo {

   define_variable__#jo:

   name__#jo:
      xx current_free_address$primitive_string_heap

      make_name_string string

   link__#jo:
      xx link
      link = link__#jo

   type__#jo:
      xx JO_TYPE__primitive_function

   jo:
      xx explain$variable

      ;; 後面跟着作爲 全局變元之值的 bead_size 大小的數值
      ;; 只能有一個值

      }
   #+end_src
* -----------------------------------
* primitive_string_heap
  #+begin_src fasm :tangle 1st-instar.fasm
  size$primitive_string_heap = 100 * 1024 ;; (byte)
  address$primitive_string_heap:
     times size$primitive_string_heap db 0
  #+end_src
* jo
** note explain
   * 尋求珠之意義
   * 注意
     每次經由 next 間接跳
     到這裏的詮釋者的時候
     rax 都保存着珠的值
     所以 rax 這個寄存器會被作爲某些詮釋者的參數
** explain$function
   * 把由這個 function 類型的 珠
     所找到的 一串珠珠 入 return_stack
   * a jojo can not be of size 0 or 1
   * use rax as an argument
     which stores a jo
   #+begin_src fasm :tangle 1st-instar.fasm
   explain$function:
      add rax, bead_size
      push_return_stack rax
      next
   #+end_src
** explain$variable
   #+begin_src fasm :tangle 1st-instar.fasm
   explain$variable:
      add rax, bead_size
      mov rbx, [rax]
      push_argument_stack rbx
      next
   #+end_src
* begin_to_interpret_threaded_code
  #+begin_src fasm :tangle 1st-instar.fasm
  begin_to_interpret_threaded_code:

     cld ;; set DF = 0, then rsi and rdi are incremented

     mov pointer$argument_stack,  address$argument_stack
     mov pointer$return_stack,    address$return_stack

     mov rax, first_jojo
     push_return_stack rax
     next

  first_jojo:
     xx little_test
  #+end_src
* argument_stack
** memory allocation
   #+begin_src fasm :tangle 1st-instar.fasm
   address$argument_stack labeling
      preserve 1024 * 1024 * bead_size
   #+end_src
* return_stack
** memory allocation
   #+begin_src fasm :tangle 1st-instar.fasm
   address$return_stack labeling
      preserve 1024 * 1024 * bead_size
   #+end_src
* little_test
  #+begin_src fasm :tangle 1st-instar.fasm
  define_function "little_test", little_test
    xx V__ak
    xx exit_with_TOS
    xx exit

  define_variable "47", V__ak
    xx 47

  define_primitive_function "exit-with-TOS", exit_with_TOS
      pop_argument_stack sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall
  #+end_src
* -----------------------------------
* epilog
** un_initialized_memory
   #+begin_src fasm :tangle 1st-instar.fasm
   size$un_initialized_memory = 64 * 1024 * 1024 ;; (byte)

   segment readable writeable
   address$un_initialized_memory:
       rb size$un_initialized_memory
   #+end_src
* ===================================
