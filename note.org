#+TITLE: note about cicada project
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


1. 通过 引入 address 这个语法关键词
   我就可以统一 define 的使用了
   将 只有 单一的 define 没有别的 东西了
   ><><>< 注意 ><><><
   这里要更改跟 GC 有关的代码
2. 新的 define 还有一个问题是
   每个名词 可以给出 几个值到 Argument-stack
   是不确定的
   这是可以接受的
   就像是 对函数的注释 一样
   只要给 对名词的定义 相应的注释就行了
   并且 之后 还可以用 设计良好的 文本 编辑器 来解决这个问题
3. 每个 名词 都有固定个数的 Cell
   define-constant-string 也将没消除了
   也就是说 在汇编代码中 也需要使用 具有可变长度的 名词
   也就是说 相关的 macro 应该被重写了
   我正好可以改一下 macro 的命名
----------------------------------
1. the whole english-core.org needs to be rewrited
2. group the functions into groups
   and write more tests for them
3. make good use of indentation
   1) for string
   2) for wodili 应该 在 wodili 的已有的 解析器 的基础上
      增加一个 好好 利用 indentation 的解析器
      两种解析器各自有各自的用处
   3) 把 利用"支撑树" 来进行相对引用的 性质加到 yaml 中
      就能 形成 我想要的 digrap 的语法
4. redesign the syntax about chars
   to allow :
   1) 不可打印的字符 还有 关于 utf8 的东西
5. redesign the syntax about strings
   to allow :
   1. 格式输入
   2. 当然允许在函数体内使用简单的字符串了
      因为现在一切都是函数体了
6. 写编译器
   1) 从最简单 的 babystep 开始
   2) 编译 bootloader
   3) 注意要保持设计的灵活性
      或者直接从 文档开始
      用中文写文档 以加快速度
* ==================================================
* TODO
** note
   1. erlang 的 bit syntax 在于让人方便地处理 bit fields
      这在于 能 用模式匹配
   2. 不能统一命名规则 是一件很烦人的事
      也许 在有自己的汇编器之前
      我应该 用 ocaml 写一个简单的 编译器
   3. ><><>< 也许 我现在 就应该 试着实现 对 函数性质 的 询问器
   4. 关于 linux下 图形界面 的 文本编辑器
      因为我已经能把 动态链接的库加载到 cicada 中了
      所以是有可能实现的
      需要用 C 把某先函数包装好
      在 cicada 中调用 C 函数的时候需要保护跟栈 有关的寄存器
   5. 完成编译器后实现 hash-table 的 dictionary
   6. it also feels fun
      to reimplement some UNIX userland functions :)
   7. 比如 当同时考虑 整数 还有 实数 等等 数据类型的时候
      面向对象的 节省命名空间 的优点 就充分地体现出来了
      这在于 (也只在于) 这样写出来的 代码
      更接近于人们日常对数学运算的模糊表达
   8. 需要好好 分析一下 增加了 Lambda-stack 之后
      整个系统的数学性质的变化
      因为 感觉上 太帅了
      好像 增加了一个维度
      好像 走出了柏拉图的洞穴一样
   9. as the "debuger" is defined in cicada code
      it is hard to do good error handling in assembly code
      这是因为我没法在出错的时候即使调用 debuger 来报错
      - 比如 通常的函数类型的错误
        我应该 及时的 调用 debuger 来报告错误
        而在不利的条件下 我必须 返回一个出错码
        来表示函数 所接受的数据类型不对
   10. 需要 cicada-assembler 的理由:
       1) 统一 命名规则
       2) 让我 能够探索一些关于编译的技术
       3) 有些 小的 CPU 并没有 类似 fasm 的 合适的编译器的
          当我有 cicada-assembler 的时候
          我就能不受限制于这个事实了
       4) 当我调整代码的结构
          以让我方便地 维护两个汇编版本的时候
          我就发现 其中有很多重复的部分
          想要消除这些重复
          我可以通过 更多的 把文件 分开来实现
          但是如果我想保持
          我的 类文学编程 组织代码的风格的话
          也许 创造一些新的东西来支持 我的风格就是必须的了
   11. 不需要 cicada-assembler 的理由:
       1) 一个人认为 一个语言需要这种东西
          可能只是因为 当这个语言的编译器能够自己编译自己的时候
          看起来很 cool 而已
       2) 为了 实现 一个 x86-64 的汇编器
          有太多的 关于 CPU 的底层细节需要 被掌握
   12. 就用户接口的设计而言
       我可以把那几个 核心的栈 的图示 放在 左边的一个窗口里
       在这之后 我就能设计 debuger 的更好的使用方式
       但是一个问题是 当我的界面不再是一个简单的解释器的时候
       我就不能 直接利用 emacs 了
       也就是必须 要先写自己的 文本编辑器
       之后才能考虑窗口 之类的问题
   13. 也许 可以从 isforth 那里 学习在 linux 下写文本编辑器的基本工作
   14. 生成中文字典 交给 Recaler
   15. 支持 windows 及其环境下的开发
   16. 支持 Mac 及其环境下的开发
** about decision
   1. 每当一个设计决策的
      1. 选项一:
         会导致更多的新试验
         并且有可能让他做更多的设计决策
      2. 选项二:
         会让设计者走向更传统而有章法可循的实现
      这个时候正常的设计者就倾向于选项二
      这就是为什么人们想要
      模块系统 代码复用 等等语言性状
      对于对复杂性的控制而言 这些性状其实都不是本质的
   2. 我选择做非正常的设计者
      就算我发现一个设计决策可能会让我重写很多的代码
      经过客观而细致的评价之后
      只要这个决策是好的
      我依然会作出这个决策
   3. 正常的设计者所做的决策 可以被归结为 "非理性的决策"
      我发现在生活中的某些方面我也在做着许多的 "非理性的决策"
   4. 启示是
      每次做决策的时候 都要清楚地明白 "非理性的决策" 的存在
      那是人性的弱点
   5. 如果我想为我的语言做广告
      我可以做一个对比 来展示
      我的语言 在各个小的方面
      是如何优越于 其他它的各种语言的相应方面的
** about foundation
   1. 我可以基于现在的信息技术
      设计一种新的组织结构
      来形成决策
      让每个人都能参与进来
   2. 我可以通过展示这种新的组织结构的可行性
      来打破 人们对政治的 "不参与" 态度
      还有 "无以参与" 的状态
   3. 其实我明白
      如果真的想在现实的政治世界改变这种现象
      必须有一场革命才行
   4. 也许 foundation 这个词并不适用来描述这样的组织
      我应该寻求一个新的词
      来给人以 "异" 感
   5. 我需要选举
      但是 代表人 与 选民 之间
      可以通过 我所掌握的信息技术形成更有效的对话
      我所要设计的新的体制
      就是要保证这种对话的通畅
      不要让 "人民代表大会" 这种可笑的东西产生
   6. 常会的进程和项目计划的提出
      将用最简介易懂的语言表达于公开的媒体上
      并且有机制能够保证
      选民对这些公开的信息的反馈能够听到
   7. 但是其实这种组织只有在政治世界才能有效
      因为 要知道
      一个公司的目标是盈利
      一个 NPO 就算以别的理想为目标
      在这类组织中 不能形成 可以类比政治选民的人群
** the right thing
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      这是就已经实现的部分而言的
      指必须没有bug
      当没有达到 Completeness 时
      没有实现的部分 比如某些特里的处理 就不被考虑在内
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      这是因为 一致性 就表明了设计本身的优良
      从长远的角度看来 一致性 是最有价值的
** 关于 错误处理
   1. 有两种 错误处理机制在 cicada 中被使用了)
      1 一种是 在出错的时候当场 调用 debuger
      2) 一种是 在出错的时候返回 出错码
   2. 第一种是 lisp 的 REPL 中常用的方法
      第二种是 C 和 UNIX 中被系统使用了的方法
   3. 以第一用方式实现的函数的特点是:
      尽早地 报告错误就能把错误报告的更详尽
      并且给 用户 当场更改错误的机会
   4. 以第二用方式实现的函数的特点是:
      可以一致 的方式 允许错误的出现
      典型的 场合是 对 number 的 parsing 错误
   ----------------------------------
   但是这两种 处理方式 又可以 相互实现对方的好的性状:
   1. 第一种的好的性状之一是 可以把错误报告的更详细
      第二种风格的函数 只要不要 返回出错码
      而 返回更丰富的数据结构 来报告错误就 也能达到这种效果
   2.
   3.
* ==================================================
* english-core
** TODO
   1. use hash-table to lookup dictionary
      then mutually recursive call
   2. 用hash-table来find
      这些不必实现在汇编代码中
      因为 list还是必要的
      因为这样就能保持对字典的灵活控制
      所以 需要写一些函数把
      字典重新加载到 hash-table 中
   3. need to redesign the way to do test
      should tangle test to separated file
      for i do not have my org-mode now
   4. wodyli processing
      then digrap in cicada
   5. tab completion in the REPL
      (or in text editor)
   6. let functions in assembly-code
      be able to call functions in cicada-style-assembly-code
   7. >< 实现对多种实现技术的定制
   8. >< 重新思考某些术语和命名方式
   9. cicada should design it's own abstractions of IO
      this can help cicada to be portable
      现在 有的只是 read-char 和 write-char 两个基础的东西而已
      这样太贫乏了
   10. memory allocation
   11. flow-point number
   12. >< maybe substitute word to execute in lambda-body
   13. >< maybe syntax-check
   14. >< modern pattern-match  HOW ???
   15. better interface for debuger
   16. TAIL-CALL-OPTIMIZATION in apply lambda-body
   17. more protection on allocated memory
       maybe use paging
   18. cicada-assembler
   19. cicada-editor
   20. APL-like array-processing
   21. needs better sexp-reader&write
       design a better way
       to use local-label to from list-with-circuit
** TEN COMMANDMENTS OF CICADA
   1. you can break any commandment when necessary
   2. ``The whole point of Forth was that
      you didn't write programs in Forth
      you wrote vocabularies in Forth.
      When you devised an application
      you wrote a hundred words or so that discussed the application
      and you used those hundred words
      to write a one line definition to solve the application.
      It is not easy to find those hundred words,
      but they exist,
      they always exist.''
** 以名释性
   (string-reference <string> <index>)
   (string-compare <string1> <string2>)
   (string-append <string1> <string2>)
   发现命名是一个问题
   每个动词比如compare
   可以是 string-compare 或 list-compare
   这就要求在命名上给每个函数加上数据类型的前缀
   作为特殊的前缀
   也许应该用 string:compare 而不是 string-compare
   这种看来劳神的前缀的需要是因为
   我不允许函数名的重载
   如果我统一这种对数据类型前缀的使用
   那么 动态类型的量 和 非动态类型的量
   之间命名规则的冲突也就被化解了
   也许 string-append 应该被叫做 string:^_^
   就像 ^_^ 在 dalin 中的效果一样
   但是这两种函数之间又有区别
   重要的区别是
   他们是返回新的数据还是在原来数据的基础上做副作用
   我还可以用对命名函数的约定来
   让函数的名字体现更多的函数的性质
   也就是说 cicada 的一个特点是
   ``以名释性''
   这是实现起来最简单的
   但是需要设计良好的命名规则
   在给函数取名字的时候
   写代码的人也要花一些功夫思考
   才能让这个名字恰当地体现函数的性质
   同时最重要的是
   这种方案
   可以在最大程度上减轻人们在读代码的时候的
   认知上的负担
   ------------------
   但是有一些重要的函数比如 write
   还是需要取处理不同类型的量
** about bra-ket
   1. 以个 REPL 的性质很像是 bra-ket 中的 一个 bra
      symbol-REPL 作为 bra
      所对应的 ket 可以是 bye,symbol-REPL
   2. 各个 REPL 和 bra 之间
      必须能够灵活的相互递归调用
      我没能实现很好的机制来完成这一点
   3. 并且我现在应该把 REPL 和 bra-ket 的实现方式统一起来
      我以前并没有意识到它们是完全相同的东西
      它们之前确实有区别
      但是我应该把它们的共同点提取出来
      >< 这种``对共同点的提取''
      用函数的 factoring 做起来
      和用 class 的继承做起来 相比
      感觉有什么不同 ???
** IDE
   另外还有 IDE
   通过语法高亮和 mimi-buffer
   来帮助代码的阅读者来
   获知名词和动词的语义
   与命名规则一样
   这一切都是为了
   减轻``代码的阅读者的认知上的负担''
** the naming conventions in cicada
   回顾一下 cicada 中现在所使用的命名规则
   做一个系统的笔记
   这也将方便将来文档的撰写
   1. 首先是关于 primitive functions
      它们的命名都是简单的用"-"来连词的
      尽管这里也有类似数据类型的概念
      比如string[address, length]
      没有复杂的跟类型有关的前缀
   2. 也就是说"-"是用来把单个的word链接成短语的
   3. 而在 basic 中
      还用到了","
      它是用来把短语链接成短句的
      比如 ``define-variable,by-string''
      在这个例子中 ``by-string'' 表明了
      这个函数的参数的数据类型
   4. ":"被用作前缀的链接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大写表明他们是名词性的
      这些常量或变量前缀单单指明了
      这个名词的功能
      而没有指明这个名词的实现细节
      >< 这种特性是好的吗?
      这是好的 如果 人们总能简单地从这些描述特性的词中推测出这些名词的实现细节
      这是不好的 如果 这种推测并不平凡和简单 而带来了额外的认知上的负担
   5. 对名词而言
      第一个简单的跟类型无关的描述函数功能的前缀是"help:"
      也就是说前缀的使用方式是相当自由的
      >< 我不应该做更细致的标准式来削弱这种自由性吗?
   6. 前缀是可以有多个的
      比如"help:string:copy"
** about programming paradigms
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特点是这样的模型非常节省用来定义函数的命名空间
     这样是以数据结构为中心的
     函数 (算法或对数据结构的处理过程) 在思想观念上的重要性 屈居次位
     这是在尝试
     让我们的编程行为适应我们对这个世界的最通俗的非结构化的理解
     我们能够辨别我们在这个世界上所观察到的各种物体(对象)
     并且我们总在以某种方式与这些对象交流
     每个对象是一个内蕴的独立的个体
     并且在我们的观察过程中
     我们给对象分类
     分类在这里其实是不重要的
     - 这是因为分类不是一个系统的方法
       分类的过程可以是相当任意的
       不同的分类者 去分类 同一个对象的集合时
       按照他们的理解方式的不同 他们会作出不同的分类
       看看生物学就知道了
     重要的是每个内蕴的个体
   - functional
     computation should be viewed as functions act on their arguments
     并且这些函数的行为 要具有数学意义上的函数的某些重要特性
     这是以算法为中心的
     这是在尝试
     用我们的数学知识来帮助我们编程
     而数学代表了我们对这个世界的结构化的理解
     我们观察这个世界
     然后用数学的语言还有数学的方法论总结我们的观察结果
     如果 说数学的方法论是"纯粹客观的" 太过有争议
     那么 说这种方法论相比较与其他的编程范式更加具有客观性
     是没有错的
** object-oriented
   其实 利用 list-processing 我可以在 cicada 中加入对 object-oriented (class and message-passing) 的支持
   正如 我用 list-processing 来实现 lambda-calculus 一样
   并且我想 object-oriented 这种编程范式也许更适合用来实现 digrap
   但是 问题是 新的语法元素必须被引进
   这也许可以通过写一个不同的 REPL 来实现
* ==================================================
* baremetal
** TODO
   1. 作为一个使用纯粹释性语言
      我应该 重新 思考 对 公共的 函数库的使用方式
   2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
   3. SMP support
      作为一个以栈为基础的语言
      我应该重新思考 利用 多核 的方式
   4. learn more from baremetal-OS
   5. convert the code about storage & BMFS from old-asm to forth-like-asm
      to examine the bug of "readsectors"
   6. fix "bye"
   7. design game-like UI in text mode
   8. rewrite cicada to make it standard and portable
      (this will always be TODO)
** TEN COMMANDMENTS OF ASSEMBLY
   1. you can break any commandment when necessary
   2. when you want to use a ``Const'' or a ``Var'' in assembly
      use it as the following example:
      - define a Const:
        defConst "LinuxProgramHeaderAddress", 0, LinuxProgramHeaderAddress
      - use a Const:
        mov [LinuxProgramHeaderAddress + CellWidth], rsp
      - define a Var:
        defVar "Here",  0, Here
      - use a Var:
        mov [Here + CellWidth], TemporaryRegister
   3. when you want to expose a label defined in assembly to cicada
      do it as the following example:
      defConst "UserDataArea", UserDataArea, TheUserDataArea
** about the structure of the code
   1. 汇编代码所实现的是一个 可扩展的虚拟机
      代码 可以分为4部分 :
      1) 初始化CPU和硬件的代码
      2) 基本的 从CPU所提供的汇编指令集中
         提取出来的 ``primitive functions''
      3) 关于基本输入输出的
         这一部分用来形成REPL
      4) 关于函数定义的
         这一部分用来实现在解释器中对函数的编译
   2. 我需要按照上面的分类
      来重新组织代码的结构
      并且形成一个这个``可扩展的虚拟机''的标准
      并且形成一个统一的接口用来实现上面的"3.4."这两部分
      这些都是为了今后 向其他硬件移植而做准备的
      当然
      同时也是为了让代码的宏观的逻辑结构更清晰
* linux
** TODO
   1. to allow executables to dynamically access external functionality at run time
      and thereby reduce their overall memory footprint
      在我的操作系统中 我可以以我的方式来完成上面的这种特性
      我只需要一个 "need" 函数 来声明 某段被解释的代码 所需要的 sub-dictionary
      我还需要一些 处理 sub-dictionary 的函数
      sub-dictionary 的性质 是 :
      - 它可以有很多个
      - 并且它所占用的 内存可以被回收的
      - 内存的回收 可以用 类似字符串的 垃圾回收器 来完成
      - 当全面地使用 hash 来实现 dictionary 时
        内存的回收 也可以用 类似链表的 垃圾回收器 来完成
** note
   1. 在写一个文本编辑器之前
      我不得不以linux为自己的工作环境
      1) 利用 emacs
         我可以快速地测试 language-cores
      2) 利用 linux 中的图形环境 和 中文字体
         我可以 继续研究 蝉语的中文语法
* windows
* ==================================================
