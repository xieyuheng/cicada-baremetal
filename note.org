#+TITLE: note about cicada project
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


1. 从 input 读取 string 的工作
   全部由 渐进编译器 完成
   这可以被看作一次 factoring
   渐进编译器 需要做的是
   1) 不断的读字符串
      判断什么时候应该停止读取
   2) 停止读字符串之后
      就调用 compiler 然后 马上 call 被编译好的函数
2. add data section of function
   之后才能实现按 ":" 这个语法关键词
   #+begin_src cicada
   : kkk
     1 2 3 . . .
       : aaa
         4 5 6 . . .
         Exit
       ; define-function
     aaa
     Exit
   ; define-function

   每次调用到 kkk 的时候 都会重新编译一个 aaa 到字典中

   编译的结果是:
   可以发现 同对 lambda 的处理一样 还是几乎线性的

   _literal 1
   _literal 2
   _literal 3
   . . .
     <string[address, length]>
     define-function
   aaa
   Exit

   string:
   aaa
   4 5 6 . . .
   Exit
   ---------
   #+end_src
3. let the interpreter works as a compiler
4. move "if else then" to assembly code
5. new string syntax
6. new way to use variables
7. change naming convention in assembly code
8. clean up code and note
* ==================================================
* TODO
** note
   1. 好好复习一下 forth 的各种 thread 技术
   2. 保留老的 REPL
      重写 语法编撰者
      实现数据段 以允许嵌套的 函数定义
      1) 用来给出数据段的 语法关键词的实现 必须具有可扩展性
         这可能就要求我把 它们实现为一类特殊的 word 的类型
         word 中确实还有一个 type field (一个64-bits) 没用呢
      2) 数据段 必须跟在函数体的后面
         这要求 在需要编写数据段的时候
         必须计算到函数体的末端的距离
         也可以先把需要填写地址的点空下来
         在编译完函数体 并得到函数体末端的地址之后
         再把空下来的地方填上
      3) 很容易在数据段中处理字符串
         但是其他涉及到 GC 的数据类型可能就有问题了
         我可以先忽略这一点
         限制这些数据类型在函数体中的使用
         之后再补充对这些问题的处理
      4) 考虑到之后的编译器
         就知道
         数据段的使用一定是必要
      5) 对于嵌套在函数体中的字符串的处理
         eval 变成了 compile & call
         这就要求为 compile & call 而分出来的内存
         必须是用栈来处理的
   3. 用一个新的语法关键词 来处理常量与变量 这两种名词对语义的过载
      就像 literal 一样 这是很容易在 函数体中实现的
      但是在 REPL 中却没有这种机制
      特殊的语法关键词 不能在 REPL 中调用
      应该保护它们
      目前 特殊的语法关键词 在函数体中是被当作标记来使用的
   4. 如果想要在 REPL 中使用这些特殊的语法关键词
      那么 在编译语义和解释语义之间
      就一定要用 两种不同的方式来处理 它们
      address 是这样 if 和 branch 也是这样
      我应该去处理它们
      而不是为了"实现"的简单性而放弃在解释器中对它们的处理
   5. 当把 word-list 这个数据结构消除之后
      通过 引入 address 这个语法关键词
      我就可以统一 define 的使用了
      将 只有 单一的 define 没有别的 东西了
      1) ><><>< 注意
         这里要更改跟 GC 有关的代码
   6. 通过 引入 类似 address 的语法关键词
      我还能实现更多的的 有趣的效果
      1) 一个问题
         目前
         语法关键词 是解释器 统一处理的
         我不能很容易地像定义函数一样 定义一个新的 语法关键词
         也许 通过 好好利用 word 的类型
         我就能解决这个问题
      2) 我想这是很难的
         因为首先在解释语义和编译语义下对同一个语法关键词的添加
         就需要不同的处理方式
         如果想实现一般的添加语法关键词的方式
         就得在 基本的 用来实现 REPL 的函数
         还有 基本的 用来实现 编译语义 的函数 上面添加 hook
         需要维护一个全局的 语法关键词的表 来帮助这些函数
      3) 但是每个语法关键词还是需要被实现两遍
         除非我更改 解释器的运行方式
         使得每次在输入表达式的时候
         机器都统一地用编译语义来处理 表达式
         我想 很多语言的实现者正是以这种所谓的渐进编译的方法
         来实现解决这个问题的
      4) 如何实现呢?
         每一次的输入需要被当作一段函数来编译
         内存如何分配? 如何回收?
         以这种设计为基础 是否能引出有趣的性状
      5) 问题是在 REPL 中所输入的需要被解释的代码段
         通常是函数的定义
         如果要把这些代码段处理成函数
         那么最少有两个问题需要解决:
         1. 明显的 Exit 的问题
         2. 嵌套的函数体必须被处理
      6) 从这里也可以看出 ocaml 使用 ";;" 来标记表达式的原因
      7) REPL 的名字也应该变了
         read compile call loop
         注意这里紧接着 compile 的 call
         而 一般的语法编撰者 只是 编译而已
      8) 嵌套 在内存的 函数定义
         必须以 string 的形式储存在 外层的函数的函数体内
         每次调用的时候 都通过 eval 一个 string 来重新定义一个新的函数
         但是 eval 已经被消除了 ????
         eval 就是编译然后调用
         没有 execute-word 也就没有 eval 了
      9) 嵌套的函数定义并不是没法处理
         毕竟我已经处理过 嵌套的 lambda-term 了
      10) 这样我是不是就形成了一种
          反向的
          具有劣质语法的
          lisp 方言 ????
      11) 还有一个问题就是
          我必须形成 有独立意义的
          可以被编译成函数的代码块 之后
          才能把这段代码提交给编译器去编译
          也就是说 在某些 reader 之中的时候
          代码块 是不会被提交的
          并不需要 新的 语法来标记 代码块
      12) 注意目前编译器所处理的已经是字符串了
      13) 这是极大的改变
          所有的东西都需要重新考虑了
      14) 语法编撰者 的参数是一个字符串
          这个字符串来自哪里并不重要
          在解释语义里 ":" 会把 代表函数体的字符串储存在一个 buffer 中
          而在渐进编译的 解释器中
          这些字符串 必须被 放到新分配的 静态内存中
          也就是说 函数体必须有自己的 数据段
          并且这些数据段是
          不能被垃圾回收器处理的 纯粹静态分配的 内存
      15) 关于渐进编译器的用户接口
          渐进编译器 可以维护一个匿名函数的 数组
          新定义的函数会替代最老的函数
          这样就给了引用前面的某个函数的机会
          还可以提供一些机制 来处理这个 匿名函数 的数组
      16) 渐进编译是可行的
          只要在每次 读入 代码段的时候
          补足一个 Exit 就行了
          明显的使用 Exit 就会在末尾多一个 Exit
          多一个并没有关系
          这样就 让用户可以在解释器中 输入复杂的代码段了
   ----------------------------------
   1. erlang 的 bit syntax 在于让人方便地处理 bit fields
      我可以利用 erlang 的 bit syntax
      来重新设计 cicada 中关于字符的语法
   2. 在更改核心语法 的时候 顺便把 字符串 的语法改了
      从 yaml 学可读性更强的语法
      并允许在函数体内使用简单的字符串
   3. redesign the syntax about chars (to allow ...)
      and strings (to allow ...)
   4. 不能统一命名空间 是一件很烦人的事
      也许 在有自己的汇编器之前
      我应该 用 ocaml 或 pearl 写一个简单的 编译器
   5. 新的 define 还有一个问题是
      每个名词 可以给出 几个值到 Argument-stack
      是不确定的
      这是可以接受的
      就像是 对函数的注释 一样
      只要给 对名词的定义 相应的注释就行了
      并且 之后 还可以用 设计良好的 文本 编辑器 来解决这个问题
   6. ><><>< 也许 我现在 就应该 试着实现 对 函数性质 的 询问器
   7. 我有点不知道应该如何继续下去了
      下一个着手点是哪里 ?
      目标是 我需要自己的 编译器
      我将使用 lambda-calculus 所提供的代入语义 来实现它
      我需要 让 已有的 lambda-calculus 的语法更方便使用
      对常量和变量的统一化处理能给这里一些启示吗 ?
      原则是 减少 标点符号的使用
      并且 尽量少 制定命名规则
      所以:
      1) 先修改 lambda-calculus 语法
      2) 改常量和变量的使用方式
      3) 写编译器
      4) 从最简单 的 babystep 开始
      5) 编译 bootloader
      6) 编译 ...
      7) 注意要保持设计的灵活性
         或者直接从 文档开始
         用中文写文档 以加快速度
   8. 关于 linux下 图形界面 的 文本编辑器
      因为我已经能把 动态链接的库加载到 cicada 中了
      所以是有可能实现的
      需要用 C 把某先函数包装好
      在 cicada 中调用 C 函数的时候需要保护跟栈 有关的寄存器
   9. 完成编译器后实现 hash-table 的 dictionary
   10. I simply won't allow myself to do something ad hoc anymore
       for if you use something ad hoc
       when you wish to well-design something related to it
       you have to go back and redesign the ad hoc better
   11. I have learned something about yaml
       gonna use the good parts of it to redesign something in cicada
       if I can disign the syntax of cicada about data structures
       to let them be used as a "human-readable data serialization format"
       then I can say that I have designed something good and new
       1) 但是注意如果 把 类 yaml 的 对 indentation 的解析
          也加入到 cicada 中那就必须要使用另一个 REPL 了
       2) 应该 在 wodili 的已有的 解析器 的基础上
          增加一个 好好 利用 indentation 的解析器
          两种解析器各自有各自的用处
       3) 把 利用"支撑树" 来进行相对引用的 性质加到 yaml 中
          就能 形成 我想要的 digrap 的语法
       4) 处理 这些语法 的 解析器 原来叫做这些 文档格式 的 API
   12. it also feels fun
       to reimplement some UNIX userland functions :)
   13. 关于io主页文档中的 code listing 需能制定我所喜欢的字体
   14. 写汇编器是必须的
       单单写一个 以 fasm 为输出 的编译器
       是满足不了要求的
   15. 当在执行一个函数 到一半的时候
       发现其中的某个函数(或变量)没有被定义
       我将可以 把用户代入到 一个 REPL 中
       让用户有机会补全这个定义 然后在从一半的位置重新开始计算
   16. 比如 当同时考虑 整数 还有 实数 等等 数据类型的时候
       面向对象的 节省命名空间 的优点 就充分地体现出来了
       这在于 (也只在于) 这样写出来的 代码
       更接近于人们日常对数学运算的模糊表达
   17. 需要好好 分析一下 增加了 Lambda-stack 之后
       整个系统的数学性质的变化
       因为 感觉上 太帅了
       好像 增加了一个维度
       好像 走出了柏拉图的洞穴一样
   18. as the "debuger" is defined in cicada code
       it is hard to do good error handling in assembly code
       这是因为我没法在出错的时候即使调用 debuger 来报错
       - 比如 通常的函数类型的错误
         我应该 及时的 调用 debuger 来报告错误
         而在不利的条件下 我必须 返回一个出错码
         来表示函数 所接受的数据类型不对
   19. do not use the data structure "word-list" anymore
       just let ":" and ";" read a string to a buffer
       this will force me to refine the functions about string processing
   20. really need a better way to do tests
       and I need to design better test-suit
   21. 需要 cicada-assembler 的理由:
       1) 统一 命名规则
       2) 让我 能够探索一些关于编译的技术
       3) 有些 小的 CPU 并没有 类似 fasm 的 合适的编译器的
          当我有 cicada-assembler 的时候
          我就能不受限制于这个事实了
       4) 当我调整代码的结构
          以让我方便地 维护两个汇编版本的时候
          我就发现 其中有很多重复的部分
          想要消除这些重复
          我可以通过 更多的 把文件 分开来实现
          但是如果我想保持
          我的 类文学编程 组织代码的风格的话
          也许 创造一些新的东西来支持 我的风格就是必须的了
   22. 不需要 cicada-assembler 的理由:
       1) 一个人认为 一个语言需要这种东西
          可能只是因为 当这个语言的编译器能够自己编译自己的时候
          看起来很 cool 而已
       2) 为了 实现 一个 x86-64 的汇编器
          有太多的 关于 CPU 的底层细节需要 被掌握
   23. 就用户接口的设计而言
       我可以把那几个 核心的栈 的图示 放在 左边的一个窗口里
       在这之后 我就能设计 debuger 的更好的使用方式
       但是一个问题是 当我的界面不再是一个简单的解释器的时候
       我就不能 直接利用 emacs 了
       也就是必须 要先写自己的 文本编辑器
       之后才能考虑窗口 之类的问题
   24. 也许 可以从 isforth 那里 学习在 linux 下写文本编辑器的基本工作
   25. 生成中文字典 交给 Recaler
   26. 支持 windows 及其环境下的开发
   27. 支持 Mac 及其环境下的开发
** about decision
   1. 每当一个设计决策的
      1. 选项一:
         会导致更多的新试验
         并且有可能让他做更多的设计决策
      2. 选项二:
         会让设计者走向更传统而有章法可循的实现
      这个时候正常的设计者就倾向于选项二
      这就是为什么人们想要
      模块系统 代码复用 等等语言性状
      对于对复杂性的控制而言 这些性状其实都不是本质的
   2. 我选择做非正常的设计者
      就算我发现一个设计决策可能会让我重写很多的代码
      经过客观而细致的评价之后
      只要这个决策是好的
      我依然会作出这个决策
   3. 正常的设计者所做的决策 可以被归结为 "非理性的决策"
      我发现在生活中的某些方面我也在做着许多的 "非理性的决策"
   4. 启示是
      每次做决策的时候 都要清楚地明白 "非理性的决策" 的存在
      那是人性的弱点
   5. 如果我想为我的语言做广告
      我可以做一个对比 来展示
      我的语言 在各个小的方面
      是如何优越于 其他它的各种语言的相应方面的
** about foundation
   1. 我可以基于现在的信息技术
      设计一种新的组织结构
      来形成决策
      让每个人都能参与进来
   2. 我可以通过展示这种新的组织结构的可行性
      来打破 人们对政治的 "不参与" 态度
      还有 "无以参与" 的状态
   3. 其实我明白
      如果真的想在现实的政治世界改变这种现象
      必须有一场革命才行
   4. 也许 foundation 这个词并不适用来描述这样的组织
      我应该寻求一个新的词
      来给人以 "异" 感
   5. 我需要选举
      但是 代表人 与 选民 之间
      可以通过 我所掌握的信息技术形成更有效的对话
      我所要设计的新的体制
      就是要保证这种对话的通畅
      不要让 "人民代表大会" 这种可笑的东西产生
   6. 常会的进程和项目计划的提出
      将用最简介易懂的语言表达于公开的媒体上
      并且有机制能够保证
      选民对这些公开的信息的反馈能够听到
   7. 但是其实这种组织只有在政治世界才能有效
      因为 要知道
      一个公司的目标是盈利
      一个 NPO 就算以别的理想为目标
      在这类组织中 不能形成 可以类比政治选民的人群
** about semantic
   1. 在 重写某些基础的部分的时候
      我发现 两种语义的不一致 带来的问题很大
      所以
      纯粹的编译的 与 纯粹的解释的 是设计起来更方便的
      也许 那样才是 更好的
      比如 利用 hash-table of symbol 所实现的 scheme 解释器
      又比如 C 这类过程式语言 的 编译器
** the right thing
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      这是就已经实现的部分而言的
      指必须没有bug
      当没有达到 Completeness 时
      没有实现的部分 比如某些特里的处理 就不被考虑在内
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      这是因为 一致性 就表明了设计本身的优良
      从长远的角度看来 一致性 是最有价值的
** 关于 错误处理
   1. 有两种 错误处理机制在 cicada 中被使用了)
      1 一种是 在出错的时候当场 调用 debuger
      2) 一种是 在出错的时候返回 出错码
   2. 第一种是 lisp 的 REPL 中常用的方法
      第二种是 C 和 UNIX 中被系统使用了的方法
   3. 以第一用方式实现的函数的特点是:
      尽早地 报告错误就能把错误报告的更详尽
      并且给 用户 当场更改错误的机会
   4. 以第二用方式实现的函数的特点是:
      可以一致 的方式 允许错误的出现
      典型的 场合是 对 number 的 parsing 错误
   ----------------------------------
   但是这两种 处理方式 又可以 相互实现对方的好的性状:
   1. 第一种的好的性状之一是 可以把错误报告的更详细
      第二种风格的函数 只要不要 返回出错码
      而 返回更丰富的数据结构 来报告错误就 也能达到这种效果
   2.
   3.
* ==================================================
* english-core
** TODO
   1. better interface for lambda
   2. use hash-table to lookup dictionary
      then mutually recursive call
   3. 用hash-table来find
      这些不必实现在汇编代码中
      因为 list还是必要的
      因为这样就能保持对字典的灵活控制
      所以 需要写一些函数把
      字典重新加载到 hash-table 中
   4. need to redesign the way to do test
      should tangle test to separated file
      for i do not have my org-mode now
   5. wodyli processing
      then digrap in cicada
   6. tab completion in the REPL
      (or in text editor)
   7. let functions in assembly-code
      be able to call functions in cicada-style-assembly-code
   8. 实现对多种实现技术的定制
   9. 重新思考某些术语和命名方式
   10. 更改所谓的线程技术
       以支持汇编扩展
       然后利用会汇编扩展的良好支持来优化某些代码
   11. cicada should design it's own abstractions of IO
       this can help cicada to be portable
   12. memory allocation
   13. flow-point number
   14. >< maybe substitute word to execute in lambda-body
   15. >< maybe syntax-check
   16. >< modern pattern-match  HOW ???
   17. better interface for debuger
   18. TAIL-CALL-OPTIMIZATION in apply lambda-body
   19. more protection on allocated memory
       maybe use paging
   20. cicada-assembler
   21. cicada-editor
   22. APL-like array-processing
   23. needs better sexp-reader&write
       design a better way
       to use local-label to from list-with-circuit
** 关于 lambda-calculus 的语法
   1. 我发现 在 cicada 中 lambda-calculus 的语法非常背离传统
      也许我应该嵌入新的 语法解析器来实现 lambda-calculus
      而不是 继续使用 那个 "几乎不解析任何语法的解释器"
** TEN COMMANDMENTS OF CICADA
   1. you can break any commandment when necessary
   2. ``The whole point of Forth was that
      you didn't write programs in Forth
      you wrote vocabularies in Forth.
      When you devised an application
      you wrote a hundred words or so that discussed the application
      and you used those hundred words
      to write a one line definition to solve the application.
      It is not easy to find those hundred words,
      but they exist,
      they always exist.''
** 以名释性
   (string-reference <string> <index>)
   (string-compare <string1> <string2>)
   (string-append <string1> <string2>)
   发现命名是一个问题
   每个动词比如compare
   可以是 string-compare 或 list-compare
   这就要求在命名上给每个函数加上数据类型的前缀
   作为特殊的前缀
   也许应该用 string:compare 而不是 string-compare
   这种看来劳神的前缀的需要是因为
   我不允许函数名的重载
   如果我统一这种对数据类型前缀的使用
   那么 动态类型的量 和 非动态类型的量
   之间命名规则的冲突也就被化解了
   也许 string-append 应该被叫做 string:^_^
   就像 ^_^ 在 dalin 中的效果一样
   但是这两种函数之间又有区别
   重要的区别是
   他们是返回新的数据还是在原来数据的基础上做副作用
   我还可以用对命名函数的约定来
   让函数的名字体现更多的函数的性质
   也就是说 cicada 的一个特点是
   ``以名释性''
   这是实现起来最简单的
   但是需要设计良好的命名规则
   在给函数取名字的时候
   写代码的人也要花一些功夫思考
   才能让这个名字恰当地体现函数的性质
   同时最重要的是
   这种方案
   可以在最大程度上减轻人们在读代码的时候的
   认知上的负担
   ------------------
   但是有一些重要的函数比如 write
   还是需要取处理不同类型的量
** IDE
   另外还有 IDE
   通过语法高亮和 mimi-buffer
   来帮助代码的阅读者来
   获知名词和动词的语义
   与命名规则一样
   这一切都是为了
   减轻``代码的阅读者的认知上的负担''
** the naming conventions in cicada
   回顾一下 cicada 中现在所使用的命名规则
   做一个系统的笔记
   这也将方便将来文档的撰写
   1. 首先是关于 primitive functions
      它们的命名都是简单的用"-"来连词的
      尽管这里也有类似数据类型的概念
      比如string[address, length]
      没有复杂的跟类型有关的前缀
   2. 也就是说"-"是用来把单个的word链接成短语的
   3. 而在 *basic* 中
      还用到了","
      它是用来把短语链接成短句的
      比如 ``define-variable,by-string''
      在这个例子中 ``by-string'' 表明了
      这个函数的参数的数据类型
   4. ":"被用作前缀的链接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大写表明他们是名词性的
      这些常量或变量前缀单单指明了
      这个名词的功能
      而没有指明这个名词的实现细节
      >< 这种特性是好的吗?
      这是好的 如果 人们总能简单地从这些描述特性的词中推测出这些名词的实现细节
      这是不好的 如果 这种推测并不平凡和简单 而带来了额外的认知上的负担
   5. 对名词而言
      第一个简单的跟类型无关的描述函数功能的前缀是"help:"
      也就是说前缀的使用方式是相当自由的
      >< 我不应该做更细致的标准式来削弱这种自由性吗?
   6. 前缀是可以有多个的
      比如"help:string:copy"
** about programming paradigms
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特点是这样的模型非常节省用来定义函数的命名空间
     这样是以数据结构为中心的
     函数 (算法或对数据结构的处理过程) 在思想观念上的重要性 屈居次位
     这是在尝试
     让我们的编程行为适应我们对这个世界的最通俗的非结构化的理解
     我们能够辨别我们在这个世界上所观察到的各种物体(对象)
     并且我们总在以某种方式与这些对象交流
     每个对象是一个内蕴的独立的个体
     并且在我们的观察过程中
     我们给对象分类
     分类在这里其实是不重要的
     - 这是因为分类不是一个系统的方法
       分类的过程可以是相当任意的
       不同的分类者 去分类 同一个对象的集合时
       按照他们的理解方式的不同 他们会作出不同的分类
       看看生物学就知道了
     重要的是每个内蕴的个体
   - functional
     computation should be viewed as functions act on their arguments
     并且这些函数的行为 要具有数学意义上的函数的某些重要特性
     这是以算法为中心的
     这是在尝试
     用我们的数学知识来帮助我们编程
     而数学代表了我们对这个世界的结构化的理解
     我们观察这个世界
     然后用数学的语言还有数学的方法论总结我们的观察结果
     如果 说数学的方法论是"纯粹客观的" 太过有争议
     那么 说这种方法论相比较与其他的编程范式更加具有客观性
     是没有错的
** about string processing
   1. 我可以实现一些适用于用来写
      string-reader 和 string-writer
      的基础函数
      使得用户很容易在 cicada 中实现自己所希望的这类函数
      string-writer 用于 格式输出 之类的东西
** object-oriented
   其实 利用 list-processing 我可以在 cicada 中加入对 object-oriented (class and message-passing) 的支持
   正如 我用 list-processing 来实现 lambda-calculus 一样
   并且我想 object-oriented 这种编程范式也许更适合用来实现 digrap
   但是 问题是 新的语法元素必须被引进
   这也许可以通过写一个不同的 REPL 来实现
** about bra-ket
   1. 以个 REPL 的性质很像是 bra-ket 中的 一个 bra
      symbol-REPL 作为 bra
      所对应的 ket 可以是 bye,symbol-REPL
   2. 各个 REPL 和 bra 之间
      必须能够灵活的相互递归调用
      我没能实现很好的机制来完成这一点
   3. 并且我现在应该把 REPL 和 bra-ket 的实现方式统一起来
      我以前并没有意识到它们是完全相同的东西
      它们之前确实有区别
      但是我应该把它们的共同点提取出来
      >< 这种``对共同点的提取''
      用函数的 factoring 做起来
      和用 class 的继承做起来 相比
      感觉有什么不同 ???
* ==================================================
* baremetal
** TODO
   1. 作为一个使用纯粹释性语言
      我应该 重新 思考 对 公共的 函数库的使用方式
   2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
   3. SMP support
      作为一个以栈为基础的语言
      我应该重新思考 利用 多核 的方式
   4. learn more from baremetal-OS
   5. convert the code about storage & BMFS from old-asm to forth-like-asm
      to examine the bug of "readsectors"
   6. fix "bye"
   7. design game-like UI in text mode
   8. rewrite cicada to make it standard and portable
      (this will always be TODO)
** TEN COMMANDMENTS OF ASSEMBLY
   1. you can break any commandment when necessary
   2. when you want to use a ``Const'' or a ``Var'' in assembly
      use it as the following example:
      - define a Const:
        defConst "LinuxProgramHeaderAddress", 0, LinuxProgramHeaderAddress
      - use a Const:
        mov [LinuxProgramHeaderAddress + CellWidth], rsp
      - define a Var:
        defVar "Here",  0, Here
      - use a Var:
        mov [Here + CellWidth], TemporaryRegister
   3. when you want to expose a label defined in assembly to cicada
      do it as the following example:
      defConst "UserDataArea", UserDataArea, TheUserDataArea
** about the structure of the code
   1. 汇编代码所实现的是一个 可扩展的虚拟机
      代码 可以分为4部分 :
      1) 初始化CPU和硬件的代码
      2) 基本的 从CPU所提供的汇编指令集中
         提取出来的 ``primitive functions''
      3) 关于基本输入输出的
         这一部分用来形成REPL
      4) 关于函数定义的
         这一部分用来实现在解释器中对函数的编译
   2. 我需要按照上面的分类
      来重新组织代码的结构
      并且形成一个这个``可扩展的虚拟机''的标准
      并且形成一个统一的接口用来实现上面的"3.4."这两部分
      这些都是为了今后 向其他硬件移植而做准备的
      当然
      同时也是为了让代码的宏观的逻辑结构更清晰
* linux
** TODO
   1. 使得 cicada 在编译时期能够使用 共享的子程库
   2. 写一个 libc 版本的 cicada 试试
   3. 让 cicada 在编译期 把 ld 作为一个 共享的子程 来使用
      并学习它的接口
      这样在解释器里我就能 动态地调用 任何 共享的子程库 中的函数了
   4. to allow executables to dynamically access external functionality at run time
      and thereby reduce their overall memory footprint
      在我的操作系统中 我可以以我的方式来完成上面的这种特性
      我只需要一个 "need" 函数 来声明 某段被解释的代码 所需要的 sub-dictionary
      我还需要一些 处理 sub-dictionary 的函数
      sub-dictionary 的性质 是 :
      - 它可以有很多个
      - 并且它所占用的 内存可以被回收的
      - 内存的回收 可以用 类似字符串的 垃圾回收器 来完成
      - 当全面地使用 hash 来实现 dictionary 时
        内存的回收 也可以用 类似链表的 垃圾回收器 来完成
** note
   1. 在写一个文本编辑器之前
      我不得不以linux为自己的工作环境
      1) 利用 emacs
         我可以快速地测试 language-cores
      2) 利用 linux 中的图形环境 和 中文字体
         我可以 继续研究 蝉语的中文语法
* windows
* ==================================================
