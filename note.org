#+TITLE: note about cicada project
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* TODO
** ><
   1. 关于io主页文档中的 code listing 需能制定我所喜欢的字体
   2. 写汇编器是必须的
      单单写一个 以 fasm 为输出 的编译器
      是满足不了要求的
   3. 当在执行一个函数 到一半的时候
      发现其中的某个函数(或变量)没有被定义
      我将可以 把用户代入到 一个 REPL 中
      让用户有机会补全这个定义 然后在从一半的位置重新开始计算
   4. 比如 当同时考虑 整数 还有 实数 等等 数据类型的时候
      面向对象的 节省命名空间 的优点 就充分地体现出来了
      这在于 (也只在于) 这样写出来的 代码
      更接近于人们日常对数学运算的模糊表达
   5. 需要好好 分析一下 增加了 Lambda-stack 之后
      整个系统的数学性质的变化
      因为 感觉上 太帅了
      好像 增加了一个维度
      好像 走出了柏拉图的洞穴一样
   6. as the "debuger" is defined in cicada code
      it is hard to do good error handling in assembly code
      这是因为我没法在出错的时候即使调用 debuger 来报错
      - 比如 通常的函数类型的错误
        我应该 及时的 调用 debuger 来报告错误
        而在不利的条件下 我必须 返回一个出错码
        来表示函数 所接受的数据类型不对
   7. >< maybe get rid of "One" "Two" "Three" ...
   8. do not use the data structure "word-list" anymore
      just let ":" and ";" read a string to a buffer
      this will force me to refine the functions about string processing
   9. really need a better way to do tests
      and I need to design better test-suit
   10. 需要 cicada-assembler 的理由:
       1) 统一 命名规则
       2) 让我 能够探索一些关于编译的技术
       3) 有些 小的 CPU 并没有 类似 fasm 的 合适的编译器的
          当我有 cicada-assembler 的时候
          我就能不受限制于这个事实了
       4) 当我调整代码的结构
          以让我方便地 维护两个汇编版本的时候
          我就发现 其中有很多重复的部分
          想要消除这些重复
          我可以通过 更多的 把文件 分开来实现
          但是如果我想保持
          我的 类文学编程 组织代码的风格的话
          也许 创造一些新的东西来支持 我的风格就是必须的了
   11. 不需要 cicada-assembler 的理由:
       1) 一个人认为 一个语言需要这种东西
          可能只是因为 当这个语言的编译器能够自己编译自己的时候
          看起来很 cool 而已
       2) 为了 实现 一个 x86-64 的汇编器
          有太多的 关于 CPU 的底层细节需要 被掌握
   12. 就用户接口的设计而言
       我可以把那几个 核心的栈 的图示 放在 左边的一个窗口里
       在这之后 我就能设计 debuger 的更好的使用方式
       但是一个问题是 当我的界面不再是一个简单的解释器的时候
       我就不能 直接利用 emacs 了
       也就是必须 要先写自己的 文本编辑器
       之后才能考虑窗口 之类的问题
   13. 也许 可以从 isforth 那里 学习在 linux 下写文本编辑器的基本工作
   14. fix the load-file function of linux version
   15. 生成中文字典 交给 Recaler
   16. 支持 windows 及其环境下的开发
   17. 支持 Mac 及其环境下的开发
** 关于 错误处理
   1. 有两种 错误处理机制在 cicada 中被使用了
      1) 一种是 在出错的时候当场 调用 debuger
      2) 一种是 在出错的时候返回 出错码
   2. 第一种是 lisp 的 REPL 中常用的方法
      第二种是 C 和 UNIX 中被系统使用了的方法
   3. 以第一用方式实现的函数的特点是:
      尽早地 报告错误就能把错误报告的更详尽
      并且给 用户 当场更改错误的机会
   4. 以第二用方式实现的函数的特点是:
      可以一致 的方式 允许错误的出现
      典型的 场合是 对 number 的 parsing 错误
   ----------------------------------
   但是这两种 处理方式 又可以 相互实现对方的好的性状:
   1. 第一种的好的性状之一是 可以把错误报告的更详细
      第二种风格的函数 只要不要 返回出错码
      而 返回更丰富的数据结构 来报告错误就 也能达到这种效果
   2.
   3.
* ==================================================
* english-core
** TODO
   1. better interface for lambda
   2. use hash-table to lookup dictionary
      then mutually recursive call
   3. 用hash-table来find
      这些不必实现在汇编代码中
      因为 list还是必要的
      因为这样就能保持对字典的灵活控制
      所以 需要写一些函数把
      字典重新加载到 hash-table 中
   4. need to redesign the way to do test
      should tangle test to separated file
      for i do not have my org-mode now
   5. wodyli processing
      then digrap in cicada
   6. tab completion in the REPL
      (or in text editor)
   7. let functions in assembly-code
      be able to call functions in cicada-style-assembly-code
   8. 实现对多种实现技术的定制
   9. 重新思考某些术语和命名方式
   10. 更改所谓的线程技术
       以支持汇编扩展
       然后利用会汇编扩展的良好支持来优化某些代码
   11. cicada should design it's own abstractions of IO
       this can help cicada to be portable
   12. memory allocation
   13. flow-point number
   14. >< maybe substitute word to execute in lambda-body
   15. >< maybe syntax-check
   16. >< modern pattern-match  HOW ???
   17. better interface for debuger
   18. TAIL-CALL-OPTIMIZATION in apply lambda-body
   19. more protection on allocated memory
       maybe use paging
   20. cicada-assembler
   21. cicada-editor
   22. APL-like array-processing
   23. needs better sexp-reader&write
       design a better way
       to use local-label to from list-with-circuit
** 关于 lambda-calculus 的语法
   1. 我发现 在 cicada 中 lambda-calculus 的语法非常背离传统
      也许我应该嵌入新的 语法解析器来实现 lambda-calculus
      而不是 继续使用 那个 "几乎不解析任何语法的解释器"
** TEN COMMANDMENTS OF CICADA
   1. you can break any commandment when necessary
   2. ``The whole point of Forth was that
      you didn't write programs in Forth
      you wrote vocabularies in Forth.
      When you devised an application
      you wrote a hundred words or so that discussed the application
      and you used those hundred words
      to write a one line definition to solve the application.
      It is not easy to find those hundred words,
      but they exist,
      they always exist.''
** 以名释性
   (string-reference <string> <index>)
   (string-compare <string1> <string2>)
   (string-append <string1> <string2>)
   发现命名是一个问题
   每个动词比如compare
   可以是 string-compare 或 list-compare
   这就要求在命名上给每个函数加上数据类型的前缀
   作为特殊的前缀
   也许应该用 string:compare 而不是 string-compare
   这种看来劳神的前缀的需要是因为
   我不允许函数名的重载
   如果我统一这种对数据类型前缀的使用
   那么 动态类型的量 和 非动态类型的量
   之间命名规则的冲突也就被化解了
   也许 string-append 应该被叫做 string:^_^
   就像 ^_^ 在 dalin 中的效果一样
   但是这两种函数之间又有区别
   重要的区别是
   他们是返回新的数据还是在原来数据的基础上做副作用
   我还可以用对命名函数的约定来
   让函数的名字体现更多的函数的性质
   也就是说 cicada 的一个特点是
   ``以名释性''
   这是实现起来最简单的
   但是需要设计良好的命名规则
   在给函数取名字的时候
   写代码的人也要花一些功夫思考
   才能让这个名字恰当地体现函数的性质
   同时最重要的是
   这种方案
   可以在最大程度上减轻人们在读代码的时候的
   认知上的负担
   ------------------
   但是有一些重要的函数比如 write
   还是需要取处理不同类型的量
** IDE
   另外还有 IDE
   通过语法高亮和 mimi-buffer
   来帮助代码的阅读者来
   获知名词和动词的语义
   与命名规则一样
   这一切都是为了
   减轻``代码的阅读者的认知上的负担''
** the naming conventions in cicada
   回顾一下 cicada 中现在所使用的命名规则
   做一个系统的笔记
   这也将方便将来文档的撰写
   1. 首先是关于 primitive functions
      它们的命名都是简单的用"-"来连词的
      尽管这里也有类似数据类型的概念
      比如string[address, length]
      没有复杂的跟类型有关的前缀
   2. 也就是说"-"是用来把单个的word链接成短语的
   3. 而在 *basic* 中
      还用到了","
      它是用来把短语链接成短句的
      比如 ``define-variable,by-string''
      在这个例子中 ``by-string'' 表明了
      这个函数的参数的数据类型
   4. ":"被用作前缀的链接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大写表明他们是名词性的
      这些常量或变量前缀单单指明了
      这个名词的功能
      而没有指明这个名词的实现细节
      >< 这种特性是好的吗?
      这是好的 如果 人们总能简单地从这些描述特性的词中推测出这些名词的实现细节
      这是不好的 如果 这种推测并不平凡和简单 而带来了额外的认知上的负担
   5. 对名词而言
      第一个简单的跟类型无关的描述函数功能的前缀是"help:"
      也就是说前缀的使用方式是相当自由的
      >< 我不应该做更细致的标准式来削弱这种自由性吗?
   6. 前缀是可以有多个的
      比如"help:string:copy"
** about programming paradigms
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特点是这样的模型非常节省用来定义函数的命名空间
     这样是以数据结构为中心的
     函数 (算法或对数据结构的处理过程) 在思想观念上的重要性 屈居次位
     这是在尝试
     让我们的编程行为适应我们对这个世界的最通俗的非结构化的理解
     我们能够辨别我们在这个世界上所观察到的各种物体(对象)
     并且我们总在以某种方式与这些对象交流
     每个对象是一个内蕴的独立的个体
     并且在我们的观察过程中
     我们给对象分类
     分类在这里其实是不重要的
     - 这是因为分类不是一个系统的方法
       分类的过程可以是相当任意的
       不同的分类者 去分类 同一个对象的集合时
       按照他们的理解方式的不同 他们会作出不同的分类
       看看生物学就知道了
     重要的是每个内蕴的个体
   - functional
     computation should be viewed as functions act on their arguments
     并且这些函数的行为 要具有数学意义上的函数的某些重要特性
     这是以算法为中心的
     这是在尝试
     用我们的数学知识来帮助我们编程
     而数学代表了我们对这个世界的结构化的理解
     我们观察这个世界
     然后用数学的语言还有数学的方法论总结我们的观察结果
     如果 说数学的方法论是"纯粹客观的" 太过有争议
     那么 说这种方法论相比较与其他的编程范式更加具有客观性
     是没有错的
** about string processing
   1. 我可以实现一些适用于用来写
      string-reader 和 string-writer
      的基础函数
      使得用户很容易在 cicada 中实现自己所希望的这类函数
      string-writer 用于 格式输出 之类的东西
** object-oriented
   其实 利用 list-processing 我可以在 cicada 中加入对 object-oriented (class and message-passing) 的支持
   正如 我用 list-processing 来实现 lambda-calculus 一样
   并且我想 object-oriented 这种编程范式也许更适合用来实现 digrap
   但是 问题是 新的语法元素必须被引进
   这也许可以通过写一个不同的 REPL 来实现
** about bra-ket
   1. 以个 REPL 的性质很像是 bra-ket 中的 一个 bra
      symbol-REPL 作为 bra
      所对应的 ket 可以是 bye,symbol-REPL
   2. 各个 REPL 和 bra 之间
      必须能够灵活的相互递归调用
      我没能实现很好的机制来完成这一点
   3. 并且我现在应该把 REPL 和 bra-ket 的实现方式统一起来
      我以前并没有意识到它们是完全相同的东西
      它们之前确实有区别
      但是我应该把它们的共同点提取出来
      >< 这种``对共同点的提取''
      用函数的 factoring 做起来
      和用 class 的继承做起来 相比
      感觉有什么不同 ???
* ==================================================
* about assembler
  1. 动机
     1) 统一汇编代码和 cicada 代码中的命名规则
     2) 方便向没有很好的汇编器的小型机器移植
     3) 作为一个系统程序员 我需要尽量避免 "抽象泄漏"
        这在于 我发现 当需要处理
        ELF文件格式 以及对共享库的动态调用的时候
        有很多底层的东西还是我没有理解的
        而 fasm 在形成 ELF 的时候 共享库的动态调用 有问题
        这个问题 让我认识到了 在 cicada 中实现汇编器的紧迫性
  2. 方法
     以 fasm 为汇编器 编译的目标代码
     但是仅仅使用 "db" 还有 很 CPU 指令有关的部分
     也就是说通过暂时把最枯燥与无聊的工作外包给 fasm
     我能够在 cicada 快速地实现一个汇编器
     并且在不好处理 或 没时间处理的地方 能够给我一个退路
  3. 对语义的处理
     就我的认识而言 解释语义与编译语义 之间有很大的不一致性
     也许这只 cicada (类 Forth 语言) 的特点而已
     对于 cicada (类 Forth 语言) 其特点在于
     1) 解释器 中的 cicada 代码 和 汇编器中的 汇编代码
        都在以相似的方式把函数编译到字典中
     2) 在解释器中 对函数的编译依赖于函数的顺序
        被调用的辅助函数 必须得出现在调用它的函数之前
        不方便进行相互递归
        很方便重新定义一个函数
     3) 在汇编代码中 对函数的编译不依赖于函数的顺序
        很方便进行相互递归
        不方便重新定义函数
  4. 步骤
     1) 首先
        在已有的 linux 版本的 cicada 解释器中实现 对文件的处理
     2) 接着
        利用 文件处理函数 在解释器中 实现编译器
        这个编译器必须要能够 方便地 重新定义函数
        这样就能够
        直接重新利用曾经被解释器的代码
        再把原本的汇编代码按新的编译器的语法重写一遍
        然后我就获得了一个测试我的新编译器的机会
        即去把这些代码编译成一个能用的解释器
     3) 然后
        利用编译器对函数的编译不依赖于函数的顺序的特点
        重写那些 没有在编译器中处理好的函数
        获得一个目前只能被新的编译器处理
        而不能被旧的解释器处理的版本
     4) 之后
        重新实现解释器中的基本函数
        使得解释器对函数的定义也不依赖于函数的顺序
        此时两个版本就应该能够同时被两个机器处理了
     5) 最后
        cicada 将能够基本独立
        我所获得的将不是分开的 一个解释器 和 一个编译器
        而是一个具有编译功能的解释器
        对于同样的代码
        在测试的时候我可以使用解释器
        在测试结束之后
        我可以把被解释的代码 融合到稳定的被编译的代码中
* ==================================================
* baremetal
** TODO
   1. 作为一个使用纯粹释性语言
      我应该 重新 思考 对 公共的 函数库的使用方式
   2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
   3. SMP support
      作为一个以栈为基础的语言
      我应该重新思考 利用 多核 的方式
   4. learn more from baremetal-OS
   5. convert the code about storage & BMFS from old-asm to forth-like-asm
      to examine the bug of "readsectors"
   6. fix "bye"
   7. design game-like UI in text mode
   8. rewrite cicada to make it standard and portable
      (this will always be TODO)
** TEN COMMANDMENTS OF ASSEMBLY
   1. you can break any commandment when necessary
   2. when you want to use a ``Const'' or a ``Var'' in assembly
      use it as the following example:
      - define a Const:
        defConst "LinuxProgramHeaderAddress", 0, LinuxProgramHeaderAddress
      - use a Const:
        mov [LinuxProgramHeaderAddress + CellWidth], rsp
      - define a Var:
        defVar "Here",  0, Here
      - use a Var:
        mov [Here + CellWidth], TemporaryRegister
   3. when you want to expose a label defined in assembly to cicada
      do it as the following example:
      defConst "UserDataArea", UserDataArea, TheUserDataArea
** about the structure of the code
   1. 汇编代码所实现的是一个 可扩展的虚拟机
      代码 可以分为4部分 :
      1) 初始化CPU和硬件的代码
      2) 基本的 从CPU所提供的汇编指令集中
         提取出来的 ``primitive functions''
      3) 关于基本输入输出的
         这一部分用来形成REPL
      4) 关于函数定义的
         这一部分用来实现在解释器中对函数的编译
   2. 我需要按照上面的分类
      来重新组织代码的结构
      并且形成一个这个``可扩展的虚拟机''的标准
      并且形成一个统一的接口用来实现上面的"3.4."这两部分
      这些都是为了今后 向其他硬件移植而做准备的
      当然
      同时也是为了让代码的宏观的逻辑结构更清晰
* linux
** TODO
   1. 使得 cicada 在编译时期能够使用 共享的子程库
   2. 写一个 libc 版本的 cicada 试试
   3. 让 cicada 在编译期 把 ld 作为一个 共享的子程 来使用
      并学习它的接口
      这样在解释器里我就能 动态地调用 任何 共享的子程库 中的函数了
   4. to allow executables to dynamically access external functionality at run time
      and thereby reduce their overall memory footprint
      在我的操作系统中 我可以以我的方式来完成上面的这种特性
      我只需要一个 "need" 函数 来声明 某段被解释的代码 所需要的 sub-dictionary
      我还需要一些 处理 sub-dictionary 的函数
      sub-dictionary 的性质 是 :
      - 它可以有很多个
      - 并且它所占用的 内存可以被回收的
      - 内存的回收 可以用 类似字符串的 垃圾回收器 来完成
      - 当全面地使用 hash 来实现 dictionary 时
        内存的回收 也可以用 类似链表的 垃圾回收器 来完成
** note
   1. 在写一个文本编辑器之前
      我不得不以linux为自己的工作环境
      1) 利用 emacs
         我可以快速地测试 language-cores
      2) 利用 linux 中的图形环境 和 中文字体
         我可以 继续研究 蝉语的中文语法
* windows
* ==================================================
