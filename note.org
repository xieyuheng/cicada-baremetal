#+TITLE: note about cicada project
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* 設計字符串的格式輸出
  我要實現一種最靈活的格式輸出
* 設計新的打印數字的語法 [關於打印的語法]
* write a better meet-undefined-word
  1. 如果我想要在 cicada 的代碼中重寫這個函數
     那麼 只要用一個變量
     讓這個函數調用這個變量中所保存的函數就行了
     這樣我就能以相當精確的方式 重新設置處理未定義的位置的函數了
  2. 另外的使得對某個函數的動態改變稱爲可能的方式是
     直接從 symbol 找到找新的 symbol 所對應的 函數值
     當更新 一個 symbol 所對應的函數之後
     就能 重新設置處理未定義的位置的函數了
     但是這種方式並不是很精確
  3. 那麼我需不需要在 cicada 的代碼中重寫這個函數呢 ??
     也許是需要的
     並且在 不同的 語言核下
     所希望使用的 處理函數可能是不同的
  4. 但是這種全局變量的使用可能並不是很好到的編程實踐
* 文案工作
* redesign the debuger
  1. as the "debuger" is defined in cicada code
     it is hard to do good error handling in assembly code
     這是因爲我沒法在出錯的時候即使調用 debuger 來報錯
     - 比如 通常的函數類型的錯誤
       我應該 及時的 調用 debuger 來報告錯誤
       而在不利的條件下 我必須 返回一個出錯碼
       來表示函數 所接受的數據類型不對
* re-writing garbage-collectior
  1. ??? 對於新的 define 要更改 GC
     整個 GC 都應該被重寫了嗎 ???
* make good use of indentation
  1. for wodili 應該 在 wodili 的已有的 解析器 的基礎上
     增加一個 好好 利用 indentation 的解析器
     兩種解析器各自有各自的用處
  2. 把 利用"支撐樹" 來進行相對引用的 性質加到 yaml 中
     就能 形成 我想要的 digrap 的語法
* write a cross compiler
  1. 從最簡單 的 babystep 開始
  2. 編譯 bootloader
  3. 注意要保持設計的靈活性
     或者直接從 文檔開始
     用中文寫文檔 以加快速度
  -----------------------------
  1. 需要 cicada-assembler 的理由:
     1) 統一 命名規則
     2) 讓我 能夠探索一些關於編譯的技術
     3) 有些 小的 CPU 並沒有 類似 fasm 的 合適的編譯器的
        當我有 cicada-assembler 的時候
        我就能不受限制於這個事實了
     4) 當我調整代碼的結構
        以讓我方便地 維護兩個彙編版本的時候
        我就發現 其中有很多重複的部分
        想要消除這些重複
        我可以通過 更多的 把文件 分開來實現
        但是如果我想保持
        我的 類文學編程 組織代碼的風格的話
        也許 創造一些新的東西來支持 我的風格就是必須的了
  2. 不需要 cicada-assembler 的理由:
     1) 一個人認爲 一個語言需要這種東西
        可能只是因爲 當這個語言的編譯器能夠自己編譯自己的時候
        看起來很 cool 而已
     2) 爲了 實現 一個 x86-64 的彙編器
        有太多的 關於 CPU 的底層細節需要 被掌握
* more syntax
** erlang's bit syntax
   在於讓人方便地處理 bit fields
   這在於 能 用模式匹配
** redesign the syntax about strings
* 關於 linux下 圖形界面 的 文本編輯器
  因爲我已經能把 動態鏈接的庫加載到 cicada 中了
  所以是有可能實現的
  需要用 C 把某先函數包裝好
  在 cicada 中調用 C 函數的時候需要保護跟棧 有關的寄存器
* reimplement some UNIX userland functions
* about OO support
  1. 比如 當同時考慮 整數 還有 實數 等等 數據類型的時候
     面向對象的 節省命名空間 的優點 就充分地體現出來了
     這在於 (也只在於) 這樣寫出來的 代碼
     更接近於人們日常對數學運算的模糊表達
* about UI
  我可以把那幾個 核心的棧 的圖示 放在 左邊的一個窗口裏
  在這之後 我就能設計 debuger 的更好的使用方式
  但是一個問題是 當我的界面不再是一個簡單的解釋器的時候
  我就不能 直接利用 emacs 了
  也就是必須 要先寫自己的 文本編輯器
  之後才能考慮窗口 之類的問題
* learn from isforth
* more platforms
  1. windows
  2. Mac
* word boundary
  1. ><><>< the note about word boundary is wrong ???
* branch
  1. 是否對 branch 給更好的支持 ?
     用 label 來計算 offset ???
* english-core
  1. use hash-table to lookup dictionary
     then mutually recursive call
  2. 用hash-table來find
     這些不必實現在彙編代碼中
     因爲 list還是必要的
     因爲這樣就能保持對字典的靈活控制
     所以 需要寫一些函數把
     字典重新加載到 hash-table 中
  3. need to redesign the way to do test
     should tangle test to separated file
     for i do not have my org-mode now
  4. wodyli processing
     then digrap in cicada
  5. tab completion in the REPL
     (or in text editor)
  6. let functions in assembly-code
     be able to call functions in cicada-style-assembly-code
  7. >< 實現對多種實現技術的定製
  8. >< 重新思考某些術語和命名方式
  9. cicada should design it's own abstractions of IO
     this can help cicada to be portable
     現在 有的只是 read-char 和 write-char 兩個基礎的東西而已
     這樣太貧乏了
  10. memory allocation
  11. flow-point number
  12. >< maybe substitute word to execute in lambda-body
  13. >< maybe syntax-check
  14. >< modern pattern-match  HOW ???
  15. better interface for debuger
  16. TAIL-CALL-OPTIMIZATION in apply lambda-body
  17. more protection on allocated memory
      maybe use paging
  18. cicada-assembler
  19. cicada-editor
  20. APL-like array-processing
  21. needs better sexp-reader&write
      design a better way
      to use local-label to from list-with-circuit
* baremetal
  1. 作爲一個使用純粹釋性語言
     我應該 重新 思考 對 公共的 函數庫的使用方式
  2. in lmode, how to set up the "attributes-and-type" field in an entry of IDT ?
  3. SMP support
     作爲一個以棧爲基礎的語言
     我應該重新思考 利用 多核 的方式
  4. learn more from baremetal-OS
  5. convert the code about storage & BMFS from old-asm to forth-like-asm
     to examine the bug of "readsectors"
  6. fix "bye"
  7. design game-like UI in text mode
  8. rewrite cicada to make it standard and portable
     (this will always be TODO)
* linux
  1. to allow executables to dynamically access external functionality at run time
     and thereby reduce their overall memory footprint
     在我的操作系統中 我可以以我的方式來完成上面的這種特性
     我只需要一個 "need" 函數 來聲明 某段被解釋的代碼 所需要的 sub-dictionary
     我還需要一些 處理 sub-dictionary 的函數
     sub-dictionary 的性質 是 :
     - 它可以有很多個
     - 並且它所佔用的 內存可以被回收的
     - 內存的回收 可以用 類似字符串的 垃圾回收器 來完成
     - 當全面地使用 hash 來實現 dictionary 時
       內存的回收 也可以用 類似鏈表的 垃圾回收器 來完成
* ==================================================
* note
** about decision
   1. 每當一個設計決策的
      1. 選項一:
         會導致更多的新試驗
         並且有可能讓他做更多的設計決策
      2. 選項二:
         會讓設計者走向更傳統而有章法可循的實現
      這個時候正常的設計者就傾向於選項二
      這就是爲什麼人們想要
      模塊系統 代碼複用 等等語言性狀
      對於對複雜性的控制而言 這些性狀其實都不是本質的
   2. 我選擇做非正常的設計者
      就算我發現一個設計決策可能會讓我重寫很多的代碼
      經過客觀而細緻的評價之後
      只要這個決策是好的
      我依然會作出這個決策
   3. 正常的設計者所做的決策 可以被歸結爲 "非理性的決策"
      我發現在生活中的某些方面我也在做着許多的 "非理性的決策"
   4. 啓示是
      每次做決策的時候 都要清楚地明白 "非理性的決策" 的存在
      那是人性的弱點
   5. 如果我想爲我的語言做廣告
      我可以做一個對比 來展示
      我的語言 在各個小的方面
      是如何優越於 其他它的各種語言的相應方面的
** about foundation
   1. 我可以基於現在的信息技術
      設計一種新的組織結構
      來形成決策
      讓每個人都能參與進來
   2. 我可以通過展示這種新的組織結構的可行性
      來打破 人們對政治的 "不參與" 態度
      還有 "無以參與" 的狀態
   3. 其實我明白
      如果真的想在現實的政治世界改變這種現象
      必須有一場革命才行
   4. 也許 foundation 這個詞並不適用來描述這樣的組織
      我應該尋求一個新的詞
      來給人以 "異" 感
   5. 我需要選舉
      但是 代表人 與 選民 之間
      可以通過 我所掌握的信息技術形成更有效的對話
      我所要設計的新的體制
      就是要保證這種對話的通暢
      不要讓 "人民代表大會" 這種可笑的東西產生
   6. 常會的進程和項目計劃的提出
      將用最簡介易懂的語言表達於公開的媒體上
      並且有機制能夠保證
      選民對這些公開的信息的反饋能夠聽到
   7. 但是其實這種組織只有在政治世界纔能有效
      因爲 要知道
      一個公司的目標是盈利
      一個 NPO 就算以別的理想爲目標
      在這類組織中 不能形成 可以類比政治選民的人羣
** the right thing
   1. Simplicity
      the design must be simple,
      both in implementation and interface.
      It is more important for the interface to be simple than the implementation.
   2. Correctness
      the design must be correct in all observable aspects.
      Incorrectness is simply not allowed.
      這是就已經實現的部分而言的
      指必須沒有bug
      當沒有達到 Completeness 時
      沒有實現的部分 比如某些特里的處理 就不被考慮在內
   3. Completeness
      the design must cover as many important situations as is practical.
      All reasonably expected cases must be covered.
      Simplicity is not allowed to overly reduce completeness.
   4. Consistency
      the design must not be inconsistent.
      A design is allowed to be slightly less simple and less complete to avoid inconsistency.
      Consistency is as important as correctness.
      這是因爲 一致性 就表明瞭設計本身的優良
      從長遠的角度看來 一致性 是最有價值的
** about function-group
   1. group the functions into groups
      and write more tests for them
   2. I need to use "group" as an unit
      to manage the dependences between functions
      我需要 以 group 爲單位 來 管理 functions 之間的依賴關係
   3. only need three new words
      1) group
      2) need (mutual need is allowed)
      3) primitive
      其實只需要用
      1) 用 group 這個 語法關鍵詞 來聲明 word-group
      2) 用 need 這個語法關鍵詞 來聲明 依賴關係
         need 允許 循環聲明
      3) 用 primitive 這個語法關鍵詞 來聲明 不依賴任何其他 group 的 group
   4. for now
      I just use an format to document the relations between groups
      I will implement functions to
      目前 先設計一種
      能夠 在將來被處理的
      用文檔來註釋 這種依賴關係的 格式
   5. 核心部分的 函數不必 被聲明
      只有那些 明顯地形成了 一個模塊化的 group 才用聲明
      否則就 太羅嗦了
      但是這裏並沒有 明確的界限
      哪些 纔是 核心的不用被聲明的 東西
      那些 是 需要被聲明的 ??
      都沒沒用 明確的界限 並且隨時可能變動的
** 關於 錯誤處理
   1. 有兩種 錯誤處理機制在 cicada 中被使用了)
      1 一種是 在出錯的時候當場 調用 debuger
      2) 一種是 在出錯的時候返回 出錯碼
   2. 第一種是 lisp 的 REPL 中常用的方法
      第二種是 C 和 UNIX 中被系統使用了的方法
   3. 以第一用方式實現的函數的特點是:
      儘早地 報告錯誤就能把錯誤報告的更詳盡
      並且給 用戶 當場更改錯誤的機會
   4. 以第二用方式實現的函數的特點是:
      可以一致 的方式 允許錯誤的出現
      典型的 場合是 對 number 的 parsing 錯誤
   ----------------------------------
   但是這兩種 處理方式 又可以 相互實現對方的好的性狀:
   1. 第一種的好的性狀之一是 可以把錯誤報告的更詳細
      第二種風格的函數 只要不要 返回出錯碼
      而 返回更豐富的數據結構 來報告錯誤就 也能達到這種效果
   2.
   3.
* ==================================================
* english-core
** 以名釋性
   (string-reference <string> <index>)
   (string-compare <string1> <string2>)
   (string-append <string1> <string2>)
   發現命名是一個問題
   每個動詞比如compare
   可以是 string-compare 或 list-compare
   這就要求在命名上給每個函數加上數據類型的前綴
   作爲特殊的前綴
   也許應該用 string:compare 而不是 string-compare
   這種看來勞神的前綴的需要是因爲
   我不允許函數名的重載
   如果我統一這種對數據類型前綴的使用
   那麼 動態類型的量 和 非動態類型的量
   之間命名規則的衝突也就被化解了
   也許 string-append 應該被叫做 string:^_^
   就像 ^_^ 在 dalin 中的效果一樣
   但是這兩種函數之間又有區別
   重要的區別是
   他們是返回新的數據還是在原來數據的基礎上做副作用
   我還可以用對命名函數的約定來
   讓函數的名字體現更多的函數的性質
   也就是說 cicada 的一個特點是
   ``以名釋性''
   這是實現起來最簡單的
   但是需要設計良好的命名規則
   在給函數取名字的時候
   寫代碼的人也要花一些功夫思考
   才能讓這個名字恰當地體現函數的性質
   同時最重要的是
   這種方案
   可以在最大程度上減輕人們在讀代碼的時候的
   認知上的負擔
   ------------------
   但是有一些重要的函數比如 write
   還是需要取處理不同類型的量
** about bra-ket
   1. 以個 REPL 的性質很像是 bra-ket 中的 一個 bra
      symbol-REPL 作爲 bra
      所對應的 ket 可以是 bye,symbol-REPL
   2. 各個 REPL 和 bra 之間
      必須能夠靈活的相互遞歸調用
      我沒能實現很好的機制來完成這一點
   3. 並且我現在應該把 REPL 和 bra-ket 的實現方式統一起來
      我以前並沒有意識到它們是完全相同的東西
      它們之前確實有區別
      但是我應該把它們的共同點提取出來
      >< 這種``對共同點的提取''
      用函數的 factoring 做起來
      和用 class 的繼承做起來 相比
      感覺有什麼不同 ???
** IDE
   另外還有 IDE
   通過語法高亮和 mimi-buffer
   來幫助代碼的閱讀者來
   獲知名詞和動詞的語義
   與命名規則一樣
   這一切都是爲了
   減輕``代碼的閱讀者的認知上的負擔''
** the naming conventions in cicada
   回顧一下 cicada 中現在所使用的命名規則
   做一個系統的筆記
   這也將方便將來文檔的撰寫
   1. 首先是關於 primitive functions
      它們的命名都是簡單的用"-"來連詞的
      儘管這裏也有類似數據類型的概念
      比如string[address, length]
      沒有複雜的跟類型有關的前綴
   2. 也就是說"-"是用來把單個的word鏈接成短語的
   3. 而在 basic 中
      還用到了","
      它是用來把短語鏈接成短句的
      比如 ``define-variable,by-string''
      在這個例子中 ``by-string'' 表明瞭
      這個函數的參數的數據類型
   4. ":"被用作前綴的鏈接符
      比如 ``Message:bye'' 和 ``Key-word:then''
      首字母大寫表明他們是名詞性的
      這些常量或變量前綴單單指明瞭
      這個名詞的功能
      而沒有指明這個名詞的實現細節
      >< 這種特性是好的嗎?
      這是好的 如果 人們總能簡單地從這些描述特性的詞中推測出這些名詞的實現細節
      這是不好的 如果 這種推測並不平凡和簡單 而帶來了額外的認知上的負擔
   5. 對名詞而言
      第一個簡單的跟類型無關的描述函數功能的前綴是"help:"
      也就是說前綴的使用方式是相當自由的
      >< 我不應該做更細緻的標準式來削弱這種自由性嗎?
   6. 前綴是可以有多個的
      比如"help:string:copy"
** about programming paradigms
   - imperative
     to describe computation in terms of statements
     that change a program state
     in much the same way that imperative mood in natural languages
     expresses commands to take action
   - object-oriented
     computation should be viewed as an intrinsic capability of objects
     that can be invoked by sending messages
     其重要的特點是這樣的模型非常節省用來定義函數的命名空間
     這樣是以數據結構爲中心的
     函數 (算法或對數據結構的處理過程) 在思想觀念上的重要性 屈居次位
     這是在嘗試
     讓我們的編程行爲適應我們對這個世界的最通俗的非結構化的理解
     我們能夠辨別我們在這個世界上所觀察到的各種物體(對象)
     並且我們總在以某種方式與這些對象交流
     每個對象是一個內蘊的獨立的個體
     並且在我們的觀察過程中
     我們給對象分類
     分類在這裏其實是不重要的
     - 這是因爲分類不是一個系統的方法
       分類的過程可以是相當任意的
       不同的分類者 去分類 同一個對象的集合時
       按照他們的理解方式的不同 他們會作出不同的分類
       看看生物學就知道了
     重要的是每個內蘊的個體
   - functional
     computation should be viewed as functions act on their arguments
     並且這些函數的行爲 要具有數學意義上的函數的某些重要特性
     這是以算法爲中心的
     這是在嘗試
     用我們的數學知識來幫助我們編程
     而數學代表了我們對這個世界的結構化的理解
     我們觀察這個世界
     然後用數學的語言還有數學的方法論總結我們的觀察結果
     如果 說數學的方法論是"純粹客觀的" 太過有爭議
     那麼 說這種方法論相比較與其他的編程範式更加具有客觀性
     是沒有錯的
** object-oriented
   其實 利用 list-processing 我可以在 cicada 中加入對 object-oriented (class and message-passing) 的支持
   正如 我用 list-processing 來實現 lambda-calculus 一樣
   並且我想 object-oriented 這種編程範式也許更適合用來實現 digrap
   但是 問題是 新的語法元素必須被引進
   這也許可以通過寫一個不同的 REPL 來實現
* ==================================================
* baremetal
** about the structure of the code
   1. 彙編代碼所實現的是一個 可擴展的虛擬機
      代碼 可以分爲4部分 :
      1) 初始化CPU和硬件的代碼
      2) 基本的 從CPU所提供的彙編指令集中
         提取出來的 ``primitive functions''
      3) 關於基本輸入輸出的
         這一部分用來形成REPL
      4) 關於函數定義的
         這一部分用來實現在解釋器中對函數的編譯
   2. 我需要按照上面的分類
      來重新組織代碼的結構
      並且形成一個這個``可擴展的虛擬機''的標準
      並且形成一個統一的接口用來實現上面的"3.4."這兩部分
      這些都是爲了今後 向其他硬件移植而做準備的
      當然
      同時也是爲了讓代碼的宏觀的邏輯結構更清晰
* linux
** note
   1. 在寫一個文本編輯器之前
      我不得不以linux爲自己的工作環境
      1) 利用 emacs
         我可以快速地測試 language-cores
      2) 利用 linux 中的圖形環境 和 中文字體
         我可以 繼續研究 蟬語的中文語法
* windows
* ==================================================
* 記
** 直觀 與 抽象
   1. 用抽象的數學來描述那些
      超出我們直觀的想像能力的東西
      是非常重要的
      每個個體的人的直觀想像能力的侷限性
      決定了他對抽象方法的需要
   2. 同時
      我們的想像能力本身卻又是可以拓展的
      就像一個潛水者通過長期的練習就能夠更熟悉水的性質一樣
      對某種語言的學習
      或者對某種新的表達方式的學習
      也能幫我們去熟悉一種新的思考方式
   3. 但是我們應該如何來看待我們所學到的某種新的思考方式呢 ?
      我們拓展了我們的直觀想像 ?
      還是我們獲取了新的抽象技巧 ?
      看似對立的 直觀想像 和 符號性的抽象技巧
      本爲一物矣
** 編譯器的漸進開發
   1. 有一種對編譯器的測試叫 三重編譯 測試
      當有一個能編譯自身的編譯器之後
      當你更改編譯器的源代碼
      而得到一個新的編譯器之後
      對同樣的源代碼
      必須要編譯三次來檢驗新的編譯器是否基本正確
      第一次使用舊的編譯器
      第二次使用新的編譯器
      第三次使用新新的編譯器
      測試在於比較 新的編譯器 和 新新的編譯器 是否完全相同
      它們應該完全相同 因爲它們是 "同樣的" 編譯器編譯
      編譯 同一份源代碼 所得到的二進制文件
* ==================================================
