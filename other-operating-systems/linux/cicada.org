#+TITLE: cicada language
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* *preface*
** linux_syscalls
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; see /usr/include/asm/unistd_64.h (on archlinux)

   ;; parameters order of syscall:
   define sys_6_r8  r8
   define sys_5_r9  r9
   define sys_4_r10 r10
   define sys_3_rdx rdx
   define sys_2_rsi rsi
   define sys_1_rdi rdi
   define sys_n_rax rax

   ;; syscall number:
   define syscall_read                      0
   define syscall_write                     1
   define syscall_open                      2
   define syscall_close                     3

   define syscall_stat                      4
   define syscall_fstat                     5
   define syscall_lstat                     6
   define syscall_poll                      7
   define syscall_lseek                     8
   define syscall_mmap                      9
   define syscall_mprotect                  10
   define syscall_munmap                    11
   define syscall_brk                       12
   define syscall_rt_sigaction              13
   define syscall_rt_sigprocmask            14
   define syscall_rt_sigreturn              15
   define syscall_ioctl                     16
   define syscall_pread64                   17
   define syscall_pwrite64                  18
   define syscall_readv                     19
   define syscall_writev                    20
   define syscall_access                    21
   define syscall_pipe                      22
   define syscall_select                    23
   define syscall_sched_yield               24
   define syscall_mremap                    25
   define syscall_msync                     26
   define syscall_mincore                   27
   define syscall_madvise                   28
   define syscall_shmget                    29
   define syscall_shmat                     30
   define syscall_shmctl                    31
   define syscall_dup2                       32
   define syscall_dup2                      33
   define syscall_pause                     34
   define syscall_nanosleep                 35
   define syscall_getitimer                 36
   define syscall_alarm                     37
   define syscall_setitimer                 38
   define syscall_getpid                    39
   define syscall_sendfile                  40
   define syscall_socket                    41
   define syscall_connect                   42
   define syscall_accept                    43
   define syscall_sendto                    44
   define syscall_recvfrom                  45
   define syscall_sendmsg                   46
   define syscall_recvmsg                   47
   define syscall_shutdown                  48
   define syscall_bind                      49
   define syscall_listen                    50
   define syscall_getsockname               51
   define syscall_getpeername               52
   define syscall_socketpair                53
   define syscall_setsockopt                54
   define syscall_getsockopt                55
   define syscall_clone                     56
   define syscall_fork                      57
   define syscall_vfork                     58
   define syscall_execve                    59

   define syscall_exit                      60

   define syscall_wait4                     61
   define syscall_kill                      62
   define syscall_uname                     63
   define syscall_semget                    64
   define syscall_semop                     65
   define syscall_semctl                    66
   define syscall_shmdt                     67
   define syscall_msgget                    68
   define syscall_msgsnd                    69
   define syscall_msgrcv                    70
   define syscall_msgctl                    71
   define syscall_fcntl                     72
   define syscall_flock                     73
   define syscall_fsync                     74
   define syscall_fdatasync                 75
   define syscall_truncate                  76
   define syscall_ftruncate                 77
   define syscall_getdents                  78
   define syscall_getcwd                    79
   define syscall_chdir                     80
   define syscall_fchdir                    81
   define syscall_rename                    82
   define syscall_mkdir                     83
   define syscall_rmdir                     84
   define syscall_creat                     85
   define syscall_link                      86
   define syscall_unlink                    87
   define syscall_symlink                   88
   define syscall_readlink                  89
   define syscall_chmod                     90
   define syscall_fchmod                    91
   define syscall_chown                     92
   define syscall_fchown                    93
   define syscall_lchown                    94
   define syscall_umask                     95
   define syscall_gettimeofday              96
   define syscall_getrlimit                 97
   define syscall_getrusage                 98
   define syscall_sysinfo                   99
   define syscall_times                     100
   define syscall_ptrace                    101
   define syscall_getuid                    102
   define syscall_syslog                    103
   define syscall_getgid                    104
   define syscall_setuid                    105
   define syscall_setgid                    106
   define syscall_geteuid                   107
   define syscall_getegid                   108
   define syscall_setpgid                   109
   define syscall_getppid                   110
   define syscall_getpgrp                   111
   define syscall_setsid                    112
   define syscall_setreuid                  113
   define syscall_setregid                  114
   define syscall_getgroups                 115
   define syscall_setgroups                 116
   define syscall_setresuid                 117
   define syscall_getresuid                 118
   define syscall_setresgid                 119
   define syscall_getresgid                 120
   define syscall_getpgid                   121
   define syscall_setfsuid                  122
   define syscall_setfsgid                  123
   define syscall_getsid                    124
   define syscall_capget                    125
   define syscall_capset                    126
   define syscall_rt_sigpending             127
   define syscall_rt_sigtimedwait           128
   define syscall_rt_sigqueueinfo           129
   define syscall_rt_sigsuspend             130
   define syscall_sigaltstack               131
   define syscall_utime                     132
   define syscall_mknod                     133
   define syscall_uselib                    134
   define syscall_personality               135
   define syscall_ustat                     136
   define syscall_statfs                    137
   define syscall_fstatfs                   138
   define syscall_sysfs                     139
   define syscall_getpriority               140
   define syscall_setpriority               141
   define syscall_sched_setparam            142
   define syscall_sched_getparam            143
   define syscall_sched_setscheduler        144
   define syscall_sched_getscheduler        145
   define syscall_sched_get_priority_max    146
   define syscall_sched_get_priority_min    147
   define syscall_sched_rr_get_interval     148
   define syscall_mlock                     149
   define syscall_munlock                   150
   define syscall_mlockall                  151
   define syscall_munlockall                152
   define syscall_vhangup                   153
   define syscall_modify_ldt                154
   define syscall_pivot_root                155
   define syscall__sysctl                   156
   define syscall_prctl                     157
   define syscall_arch_prctl                158
   define syscall_adjtimex                  159
   define syscall_setrlimit                 160
   define syscall_chroot                    161
   define syscall_sync                      162
   define syscall_acct                      163
   define syscall_settimeofday              164
   define syscall_mount                     165
   define syscall_umount2                   166
   define syscall_swapon                    167
   define syscall_swapoff                   168
   define syscall_reboot                    169
   define syscall_sethostname               170
   define syscall_setdomainname             171
   define syscall_iopl                      172
   define syscall_ioperm                    173
   define syscall_create_module             174
   define syscall_init_module               175
   define syscall_delete_module             176
   define syscall_get_kernel_syms           177
   define syscall_query_module              178
   define syscall_quotactl                  179
   define syscall_nfsservctl                180
   define syscall_getpmsg                   181
   define syscall_putpmsg                   182
   define syscall_afs_syscall               183
   define syscall_tuxcall                   184
   define syscall_security                  185
   define syscall_gettid                    186
   define syscall_readahead                 187
   define syscall_setxattr                  188
   define syscall_lsetxattr                 189
   define syscall_fsetxattr                 190
   define syscall_getxattr                  191
   define syscall_lgetxattr                 192
   define syscall_fgetxattr                 193
   define syscall_listxattr                 194
   define syscall_llistxattr                195
   define syscall_flistxattr                196
   define syscall_removexattr               197
   define syscall_lremovexattr              198
   define syscall_fremovexattr              199
   define syscall_tkill                     200
   define syscall_time                      201
   define syscall_futex                     202
   define syscall_sched_setaffinity         203
   define syscall_sched_getaffinity         204
   define syscall_set_thread_area           205
   define syscall_io_setup                  206
   define syscall_io_destroy                207
   define syscall_io_getevents              208
   define syscall_io_submit                 209
   define syscall_io_cancel                 210
   define syscall_get_thread_area           211
   define syscall_lookup_dcookie            212
   define syscall_epoll_create              213
   define syscall_epoll_ctl_old             214
   define syscall_epoll_wait_old            215
   define syscall_remap_file_pages          216
   define syscall_getdents64                217
   define syscall_set_tid_address           218
   define syscall_restart_syscall           219
   define syscall_semtimedop                220
   define syscall_fadvise64                 221
   define syscall_timer_create              222
   define syscall_timer_settime             223
   define syscall_timer_gettime             224
   define syscall_timer_getoverrun          225
   define syscall_timer_delete              226
   define syscall_clock_settime             227
   define syscall_clock_gettime             228
   define syscall_clock_getres              229
   define syscall_clock_nanosleep           230
   define syscall_exit_group                231
   define syscall_epoll_wait                232
   define syscall_epoll_ctl                 233
   define syscall_tgkill                    234
   define syscall_utimes                    235
   define syscall_vserver                   236
   define syscall_mbind                     237
   define syscall_set_mempolicy             238
   define syscall_get_mempolicy             239
   define syscall_mq_open                   240
   define syscall_mq_unlink                 241
   define syscall_mq_timedsend              242
   define syscall_mq_timedreceive           243
   define syscall_mq_notify                 244
   define syscall_mq_getsetattr             245
   define syscall_kexec_load                246
   define syscall_waitid                    247
   define syscall_add_key                   248
   define syscall_request_key               249
   define syscall_keyctl                    250
   define syscall_ioprio_set                251
   define syscall_ioprio_get                252
   define syscall_inotify_init              253
   define syscall_inotify_add_watch         254
   define syscall_inotify_rm_watch          255
   define syscall_migrate_pages             256
   define syscall_openat                    257
   define syscall_mkdirat                   258
   define syscall_mknodat                   259
   define syscall_fchownat                  260
   define syscall_futimesat                 261
   define syscall_newfstatat                262
   define syscall_unlinkat                  263
   define syscall_renameat                  264
   define syscall_linkat                    265
   define syscall_symlinkat                 266
   define syscall_readlinkat                267
   define syscall_fchmodat                  268
   define syscall_faccessat                 269
   define syscall_pselect6                  270
   define syscall_ppoll                     271
   define syscall_unshare                   272
   define syscall_set_robust_list           273
   define syscall_get_robust_list           274
   define syscall_splice                    275
   define syscall_tee                       276
   define syscall_sync_file_range           277
   define syscall_vmsplice                  278
   define syscall_move_pages                279
   define syscall_utimensat                 280
   define syscall_epoll_pwait               281
   define syscall_signalfd                  282
   define syscall_timerfd_create            283
   define syscall_eventfd                   284
   define syscall_fallocate                 285
   define syscall_timerfd_settime           286
   define syscall_timerfd_gettime           287
   define syscall_accept4                   288
   define syscall_signalfd4                 289
   define syscall_eventfd2                  290
   define syscall_epoll_create1             291
   define syscall_dup3                      292
   define syscall_pipe2                     293
   define syscall_inotify_init1             294
   define syscall_preadv                    295
   define syscall_pwritev                   296
   define syscall_rt_tgsigqueueinfo         297
   define syscall_perf_event_open           298
   define syscall_recvmmsg                  299
   define syscall_fanotify_init             300
   define syscall_fanotify_mark             301
   define syscall_prlimit64                 302
   define syscall_name_to_handle_at         303
   define syscall_open_by_handle_at         304
   define syscall_clock_adjtime             305
   define syscall_syncfs                    306
   define syscall_sendmmsg                  307
   define syscall_setns                     308
   define syscall_getcpu                    309
   define syscall_process_vm_readv          310
   define syscall_process_vm_writev         311
   define syscall_kcmp                      312
   define syscall_finit_module              313


   STDIN  = 0
   STDOUT = 1
   STDERR = 2

   open_read         = 0
   open_write        = 1
   open_readAndWrite = 2

   open_creat      = 0100o
   open_rewrite    = 1000o ;; rewrite if file exist
   open_append     = 2000o

   open_excl       = 0200o ;; ensure that THIS call creates the file
   open_noctty     = 0400o
   open_nonblock   = 4000o
   open_nondelay   = open_nonblock
   open_sync       = 10000o
   open_async      = 20000o
   open_direct     = 40000o
       ;; to minimize cache effects of the I/O to and from this file.
   open_largefile  = 100000o
   open_directory  = 200000o
   open_nofollow   = 400000o ;; If pathname is a symbolic link, then the open fails.
   #+end_src
** equ
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; in fasm, ``dup'' is a reserved word
   dup equ duplicate

   ;; 64-bits
   xx equ dq
   CellWidth equ 8
   #+end_src
** ASCII
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ASCII_backspace = 8
   ASCII_tab       = 9
   ASCII_linefeed  = 10
   ASCII_newline   = 10
   ASCII_esc       = 27
   ASCII_escape    = 27
   ASCII_space     = 32
   ASCII_delete    = 127
   #+end_src
** format header and entry
   #+begin_src fasm :tangle ../../play/cicada.fasm
   format elf64 executable 3
   entry cicada_virtual_machine
   #+end_src
* ==================================================
* *macro for cicada virtual machine*
** registers & pop & push
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; if you want to extend cicada in assembly,
   ;; the following four registers must not be used
   ;; =================================
   define NextWordPointer      r15
   define ReturnStackPointer   r14
   define ArgumentStackPointer r13
   define GreyPairStackPointer r12
   ;; =================================

   define ExplainerPointer     rax
   define TemporaryRegister    r11
   define TemporaryRegister2   r10


   macro pushReturnStack Register {
          sub ReturnStackPointer, CellWidth
          mov [ReturnStackPointer], Register
          }
   macro popReturnStack Register {
          mov Register, [ReturnStackPointer]
          add ReturnStackPointer, CellWidth
          }

   macro pushArgumentStack Register {
          sub ArgumentStackPointer, CellWidth
          mov [ArgumentStackPointer], Register
          }
   macro popArgumentStack Register {
          mov Register, [ArgumentStackPointer]
          add ArgumentStackPointer, CellWidth
          }


   ;; macro pushReturnStack Register {
   ;;    lea ReturnStackPointer, [ReturnStackPointer - CellWidth]
   ;;    mov [ReturnStackPointer], Register
   ;;    }
   ;; macro popReturnStack Register {
   ;;    mov Register, [ReturnStackPointer]
   ;;    lea ReturnStackPointer, [ReturnStackPointer + CellWidth]
   ;;    }

   ;; macro pushArgumentStack Register {
   ;;    lea ArgumentStackPointer, [ArgumentStackPointer - CellWidth]
   ;;    mov [ArgumentStackPointer], Register
   ;;    }
   ;; macro popArgumentStack Register {
   ;;    mov Register, [ArgumentStackPointer]
   ;;    lea ArgumentStackPointer, [ArgumentStackPointer + CellWidth]
   ;;    }
   #+end_src
** word-types & next
   1. every word-type needs a explainer (or elucidator)
   2. a explainer may explain more then one word-types
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; notations :
   ;; 1. ``the dictionary'' as a datastructure is a single-linked-list
   ;; 2. an entry in ``the dictionary'' is ``a word''
   ;; 3. ``a word'' as a datastructure looks like the following :
   ;;       (unit : CellWidth)
   ;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
   ;;    ||  m : name-string  ||
   ;;    ||  1 : SizeOfFunctionBody  ||
   ;;    ||  1 : identification  ||
   ;;    ||  1 : link  ||
   ;;    ||  1 : type  ||
   ;;    ||  1 : address-of-name-string-header  ||
   ;;    ||  1 : address-of-explainer  ||
   ;;    ||  n : body  ||
   ;; 4. so, I adopt two notations to represent ``a word'' :
   ;;    word[link]      == address in a word where the link is stored
   ;;    word[explainer] == address in a word where the address-of-explainer is stored
   ;;    word[explainer] == address in a word before the function-body
   ;;    word[explainer] == address in a word as the head of a function-body


   ;; note that:
   ;;   there are only two ways to jump to a explainer
   ;;   1. next
   ;;   2. execute


   ;; not matter what way you use to set :
   ;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
   ;; then :
   ;;   jmp qword[ExplainerPointer]
   ;; it will works just well !!!

   ;; specially, about ``next'',
   ;; the way we use to set :
   ;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
   ;; is to find the address-of-explainer by :
   ;;    NextWordPointer  == an address in a function-body
   ;;   [NextWordPointer] == word-to-jump[explainer]
   ;; so, NextWordPointer is all that ``next'' needed
   ;; set [NextWordPointer] == word-to-jump[explainer]  correctly
   ;; then call ``next''
   ;; it will works just well !!!


   ;; 1. this ``next'' do tail-call-optimization
   ;; 2. in the following FASM marco, anonymous label of FASM is used
   ;;    (of course, label in marco must be anonymous !)
   ;;    hence, when using anonymous labels in assembly,
   ;;    they can not across ``next'' !


   ;; macro next {
   ;;    ;== NEED:
   ;;    ;==     NextWordPointer  points at an address in a function-body
   ;;    ;==    [NextWordPointer] == word-to-jump[explainer]
   ;;    ;== CHNG:
   ;;    ;==     NextWordPointer  points at next address in a function-body
   ;;    ;==    [NextWordPointer] == new-word-to-jump[explainer]
   ;;    ;==     ExplainerPointer  points at the address in a word
   ;;    ;==                      where the address-of-explainer is stored
   ;;    ;==    [ExplainerPointer] == address-of-explainer (of word-to-jump)
   ;;    mov ExplainerPointer, [NextWordPointer]
   ;;    add NextWordPointer, CellWidth
   ;;    ;; why not: cmp qword[NextWordPointer], Exit  ???
   ;;    cmp dword[NextWordPointer], Exit
   ;;    ;-- IF: [NextWordPointer] =/= Exit
   ;;    jne @f
   ;;    ;-- EL: [NextWordPointer] == Exit
   ;;    popReturnStack NextWordPointer
   ;; @@:
   ;;    jmp qword[ExplainerPointer]
   ;;    }
   ;;    ;; maybe need more optimization,
   ;;    ;; for the above ``popReturnStack NextWordPointer'' may be
   ;;    ;; followed by ``pushReturnStack NextWordPointer'' (in explainFunctionBody)




   macro next {
     mov ExplainerPointer, [NextWordPointer]
     add NextWordPointer, CellWidth
     ;; mov TemporaryRegister2, Exit
     ;; cmp qword[NextWordPointer], TemporaryRegister2
     cmp dword[NextWordPointer], Exit
     je @f
     cmp dword[NextWordPointer], 已矣
     je @f
     jmp qword[ExplainerPointer]
   @@:
     popReturnStack NextWordPointer
     jmp qword[ExplainerPointer]
     }



   ;; initial Link to point to NULL
   Link = 0



   macro defWord WordString, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   SizeOfFunctionBodyOf#Word:
           xx (EndOfFunctionBodyOf#Word - Word)/8 - 1
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainFunctionBody
   ;;--------------------------------------
           ;; here follows a list of word[explainer]
           }
   macro defWordEnd Word {
   EndOfFunctionBodyOf#Word:
   }


   ;; 1. if ``next'' meet ``Exit'',
   ;;    ``next'' will ``popReturnStack NextWordPointer''
   ;; 2. on the other hand,
   ;;    explainFunctionBody is the only explainer
   ;;    who ``pushReturnStack NextWordPointer''
   ;; 3. so, it is these two functions, ``next'' and ``explainFunctionBody'',
   ;;    which handle the nested function calls



   ;; assembly code have no explainer
   macro defCode WordString, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx AssemblerCodeOf#Word
   ;;--------------------------------------
   AssemblerCodeOf#Word:
           ;; here follows the assembly code
           }






   macro defVar WordString, InitialValue, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainVar
   ;;--------------------------------------
           xx InitialValue
   ;;--------------------------------------
           }





   macro defConst WordString, InitialValue, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainConst
   ;;--------------------------------------
           xx InitialValue
   ;;--------------------------------------
           }





   ;; in stack:
   ;;   string[address, length]
   ;; in memory:
   ;;   ||  1 : length  ||
   ;;   ||  n : string  ||
   macro defConstString WordString, ConstStringValue, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainConstString
   ;;--------------------------------------
           xx (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
   ;;--------------------------------------
   ConstStringValueOf#Word:
           db ConstStringValue
   EndOfConstStringValueOf#Word:
   ;;--------------------------------------
           }
   #+end_src
* *start cicada virtual machine*
** start
   #+begin_src fasm :tangle ../../play/cicada.fasm
   segment readable executable
   cicada_virtual_machine:

           cld ;; set DF = 0, then rsi and rdi are incremented

   ;; [rsp+8*0]=N           argc number of arguments
   ;; [rsp+8*1]             argv0 name of executable (e.g. ./a00)
   ;; [rsp+8*2]             argv1 (if any) - 1st param after name of executable
   ;; ...
   ;; [rsp+8*N]             argvN - Nth param
   ;; qword [rsp+8*(N+1)]=0 end of arguments
   ;; [rsp+8*(N+2)]         envp environment
   ;; ...
   ;; qword [rsp+....]=0    end of environment

       ;; the Address we want is stored in [rsp] but not rsp
       ;; because rsp is the standard-stack-pointer
       ;; the Address we want is pushed into the standard-stack

           ;; beware of the way
           ;;   to use the ``Const'' or ``Var'' in assembly

           mov [LinuxProgramHeaderAddress + CellWidth], rsp

           mov ArgumentStackPointer,   ArgumentStackTop
           mov GreyPairStackPointer, GreyPairStackTop
           mov ReturnStackPointer,   ReturnStackTop

           ;; initialize the variable ``Here''
           ;; to point at beginning of DataSegment
           mov TemporaryRegister, UserDataArea
           mov [Here + CellWidth], TemporaryRegister
           mov NextWordPointer, cicada_begin_thread

           next

   segment readable writeable
   cicada_begin_thread:

           xx initialize
           xx basicREPL
           ;; xx assemblyDebug

   defConst "LinuxProgramHeaderAddress", 0, LinuxProgramHeaderAddress

   ;; test:
   ;; LinuxProgramHeaderAddress fetch . cr
   ;; LinuxProgramHeaderAddress CellWidth 1 * + fetch
   ;;   20 printString cr
   ;; LinuxProgramHeaderAddress CellWidth 2 * + fetch
   ;;   3 printString cr
   #+end_src
** basic-REPL
   REPL for cicada is ``read execute (maybe print) loop''
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defWord "basic-REPL", basicREPL
          ;; (* unknown -- unknown *)
          xx TheReturnStackTop, resetReturnStackPointer
          xx TheArgumentStackTop, resetArgumentStackPointer
          xx readWordForRuntime
          xx executeWord
          xx branch, -3
          ;; must not end with Exit here
   defWordEnd basicREPL


   ;; defWord "execute-word", executeWord
   ;;    ;; (* string[address, length] -- unknown *)
   ;;    xx dup2, stringDenoteNumber?, false?branch, 4
   ;;    xx   number, drop
   ;;    xx   Exit
   ;;    xx find, dup, zero?branch, 4
   ;;    xx   wordLinkToWordExplainer, execute
   ;;    xx   Exit
   ;;    xx drop, printErrorInfoForExecuteWord
   ;;    xx Exit
   ;; defWordEnd executeWord


   defWord "execute-word", executeWord
          ;; (* string[address, length] -- unknown *)
          xx dup2, stringDenoteNumber?, false?branch, 4
          xx   number, drop
          xx   Exit
          xx dup2, find, dup, zero?branch, 6
          xx   xxswapx, drop2
          xx   wordLinkToWordExplainer, execute
          xx   Exit
          xx drop ;; drop zore
          xx Message_undefined_word, printString
          xx printString
          xx literal, ASCII_linefeed, writeChar
          xx Exit
   defWordEnd executeWord

   defConstString "Message:undefined-word", "   UNDEFINED WORD: ", Message_undefined_word
   #+end_src
* *initialize*
** initialize
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defWord "initialize", initialize
          ;; (* -- *)

          xx loadCoreFile

          xx Exit
   defWordEnd initialize
   #+end_src
** loadCoreFile
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defCode "load-core-file", loadCoreFile
          ;; (* -- *)
          mov rsi, LocationOfEnglishCore
          mov rdi, InputBuffer
          mov rcx, SizeOfEnglishCore
          rep movsb
          ;; reset [ReadingBoundary + CellWidth]
          mov [ReadingBoundary + CellWidth], rdi
          next

   align 16
   LocationOfEnglishCore:
      file 'english-core.ccd'
   SizeOfEnglishCore = ($ - LocationOfEnglishCore) ;; unit :: byte
   #+end_src
* *primitive functions*
** Var & Const
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defVar "Base", 10, Base
   defVar "Here",  0, Here

   defVar "first-word-in-dictionary", LinkOfTheLatestWordInAssembly , FirstWordInDictionary
   ;; note that:
   ;;   the above is LinkOfTheLatestWordInThisFile
   ;;   NOT TheLatestWordInThisFile

   ;; ------------------------------------------
   defConst "Cell-width", CellWidth, TheCellWidth

   defConst "Zero",  0, Zero
   defConst "One",   1, One
   defConst "Two",   2, Two
   defConst "Three", 3, Three
   defConst "Four",  4, Four
   defConst "Five",  5, Five
   defConst "Six",   6, Six
   defConst "Seven", 7, Seven
   defConst "Eight", 8, Eight
   defConst "Nine",  9, Nine
   defConst "Ten",  10, Ten

   defConst "False", 0, False
   defConst "True",  1, True

   defConst "Bin-base", 2,  BinBase
   defConst "Oct-base", 8,  OctBase
   defConst "Dec-base", 10, DecBase
   defConst "Hex-base", 16, HexBase
   defConst "Aph-base", 36, AphBase
   #+end_src
** special key words (with chinese support)
#+begin_src fasm :tangle ../../play/cicada.fasm
;; special key words are not functions
;; but all about defineFunction is to use old functions to make new function
;; so, more appropriately,
;; when using ``literal'' or ``branch''
;; we are making new functions,
;; in a way, which is different from function-composition.
;; hence :
;; 1. ``literal'' is a set of function,
;;    ``literal 666'' is a function in this set.
;;    or ``literal'' is a function
;;    which takes ``666'' as an argumt, and returns a function.
;; 2. ``branch'' by itself has no function-semantic.
;; 3. it is obvious that,
;;    how ``== false?branch 6 ... ...'' is a means
;;    to make new function out of old functions.
;; 4. note that to achieve the function-semantic,
;;    we have to constrain ourself when using these special key words,
;;    for example, ``infinite-loop'' built by ``branch''
;;    is definitely has no function-semantic.

defCode "literal", literal
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumentStack rax
   cmp dword[NextWordPointer], Exit
   je literal_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je literal_meet_Exit
   next
literal_meet_Exit:
   popReturnStack NextWordPointer
   next


defCode "branch", branch
   ;; usage(in assembly): xx branch, number
   ;; the number denotes an offset
   ;; the base point of the offset is the place where the number stored
   ;; note that: in the function branch, [NextWordPointer] = offset
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   cmp dword[NextWordPointer], Exit
   je branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je branch_meet_Exit
   next
branch_meet_Exit:
   popReturnStack NextWordPointer
   next


defCode "zero?branch", zero?branch
   ;; ( n -- )
   popArgumentStack rax
   test rax, rax
   jnz zero?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp zero?branch_help_toBranch
zero?branch_toBranch:
   add NextWordPointer, CellWidth
zero?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je zero?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je zero?branch_meet_Exit
   next
zero?branch_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "false?branch", false?branch
   ;; ( n -- )
   ;; false?branch is identical to zero?branch
   ;; but we can not use defWord to define false?branch by false?branch
   ;; for it is a special key word
   popArgumentStack rax
   test rax, rax
   jnz false?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp false?branch_help_toBranch
false?branch_toBranch:
   add NextWordPointer, CellWidth
false?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je false?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je false?branch_meet_Exit
   next
false?branch_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "notFalse?branch", notFalse?branch
   ;; ( n -- )
   popArgumentStack rax
   test rax, rax
   jz notFalse?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp notFalse?branch_help_toBranch
notFalse?branch_toBranch:
   add NextWordPointer, CellWidth
notFalse?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je notFalse?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je notFalse?branch_meet_Exit
   next
notFalse?branch_meet_Exit:
   popReturnStack NextWordPointer
   next
#+end_src
** chinese key words
#+begin_src fasm :tangle ../../play/cicada.fasm
defCode "即", 即
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumentStack rax
   cmp dword[NextWordPointer], Exit
   je 即_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 即_meet_Exit
   next
即_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "转", 转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   cmp dword[NextWordPointer], Exit
   je 转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 转_meet_Exit
   next
转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "零则转", 零则转
   ;; ( n -- )
   popArgumentStack rax
   test rax, rax
   jnz 零则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 零则转_help_去转
零则转_去转:
   add NextWordPointer, CellWidth
零则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 零则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 零则转_meet_Exit
   next
零则转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "假则转", 假则转
   ;; ( n -- )
   popArgumentStack rax
   test rax, rax
   jnz 假则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 假则转_help_去转
假则转_去转:
   add NextWordPointer, CellWidth
假则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 假则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 假则转_meet_Exit
   next
假则转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "非假则转", 非假则转
   ;; ( n -- )
   popArgumentStack rax
   test rax, rax
   jz 非假则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 非假则转_help_去转
非假则转_去转:
   add NextWordPointer, CellWidth
非假则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 非假则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 非假则转_meet_Exit
   next
非假则转_meet_Exit:
   popReturnStack NextWordPointer
   next
#+end_src
** stack processing
*** drop & dup
        #+begin_src fasm :tangle ../../play/cicada.fasm
         defCode "drop", drop
        ;; (* a -- *)
        popArgumentStack rax
        next

         defCode "drop2", drop2
        ;; (* a b -- *)
        popArgumentStack rax
        popArgumentStack rax
        next

         defCode "dup", dup
        ;; (* a -- a a *)
        mov  rax, [ArgumentStackPointer]
        pushArgumentStack rax
        next

         defCode "dup2", dup2
        ;; (* a b -- a b a b *)
        mov  rbx, [ArgumentStackPointer]
        mov  rax, [ArgumentStackPointer + CellWidth]
        pushArgumentStack rax
        pushArgumentStack rbx
        next
        #+end_src
*** over
        #+begin_src fasm :tangle ../../play/cicada.fasm
        defCode "over", over
       ;; (* a b -- a b | a *)
       mov  rax, [ArgumentStackPointer + CellWidth]
       pushArgumentStack rax
       next

        defCode "x|over|xx", xoverxx
       ;; (* a | b c -- a | b c | a *)
       mov  rax, [ArgumentStackPointer + (2 * CellWidth)]
       pushArgumentStack rax
       next

        defCode "xx|over|x", xxoverx
       ;; (* a b | c -- a b | c | a b *)
       mov  rax, [ArgumentStackPointer + (2 * CellWidth)]
       pushArgumentStack rax
       mov  rax, [ArgumentStackPointer + (2 * CellWidth)] ;; not (1 * CellWidth)
       pushArgumentStack rax
       next

        defCode "xx|over|xx", xxoverxx
       ;; (* a b | c d -- a b | c d | a b *)
       mov  rax, [ArgumentStackPointer + (3 * CellWidth)]
       pushArgumentStack rax
       mov  rax, [ArgumentStackPointer + (3 * CellWidth)] ;; not (2 * CellWidth)
       pushArgumentStack rax
       next

        defCode "x|over|xxx", xoverxxx
       ;; (* a | b c d -- a | b c d | a *)
       mov  rax, [ArgumentStackPointer + (3 * CellWidth)]
       pushArgumentStack rax
       next

        defCode "xx|over|xxxx", xxoverxxxx
       ;; (* a b | c d e f -- a b | c d e f | a b *)
       mov  rax, [ArgumentStackPointer + (5 * CellWidth)]
       pushArgumentStack rax
       mov  rax, [ArgumentStackPointer + (5 * CellWidth)] ;; not (4 * CellWidth)
       pushArgumentStack rax
       next
        #+end_src
*** tuck
        #+begin_src fasm :tangle ../../play/cicada.fasm
        defCode "tuck", tuck
       ;; (* a b -- b | a b *)
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rax
       pushArgumentStack rbx
       next

        defCode "x|tuck|xx", xtuckxx
       ;; (* a | b c -- b c | a | b c *)
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       next

        defCode "xx|tuck|x", xxtuckx
       ;; (* a b | c -- c | a b | c *)
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rcx
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       next

        defCode "xx|tuck|xx", xxtuckxx
       ;; (* a b | c d -- c d | a b | c d *)
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rcx
       pushArgumentStack rdx
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rdx
       next

        defCode "xxx|tuck|x", xxxtuckx
       ;; (* a b c | d -- d | a b c | d *)
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rdx
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rdx
       next
        #+end_src
*** swap
        #+begin_src fasm :tangle ../../play/cicada.fasm
        defCode "swap", swap
       ;; (* a b -- b a *)
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rax
       next

        defCode "x|swap|xx", xswapxx
       ;; (* a | b c -- b c | a *)
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rax
       next

        defCode "xx|swap|x", xxswapx
       ;; (* a b | c -- c | a b *)
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rcx
       pushArgumentStack rax
       pushArgumentStack rbx
       next

        defCode "x|swap|xxx", xswapxxx
       ;; (* a | b c d -- b c d | a *)
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rdx
       pushArgumentStack rax
       next

        defCode "xxx|swap|x", xxxswapx
       ;; (* a b c | d -- d | a b c *)
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rdx
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       next

        defCode "xx|swap|xx", xxswapxx
       ;; (* a b | c d -- c d | a b *)
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rcx
       pushArgumentStack rdx
       pushArgumentStack rax
       pushArgumentStack rbx
       next


        defCode "x|swap|xxxx", xswapxxxx
       ;; (* a | b c d e -- b c d e | a *)
       popArgumentStack r8 ;; e
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rdx
       pushArgumentStack r8 ;; e
       pushArgumentStack rax
       next

        defCode "xxxx|swap|x", xxxxswapx
       ;; (* a b c d | e --  e | a b c d *)
       popArgumentStack r8 ;; e
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack r8 ;; e
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rdx
       next


        defCode "xx|swap|xxxx", xxswapxxxx
       ;; (* a b | c d e f -- c d e f | a b *)
       popArgumentStack r9 ;; f
       popArgumentStack r8 ;; e
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack rcx
       pushArgumentStack rdx
       pushArgumentStack r8 ;; e
       pushArgumentStack r9 ;; f
       pushArgumentStack rax
       pushArgumentStack rbx
       next

        defCode "xxxx|swap|xx", xxxxswapxx
       ;; (* a b c d | e f --  e f | a b c d *)
       popArgumentStack r9 ;; f
       popArgumentStack r8 ;; e
       popArgumentStack rdx
       popArgumentStack rcx
       popArgumentStack rbx
       popArgumentStack rax
       pushArgumentStack r8 ;; e
       pushArgumentStack r9 ;; f
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       pushArgumentStack rdx
       next
        #+end_src
*** ohters
        #+begin_src fasm :tangle ../../play/cicada.fasm
        defCode "|123->321|", abcTOcba
       popArgumentStack rax
       popArgumentStack rbx
       popArgumentStack rcx
       pushArgumentStack rax
       pushArgumentStack rbx
       pushArgumentStack rcx
       next
        #+end_src
** fixnum
       #+begin_src fasm :tangle ../../play/cicada.fasm
       defCode "add1", add1
          ;; (* n -- n+1 *)
          inc qword[ArgumentStackPointer]
          next

       defCode "add2", add2
          ;; (* n -- n+1 *)
          add qword[ArgumentStackPointer], 2
          next

       defCode "add3", add3
          ;; (* n -- n+1 *)
          add qword[ArgumentStackPointer], 3
          next

       defCode "add4", add4
          ;; (* n -- n+4 *)
          add qword[ArgumentStackPointer], 4
          next

       defCode "add8", add8
          ;; (* n -- n+8 *)
          add qword[ArgumentStackPointer], 8
          next


       defCode "sub1", sub1
          ;; (* n -- n-1 *)
          dec qword[ArgumentStackPointer]
          next

       defCode "sub2", sub2
          ;; (* n -- n-1 *)
          sub qword[ArgumentStackPointer], 2
          next

       defCode "sub3", sub3
          ;; (* n -- n-1 *)
          sub qword[ArgumentStackPointer], 3
          next

       defCode "sub4", sub4
          ;; (* n -- n-4 *)
          sub qword[ArgumentStackPointer], 4
          next

       defCode "sub8", sub8
          ;; (* n -- n-8 *)
          sub qword[ArgumentStackPointer], 8
          next


       defCode "+", addition
          ;; (* a b -- a+b *)
          popArgumentStack rax
          add qword[ArgumentStackPointer], rax
          next

       defCode "-", subtraction
          ;; (* a b -- a-b *)
          popArgumentStack rax
          sub qword[ArgumentStackPointer], rax
          next

       defCode "*", multiple
          ;; (* a b -- a*b *)
          popArgumentStack  rbx ;; 2ed arg
          popArgumentStack  rax ;; 1st arg
          imul rbx, rax
          ;; imul will ignore overflow
          ;; when there are two registers as arg
          ;; imul will save the result into the first register
          pushArgumentStack rbx
          next

       defCode "mod/", moddiv
          ;; (* a, b -- a mod b, quotient *)
          ;; (* dividend, divisor -- remainder, quotient *)
          ;; the arg of idiv is divisor
          ;; the lower half of dividend is taken from rax
          ;; the upper half of dividend is taken from rdx
          xor  rdx, rdx   ;; high-part of dividend is not used
          popArgumentStack  rbx ;; 2ed arg
          popArgumentStack  rax ;; 1st arg
          idiv rbx
          ;; the remainder is stored in rdx
          ;; the quotient  is stored in rax
          pushArgumentStack rdx ;; remainder
          pushArgumentStack rax ;; quotient
          next
       #+end_src
** memory
       #+begin_src fasm :tangle ../../play/cicada.fasm
       ;; ``save'' and ``fetch'' default to a CellWidth (== 8 bytes)
       ;; the rule of ``fetch2'' and so on are:
       ;;   in memory:
       ;;     ||  1 : value-1  ||
       ;;     ||  1 : value-2  ||
       ;;     ||  1 : value-3  ||
       ;;     ...
       ;;   on stack:
       ;;     [ ... , value-3, value-2, value-1]
       ;; of course we have:
       ;;   fetch2 : memory=copy=>stack
       ;;   save2  : stack->memory

       defCode "save", save
          ;; ( value, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          mov qword[rbx], rax
          next

       defCode "save2", save2
          ;; ( value-2, value-1, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          mov qword[rbx], rax
          popArgumentStack rax
          mov qword[rbx + CellWidth], rax
          next



       defCode "fetch", fetch
          ;; ( address -- value )
          popArgumentStack  rbx
          mov rax, qword[rbx]
          pushArgumentStack rax
          next

       defCode "fetch2", fetch2
          ;; ( address -- value-1, value-2 )
          popArgumentStack  rbx
          mov rax, qword[rbx + CellWidth]
          pushArgumentStack rax
          mov rax, qword[rbx]
          pushArgumentStack rax
          next



       defCode "add-save", addSave
          ;; ( number to add, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          add qword[rbx], rax
          next

       defCode "sub-save", subSave
          ;; ( number to add, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          sub qword[rbx], rax
          next


       defCode "save-byte", saveByte
          ;; ( value, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          mov byte[rbx], al
          next

       defCode "save-two-bytes", saveTwoBytes
          ;; ( value, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          mov word [rbx], ax
          next

       defCode "save-four-bytes", saveFourBytes
          ;; ( value, address -- )
          popArgumentStack rbx
          popArgumentStack rax
          mov dword [rbx], eax
          next


       defCode "fetch-byte", fetchByte
          ;; ( address -- value )
          popArgumentStack rbx
          xor rax, rax
          mov al, byte[rbx]
          pushArgumentStack rax
          next

       defCode "fetch-two-bytes", fetchTwoBytes
          ;; ( address -- value )
          popArgumentStack rbx
          xor rax, rax
          mov ax, word[rbx]
          pushArgumentStack rax
          next

       defCode "fetch-four-bytes", fetchFourBytes
          ;; ( address -- value )
          popArgumentStack rbx
          xor rax, rax
          mov eax, dword[rbx]
          pushArgumentStack rax
          next




       defCode "copy-byte", copyByte
          ;; ( source address, destination address --
          ;;   source address + 1, destination address + 1 )
          mov rbx, [ArgumentStackPointer + CellWidth] ;; source address
          mov al,  byte[rbx]                        ;; get a char from source address
          popArgumentStack rdi                        ;; destination address
          stosb                                     ;; copy to destination
          pushArgumentStack rdi                       ;; destination address is incremented by stosb
          inc qword[ArgumentStackPointer + CellWidth] ;; increment source address
          next

       defCode "copy-byte-string", copyByteString
          ;; ( source address, destination address, length -- )
          popArgumentStack rcx
          popArgumentStack rdi
          popArgumentStack rsi
          rep movsb
          next
       #+end_src
** string
       #+begin_src fasm :tangle ../../play/cicada.fasm
       ;; return false when length == 0
       defCode "compare-string?", compareString?
          ;; (* address of string-1, address of string-2, length -- True or False *)
          popArgumentStack rcx
          popArgumentStack rdi
          popArgumentStack rsi
          repe cmpsb
          sete al
          movzx rax, al
          pushArgumentStack rax
          next

       defWord "equal-string?", equalString?
          ;; (* string-1[address-1, length-1], string-2[address-2, length-2]
          ;;   -- True or False *)
          xx xoverxx, equal?, false?branch, 4
          xx swap, compareString?, Exit
          xx drop, drop, drop, False
          xx Exit
       defWordEnd equalString?
       #+end_src
** predicates
       1. 0 as False
          1 as True
       2. there can not be bool-type in low-level forth-like-language
       3. ``notFalse?'' is NOT ``true?''
       4. ``false?'' is ``zero?''
          ``true?'' is ``one?''
       #+begin_src fasm :tangle ../../play/cicada.fasm
       defCode "==", equal?
          popArgumentStack rbx
          popArgumentStack rax
          cmp   rbx, rax
          sete  al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode "=/=", notEqual?
          popArgumentStack rbx
          popArgumentStack rax
          cmp   rbx, rax
          setne al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode "<", lessThan?
          popArgumentStack rbx
          popArgumentStack rax
          cmp   rax, rbx
          setl  al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode ">", greaterThan?
          popArgumentStack   rbx
          popArgumentStack   rax
          cmp   rax, rbx
          setg  al
          movzx rax, al
          pushArgumentStack  rax
          next

       defCode "<=", lessOrEqual?
          popArgumentStack rbx
          popArgumentStack rax
          cmp   rax, rbx
          setle al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode ">=", greaterOrEqual?
          popArgumentStack rbx
          popArgumentStack rax
          cmp   rax, rbx
          setge al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode "zero?", zero?
          popArgumentStack rax
          test  rax,rax
          setz  al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode "not-zero?", notZero?
          popArgumentStack rax
          test  rax,rax
          setnz al
          movzx rax, al
          pushArgumentStack rax
          next


       defWord "one?", one?
          xx One, equal?
          xx Exit
       defWordEnd one?

       defWord "true?", true?
          xx one?
          xx Exit
       defWordEnd true?

       defWord "false?", false?
          xx zero?
          xx Exit
       defWordEnd false?
       #+end_src
** bitwise operations
       1. ``bitwiseAnd'' and ``bitwiseOr'' handle 64 bits value
       2. x y bitwiseAnd
          ==
          x bitwiseInvert y bitwiseInvert bitwiseOr bitwiseInvert
       #+begin_src fasm :tangle ../../play/cicada.fasm
       defCode "bitwise-and", bitwiseAnd
          ;; ( a, b -- a and b )
          popArgumentStack rbx
          and [ArgumentStackPointer], rbx
          next

       defCode "bitwise-or", bitwiseOr
          ;; ( a, b -- a or b )
          popArgumentStack rbx
          or  [ArgumentStackPointer], rbx
          next

       defCode "bitwise-xor", bitwiseXor
          ;; ( a, b -- a xor b )
          popArgumentStack rbx
          xor [ArgumentStackPointer], rbx
          next

       defCode "bitwise-invert", bitwiseInvert
          ;; ( a -- invert a )
          not qword[ArgumentStackPointer]
          next
       #+end_src
** single bit operations
       1. offset is of LSB
       2. offset in [0, ..., 63]
       3. step   in [1, ..., 64]
       #+begin_src fasm :tangle ../../play/cicada.fasm
       ;; BT copies a bit from a given register to the carry flag
       defCode "fetch-bit", fetchBit
          ;; ( fixnum, offset -- bit )
          popArgumentStack rbx
          popArgumentStack rax
          bt rax, rbx
          setc al
          movzx rax, al
          pushArgumentStack rax
          next

       defCode "set-bit", setBit
          ;; ( fixnum, offset -- fixnum )
          popArgumentStack rbx
          popArgumentStack rax
          bts rax, rbx
          pushArgumentStack rax
          next

       defCode "clear-bit", clearBit
          ;; ( fixnum, offset -- fixnum )
          popArgumentStack rbx
          popArgumentStack rax
          btr rax, rbx
          pushArgumentStack rax
          next

       defCode "invert-bit", invertBit
          ;; ( fixnum, offset -- fixnum )
          popArgumentStack rbx
          popArgumentStack rax
          btc rax, rbx
          pushArgumentStack rax
          next



       ;; "bsf" "bsr"
       ;; instructions scan a word or double word for first set bit
       ;; and store the index of this bit into destination operand
       ;; which must be general register
       ;; The bit string being scanned is specified by source operand
       ;; it may be either general register or memory
       ;; The ZF flag is set if the entire string is zero (no set bits are found)
       ;; otherwise it is cleared

       ;; If no set bit is found
       ;; the value of the destination register is undefined
       ;; "bsf" scans from low order to high order (starting from bit index zero)
       ;; "bsr" scans from high order to low order


       ;; note that:
       ;; if can not find ``SetBit''
       ;; the following functions will return -1

       defCode "find-lowest-set-bit", findLowestSetBit
          ;; ( fixnum -- offset )
          popArgumentStack rax
          bsf rax, rax
          jz tryToFindLowestSetBit_But_NoSetBitIsFound
          pushArgumentStack rax
          next
       tryToFindLowestSetBit_But_NoSetBitIsFound:
          mov rax, -1
          pushArgumentStack rax
          next

       defCode "find-highest-set-bit", findHighestSetBit
          ;; ( fixnum -- offset )
          popArgumentStack rax
          bsr rax, rax
          jz tryToFindHighestSetBit_But_NoSetBitIsFound
          pushArgumentStack rax
          next
       tryToFindHighestSetBit_But_NoSetBitIsFound:
          mov rax, -1
          pushArgumentStack rax
          next
       #+end_src
** bits shift & rotate
       #+begin_src fasm :tangle ../../play/cicada.fasm
       ;; "shl"
       ;; shifts the destination operand left
       ;; by the number of bits specified in the second operand
       ;; The destination operand can be general register or memory
       ;; The second operand can be an immediate value or the CL register
       ;; as bits exit from the left, zeros in from the right
       ;; The last bit that exited is stored in CF
       ;; "sal" is a synonym for "shl"
       defCode "shift-left", shiftLeft
          ;; ( fixnum, step -- fixnum * 2^step )
          popArgumentStack rcx
          shl qword[ArgumentStackPointer], cl
          next

       defCode "shift-right", shiftRight
          ;; ( fixnum, step -- fixnum / 2^step )
          popArgumentStack rcx
          shr qword[ArgumentStackPointer], cl
          next

       defCode "shift-right-preserve-sign", shiftRightPreserveSign
          ;; ( fixnum, step -- new fixnum )
          popArgumentStack rcx
          sar qword[ArgumentStackPointer], cl
          next



       ;; note that:
       ;; ``double'' is 128 bit value here

       ;; "shld"
       ;; shifts bits of the destination operand to the left
       ;; by the number of bits specified in third operand,
       ;; while shifting
       ;; move high order bits from the source operand
       ;; into the destination operand on the right.
       ;; The source operand remains unmodified.
       ;; The destination operand can be a word or double word general register or memory,
       ;; the source operand must be a general register,
       ;; third operand can be an immediate value or the CL register.
       defCode "double-shift-left", doubleShiftLeft
          ;; ( fixnum-1, fixnum-2, step --
          ;;   new fixnum-1, new fixnum-2 )
          popArgumentStack rcx
          popArgumentStack rax
          shld qword[ArgumentStackPointer], rax, cl
          shl rax, cl
          pushArgumentStack rax
          next


       ;; "shrd"
       ;; shifts bits of the destination operand to the right,
       ;; while shifting
       ;; move low order bits from the source operand
       ;; into the destination operand on the left.
       ;; The source operand remains unmodified.
       ;; Rules for operands are the same as for the "shld" instruction.
       defCode "double-shift-right", doubleShiftRight
          ;; ( fixnum-1, fixnum-2, step --
          ;;   new fixnum-1, new fixnum-2 )
          popArgumentStack rcx
          popArgumentStack rbx
          popArgumentStack rax
          shrd rbx, rax, cl
          shr rax, cl
          pushArgumentStack rax
          pushArgumentStack rbx
          next

       defCode "double-shift-right-preserve-sign", doubleShiftRightPreserveSign
          ;; ( fixnum-1, fixnum-2, step --
          ;;   new fixnum-1, new fixnum-2 )
          popArgumentStack rcx
          popArgumentStack rbx
          popArgumentStack rax
          shrd rbx, rax, cl
          sar rax, cl
          pushArgumentStack rax
          pushArgumentStack rbx
          next




       defCode "rotate-left", rotateLeft
          ;; ( fixnum, step -- new fixnum )
          popArgumentStack rcx
          rol qword[ArgumentStackPointer], cl
          next

       defCode "rotate-right", rotateRight
          ;; ( fixnum, step -- new fixnum )
          popArgumentStack rcx
          ror qword[ArgumentStackPointer], cl
          next
       #+end_src
** about ReturnStack
       #+begin_src fasm :tangle ../../play/cicada.fasm
       defCode "push-return-stack", toPushReturnStack
          ;; (* address --> ReturnStack: address *)
          popArgumentStack  rax
          pushReturnStack rax
          next

       defCode "pop-return-stack", toPopReturnStack
          ;; (* ReturnStack: address --> address *)
          popReturnStack  rax
          pushArgumentStack rax
          next

       ;; up to now
       ;; the above two class classic forth words
       ;; have not been used by cicada yet


       defCode "fetch-return-stack-pointer", fetchReturnStackPointer
          ;; (* -- an address in the ReturnStack *)
          pushArgumentStack ReturnStackPointer
          next

       defCode "reset-return-stack-pointer", resetReturnStackPointer
          ;; (* an address in the ReturnStack -- *)
          popArgumentStack ReturnStackPointer
          next

       defCode "drop-return-stack", dropReturnStack
          ;; (* -- *)
          add ReturnStackPointer, CellWidth
          next
       #+end_src
** about ArgumentStack
       #+begin_src fasm :tangle ../../play/cicada.fasm
       ;; to know why the following funny thing happens,
       ;; see the definition of the macro ``pushArgumentStack'',
       defCode "make-self-reference-value", makeSelfReferenceValue
          ;; ( -- address )
          pushArgumentStack ArgumentStackPointer
          next

       defWord "fetch-argument-stack-pointer", fetchArgumentStackPointer
          xx makeSelfReferenceValue, add8, Exit
       defWordEnd fetchArgumentStackPointer

       defCode "reset-argument-stack-pointer", resetArgumentStackPointer
          ;; ( address -- )
          popArgumentStack ArgumentStackPointer
          next
       #+end_src
** about GreyPairStack
       #+begin_src fasm :tangle ../../play/cicada.fasm
       defCode "push-grey-pair-stack", pushGreyPairStack
          ;; (* pair[address] --> GreyPairStack: pair[address] *)
          popArgumentStack rax
          lea GreyPairStackPointer, [GreyPairStackPointer - CellWidth]
          mov [GreyPairStackPointer], rax
          next

       defCode "pop-grey-pair-stack", popGreyPairStack
          ;; (* GreyPairStack: pair[address] --> pair[address] *)
          mov rax, [GreyPairStackPointer]
          lea GreyPairStackPointer, [GreyPairStackPointer + CellWidth]
          pushArgumentStack rax
          next

       defCode "empty-grey-pair-stack?", emptyGreyPairStack?
          ;; (* -- True or False *)
          mov rax, GreyPairStackTop
          cmp GreyPairStackPointer, rax
          ;; note that:
          ;; GreyPairStackPointer >= GreyPairStackTop
          ;; means stack over flow
          setge al
          movzx rax, al
          pushArgumentStack rax
          next
       #+end_src
** WordList
       WordList is returned by readWordListForLexicographer
       #+begin_src fasm :tangle ../../play/cicada.fasm
       defCode "tail-of-word-list", tailOfWordList
          ;; (* wordList[address, the number of words] --
          ;;    wordList[new address, number - 1] *)
          popArgumentStack rcx
          popArgumentStack rsi
          lodsq
          add rsi, rax
          pushArgumentStack rsi
          dec rcx
          pushArgumentStack rcx
          next

       defCode "head-of-word-list", headOfWordList
          ;; (* wordList[address, the number of words] --
          ;;    wordString[address, length] *)
          popArgumentStack rbx ;; do not need this arg
          popArgumentStack rsi
          mov rcx, qword[rsi]
          add rsi, CellWidth
          pushArgumentStack rsi
          pushArgumentStack rcx
          next

       defWord "tail-and-head-of-word-list", tailAndHeadOfWordList
          ;; (* wordList[address, the number of words] --
          ;;    wordList[new address, number - 1], wordString[address, length] *)
          xx dup2
          xx tailOfWordList
          xx xxswapxx
          xx headOfWordList
          xx Exit
       defWordEnd tailAndHeadOfWordList
       #+end_src
* *the dictionary & the lexicographer*
** note
   1. there are many lexicographers,
      they work together to define words into the dictionary
   2. to create a new word is to use some words to describe the new word,
      and set an explainer to explain the description of the new word.
   3. to define a new word,
      we just need to add the new created word to the dictionary.
   4. when someone try to find a word in the dictionary,
      the explainer of that word explains the word for him
   5. due to the constrain of fasm's syntax,
      the ``names'' of some words varys between fasm and forth
      here are some warnings:
      1) for syntax sugar :
         defWord ":", readWordListForLexicographer
         defCode "x|swap|xx", xswapxx
         defWord ".", printLittleNumber
      2) for already used label-name :
         defConst "ReturnStackTop", ReturnStackTop, TheReturnStackTop
** explainers & execute & Exit
   #+begin_src fasm :tangle ../../play/cicada.fasm
   segment readable executable
   explainVar:
      ;; ( -- address )
      add ExplainerPointer, CellWidth
      pushArgumentStack ExplainerPointer
      next

   segment readable executable
   explainConst:
      ;; ( -- value )
      add ExplainerPointer, CellWidth
      mov TemporaryRegister, [ExplainerPointer]
      pushArgumentStack TemporaryRegister
      next

   segment readable executable
   explainFunctionBody:
      pushReturnStack NextWordPointer
      ;; to calculate the address in a word where the function-body is stored
      ;; this address is as an ``argumt'' of explainFunctionBody
      add ExplainerPointer, CellWidth
      mov NextWordPointer, ExplainerPointer
      next

   segment readable executable
   explainConstString:
      ;; ( -- string[address, length] )
      add ExplainerPointer, CellWidth
      mov TemporaryRegister, [ExplainerPointer]
      add ExplainerPointer, CellWidth
      pushArgumentStack ExplainerPointer
      pushArgumentStack TemporaryRegister
      next



   defCode "execute", execute
     ;; ( word[address of explainer] -- )
     popArgumentStack ExplainerPointer
     jmp qword[ExplainerPointer]

   ;; not matter what way you use to set :
   ;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
   ;; then :
   ;;   jmp qword[ExplainerPointer]
   ;; it will works just well !!!




   ;; the following Exit helps tail-call-optimization
   ;; it just let you decide where is the end of FunctionBody
   ;; in a FunctionBody, the ``Exit'' as a word will never be called
   defConst "Exit", Exit, Exit
   defConst "已矣", 已矣, 已矣
   ;; (* so, the following numbers are the same :
   ;;   Exit
   ;;   readWord Exit find wordLinkToWordExplainer
   ;;   *)

   defConst "Function-body-explainer",   explainFunctionBody, FunctionBodyExplainer
   defConst "Variable-explainer",        explainVar,          VarExplainer
   defConst "Constant-explainer",        explainConst,        ConstExplainer
   defConst "Constant-string-explainer", explainConstString,  ConstStringExplainer
   #+end_src
** find (dictionary look up)
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; recall
   ;; a word in the dictionary (unit : CellWidth = 8 bytes)
   ;; ==
   ;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
   ;;    ||  m : name-string  ||
   ;;    ||  1 : SizeOfFunctionBody  ||
   ;;    ||  1 : identification  ||
   ;;    ||  1 : link  ||
   ;;    ||  1 : type  ||
   ;;    ||  1 : address-of-name-string-header  ||
   ;;    ||  1 : address-of-explainer  ||
   ;;    ||  n : body  ||
   ;; where
   ;;   ||  1 : type  ||
   ;; ==
   ;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
   ;; type-bit-0 is for HiddenWord

   define WordType_HiddenMask 00000001h


   defWord "word-link->word-string", wordLinkToWordString
      ;; (* link[address] -- string[address, length] *)
      xx literal, CellWidth
      xx Two, multiple
      xx addition
      xx fetch
      xx dup, literal, CellWidth, addition
      xx swap, fetch
      xx Exit
   defWordEnd wordLinkToWordString

   defWord "help,find", help_find
      ;; (* wordString[address, length], link[address] -- word[address of link] or Zero *)
      xx dup, zero?, false?branch, 4
      xx   xxswapx, drop2
      xx   Exit
      xx xxtuckx, wordLinkToWordString, xxoverxx, equalString?, false?branch, 3
      xx   drop2
      xx   Exit
      xx xswapxx, fetch
      xx help_find
      xx Exit
   defWordEnd help_find

   defWord "find", find
      ;; (* wordString[address, length] -- word[address of link] or Zero *)
      xx FirstWordInDictionary, fetch
      xx help_find
      xx Exit
   defWordEnd find


   ;; usage;
   ;; 1 2 readWord + find wordLinkToWordExplainer execute . (* 3 *)
   defWord "word-link->word-explainer", wordLinkToWordExplainer
      ;; (* word[address of link] -- word[address of explainer] or Zero *)
      xx literal, CellWidth
      xx Three, multiple
      xx addition
      xx Exit
   defWordEnd wordLinkToWordExplainer
   #+end_src
** the basic lexicographer
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defWord "append-number-to-here", appendNumberToHere
      ;; (* a 64 bits number -- *)
      ;; reset ``Here'', which points next free memory
      xx Here, fetch
      xx save
      xx Here, fetch
      xx literal, CellWidth, addition
      xx Here ,save
      xx Exit
   defWordEnd appendNumberToHere

   ;; note that:
   ;; a string in stack is string[address, length]
   ;; a string in memory is ||  1 : length  ||  n : string  ||
   defWord "append-string-to-here", appendStringToHere
      ;; (* string[address, length] -- *)
      ;; leave a length behind, for update Here
      xx dup, xxswapx
      ;;   ||  1 : length  ||
      xx dup, appendNumberToHere
      ;;   ||  n : string  ||
      xx Here, fetch, swap, copyByteString
      ;; update Here
      xx Here, fetch, addition, Here, save
      xx Exit
   defWordEnd appendStringToHere

   defWord "create-word-header", createWordHeader
      ;; (* byString *)
      ;; (* string[address, length] -- word[address of link] *)
      xx Here, fetch, xxswapx ;; for address-of-name-string-header
      xx appendStringToHere
      xx Here, fetch, appendNumberToHere ;; (* identification *)
      xx Here, fetch ;; (* leave the word[link] *)
      xx Zero, appendNumberToHere ;; (* link *)
      xx Zero, appendNumberToHere ;; (* type *)
      xx swap
      xx appendNumberToHere ;; address-of-name-string-header
      xx Exit
   defWordEnd createWordHeader


   defWord "create-word-header-for-function", createWordHeaderForFunction
      ;; (* string[address, length] -- word[address of link] *)
      xx Here, fetch, xxswapx ;; for address-of-name-string-header
      xx appendStringToHere
      xx Zero, appendNumberToHere ;; (* SizeOfFunctionBody *)
      xx Here, fetch, appendNumberToHere ;; (* identification *)
      xx Here, fetch ;; (* leave the word[link] *)
      xx Zero, appendNumberToHere ;; (* link *)
      xx Zero, appendNumberToHere ;; (* type *)
      xx swap
      xx appendNumberToHere ;; address-of-name-string-header
      xx Exit
   defWordEnd createWordHeaderForFunction



   defWord "append-word-description-to-here", appendWordDescriptionToHere
      ;; (* wordList[address, the number of words] -- *)
      xx dup, zero?branch, 16;-- GOTO: drop2
      xx tailAndHeadOfWordList
      xx dup2, stringDenoteNumber?
      xx false?branch, 6;-- GOTO: find
      ;; reading-error reported by ``number'' is not handled
      xx number, drop, appendNumberToHere
      xx branch, -12;-- GOTO: the beginning

      xx find, wordLinkToWordExplainer, appendNumberToHere
      xx branch, -17;-- GOTO: the beginning

      xx drop2
      xx Exit
   defWordEnd appendWordDescriptionToHere

   defWord "add-new-word-to-dictionary", addNewWordToDictionary
      ;; reset FirstWordInDictionary to point to the newly defined word
      ;; (* word[address of link] -- *)
      xx dup
      xx FirstWordInDictionary, fetch
      xx swap
      xx save
      xx FirstWordInDictionary, save
      xx Exit
   defWordEnd addNewWordToDictionary

   defWord "set-size-of-function-body", setSizeOfFunctionBody
      ;; (* wordList[address, the number of words], word[address of link] --
      ;;    wordList[address, the number of words], word[address of link] *)
      xx dup
      xx literal, CellWidth, subtraction
      xx literal, CellWidth, subtraction
      xx xoverxx
      xx swap
      xx save
      xx Exit
   defWordEnd setSizeOfFunctionBody

   defWord "define-function", defineFunction
      ;; (* wordList[address, the number of words] -- *)
      ;; to create a new word
      ;; is to use some words to describe the new word,
      ;; and let an explainer to explain the description of the new word.
      ;; to define a new word
      ;; is to add the new created word to the dictionary.
      xx tailAndHeadOfWordList
      xx createWordHeaderForFunction
      xx FunctionBodyExplainer, appendNumberToHere
      xx setSizeOfFunctionBody
      xx xxswapx
      xx appendWordDescriptionToHere
      xx addNewWordToDictionary
      xx Exit
   defWordEnd defineFunction
   #+end_src
* *IO*
** ioctl for terminal
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; /usr/include/asm-generic/termbits.h
   ;; /usr/include/asm-generic/ioctls.h

   VMIN = 6

   ICRNL   =       0000400o
   IXON    =       0002000o
   ICANON  =       0000002o
   ISIG    =       0000001o
   ECHO    =       0000010o


   segment readable writeable

   termios:
   termios.c_iflag:       rd 1
   termios.c_oflag:       rd 1
   termios.c_cflag:       rd 1
   termios.c_lflag:       rd 1
   termios.c_line:        rb 1
   termios.c_cc:          rb 19 ;; NCCS
   termios_size = ($ - termios)

   termios_orig:
   termios_orig.c_iflag:       rd 1
   termios_orig.c_oflag:       rd 1
   termios_orig.c_cflag:       rd 1
   termios_orig.c_lflag:       rd 1
   termios_orig.c_line:        rb 1
   termios_orig.c_cc:          rb 19 ;; NCCS


   ScreenSize:  rw 1


   defCode "set-terminal-to-read-key", setTerminalToReadKey
      ;; (* -- *)
      mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
      mov sys_2_rsi, 5401h        ;; TERMIOS_GET, TCGETS
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall

      mov rsi, termios_orig
      mov rdi, termios
      mov rcx, termios_size
      cld
      rep movsb

      mov byte [termios.c_cc + VMIN], 1
      ;; icanon off, isig (^C) off, echo off
      and byte [termios.c_lflag + 0], ((- ICANON) and (- ISIG) and (- ECHO))
      ;; ixon off,   icrnl off
      and byte [termios.c_iflag + 1], ((- (IXON shr 8)) or (- (ICRNL shr 8)))
      mov rdx, termios     ;; termios or WinSize structure ptr
      mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall
      next


   defCode "set-terminal-back-to-read-line", setTerminalBackToReadLine
      ;; (* -- *)
      mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
      mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall
      next


   defCode "get-screen-size", getScreenSize
      ;; (* -- rows, cols *)
      mov sys_3_rdx, ScreenSize
      ;; [ScreenSize] == for example col=88,row=26 :: 00880026
      mov sys_2_rsi, 5413h ;; TERMIOS_WSIZE, TIOCGWINSZ
      mov sys_1_rdi, STDIN
      mov sys_n_rax, syscall_ioctl
      syscall
      ;; xor rax, rax
      mov ax, word[ScreenSize]
      pushArgumentStack rax
      mov ax, word[ScreenSize + 2]
      pushArgumentStack rax
      next
   #+end_src
** readChar
   #+begin_src fasm :tangle ../../play/cicada.fasm
   SizeOfInputBuffer = 3*1024*1024

   segment readable writeable
   InputBuffer:
      rb SizeOfInputBuffer
   EndOfInputBuffer:


   defConst "Size-of-input-buffer",  SizeOfInputBuffer,  TheSizeOfInputBuffer
   defConst "Input-buffer",          InputBuffer,        TheInputBuffer
   defConst "End-of-input-buffer",   EndOfInputBuffer,   TheEndOfInputBuffer

   ;; 1. two global variables for reading
   ;;    I can easily support `evalString' by change these two variables
   ;; 2. note that, there is no char in the address of a ``ReadingBoundary''
   ;;    an example of ``ReadingBoundary'' is ``EndOfInputBuffer''
   ;; 3. when ``CurrentReading'' == ``ReadingBoundary''
   ;;    for the function ``readChar''
   ;;    we need to reset it to read from ``InputBuffer''
   ;;    and call ``inputLine'' to fetch more chars
   ;;    and loop back
   defVar "Current-reading",  InputBuffer, CurrentReading
   defVar "Reading-boundary", InputBuffer, ReadingBoundary

   defCode "read-char", readChar
      ;; read a char from stdin, return it into the ArgumentStack as following
      ;; (*  -- char *)
      ;; readChar calls the Linux read system call to fill InputBuffer
      ;; The other thing that readChar does is
      ;; if it detects that stdin has closed, it exits the program
      ;; which is why when you hit C-d, the system exits
      call _readChar
      ;; _readChar will save the return value in rax
      pushArgumentStack rax
      next
   _readChar:
      ;; TemporaryRegister is a helper-register for ``cmp''
      mov TemporaryRegister, [CurrentReading + CellWidth]
      cmp TemporaryRegister, [ReadingBoundary + CellWidth]
      ;-- IF: [CurrentReading + CellWidth] < [ReadingBoundary + CellWidth]
      ;-- WK: there is still some chars in the InputBuffer to be processed
      jl readChar_stillSomeChars
      ;-- EL: [CurrentReading + CellWidth] >= [ReadingBoundary + CellWidth]
      ;-- WK: all chars in InputBuffer have been processed
      mov rax, EndOfInputBuffer
      cmp TemporaryRegister, rax
      jg readChar_addBlankAtTheEnding
      mov rax, InputBuffer
      cmp TemporaryRegister, rax
      jl readChar_addBlankAtTheEnding
      jmp readChar_fetchMoreCharsFromStdinToInputBuffer
   readChar_addBlankAtTheEnding:
      ;; otherwise,  when the a string not ending with blank
      ;; `evalString' will not work correctly
      mov rax, InputBuffer
      mov [CurrentReading + CellWidth], rax
      mov [ReadingBoundary + CellWidth], rax
      xor rax, rax
      mov al, 10
      ret
   readChar_stillSomeChars:
      ;; for the following will just uses the al part of rax
      ;; it is necessary to clear rax
      xor rax, rax
      ;-- DO: fetch a char from InputBuffer to rax
      ;-- NT: after _readChar return rax will be pushArgumentStack
      mov al, byte[TemporaryRegister]
      ;-- DO: increment [CurrentReading + CellWidth]
      inc TemporaryRegister
      mov [CurrentReading + CellWidth], TemporaryRegister
      ret
   ;; note that, in the following subroutine
   ;; set [CurrentReading + CellWidth]  == InputBuffer
   ;; set [ReadingBoundary + CellWidth] == InputBuffer + length of string that was input (NULL not counted)
   readChar_fetchMoreCharsFromStdinToInputBuffer:
      ;; read to fetch more input chars from STDIN to InputBuffer
      mov sys_3_rdx,     SizeOfInputBuffer    ;; max length to be read
      mov sys_2_rsi,     InputBuffer        ;; buffer address
      ;; reset [CurrentReading + CellWidth] to InputBuffer
      mov [CurrentReading + CellWidth], sys_2_rsi
      xor sys_1_rdi,     sys_1_rdi          ;; stdin
      mov sys_n_rax,     syscall_read
      syscall
      ;; the return value of syscall read
      ;; is a count of the number of bytes transferred
      test rax, rax
      ;-- IF: rax <= 0
      ;-- WK: there is an error or it is end of input
      ;-- DO: exit
      jz readChar_exit
      js readChar_exit
      ;-- EL: rax > 0
      ;-- WK: there are some chars has been fetched by syscall read
      ;-- DO: set [ReadingBoundary + CellWidth] to the right place
      ;--     ReadingBoundary = InputBuffer + the count of the number of bytes transferred
      ;-- NT: sys_2_rsi = InputBuffer
      ;--     rax = the count of the number of bytes transferred
      add sys_2_rsi, rax
      mov [ReadingBoundary + CellWidth], sys_2_rsi
      ;-- DO: jump back
      jmp _readChar


   readChar_exit:
      ;; exit with exit code = the value syscall_read returned
      xor sys_1_rdi, sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall
   #+end_src
** writeChar
   #+begin_src fasm :tangle ../../play/cicada.fasm
   segment readable writeable
   ScratchUsedByWriteChar:
      rb 1

   defCode "write-char", writeChar
      ;; ( char --  ) write a char to stdin
      ;; just calls the Linux write system call
      popArgumentStack rax
      call writeChar_helperFunction
      next
   writeChar_helperFunction:
      mov sys_1_rdi, 1 ;; stdout
      ;; write can not just write the char in al to stdout
      ;; write needs the address of the byte to write
      mov [ScratchUsedByWriteChar], al
      mov sys_2_rsi, ScratchUsedByWriteChar  ;; address
      mov sys_3_rdx, 1                       ;; max length to be write, just 1
      mov sys_n_rax, syscall_write
      syscall
      ret
   #+end_src
** printString
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defWord "print-string", printString
      ;; (* string[address, length] -- *)
      xx dup, zero?, false?branch, 3
      xx   drop2
      xx   Exit
      xx sub1, swap
      xx dup, fetchByte, writeChar
      xx add1, swap
      xx branch, -14
   defWordEnd printString
   #+end_src
** word
*** readFirstNonBlankChar & readNonBlankChar
    #+begin_src fasm :tangle ../../play/cicada.fasm
    defWord "read-first-non-blank-char", readFirstNonBlankChar
       ;; (* -- FirstNonBlankChar *)
       xx readChar, dup
       xx literal, ASCII_space
       xx greaterThan?, false?branch, 2
       xx   Exit
       xx drop
       xx branch, -10
    defWordEnd readFirstNonBlankChar

    defWord "read-non-blank-char", readNonBlankChar
       ;; (* -- FirstNonBlankChar or Zero *)
       xx readChar, dup
       xx literal, ASCII_space
       xx greaterThan?, false?branch, 2
       xx   Exit
       xx drop
       xx Zero
       xx Exit
    defWordEnd readNonBlankChar
    #+end_src
*** readWord
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; note that, Subsequent calls will overwrite BufferForReadWord
    ;; this is why there is another function ``readWordForRuntime''
    MaxWordLength = 1024

    segment readable writeable
    BufferForReadWord:
       ;; note that, Subsequent calls will overwrite BufferForReadWord
       ;; this is why there is another function ``readWordForRuntime''
       rb MaxWordLength

    segment readable writeable
    BufferForReadWordForRuntime:
       ;; note that, Subsequent calls will overwrite BufferForReadWord
       ;; this is why there is another function ``readWordForRuntime''
       rb MaxWordLength

    defWord "read-word", readWord
       ;; (*  -- wordString[address, length] *)
       ;; 1. skips any blanks (spaces, tabs, newlines)
       ;; 2. calls readChar to read characters into BufferForReadWord
       ;;    until it hits a blank
       ;; 3. returns the address of BufferForReadWord and length on the stack

       xx literal, BufferForReadWord ;; (* leave return one of the values *)
       xx Zero                       ;; (* leave length counter *)

       xx literal, BufferForReadWord
       xx readFirstNonBlankChar
       xx over, saveByte, add1
       xx swap, add1, swap

       xx readNonBlankChar, dup, zero?branch, 9
       xx   over, saveByte, add1
       xx   swap, add1, swap
       xx   branch, -11

       xx drop2
       xx Exit
    defWordEnd readWord

    defWord "read-word-for-runtime", readWordForRuntime
       ;; (*  -- wordString[address, length] *)
       ;; 1. skips any blanks (spaces, tabs, newlines)
       ;; 2. calls readChar to read characters into BufferForReadWord
       ;;    until it hits a blank
       ;; 3. returns the address of BufferForReadWord and length on the stack

       xx literal, BufferForReadWordForRuntime ;; (* leave return one of the values *)
       xx Zero                                 ;; (* leave length counter *)

       xx literal, BufferForReadWordForRuntime
       xx readFirstNonBlankChar
       xx over, saveByte, add1
       xx swap, add1, swap

       xx readNonBlankChar, dup, zero?branch, 9
       xx   over, saveByte, add1
       xx   swap, add1, swap
       xx   branch, -11

       xx drop2
       xx Exit
    defWordEnd readWordForRuntime
    #+end_src
*** readStringInToBuffer
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; note that, Subsequent calls will overwrite BasicStringBuffer
    MaxStringLength = 1024*1024

    segment readable writeable
    BasicStringBuffer:
       ;; note that, Subsequent calls will overwrite BasicStringBuffer
       rb MaxStringLength

    defConst "Basic-string-buffer", BasicStringBuffer, TheBasicStringBuffer

    defWord "read-string-into-buffer", readStringInToBuffer
       ;; (*  -- string[address of BasicStringBuffer, length] *)
       xx literal, BasicStringBuffer ;; (* leave return one of the values *)
       xx Zero                         ;; (* leave length counter *)

       xx literal, BasicStringBuffer

       xx readChar, dup
       xx literal, 34 ;; ASCII_doublequote
       xx equal?, notFalse?branch, 9
       xx   over, saveByte, add1
       xx   swap, add1, swap
       xx   branch, -14

       xx drop2
       xx Exit
    defWordEnd readStringInToBuffer
    #+end_src
*** number
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; The function uses the variable "Base" as the radix
    ;; If the word starts with a '-' character then the returned value is negative

    ;; If the string can't be parsed as a number
    ;; or contains characters outside the current BASE
    ;; then we need to return an error indication.
    ;; So we let NUMBER returns two items on the stack.

    defCode "number", number
       ;; (* wordString[address, length] --
       ;;    parsed number, length of unparsed string *)
       popArgumentStack  rcx        ;; length  of string
       popArgumentStack  rdi        ;; address of string
       call number_helperFunction
       pushArgumentStack rax        ;; parsed number
       pushArgumentStack rcx        ;; length of unparsed string (0 = no error)
       next

    number_helperFunction:
       xor  rax, rax
       xor  rbx, rbx

       test rcx, rcx
       ;-- IF: rcx == 0
       ;-- WK: trying to parse a zero-length string, it is an error
       ;-- DO: but will return 0
       jz number_return
       ;-- EL: rcx =/= 0
       ;-- WK: we have a non-empty string to be parsed
       ;-- DO: parse this non-empty string
       ;; copy the the variable Base into dl (rdx)
       ;; the following shows how to use a forth-variable-word in assembler code
       mov rdx, [Base + CellWidth]
       ;; fetch a char
       mov bl,  byte[rdi]
       inc rdi
       ;; sign-indicater
       ;; top of ArgumentStack == 0,  indicating positive
       ;; top of ArgumentStack =/= 0, indicating negative
       ;; initialize sign-indicater
       pushArgumentStack rax     ;; top of ArgumentStack == 0, indicating positive
       cmp bl, '-'
       ;-- IF: bl =/= '-'
       ;-- WK: maybe positive number, maybe error
       ;-- DO: try to convert the number
       jnz number_convert
       ;-- EL: bl == '-'
       ;-- DO: reset sign-indicater
       ;--     update the counter
       ;--     go into a loop to read all the chars
       popArgumentStack  rax
       pushArgumentStack rbx     ;; top of ArgumentStack =/= 0, indicating negative
       dec rcx                 ;; update the counter
       jnz number_fetchNextDigits
       popArgumentStack  rbx     ;; error: string is only '-'.
       mov rcx, 1
       ret

    number_update_the_counter_and_fetchNextDigits:
       dec rcx
    number_fetchNextDigits:
       mov bl,  byte[rdi]     ;; bl = next character in string
       inc rdi

    number_convert:
       cmp bl, '_'
       je number_update_the_counter_and_fetchNextDigits

       ;; from low to high along the ascii
       sub bl, '0'
       ;-- IF: char < '0'
       jb number_endThisParse
       cmp bl, 10
       ;-- IF: '0' <= char <= '9'
       jb number_tryToAddDigitUp

       ;-- EL: '9' < char
       sub bl, ('A' - '0')
       ;-- IF: '9'< char < 'A'
       jb number_endThisParse
       cmp bl, 26
       ;-- NOTE-THAT: if bl == 0, char == 'A'
       ;-- IF: 'Z' < char
       jge @f
       ;-- EL: 'A' <= char <= 'Z'
       add bl, 10 ;; for 'A' =Hex= 10
       jb number_tryToAddDigitUp

    @@:;-- IF: 'Z' < char
       sub bl, ('a' - 'A')
       ;-- IF: 'Z' < char < 'a'
       jb number_endThisParse
       cmp bl, 26
       ;-- NOTE-THAT: if bl == 0, char == 'a'
       ;-- IF: 'z' < char
       jge number_endThisParse
       ;-- EL: 'a' <= char <= 'a'
       add bl, 10 ;; for 'a' =Hex= 10
       ;; jb number_tryToAddDigitUp


    number_tryToAddDigitUp:
       cmp bl, dl
       ;-- IF: bl >= dl
       ;-- WK: this digit >= Base
       jge number_endThisParse
       ;-- EL: bl < dl
       ;-- WK: this is a good digit
       ;-- DO: so add it to rax and loop
       imul rax, rdx   ;; (set! rax (* Base rax))
       add  rax, rbx
       dec  rcx
       jnz  number_fetchNextDigits

    number_endThisParse:
    ;; negate the result according to the sign-indicater on the top of ArgumentStack
       popArgumentStack rbx
       test rbx, rbx
       jz   number_return
       neg  rax
    number_return:
       ret


    ;; the following kinds of strings denote number,
    ;; because the function ``number'' can handle them.
    ;; 1. string with '0' - '9' as first char
    ;; 2. string with '-' as first char and with '0' - '9' as second char
    ;; so "-->", "_0" do not denote number.
    ;; under HexBase,
    ;; "feed" does not denote number, but "0feed", "0_feed" denote number

    defCode "string-denote-number?", stringDenoteNumber?
       ;; ( wordString[address, length] -- true or false )
       popArgumentStack  rcx        ;; length  of string
       popArgumentStack  rdi        ;; address of string
       call stringDenoteNumber?_helperFunction
       pushArgumentStack rax        ;; true or false
       next

    stringDenoteNumber?_helperFunction:
       xor rbx, rbx

       test rcx, rcx
       ;-- IF: rcx == 0
       ;-- WK: trying to parse a zero-length string, it is an error
       jz stringDenoteNumber?_returnFalse
       ;-- EL: rcx =/= 0
       ;-- WK: we have a non-empty string to be parsed
       mov bl,  byte[rdi]
       cmp bl, '-'
       ;-- IF: bl =/= '-'
       ;-- WK: maybe positive number, maybe error
       jnz @f
       ;-- EL: bl == '-'
       inc rdi
       dec rcx                 ;; update the counter
       test rcx, rcx
       ;-- IF: rcx == 0
       ;-- WK: string is only '-'
       jz stringDenoteNumber?_returnFalse
       ;; fetch next digit
       mov  bl,  byte[rdi]
       inc  rdi

    @@:
       sub bl, '0'
       ;-- IF: char < '0'
       jb stringDenoteNumber?_returnFalse
       cmp bl, 10
       ;-- IF: '0' <= char <= '9'
       jb stringDenoteNumber?_returnTrue
       ;-- EL: returnFalse

    stringDenoteNumber?_returnFalse:
       xor rax, rax
       ret

    stringDenoteNumber?_returnTrue:
       xor rax, rax
       mov rax, qword 1
       ret
    #+end_src
*** comment
        #+begin_src fasm :tangle ../../play/cicada.fasm
        defConstString "Comment-begin-string",  "(*", CommentBeginString
        defConstString "Comment-ending-string", "*)", CommentEndingString

        defWord "ignore-comment", ignoreComment
       ;; (* -- *)
       ;; (* ignore a list of comment words from stdin *)
       xx readWord
       xx dup2, CommentBeginString, equalString?, false?branch, 5
       xx   drop2, ignoreComment, branch, -9
       ;; beware of the tail-call-optimization
       ;; a tail-recursive-call is really a loop
       xx CommentEndingString, equalString?, false?branch, -13
       xx   Exit
        defWordEnd ignoreComment


        defWord "(*", comment
       xx ignoreComment
       xx Exit
        defWordEnd comment

        ;; test:
        ;; (* ok (* ok *) ok *) ok
        #+end_src
*** readWordListForLexicographer
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; a WordList (unit : CellWidth = 8 bytes)
    ;;   ||  1 : length-of-Word-1     ||
    ;;   ||  a : Word-1--as-a-string  ||
    ;;   ||  1 : length-of-Word-2     ||
    ;;   ||  b : Word-2--as-a-string  ||
    ;;   ...


    ;; ------------------------------------------
    ;; note that, Subsequent calls will overwrite BufferForReadWordListForLexicographer
    SizeOfBufferForReadWordListForLexicographer = 2*1024*1024
    segment readable writeable
    BufferForReadWordListForLexicographer:
       rb SizeOfBufferForReadWordListForLexicographer

    defConstString "Ket:cosemi", ";", Ket_cosemi
    defConstString "Ket:fuzhe", "者", Ket_fuzhe

    defVar "Next-word-for-read-word-list-for-lexicographer", BufferForReadWordListForLexicographer, NextWordForReadWordListForLexicographer

    defWord "read-word-list-for-lexicographer", readWordListForLexicographer
       ;; (* read a WordList from stdin (ForLexicographer) *)
       ;; (* -- wordList[address, the number of words] *)

       ;; (* initialize NextWordForReadWordListForLexicographer *)
       xx literal, BufferForReadWordListForLexicographer
       xx NextWordForReadWordListForLexicographer
       xx save

       ;; (* leave return value: [buffer-address, counter] *)
       xx literal, BufferForReadWordListForLexicographer
       xx Zero

       xx readWord

       xx dup2
       xx CommentBeginString, equalString?, false?branch, 5
       xx drop2, ignoreComment, branch, -9

       xx dup2
       xx Ket_cosemi, equalString?, false?branch, 3
       xx drop2
       xx Exit

       xx dup2
       xx Ket_fuzhe, equalString?, false?branch, 3
       xx drop2
       xx Exit

       xx addWordToListForLexicographer
       xx add1
       xx branch, -27
    defWordEnd readWordListForLexicographer

    defWord ":", readWordListForLexicographer_Bra_cosemi
       xx readWordListForLexicographer
       xx Exit
    defWordEnd readWordListForLexicographer_Bra_cosemi

    defWord "夫", readWordListForLexicographer_Bra_fuzhe
       xx readWordListForLexicographer
       xx Exit
    defWordEnd readWordListForLexicographer_Bra_fuzhe


    defWord "add-word-to-list-for-lexicographer", addWordToListForLexicographer
       ;; ( wordString[address, length] -- )
       ;; leave a length behind, for update NextWordForReadWordListForLexicographer at the end
       xx dup, xxswapx
       ;;   ||  1 : length-of-Word-1     ||
       xx dup, NextWordForReadWordListForLexicographer, fetch, save
       ;; update NextWordForReadWordListForLexicographer
       xx NextWordForReadWordListForLexicographer, fetch, add8, NextWordForReadWordListForLexicographer, save
       ;;   ||  a : Word-1--as-a-string  ||
       xx NextWordForReadWordListForLexicographer, fetch, swap, copyByteString
       ;; update NextWordForReadWordListForLexicographer again
       xx NextWordForReadWordListForLexicographer, addSave
       xx Exit
    defWordEnd addWordToListForLexicographer
    #+end_src
* *misc*
** assemblyDebug
   #+begin_src fasm :tangle ../../play/cicada.fasm
   defWord ".", printLittleNumber
      xx literal, '0'
      xx addition, writeChar
      xx literal, 32
      xx writeChar
      xx literal, 32
      xx writeChar
      xx Exit
   defWordEnd printLittleNumber

   defCode "exitWithTOS", exitWithTOS
      popArgumentStack sys_1_rdi
      mov sys_n_rax, syscall_exit
      syscall

   defWord "assemblyDebug", assemblyDebug
      ;; xx ><><><
      xx exitWithTOS
   defWordEnd assemblyDebug
   #+end_src
* *ending*
** memory allocation
*** PairConstructionsArray
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; ------------------------------------------
    ;; PairConstructionsArray
    ;;   (unit : byte)
    ;; ========================
    ;;   ||  1 : color     ||
    ;; ------------------------
    ;;   ||  8 : type tag  ||
    ;;   ||  8 : value     ||
    ;; ------------------------
    ;;   ||  8 : type tag  ||
    ;;   ||  8 : value     ||
    ;; ========================
    ClrBytesSize = 1
    CarBytesSize = 16
    CdrBytesSize = 16
    ConsBytesSize = ClrBytesSize + CarBytesSize + CdrBytesSize
    NumberOfPairConstructions = 100 * 1024

    segment readable writeable
            rb ClrBytesSize
    InFrontOfTheFirstPairConstruction:
            rb (CarBytesSize + CdrBytesSize)

            rb ClrBytesSize
    FirstPairConstruction:
            rb (CarBytesSize + CdrBytesSize)

            ;; ==========================
            rb (NumberOfPairConstructions - 2) * ConsBytesSize
            ;; ==========================

            rb ClrBytesSize
    LastPairConstruction:
            rb (CarBytesSize + CdrBytesSize)


    defConst "Clr-bytes-size"  , ClrBytesSize  , TheClrBytesSize
    defConst "Car-bytes-size"  , CarBytesSize  , TheCarBytesSize
    defConst "Cdr-bytes-size"  , CdrBytesSize  , TheCdrBytesSize
    defConst "Cons-bytes-size" , ConsBytesSize , TheConsBytesSize

    defConst "Number-of-pair-constructions", NumberOfPairConstructions, TheNumberOfPairConstructions

    defConst "In-front-of-the-first-pair-construction", InFrontOfTheFirstPairConstruction, TheInFrontOfTheFirstPairConstruction
    defConst "First-pair-construction", FirstPairConstruction, TheFirstPairConstruction
    defConst "Last-pair-construction",  LastPairConstruction,  TheLastPairConstruction

    defVar "Current-free-pair-construction", FirstPairConstruction, CurrentFreePairConstruction
     #+end_src
*** HashTableForSymbol
    using linear probing
    so, the load factor must be lower then 0.5
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; ------------------------------------------
    ;; HashTableForSymbol

    ;; a SymbolEntry (unit : byte)
    ;; ===========================
    ;;  ||   8 : SymbolValue   ||
    ;; ---------------------------
    ;;  ||   1 : SymbolLength  ||
    ;; ---------------------------
    ;;  || 56+ : SymbolString  ||
    ;; ===========================

    SymbolLengthBytesSize = 1
    SymbolValueBytesSize  = 8
    SymbolStringBytesSize = 56+0
    SymbolMaxLength       = 56
    SymbolEntryBytesSize = SymbolValueBytesSize + SymbolLengthBytesSize + SymbolStringBytesSize
    ;; NumberOfSymbolEntrys = 1000003
    ;; NumberOfSymbolEntrys = 1000033
    ;; NumberOfSymbolEntrys = 1000333
    ;; NumberOfSymbolEntrys = 100003
    NumberOfSymbolEntrys = 100333
    ;; NumberOfSymbolEntrys = 997
    ;; NumberOfSymbolEntrys = 499
    ;; NumberOfSymbolEntrys = 230 ;; for a special test

    segment readable writeable
    FirstSymbolEntry:
            rb SymbolEntryBytesSize

            ;; ========================
            rb (NumberOfSymbolEntrys - 2) * SymbolEntryBytesSize
            ;; ========================

    LastSymbolEntry:
            rb SymbolEntryBytesSize


    defConst "Number-of-symbol-entrys",  NumberOfSymbolEntrys,  TheNumberOfSymbolEntrys
    defConst "Symbol-value-bytes-size",  SymbolValueBytesSize,  TheSymbolValueBytesSize
    defConst "Symbol-length-bytes-size", SymbolLengthBytesSize, TheSymbolLengthBytesSize
    defConst "Symbol-string-bytes-size", SymbolStringBytesSize, TheSymbolStringBytesSize
    defConst "Symbol-max-length",        SymbolMaxLength,       TheSymbolMaxLength
    defConst "Symbol-entry-bytes-size",  SymbolEntryBytesSize,  TheSymbolEntryBytesSize

    defConst "First-symbol-entry", FirstSymbolEntry, TheFirstSymbolEntry
    defConst "Last-symbol-entry",  LastSymbolEntry,  TheLastSymbolEntry
        #+end_src
*** two StringHeaps
    #+begin_src fasm :tangle ../../play/cicada.fasm
    SizeOfStringHeap = 5 * 1024 * 1024 ;; unit: byte
    segment readable writeable
    StringHeap1:
            rb SizeOfStringHeap
    EndOfStringHeap1:
    segment readable writeable
    StringHeap2:
            rb SizeOfStringHeap
    EndOfStringHeap2:


    defConst "Size-of-string-heap", SizeOfStringHeap, TheSizeOfStringHeap

    defConst "String-heap-1", StringHeap1, TheStringHeap1
    defConst "String-heap-2", StringHeap2, TheStringHeap2
    #+end_src
*** BufferForLoadFile
    #+begin_src fasm :tangle ../../play/cicada.fasm
    SizeOfBufferForLoadFile = 1024 * 1024 ;; unit : byte

    segment readable writeable
    BufferForLoadFile:
             rb SizeOfBufferForLoadFile


    defConst "Buffer-for-load-file", BufferForLoadFile, TheBufferForLoadFile
    defConst "Size-of-buffer-for-load-file", SizeOfBufferForLoadFile, TheSizeOfBufferForLoadFile
    #+end_src
*** FileNameBufferForOpenFile
    #+begin_src fasm :tangle ../../play/cicada.fasm
    SizeOfFileNameBufferForOpenFile = 1024 ;; unit : byte

    defConst "FileNameBufferForOpenFile", FileNameBufferForOpenFile, TheFileNameBufferForOpenFile

    segment readable writeable
    FileNameBufferForOpenFile:
             rb SizeOfFileNameBufferForOpenFile
    #+end_src
*** ------------------------------------------
*** Stacks
    1. after push the first value into ArgumentStack
       ArgumentStackPointer will point to the address of this value
    2. before push the first value into ArgumentStack
       ArgumentStackPointer point to StackTop
       and StackTop will never be used
    4. beware to understand how ``StackBottom'' and ``StackTop'' work
    #+begin_src fasm :tangle ../../play/cicada.fasm
    ;; ReturnStack
    SizeOfReturnStack = 100*1024*8

    segment readable writeable
    ReturnStackBottom:
            rb SizeOfReturnStack
    ReturnStackTop:
            rb 100*8


    ;; ArgumentStack
    SizeOfArgumentStack = 100*1024*8

    segment readable writeable
    ArgumentStackBottom:
            rb SizeOfArgumentStack
    ArgumentStackTop:
            rb 100*8


    ;; GreyPairStack
    SizeOfGreyPairStack = 100*1024*8

    segment readable writeable
    GreyPairStackBottom:
            rb SizeOfGreyPairStack
    GreyPairStackTop:
            rb 100*8


    ;; LambdaStack
    SizeOfLambdaStack = 100*1024*8

    segment readable writeable
    LambdaStackBottom:
            rb SizeOfLambdaStack
    LambdaStackTop:
            rb 100*8


    ;; StackForEvalString
    SizeOfStackForEvalString = 1024*8

    segment readable writeable
    StackForEvalStringBottom:
            rb SizeOfStackForEvalString
    StackForEvalStringTop:
            rb 100*8



    defConst "Return-stack-top",    ReturnStackTop,    TheReturnStackTop
    defConst "Return-stack-bottom", ReturnStackBottom, TheReturnStackBottom

    defConst "Argument-stack-top",    ArgumentStackTop,    TheArgumentStackTop
    defConst "Argument-stack-bottom", ArgumentStackBottom, TheArgumentStackBottom

    defConst "Lambda-stack-top", LambdaStackTop, TheLambdaStackTop
    defConst "Lambda-stack-bottom", LambdaStackBottom, TheLambdaStackBottom

    defConst "Stack-for-eval-string-bottom", StackForEvalStringBottom, TheStackForEvalStringBottom
    defConst "Stack-for-eval-string-top", StackForEvalStringTop, TheStackForEvalStringTop
    #+end_src
*** ------------------------------------------
*** UserDataArea
    #+begin_src fasm :tangle ../../play/cicada.fasm
    SizeOfUserDataArea = 16 * 1024 * 1024 ;; unit: byte
    segment readable writeable
    UserDataArea:
            rb SizeOfUserDataArea
    EndOfUserDataArea:

    defConst "User-data-area", UserDataArea, TheUserDataArea
    defConst "End-of-user-data-area", EndOfUserDataArea, TheEndOfUserDataArea
    #+end_src
** TheLatestWordInAssembly
   #+begin_src fasm :tangle ../../play/cicada.fasm
   ;; this word helps to initialize FirstWordInDictionary
   defConst "The-latest-word-in-assembly", 0, TheLatestWordInAssembly
   #+end_src
* ==================================================
