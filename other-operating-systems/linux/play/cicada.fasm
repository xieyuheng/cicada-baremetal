include "./linux_syscalls.fasm"
;; in fasm, ``dup'' is a reserved word
dup equ duplicate
;; 64-bits
xx equ dq
CellWidth equ 8
format elf64 executable 3
entry cicada_begin
;define CellWidth 8 ;; (unit : byte)

;; if you want to extend cicada in assembly,
;; the following four registers must not be used
;; =================================
define NextWordPointer      r15
define ReturnStackPointer   r14
define ArgumtStackPointer   r13
define GreyPairStackPointer r12
;; =================================

define ExplainerPointer     rax
define TemporaryRegister    r11
define TemporaryRegister2   r10


;; ``ReturnStackPointer'' always stores the address of TOC (top-of-stack),
;; NOT the address of first-free-place in the stack

;; macro pushReturnStack Register {
;;    sub ReturnStackPointer, CellWidth
;;    mov [ReturnStackPointer], Register
;;    }
;; macro popReturnStack Register {
;;    mov Register, [ReturnStackPointer]
;;    add ReturnStackPointer, CellWidth
;;    }

;;;; can't use the following macro
;;;; do not know why ...
;; macro pushArgumtStack Register {
;;    sub ArgumtStackPointer, CellWidth
;;    mov [ArgumtStackPointer], Register
;;    }
;; macro popArgumtStack Register {
;;    mov Register, [ArgumtStackPointer]
;;    add ArgumtStackPointer, CellWidth
;;    }



macro pushReturnStack Register {
   lea ReturnStackPointer, [ReturnStackPointer - CellWidth]
   mov [ReturnStackPointer], Register
   }
macro popReturnStack Register {
   mov Register, [ReturnStackPointer]
   lea ReturnStackPointer, [ReturnStackPointer + CellWidth]
   }

macro pushArgumtStack Register {
   lea ArgumtStackPointer, [ArgumtStackPointer - CellWidth]
   mov [ArgumtStackPointer], Register
   }
macro popArgumtStack Register {
   mov Register, [ArgumtStackPointer]
   lea ArgumtStackPointer, [ArgumtStackPointer + CellWidth]
   }
;; notations :
;; 1. ``the dictionary'' as a datastructure is a single-linked-list
;; 2. an entry in ``the dictionary'' is ``a word''
;; 3. ``a word'' as a datastructure looks like the following :
;;       (unit : CellWidth)
;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;    ||  m : name-string  ||
;;    ||  1 : SizeOfFunctionBody  ||
;;    ||  1 : identification  ||
;;    ||  1 : link  ||
;;    ||  1 : type  ||
;;    ||  1 : address-of-name-string-header  ||
;;    ||  1 : address-of-explainer  ||
;;    ||  n : body  ||
;; 4. so, I adopt two notations to represent ``a word'' :
;;    word[link]      == address in a word where the link is stored
;;    word[explainer] == address in a word where the address-of-explainer is stored
;;    word[explainer] == address in a word before the function-body
;;    word[explainer] == address in a word as the head of a function-body


;; note that:
;;   there are only two ways to jump to a explainer
;;   1. next
;;   2. execute


;; not matter what way you use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; then :
;;   jmp qword[ExplainerPointer]
;; it will works just well !!!

;; specially, about ``next'',
;; the way we use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; is to find the address-of-explainer by :
;;    NextWordPointer  == an address in a function-body
;;   [NextWordPointer] == word-to-jump[explainer]
;; so, NextWordPointer is all that ``next'' needed
;; set [NextWordPointer] == word-to-jump[explainer]  correctly
;; then call ``next''
;; it will works just well !!!


;; 1. this ``next'' do tail-call-optimization
;; 2. in the following FASM marco, anonymous label of FASM is used
;;    (of course, label in marco must be anonymous !)
;;    hence, when using anonymous labels in assembly,
;;    they can not across ``next'' !


;; macro next {
;;    ;== NEED:
;;    ;==     NextWordPointer  points at an address in a function-body
;;    ;==    [NextWordPointer] == word-to-jump[explainer]
;;    ;== CHNG:
;;    ;==     NextWordPointer  points at next address in a function-body
;;    ;==    [NextWordPointer] == new-word-to-jump[explainer]
;;    ;==     ExplainerPointer  points at the address in a word
;;    ;==                      where the address-of-explainer is stored
;;    ;==    [ExplainerPointer] == address-of-explainer (of word-to-jump)
;;    mov ExplainerPointer, [NextWordPointer]
;;    add NextWordPointer, CellWidth
;;    ;; why not: cmp qword[NextWordPointer], Exit  ???
;;    cmp dword[NextWordPointer], Exit
;;    ;-- IF: [NextWordPointer] =/= Exit
;;    jne @f
;;    ;-- EL: [NextWordPointer] == Exit
;;    popReturnStack NextWordPointer
;; @@:
;;    jmp qword[ExplainerPointer]
;;    }
;;    ;; maybe need more optimization,
;;    ;; for the above ``popReturnStack NextWordPointer'' may be
;;    ;; followed by ``pushReturnStack NextWordPointer'' (in explainFunctionBody)




macro next {
  mov ExplainerPointer, [NextWordPointer]
  add NextWordPointer, CellWidth
  ;; mov TemporaryRegister2, Exit
  ;; cmp qword[NextWordPointer], TemporaryRegister2
  cmp dword[NextWordPointer], Exit
  je @f
  cmp dword[NextWordPointer], 已矣
  je @f
  jmp qword[ExplainerPointer]
@@:
  popReturnStack NextWordPointer
  jmp qword[ExplainerPointer]
  }




;; initial Link to point to NULL
Link = 0


;; example of macro expanding :
;; defWord "double", double
;;    xx dup
;;    xx plus
;;    xx Exit
;; ==expand to==>
;; WordStringHeaderOfdouble:
;;         xx (EndOfdouble - WordStringOfdouble)
;; WordStringOfdouble:
;;         db "double"
;; EndOfWordStringOfdouble:
;; LinkOfdouble:
;;         xx Link
;;         Link = LinkOfdouble
;; TypeOfdouble:
;;         xx 0
;; AddressOfWordStringHeaderOfdouble:
;;         xx WordStringHeaderOfdouble
;; double:
;;         xx explainFunctionBody
;;         xx dup
;;         xx plus
;;         xx Exit


macro defWord WordString, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        xx (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
SizeOfFunctionBodyOf#Word:
        xx (EndOfFunctionBodyOf#Word - Word)/8 - 1
;;--------------------------------------
IdentificationOf#Word:
        xx IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        xx Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        xx 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        xx WordStringHeaderOf#Word
;;======================================
Word:   xx explainFunctionBody
;;--------------------------------------
        ;; here follows a list of word[explainer]
        }
macro defWordEnd Word {
EndOfFunctionBodyOf#Word:
}


;; 1. if ``next'' meet ``Exit'',
;;    ``next'' will ``popReturnStack NextWordPointer''
;; 2. on the other hand,
;;    explainFunctionBody is the only explainer
;;    who ``pushReturnStack NextWordPointer''
;; 3. so, it is these two functions, ``next'' and ``explainFunctionBody'',
;;    which handle the nested function calls
segment readable executable
explainFunctionBody:
   ;== SAVE:
   ;==     NextWordPointer  points at an old address in a function-body
   ;==    [NextWordPointer] == old-word-to-jump[explainer]
   ;== NEED:
   ;==    ExplainerPointer == current-word[explainer]
   ;==        this value can be used to calculate
   ;==        the address in a word where the function-body is stored
   ;== CHNG:
   ;==    [ExplainerPointer] == new-word-to-jump[explainer]
   ;==    [NextWordPointer] == new-word-to-jump[explainer]
   pushReturnStack NextWordPointer
   ;; to calculate the address in a word where the function-body is stored
   ;; this address is as an ``argumt'' of explainFunctionBody
   add ExplainerPointer, CellWidth
   mov NextWordPointer, ExplainerPointer
   next



;; assembly code have no explainer
macro defCode WordString, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        xx (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        xx IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        xx Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        xx 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        xx WordStringHeaderOf#Word
;;======================================
Word:   xx AssemblerCodeOf#Word
;;--------------------------------------
segment readable executable
AssemblerCodeOf#Word:
        ;; here follows the assembly code
        }




defCode "execute", execute
  ;; ( word[address of explainer] -- )
  popArgumtStack ExplainerPointer
  jmp qword[ExplainerPointer]

;; not matter what way you use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; then :
;;   jmp qword[ExplainerPointer]
;; it will works just well !!!



macro defVar WordString, InitialValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        xx (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        xx IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        xx Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        xx 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        xx WordStringHeaderOf#Word
;;======================================
Word:   xx explainVar
;;--------------------------------------
        xx InitialValue
;;--------------------------------------
        }


segment readable executable
explainVar:
   ;; ( -- address )
   add ExplainerPointer, CellWidth
   pushArgumtStack ExplainerPointer
   next



macro defConst WordString, InitialValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        xx (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        xx IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        xx Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        xx 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        xx WordStringHeaderOf#Word
;;======================================
Word:   xx explainConst
;;--------------------------------------
        xx InitialValue
;;--------------------------------------
        }

segment readable executable
explainConst:
   ;; ( -- value )
   add ExplainerPointer, CellWidth
   mov TemporaryRegister, [ExplainerPointer]
   pushArgumtStack TemporaryRegister
   next




;; in stack:
;;   string[address, length]
;; in memory:
;;   ||  1 : length  ||
;;   ||  n : string  ||
macro defConstString WordString, ConstStringValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        xx (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        xx IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        xx Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        xx 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        xx WordStringHeaderOf#Word
;;======================================
Word:   xx explainConstString
;;--------------------------------------
        xx (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
;;--------------------------------------
ConstStringValueOf#Word:
        db ConstStringValue
EndOfConstStringValueOf#Word:
;;--------------------------------------
        }


segment readable executable
explainConstString:
   ;; ( -- string[address, length] )
   add ExplainerPointer, CellWidth
   mov TemporaryRegister, [ExplainerPointer]
   add ExplainerPointer, CellWidth
   pushArgumtStack ExplainerPointer
   pushArgumtStack TemporaryRegister
   next



;; the following Exit helps tail-call-optimization
;; it just let you decide where is the end of FunctionBody
;; in a FunctionBody, the ``Exit'' as a word will never be called
defConst "Exit", Exit, Exit
;; (* so, the following numbers are the same :
;;   Exit
;;   readWord Exit find wordLinkToWordExplainer
;;   *)

;; the following is the chinese version of ``Exit''
defConst "已矣", 已矣, 已矣

defConst "FunctionBodyExplainer", explainFunctionBody, FunctionBodyExplainer
defConst "VarExplainer",          explainVar,          VarExplainer
defConst "ConstExplainer",        explainConst,        ConstExplainer
defConst "ConstStringExplainer",  explainConstString,  ConstStringExplainer
defVar "Base", 10, Base
defVar "Here",  0, Here

defVar "FirstWordInDictionary", LinkOfTheLatestWordInAssembly , FirstWordInDictionary
;; note that:
;;   the above is LinkOfTheLatestWordInThisFile
;;   NOT TheLatestWordInThisFile
defConst "CellWidth", CellWidth, TheCellWidth

defConst "Zero",  0, Zero
defConst "One",   1, One
defConst "Two",   2, Two
defConst "Three", 3, Three
defConst "Four",  4, Four
defConst "Five",  5, Five
defConst "Six",   6, Six
defConst "Seven", 7, Seven
defConst "Eight", 8, Eight
defConst "Nine",  9, Nine
defConst "Ten",  10, Ten

defConst "False", 0, False
defConst "True",  1, True

defConst "BinBase", 2,  BinBase
defConst "OctBase", 8,  OctBase
defConst "DecBase", 10, DecBase
defConst "HexBase", 16, HexBase
defConst "AphBase", 36, AphBase
;; test:
;; BinBase Base save
;; 101 011 bitwiseAnd . (* 1 *)
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . (* 1 *)
;; DecBase Base save
defCode "drop", drop
   ;; (* a -- *)
   popArgumtStack rax
   next

defCode "drop2", drop2
   ;; (* a b -- *)
   popArgumtStack rax
   popArgumtStack rax
   next

defCode "dup", dup
   ;; (* a -- a a *)
   mov  rax, [ArgumtStackPointer]
   pushArgumtStack rax
   next

defCode "dup2", dup2
   ;; (* a b -- a b a b *)
   mov  rbx, [ArgumtStackPointer]
   mov  rax, [ArgumtStackPointer + CellWidth]
   pushArgumtStack rax
   pushArgumtStack rbx
   next
defCode "over", over
   ;; (* a b -- a b | a *)
   mov  rax, [ArgumtStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "x|over|xx", xoverxx
   ;; (* a | b c -- a | b c | a *)
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
   pushArgumtStack rax
   next

defCode "xx|over|x", xxoverx
   ;; (* a b | c -- a b | c | a b *)
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)] ;; not (1 * CellWidth)
   pushArgumtStack rax
   next

defCode "xx|over|xx", xxoverxx
   ;; (* a b | c d -- a b | c d | a b *)
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)] ;; not (2 * CellWidth)
   pushArgumtStack rax
   next

defCode "x|over|xxx", xoverxxx
   ;; (* a | b c d -- a | b c d | a *)
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
   pushArgumtStack rax
   next

defCode "xx|over|xxxx", xxoverxxxx
   ;; (* a b | c d e f -- a b | c d e f | a b *)
   mov  rax, [ArgumtStackPointer + (5 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (5 * CellWidth)] ;; not (4 * CellWidth)
   pushArgumtStack rax
   next
defCode "tuck", tuck
   ;; (* a b -- b | a b *)
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "x|tuck|xx", xtuckxx
   ;; (* a | b c -- b c | a | b c *)
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|tuck|x", xxtuckx
   ;; (* a b | c -- c | a b | c *)
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|tuck|xx", xxtuckxx
   ;; (* a b | c d -- c d | a b | c d *)
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next

defCode "xxx|tuck|x", xxxtuckx
   ;; (* a b c | d -- d | a b c | d *)
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next
defCode "swap", swap
   ;; (* a b -- b a *)
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rax
   next

defCode "x|swap|xx", xswapxx
   ;; (* a | b c -- b c | a *)
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rax
   next

defCode "xx|swap|x", xxswapx
   ;; (* a b | c -- c | a b *)
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "x|swap|xxx", xswapxxx
   ;; (* a | b c d -- b c d | a *)
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   next

defCode "xxx|swap|x", xxxswapx
   ;; (* a b c | d -- d | a b c *)
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|swap|xx", xxswapxx
   ;; (* a b | c d -- c d | a b *)
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   next


defCode "x|swap|xxxx", xswapxxxx
   ;; (* a | b c d e -- b c d e | a *)
   popArgumtStack r8 ;; e
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack r8 ;; e
   pushArgumtStack rax
   next

defCode "xxxx|swap|x", xxxxswapx
   ;; (* a b c d | e --  e | a b c d *)
   popArgumtStack r8 ;; e
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack r8 ;; e
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next


defCode "xx|swap|xxxx", xxswapxxxx
   ;; (* a b | c d e f -- c d e f | a b *)
   popArgumtStack r9 ;; f
   popArgumtStack r8 ;; e
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack r8 ;; e
   pushArgumtStack r9 ;; f
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "xxxx|swap|xx", xxxxswapxx
   ;; (* a b c d | e f --  e f | a b c d *)
   popArgumtStack r9 ;; f
   popArgumtStack r8 ;; e
   popArgumtStack rdx
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   pushArgumtStack r8 ;; e
   pushArgumtStack r9 ;; f
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next
defCode "|123->321|", abcTOcba
   popArgumtStack rax
   popArgumtStack rbx
   popArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next
defCode "add1", add1
   ;; (* n -- n+1 *)
   inc qword[ArgumtStackPointer]
   next

defCode "add2", add2
   ;; (* n -- n+1 *)
   add qword[ArgumtStackPointer], 2
   next

defCode "add3", add3
   ;; (* n -- n+1 *)
   add qword[ArgumtStackPointer], 3
   next

defCode "add4", add4
   ;; (* n -- n+4 *)
   add qword[ArgumtStackPointer], 4
   next

defCode "add8", add8
   ;; (* n -- n+8 *)
   add qword[ArgumtStackPointer], 8
   next


defCode "sub1", sub1
   ;; (* n -- n-1 *)
   dec qword[ArgumtStackPointer]
   next

defCode "sub2", sub2
   ;; (* n -- n-1 *)
   sub qword[ArgumtStackPointer], 2
   next

defCode "sub3", sub3
   ;; (* n -- n-1 *)
   sub qword[ArgumtStackPointer], 3
   next

defCode "sub4", sub4
   ;; (* n -- n-4 *)
   sub qword[ArgumtStackPointer], 4
   next

defCode "sub8", sub8
   ;; (* n -- n-8 *)
   sub qword[ArgumtStackPointer], 8
   next


defCode "+", addition
   ;; (* a b -- a+b *)
   popArgumtStack rax
   add qword[ArgumtStackPointer], rax
   next

defCode "-", subtraction
   ;; (* a b -- a-b *)
   popArgumtStack rax
   sub qword[ArgumtStackPointer], rax
   next

defCode "*", multiple
   ;; (* a b -- a*b *)
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   imul rbx, rax
   ;; imul will ignore overflow
   ;; when there are two registers as arg
   ;; imul will save the result into the first register
   pushArgumtStack rbx
   next

defCode "mod/", divmod
   ;; (* a, b -- a mod b, a/b *)
   ;; (* dividend, divisor -- remainder, quotient *)
   ;; the arg of idiv is divisor
   ;; the lower half of dividend is taken from rax
   ;; the upper half of dividend is taken from rdx
   xor  rdx, rdx   ;; high-part of dividend is not used
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   idiv rbx
   ;; the remainder is stored in rdx
   ;; the quotient  is stored in rax
   pushArgumtStack rdx ;; remainder
   pushArgumtStack rax ;; quotient
   next
;; ``save'' and ``fetch'' default to a CellWidth (== 8 bytes)
;; the rule of ``fetch2'' and so on are:
;;   in memory:
;;     ||  1 : value-1  ||
;;     ||  1 : value-2  ||
;;     ||  1 : value-3  ||
;;     ...
;;   on stack:
;;     [ ... , value-3, value-2, value-1]
;; of course we have:
;;   fetch2 : memory=copy=>stack
;;   save2  : stack->memory

defCode "save", save
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   next

defCode "save2", save2
   ;; ( value-2, value-1, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   popArgumtStack rax
   mov qword[rbx + CellWidth], rax
   next



defCode "fetch", fetch
   ;; ( address -- value )
   popArgumtStack  rbx
   mov rax, qword[rbx]
   pushArgumtStack rax
   next

defCode "fetch2", fetch2
   ;; ( address -- value-1, value-2 )
   popArgumtStack  rbx
   mov rax, qword[rbx + CellWidth]
   pushArgumtStack rax
   mov rax, qword[rbx]
   pushArgumtStack rax
   next



defCode "addSave", addSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   add qword[rbx], rax
   next

defCode "subSave", subSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   sub qword[rbx], rax
   next



defCode "saveByte", saveByte
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov byte[rbx], al
   next

defCode "fetchByte", fetchByte
   ;; ( address -- value )
   popArgumtStack rbx
   xor rax, rax
   mov al, byte[rbx]
   pushArgumtStack rax
   next




defCode "copyByte", copyByte
   ;; ( source address, destination address --
   ;;   source address + 1, destination address + 1 )
   mov rbx, [ArgumtStackPointer + CellWidth] ;; source address
   mov al,  byte[rbx]                        ;; get a char from source address
   popArgumtStack rdi                        ;; destination address
   stosb                                     ;; copy to destination
   pushArgumtStack rdi                       ;; destination address is incremented by stosb
   inc qword[ArgumtStackPointer + CellWidth] ;; increment source address
   next

defCode "copyByteString", copyByteString
   ;; ( source address, destination address, length -- )
   popArgumtStack rcx
   popArgumtStack rdi
   popArgumtStack rsi
   rep movsb
   next
;; return false when length == 0
defCode "compareString?", compareString?
   ;; (* address of string-1, address of string-2, length -- True or False *)
   popArgumtStack rcx
   popArgumtStack rdi
   popArgumtStack rsi
   repe cmpsb
   sete al
   movzx rax, al
   pushArgumtStack rax
   next


defWord "equalString?", equalString?
   ;; (* string-1[address-1, length-1], string-2[address-2, length-2]
   ;;   -- True or False *)
   xx xoverxx, equal?, false?branch, 4
   xx swap, compareString?, Exit
   xx drop, drop, drop, False
   xx Exit
defWordEnd equalString?
defCode "==", equal?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   sete  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "=/=", notEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   setne al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "<", lessThan?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setl  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">", greaterThan?
   popArgumtStack   rbx
   popArgumtStack   rax
   cmp   rax, rbx
   setg  al
   movzx rax, al
   pushArgumtStack  rax
   next

defCode "<=", lessOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setle al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">=", greaterOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "zero?", zero?
   popArgumtStack rax
   test  rax,rax
   setz  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "notZero?", notZero?
   popArgumtStack rax
   test  rax,rax
   setnz al
   movzx rax, al
   pushArgumtStack rax
   next


defWord "one?", one?
   xx One, equal?
   xx Exit
defWordEnd one?

defWord "true?", true?
   xx one?
   xx Exit
defWordEnd true?

defWord "false?", false?
   xx zero?
   xx Exit
defWordEnd false?
defCode "bitwiseAnd", bitwiseAnd
   ;; ( a, b -- a and b )
   popArgumtStack rbx
   and [ArgumtStackPointer], rbx
   next

defCode "bitwiseOr", bitwiseOr
   ;; ( a, b -- a or b )
   popArgumtStack rbx
   or  [ArgumtStackPointer], rbx
   next

defCode "bitwiseXor", bitwiseXor
   ;; ( a, b -- a xor b )
   popArgumtStack rbx
   xor [ArgumtStackPointer], rbx
   next

defCode "bitwiseInvert", bitwiseInvert
   ;; ( a -- invert a )
   not qword[ArgumtStackPointer]
   next
;; BT copies a bit from a given register to the carry flag
defCode "fetchBit", fetchBit
   ;; ( fixnum, offset -- bit )
   popArgumtStack rbx
   popArgumtStack rax
   bt rax, rbx
   setc al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "setBit", setBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   bts rax, rbx
   pushArgumtStack rax
   next

defCode "clearBit", clearBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btr rax, rbx
   pushArgumtStack rax
   next

defCode "invertBit", invertBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btc rax, rbx
   pushArgumtStack rax
   next



;; "bsf" "bsr"
;; instructions scan a word or double word for first set bit
;; and store the index of this bit into destination operand
;; which must be general register
;; The bit string being scanned is specified by source operand
;; it may be either general register or memory
;; The ZF flag is set if the entire string is zero (no set bits are found)
;; otherwise it is cleared

;; If no set bit is found
;; the value of the destination register is undefined
;; "bsf" scans from low order to high order (starting from bit index zero)
;; "bsr" scans from high order to low order


;; note that:
;; if can not find ``SetBit''
;; the following functions will return -1

defCode "findLowestSetBit", findLowestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsf rax, rax
   jz tryToFindLowestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindLowestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next

defCode "findHighestSetBit", findHighestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsr rax, rax
   jz tryToFindHighestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindHighestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next
;; "shl"
;; shifts the destination operand left
;; by the number of bits specified in the second operand
;; The destination operand can be general register or memory
;; The second operand can be an immediate value or the CL register
;; as bits exit from the left, zeros in from the right
;; The last bit that exited is stored in CF
;; "sal" is a synonym for "shl"
defCode "shiftLeft", shiftLeft
   ;; ( fixnum, step -- fixnum * 2^step )
   popArgumtStack rcx
   shl qword[ArgumtStackPointer], cl
   next

defCode "shiftRight", shiftRight
   ;; ( fixnum, step -- fixnum / 2^step )
   popArgumtStack rcx
   shr qword[ArgumtStackPointer], cl
   next

defCode "shiftRightPreserveSign", shiftRightPreserveSign
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   sar qword[ArgumtStackPointer], cl
   next



;; note that:
;; ``double'' is 128 bit value here

;; "shld"
;; shifts bits of the destination operand to the left
;; by the number of bits specified in third operand,
;; while shifting
;; move high order bits from the source operand
;; into the destination operand on the right.
;; The source operand remains unmodified.
;; The destination operand can be a word or double word general register or memory,
;; the source operand must be a general register,
;; third operand can be an immediate value or the CL register.
defCode "doubleShiftLeft", doubleShiftLeft
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rax
   shld qword[ArgumtStackPointer], rax, cl
   shl rax, cl
   pushArgumtStack rax
   next


;; "shrd"
;; shifts bits of the destination operand to the right,
;; while shifting
;; move low order bits from the source operand
;; into the destination operand on the left.
;; The source operand remains unmodified.
;; Rules for operands are the same as for the "shld" instruction.
defCode "doubleShiftRight", doubleShiftRight
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   shr rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "doubleShiftRightPreserveSign", doubleShiftRightPreserveSign
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   sar rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next




defCode "rotateLeft", rotateLeft
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   rol qword[ArgumtStackPointer], cl
   next

defCode "rotateRight", rotateRight
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   ror qword[ArgumtStackPointer], cl
   next
defCode "pushReturnStack", toPushReturnStack
   ;; (* address --> ReturnStack: address *)
   popArgumtStack  rax
   pushReturnStack rax
   next

defCode "popReturnStack", toPopReturnStack
   ;; (* ReturnStack: address --> address *)
   popReturnStack  rax
   pushArgumtStack rax
   next

;; up to now
;; the above two class classic forth words
;; have not been used by cicada yet


defCode "fetchReturnStackPointer", fetchReturnStackPointer
   ;; (* -- an address in the ReturnStack *)
   pushArgumtStack ReturnStackPointer
   next

defCode "resetReturnStackPointer", resetReturnStackPointer
   ;; (* an address in the ReturnStack -- *)
   popArgumtStack ReturnStackPointer
   next

defCode "dropReturnStack", dropReturnStack
   ;; (* -- *)
   add ReturnStackPointer, CellWidth
   next
;; to know why the following funny thing happens,
;; see the definition of the macro ``pushArgumtStack'',
defCode "makeSelfReferenceValue", makeSelfReferenceValue
   ;; ( -- address )
   pushArgumtStack ArgumtStackPointer
   next

defWord "fetchArgumtStackPointer", fetchArgumtStackPointer
   xx makeSelfReferenceValue, add8, Exit
defWordEnd fetchArgumtStackPointer

defCode "resetArgumtStackPointer", resetArgumtStackPointer
   ;; ( address -- )
   popArgumtStack ArgumtStackPointer
   next
defCode "pushGreyPairStack", pushGreyPairStack
   ;; (* pair[address] --> GreyPairStack: pair[address] *)
   popArgumtStack rax
   lea GreyPairStackPointer, [GreyPairStackPointer - CellWidth]
   mov [GreyPairStackPointer], rax
   next

defCode "popGreyPairStack", popGreyPairStack
   ;; (* GreyPairStack: pair[address] --> pair[address] *)
   mov rax, [GreyPairStackPointer]
   lea GreyPairStackPointer, [GreyPairStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "emptyGreyPairStack?", emptyGreyPairStack?
   ;; (* -- True or False *)
   mov rax, GreyPairStackTop
   cmp GreyPairStackPointer, rax
   ;; note that:
   ;; GreyPairStackPointer >= GreyPairStackTop
   ;; means stack over flow
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

;; test:
;; emptyGreyPairStack? . (* 1 *)
;; 6 pushGreyPairStack emptyGreyPairStack? . (* 0 *)
;; popGreyPairStack . (* 6 *)
;; emptyGreyPairStack? . (* 1 *)
defCode "tailOfWordList", tailOfWordList
   ;; (* wordList[address, the number of words] --
   ;;    wordList[new address, number - 1] *)
   popArgumtStack rcx
   popArgumtStack rsi
   lodsq
   add rsi, rax
   pushArgumtStack rsi
   dec rcx
   pushArgumtStack rcx
   next

defCode "headOfWordList", headOfWordList
   ;; (* wordList[address, the number of words] --
   ;;    wordString[address, length] *)
   popArgumtStack rbx ;; do not need this arg
   popArgumtStack rsi
   mov rcx, qword[rsi]
   add rsi, CellWidth
   pushArgumtStack rsi
   pushArgumtStack rcx
   next

defWord "tailAndHeadOfWordList", tailAndHeadOfWordList
   ;; (* wordList[address, the number of words] --
   ;;    wordList[new address, number - 1], wordString[address, length] *)
   xx dup2
   xx tailOfWordList
   xx xxswapxx
   xx headOfWordList
   xx Exit
defWordEnd tailAndHeadOfWordList
defCode "syscallWithZoreArgument", syscallWithZoreArgument
   ;; (* callNumber -- return value *)
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithOneArgument", syscallWithOneArgument
   ;; (* arg-1, callNumber -- return value *)
   popArgumtStack sys_n_rax
   popArgumtStack sys_1_rdi
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithTwoArguments", syscallWithTwoArguments
   ;; (* arg-2, arg-1, callNumber -- return value *)
   popArgumtStack sys_n_rax
   popArgumtStack sys_1_rdi
   popArgumtStack sys_2_rsi
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithThreeArguments", syscallWithThreeArguments
   ;; (* arg-3, arg-2, arg-1, callNumber -- return value *)
   popArgumtStack sys_n_rax
   popArgumtStack sys_1_rdi
   popArgumtStack sys_2_rsi
   popArgumtStack sys_3_rdx
   syscall
   pushArgumtStack rax
   next
defCode "literal", literal
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumtStack rax
   cmp dword[NextWordPointer], Exit
   je literal_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je literal_meet_Exit
   next
literal_meet_Exit:
   popReturnStack NextWordPointer
   next


defCode "branch", branch
   ;; usage(in assembly): xx branch, number
   ;; the number denotes an offset
   ;; the base point of the offset is the place where the number stored
   ;; note that: in the function branch, [NextWordPointer] = offset
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   cmp dword[NextWordPointer], Exit
   je branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je branch_meet_Exit
   next
branch_meet_Exit:
   popReturnStack NextWordPointer
   next


defCode "zero?branch", zero?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz zero?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp zero?branch_help_toBranch
zero?branch_toBranch:
   add NextWordPointer, CellWidth
zero?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je zero?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je zero?branch_meet_Exit
   next
zero?branch_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "false?branch", false?branch
   ;; ( n -- )
   ;; false?branch is identical to zero?branch
   ;; but we can not use defWord to define false?branch by false?branch
   ;; for it is a special key word
   popArgumtStack rax
   test rax, rax
   jnz false?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp false?branch_help_toBranch
false?branch_toBranch:
   add NextWordPointer, CellWidth
false?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je false?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je false?branch_meet_Exit
   next
false?branch_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "notFalse?branch", notFalse?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jz notFalse?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp notFalse?branch_help_toBranch
notFalse?branch_toBranch:
   add NextWordPointer, CellWidth
notFalse?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je notFalse?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je notFalse?branch_meet_Exit
   next
notFalse?branch_meet_Exit:
   popReturnStack NextWordPointer
   next
defCode "即", 即
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumtStack rax
   cmp dword[NextWordPointer], Exit
   je 即_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 即_meet_Exit
   next
即_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "转", 转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   cmp dword[NextWordPointer], Exit
   je 转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 转_meet_Exit
   next
转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "零则转", 零则转
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz 零则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 零则转_help_去转
零则转_去转:
   add NextWordPointer, CellWidth
零则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 零则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 零则转_meet_Exit
   next
零则转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "假则转", 假则转
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz 假则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 假则转_help_去转
假则转_去转:
   add NextWordPointer, CellWidth
假则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 假则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 假则转_meet_Exit
   next
假则转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "非假则转", 非假则转
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jz 非假则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 非假则转_help_去转
非假则转_去转:
   add NextWordPointer, CellWidth
非假则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 非假则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 非假则转_meet_Exit
   next
非假则转_meet_Exit:
   popReturnStack NextWordPointer
   next
;; /usr/include/asm-generic/termbits.h
;; /usr/include/asm-generic/ioctls.h

VMIN = 6

ICRNL   =       0000400o
IXON    =       0002000o
ICANON  =       0000002o
ISIG    =       0000001o
ECHO    =       0000010o


segment readable writeable

termios:
termios.c_iflag:       rd 1
termios.c_oflag:       rd 1
termios.c_cflag:       rd 1
termios.c_lflag:       rd 1
termios.c_line:        rb 1
termios.c_cc:          rb 19 ;; NCCS
termios_size = ($ - termios)

termios_orig:
termios_orig.c_iflag:       rd 1
termios_orig.c_oflag:       rd 1
termios_orig.c_cflag:       rd 1
termios_orig.c_lflag:       rd 1
termios_orig.c_line:        rb 1
termios_orig.c_cc:          rb 19 ;; NCCS


ScreenSize:  rw 1


defCode "setTerminalToReadKey", setTerminalToReadKey
   ;; (* -- *)
   mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
   mov sys_2_rsi, 5401h        ;; TERMIOS_GET, TCGETS
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall

   mov rsi, termios_orig
   mov rdi, termios
   mov rcx, termios_size
   cld
   rep movsb

   mov byte [termios.c_cc + VMIN], 1
   ;; icanon off, isig (^C) off, echo off
   and byte [termios.c_lflag + 0], ((- ICANON) and (- ISIG) and (- ECHO))
   ;; ixon off,   icrnl off
   and byte [termios.c_iflag + 1], ((- (IXON shr 8)) or (- (ICRNL shr 8)))
   mov rdx, termios     ;; termios or WinSize structure ptr
   mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall
   next


defCode "setTerminalBackToReadLine", setTerminalBackToReadLine
   ;; (* -- *)
   mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
   mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall
   next


defCode "getScreenSize", getScreenSize
   ;; (* -- rows, cols *)
   mov sys_3_rdx, ScreenSize
   ;; [ScreenSize] == for example col=88,row=26 :: 00880026
   mov sys_2_rsi, 5413h ;; TERMIOS_WSIZE, TIOCGWINSZ
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall
   ;; xor rax, rax
   mov ax, word[ScreenSize]
   pushArgumtStack rax
   mov ax, word[ScreenSize + 2]
   pushArgumtStack rax
   next
defConstString "LinuxEnvName.cicada_core_path", "cicada_core_path=", LinuxEnvName.cicada_core_path
defConstString "LinuxEnvName.cicada_core", "cicada_core=", LinuxEnvName.cicada_core


defWord "getLinuxEnvHeaderAddress", getLinuxEnvHeaderAddress
   ;; (* -- [address of zero-ending-string] *)
   xx LinuxProgramHeaderAddress, fetch
   xx LinuxProgramHeaderAddress, addition, add1
   xx Exit
defWordEnd getLinuxEnvHeaderAddress


defWord "getNextLinuxEnvAddress", getNextLinuxEnvAddress
   ;; (* [address of zero-ending-string] -- next-address *)
   xx add1, dup
   xx fetchByte, Zero, equal?, false?branch, 3
   xx   add1
   xx   Exit
   xx getNextLinuxEnvAddress
   xx Exit
defWordEnd getNextLinuxEnvAddress


defWord "help_getLinuxEnvValue", help_getLinuxEnvValue
   ;; (* [address, length],
   ;;    [address of zero-ending-string] --
   ;;    [address of zero-ending-string] *)
   xx dup
   xx xxoverxx, compareString?, false?branch, 6
   xx   xxswapx
   xx   swap, drop
   xx   addition
   xx   Exit
   xx getNextLinuxEnvAddress
   xx help_getLinuxEnvValue
   xx Exit
defWordEnd help_getLinuxEnvValue

defWord "getLinuxEnvValue", getLinuxEnvValue
   ;; the string used to get EnvVar must ending with `='
   ;; (* [address, length] -- [address of zero-ending-string] *)
   xx getLinuxEnvHeaderAddress
   xx help_getLinuxEnvValue
   xx Exit
defWordEnd getLinuxEnvValue


defWord "LinuxEnvValue.cicada_core_path", LinuxEnvValue.cicada_core_path
   ;; (*  -- [address of zero-ending-string] *)
   xx LinuxEnvName.cicada_core_path, getLinuxEnvValue
   xx Exit
defWordEnd LinuxEnvValue.cicada_core_path


defWord "LinuxEnvValue.cicada_core", LinuxEnvValue.cicada_core
   ;; (*  -- [address of zero-ending-string] *)
   xx LinuxEnvName.cicada_core, getLinuxEnvValue
   xx Exit
defWordEnd LinuxEnvValue.cicada_core



defWord "lengthOfZeroEndingString", lengthOfZeroEndingString
   ;; (* ZeroEndingString[address] -- length *)
   xx Zero
   xx swap
   ;; (* length, ZeroEndingString[address] *)
   xx dup, fetchByte, Zero, equal?, false?branch, 3
   xx   drop
   xx   Exit
   xx add1, swap, add1
   ;; (* ZeroEndingString[address + 1], length + 1 *)
   xx branch, -13
   xx Exit
defWordEnd lengthOfZeroEndingString


segment readable writeable
BufferFor_get_cicada_core:
   rb 512

defWord "get_cicada_core", get_cicada_core
   ;; (* -- [address of zero-ending-string] *)
   xx LinuxEnvValue.cicada_core_path
   xx   dup, lengthOfZeroEndingString
   xx   literal, BufferFor_get_cicada_core
   xx   swap
   xx   copyByteString
   xx literal, '/'
   xx   literal, BufferFor_get_cicada_core
   xx   LinuxEnvValue.cicada_core_path, lengthOfZeroEndingString
   xx   addition, saveByte
   xx LinuxEnvValue.cicada_core
   xx   dup, lengthOfZeroEndingString
   xx   literal, BufferFor_get_cicada_core
   xx   LinuxEnvValue.cicada_core_path, lengthOfZeroEndingString
   xx   addition, add1
   xx   swap
   xx   copyByteString
   xx literal, BufferFor_get_cicada_core
   xx Exit
defWordEnd get_cicada_core


;; just syscall_read to read file into InputBuffer
defCode "loadCoreFile", loadCoreFile
   ;; (* [address of zero-ending-string] --  *)
   popArgumtStack sys_1_rdi
   mov     sys_3_rdx, 110100100b
   mov     sys_2_rsi, open_read
   mov     sys_n_rax, syscall_open
   syscall
   mov     sys_3_rdx, SizeOfBufferForLoadFile
   mov     sys_2_rsi, BufferForLoadFile
   mov     sys_1_rdi, rax
   mov     sys_n_rax, syscall_read
   syscall
   ;; reset [CurrentReading + CellWidth]
   mov TemporaryRegister, BufferForLoadFile
   mov [CurrentReading + CellWidth], TemporaryRegister
   ;; reset [ReadingBoundary + CellWidth]
   add TemporaryRegister, rax
   mov [ReadingBoundary + CellWidth], TemporaryRegister
   next
segment readable writeable
ScratchUsedByWriteChar:
   rb 1

defCode "writeChar", writeChar
   ;; ( char --  ) write a char to stdin
   ;; just calls the Linux write system call
   popArgumtStack rax
   call writeChar_helperFunction
   next
writeChar_helperFunction:
   mov sys_1_rdi, 1 ;; stdout
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [ScratchUsedByWriteChar], al
   mov sys_2_rsi, ScratchUsedByWriteChar  ;; address
   mov sys_3_rdx, 1                       ;; max length to be write, just 1
   mov sys_n_rax, syscall_write
   syscall
   ret




defConst "InputBufferSize", InputBufferSize, TheInputBufferSize
defConst "InputBuffer", InputBuffer, TheInputBuffer

;; Buffer for Linux syscall read
InputBufferSize = 3 * 1024 * 1024 ; bytes
;; InputBufferSize = 1 ; bytes
segment readable writeable
InputBuffer:
   rb InputBufferSize
EndOfInputBuffer:

;; two global variables for reading
;; I can easily support `evalString' by change these two variables
defVar "CurrentReading", InputBuffer, CurrentReading
defVar "ReadingBoundary", InputBuffer, ReadingBoundary


defCode "readChar", readChar
   ;; read a char from stdin, return it into the ArgumtStack as following
   ;; (*  -- char *)
   ;; readChar calls the Linux read system call to fill InputBuffer
   ;; The other thing that readChar does is
   ;; if it detects that stdin has closed, it exits the program
   ;; which is why when you hit C-d, the system exits
   call _readChar
   ;; _readChar will save the return value in rax
   pushArgumtStack rax
   next


_readChar:
   ;; TemporaryRegister is a helper-register for ``cmp''
   mov TemporaryRegister, [CurrentReading + CellWidth]
   cmp TemporaryRegister, [ReadingBoundary + CellWidth]
   ;-- IF: [CurrentReading + CellWidth] < [ReadingBoundary + CellWidth]
   ;-- WK: there is still some chars in the InputBuffer to be processed
   jl readChar_stillSomeChars
   ;-- EL: [CurrentReading + CellWidth] >= [ReadingBoundary + CellWidth]
   ;-- WK: all chars in InputBuffer have been processed
   mov rax, EndOfInputBuffer
   cmp TemporaryRegister, rax
   jg readChar_addBlankAtTheEnding
   mov rax, InputBuffer
   cmp TemporaryRegister, rax
   jl readChar_addBlankAtTheEnding
   jmp readChar_fetchMoreCharsFromStdinToInputBuffer
readChar_addBlankAtTheEnding:
   ;; otherwise,  when the a string not ending with blank
   ;; `evalString' will not work correctly
   mov rax, InputBuffer
   mov [CurrentReading + CellWidth], rax
   mov [ReadingBoundary + CellWidth], rax
   xor rax, rax
   mov al, 10
   ret
readChar_stillSomeChars:
   ;; for the following will just uses the al part of rax
   ;; it is necessary to clear rax
   xor rax, rax
   ;-- DO: fetch a char from InputBuffer to rax
   ;-- NT: after _readChar return rax will be pushArgumtStack
   mov al, byte[TemporaryRegister]
   ;-- DO: increment [CurrentReading + CellWidth]
   inc TemporaryRegister
   mov [CurrentReading + CellWidth], TemporaryRegister
   ret
;; note that, in the following subroutine
;; set [CurrentReading + CellWidth]  == InputBuffer
;; set [ReadingBoundary + CellWidth] == InputBuffer + length of string that was input (NULL not counted)
readChar_fetchMoreCharsFromStdinToInputBuffer:
   ;; read to fetch more input chars from STDIN to InputBuffer
   mov sys_3_rdx,     InputBufferSize    ;; max length to be read
   mov sys_2_rsi,     InputBuffer        ;; buffer address
   ;; reset [CurrentReading + CellWidth] to InputBuffer
   mov [CurrentReading + CellWidth], sys_2_rsi
   xor sys_1_rdi,     sys_1_rdi          ;; stdin
   mov sys_n_rax,     syscall_read
   syscall
   ;; the return value of syscall read
   ;; is a count of the number of bytes transferred
   test rax, rax
   ;-- IF: rax <= 0
   ;-- WK: there is an error or it is end of input
   ;-- DO: exit
   jz readChar_exit
   js readChar_exit
   ;-- EL: rax > 0
   ;-- WK: there are some chars has been fetched by syscall read
   ;-- DO: set [ReadingBoundary + CellWidth] to the right place
   ;--     ReadingBoundary = InputBuffer + the count of the number of bytes transferred
   ;-- NT: sys_2_rsi = InputBuffer
   ;--     rax = the count of the number of bytes transferred
   add sys_2_rsi, rax
   mov [ReadingBoundary + CellWidth], sys_2_rsi
   ;-- DO: jump back
   jmp _readChar


readChar_exit:
   ;; exit with exit code = the value syscall_read returned
   xor sys_1_rdi, sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall
defWord "readFirstNonBlankChar", readFirstNonBlankChar
   ;; (* -- FirstNonBlankChar *)
   xx readChar, dup
   xx literal, 32 ;; ascii.space
   xx greaterThan?, false?branch, 2
   xx   Exit
   xx drop
   xx branch, -10
defWordEnd readFirstNonBlankChar

defWord "readNonBlankChar", readNonBlankChar
   ;; (* -- FirstNonBlankChar or Zero *)
   xx readChar, dup
   xx literal, 32 ;; ascii.space
   xx greaterThan?, false?branch, 2
   xx   Exit
   xx drop
   xx Zero
   xx Exit
defWordEnd readNonBlankChar
define MaxWordLength 1024

segment readable writeable
BufferForReadWord:
   ;; note that, Subsequent calls will overwrite BufferForReadWord
   ;; this is why there is another function ``readWordForRuntime''
   rb MaxWordLength

defWord "readWord", readWord
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   xx literal, BufferForReadWord ;; (* leave return one of the values *)
   xx Zero                       ;; (* leave length counter *)

   xx literal, BufferForReadWord
   xx readFirstNonBlankChar
   xx over, saveByte, add1
   xx swap, add1, swap

   xx readNonBlankChar, dup, zero?branch, 9
   xx   over, saveByte, add1
   xx   swap, add1, swap
   xx   branch, -11

   xx drop2
   xx Exit
defWordEnd readWord


segment readable writeable
BufferForReadWordForRuntime:
   rb MaxWordLength

defWord "readWordForRuntime", readWordForRuntime
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   xx literal, BufferForReadWordForRuntime ;; (* leave return one of the values *)
   xx Zero                                 ;; (* leave length counter *)

   xx literal, BufferForReadWordForRuntime
   xx readFirstNonBlankChar
   xx over, saveByte, add1
   xx swap, add1, swap

   xx readNonBlankChar, dup, zero?branch, 9
   xx   over, saveByte, add1
   xx   swap, add1, swap
   xx   branch, -11

   xx drop2
   xx Exit
defWordEnd readWordForRuntime
define MaxStringLength 1024*1024 ;; unit : byte

defConst "BasicStringBuffer", BasicStringBuffer, TheBasicStringBuffer

segment readable writeable
BasicStringBuffer:
   ;; note that, Subsequent calls will overwrite BasicStringBuffer
   rb MaxStringLength

defWord "readStringInToBuffer", readStringInToBuffer
   ;; (*  -- string[address of BasicStringBuffer, length] *)
   xx literal, BasicStringBuffer ;; (* leave return one of the values *)
   xx Zero                         ;; (* leave length counter *)

   xx literal, BasicStringBuffer

   xx readChar, dup
   xx literal, 34 ;; ascii.doublequote
   xx equal?, notFalse?branch, 9
   xx   over, saveByte, add1
   xx   swap, add1, swap
   xx   branch, -14

   xx drop2
   xx Exit
defWordEnd readStringInToBuffer
;; The function uses the variable "Base" as the radix
;; If the word starts with a '-' character then the returned value is negative
 
;; If the string can't be parsed as a number
;; or contains characters outside the current BASE
;; then we need to return an error indication.
;; So we let NUMBER returns two items on the stack.
 
defCode "number", number
   ;; (* wordString[address, length] --
   ;;    parsed number, length of unparsed string *)
   popArgumtStack  rcx        ;; length  of string
   popArgumtStack  rdi        ;; address of string
   call number_helperFunction
   pushArgumtStack rax        ;; parsed number
   pushArgumtStack rcx        ;; length of unparsed string (0 = no error)
   next
 
number_helperFunction:
   xor  rax, rax
   xor  rbx, rbx
 
   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: trying to parse a zero-length string, it is an error
   ;-- DO: but will return 0
   jz number_return
   ;-- EL: rcx =/= 0
   ;-- WK: we have a non-empty string to be parsed
   ;-- DO: parse this non-empty string
   ;; copy the the variable Base into dl (rdx)
   ;; the following shows how to use a forth-variable-word in assembler code
   mov rdx, [Base + CellWidth]
   ;; fetch a char
   mov bl,  byte[rdi]
   inc rdi
   ;; sign-indicater
   ;; top of ArgumtStack == 0,  indicating positive
   ;; top of ArgumtStack =/= 0, indicating negative
   ;; initialize sign-indicater
   pushArgumtStack rax     ;; top of ArgumtStack == 0, indicating positive
   cmp bl, '-'
   ;-- IF: bl =/= '-'
   ;-- WK: maybe positive number, maybe error
   ;-- DO: try to convert the number
   jnz number_convert
   ;-- EL: bl == '-'
   ;-- DO: reset sign-indicater
   ;--     update the counter
   ;--     go into a loop to read all the chars
   popArgumtStack  rax
   pushArgumtStack rbx     ;; top of ArgumtStack =/= 0, indicating negative
   dec rcx                 ;; update the counter
   jnz number_fetchNextDigits
   popArgumtStack  rbx     ;; error: string is only '-'.
   mov rcx, 1
   ret
 
number_update_the_counter_and_fetchNextDigits:
   dec rcx
number_fetchNextDigits:
   mov bl,  byte[rdi]     ;; bl = next character in string
   inc rdi
 
number_convert:
   cmp bl, '_'
   je number_update_the_counter_and_fetchNextDigits
 
   ;; from low to high along the ascii
   sub bl, '0'
   ;-- IF: char < '0'
   jb number_endThisParse
   cmp bl, 10
   ;-- IF: '0' <= char <= '9'
   jb number_tryToAddDigitUp
 
   ;-- EL: '9' < char
   sub bl, ('A' - '0')
   ;-- IF: '9'< char < 'A'
   jb number_endThisParse
   cmp bl, 26
   ;-- NOTE-THAT: if bl == 0, char == 'A'
   ;-- IF: 'Z' < char
   jge @f
   ;-- EL: 'A' <= char <= 'Z'
   add bl, 10 ;; for 'A' =Hex= 10
   jb number_tryToAddDigitUp
 
@@:;-- IF: 'Z' < char
   sub bl, ('a' - 'A')
   ;-- IF: 'Z' < char < 'a'
   jb number_endThisParse
   cmp bl, 26
   ;-- NOTE-THAT: if bl == 0, char == 'a'
   ;-- IF: 'z' < char
   jge number_endThisParse
   ;-- EL: 'a' <= char <= 'a'
   add bl, 10 ;; for 'a' =Hex= 10
   ;; jb number_tryToAddDigitUp
 
 
number_tryToAddDigitUp:
   cmp bl, dl
   ;-- IF: bl >= dl
   ;-- WK: this digit >= Base
   jge number_endThisParse
   ;-- EL: bl < dl
   ;-- WK: this is a good digit
   ;-- DO: so add it to rax and loop
   imul rax, rdx   ;; (set! rax (* Base rax))
   add  rax, rbx
   dec  rcx
   jnz  number_fetchNextDigits
 
number_endThisParse:
;; negate the result according to the sign-indicater on the top of ArgumtStack
   popArgumtStack rbx
   test rbx, rbx
   jz   number_return
   neg  rax
number_return:
   ret
 
 
;; the following kinds of strings denote number,
;; because the function ``number'' can handle them.
;; 1. string with '0' - '9' as first char
;; 2. string with '-' as first char and with '0' - '9' as second char
;; so "-->", "_0" do not denote number.
;; under HexBase,
;; "feed" does not denote number, but "0feed", "0_feed" denote number
 
defCode "stringDenoteNumber?", stringDenoteNumber?
   ;; ( wordString[address, length] -- true or false )
   popArgumtStack  rcx        ;; length  of string
   popArgumtStack  rdi        ;; address of string
   call stringDenoteNumber?_helperFunction
   pushArgumtStack rax        ;; true or false
   next
 
stringDenoteNumber?_helperFunction:
   xor rbx, rbx
 
   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: trying to parse a zero-length string, it is an error
   jz stringDenoteNumber?_returnFalse
   ;-- EL: rcx =/= 0
   ;-- WK: we have a non-empty string to be parsed
   mov bl,  byte[rdi]
   cmp bl, '-'
   ;-- IF: bl =/= '-'
   ;-- WK: maybe positive number, maybe error
   jnz @f
   ;-- EL: bl == '-'
   inc rdi
   dec rcx                 ;; update the counter
   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: string is only '-'
   jz stringDenoteNumber?_returnFalse
   ;; fetch next digit
   mov  bl,  byte[rdi]
   inc  rdi
 
@@:
   sub bl, '0'
   ;-- IF: char < '0'
   jb stringDenoteNumber?_returnFalse
   cmp bl, 10
   ;-- IF: '0' <= char <= '9'
   jb stringDenoteNumber?_returnTrue
   ;-- EL: returnFalse
 
stringDenoteNumber?_returnFalse:
   xor rax, rax
   ret
 
stringDenoteNumber?_returnTrue:
   xor rax, rax
   mov rax, qword 1
   ret
defConstString "CommentBeginWordString",  "(*", CommentBeginWordString
defConstString "CommentEndingWordString", "*)", CommentEndingWordString

defWord "ignoreComment", ignoreComment
   ;; (* -- *)
   ;; (* ignore a list of comment words from stdin *)
   xx readWord
   xx dup2, CommentBeginWordString, equalString?, false?branch, 5
   xx   drop2, ignoreComment, branch, -9
   ;; beware of the tail-call-optimization
   ;; a tail-recursive-call is really a loop
   xx CommentEndingWordString, equalString?, false?branch, -13
   xx   Exit
defWordEnd ignoreComment


defWord "(*", comment
   xx ignoreComment
   xx Exit
defWordEnd comment

;; test:
;; (* ok (* ok *) ok *) ok
;; a WordList (unit : CellWidth = 8 bytes)
;;   ||  1 : length-of-Word-1     ||
;;   ||  a : Word-1--as-a-string  ||
;;   ||  1 : length-of-Word-2     ||
;;   ||  b : Word-2--as-a-string  ||
;;   ...

;; note that:
;;    Subsequent calls will overwrite BufferForReadWordListForLexicographer
segment readable writeable
BufferForReadWordListForLexicographer:
   rb 1024*1024

defConstString "EndingWordForReadWordListForLexicographer", ";", EndingWordForReadWordListForLexicographer
defConstString "ChineseEndingWordForReadWordListForLexicographer", "者", ChineseEndingWordForReadWordListForLexicographer

defVar "NextWordForReadWordListForLexicographer", BufferForReadWordListForLexicographer, NextWordForReadWordListForLexicographer

defWord "readWordListForLexicographer", readWordListForLexicographer
   ;; (* read a WordList from stdin (ForLexicographer) *)
   ;; (* -- wordList[address, the number of words] *)

   ;; (* initialize NextWordForReadWordListForLexicographer *)
   xx literal, BufferForReadWordListForLexicographer
   xx NextWordForReadWordListForLexicographer
   xx save

   ;; (* leave return value: [buffer-address, counter] *)
   xx literal, BufferForReadWordListForLexicographer
   xx Zero

   xx readWord

   xx dup2
   xx CommentBeginWordString, equalString?, false?branch, 5
   xx drop2, ignoreComment, branch, -9

   xx dup2
   xx EndingWordForReadWordListForLexicographer, equalString?, false?branch, 3
   xx drop2
   xx Exit

   xx dup2
   xx ChineseEndingWordForReadWordListForLexicographer, equalString?, false?branch, 3
   xx drop2
   xx Exit

   xx addWordToListForLexicographer
   xx add1
   xx branch, -27
defWordEnd readWordListForLexicographer

defWord ":", BeginningWordForReadWordListForLexicographer
   xx readWordListForLexicographer
   xx Exit
defWordEnd BeginningWordForReadWordListForLexicographer

defWord "夫", ChineseBeginningWordForReadWordListForLexicographer
   xx readWordListForLexicographer
   xx Exit
defWordEnd ChineseBeginningWordForReadWordListForLexicographer


defWord "addWordToListForLexicographer", addWordToListForLexicographer
   ;; ( wordString[address, length] -- )
   ;; leave a length behind, for update NextWordForReadWordListForLexicographer at the end
   xx dup, xxswapx
   ;;   ||  1 : length-of-Word-1     ||
   xx dup, NextWordForReadWordListForLexicographer, fetch, save
   ;; update NextWordForReadWordListForLexicographer
   xx NextWordForReadWordListForLexicographer, fetch, add8, NextWordForReadWordListForLexicographer, save
   ;;   ||  a : Word-1--as-a-string  ||
   xx NextWordForReadWordListForLexicographer, fetch, swap, copyByteString
   ;; update NextWordForReadWordListForLexicographer again
   xx NextWordForReadWordListForLexicographer, addSave
   xx Exit
defWordEnd addWordToListForLexicographer
;; recall
;; a word in the dictionary (unit : CellWidth = 8 bytes)
;; ==
;;   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;   ||  m : name-string  ||
;;   ||  1 : link  ||
;;   ||  1 : type  ||
;;   ||  1 : address-of-name-string-header  ||
;;   ||  1 : address-of-explainer  ||
;;   ||  n : body  ||
;; where
;;   ||  1 : type  ||
;; ==
;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
;; type-bit-0 is for HiddenWord
define WordType_HiddenMask 00000001h


;; defWord "wordLinkToWordString", wordLinkToWordString
;;    ;; (* link[address] -- string[address, length] *)
;;    xx literal, CellWidth
;;    xx Two, multiple
;;    xx addition
;;    xx fetch
;;    xx dup, literal, CellWidth, addition
;;    xx swap, fetch
;;    xx Exit
;; defWordEnd wordLinkToWordString

;; defWord "help,find", help_find
;;    ;; (* wordString[address, length], link[address] -- word[address of link] or Zero *)
;;    xx dup, zero?, false?branch, 4
;;    xx   xxswapx, drop2
;;    xx   Exit
;;    xx xxtuckx, wordLinkToWordString, xxoverxx, equalString?, false?branch, 3
;;    xx   drop2
;;    xx   Exit
;;    xx xswapxx, fetch
;;    xx help_find
;;    xx Exit
;; defWordEnd help_find

;; defWord "find", find
;;    ;; (* wordString[address, length] -- word[address of link] or Zero *)
;;    xx FirstWordInDictionary, fetch
;;    xx help_find
;;    xx Exit
;; defWordEnd find



defCode "find", find
   ;; (* wordString[address, length] -- word[address of link] or Zero *)
   ;; find doesn't find dictionary entries which are flagged as hidden
   popArgumtStack  rcx     ;; length
   popArgumtStack  rdi     ;; address
   call find_helperFunction
   ;; returns the address of the address of the link of the word in the dictionary (or null)
   pushArgumtStack rax
   next

find_helperFunction:
   ;; ><><>< if rsi is used somewhere else,
   ;; the following will be necessary.
   ;; pushArgumtStack rsi    ;; save rsi so we can use it in string comparison
   ;; initialize the searching point
   mov rdx, [FirstWordInDictionary + CellWidth]

find_lookThisPoint:
   test rdx, rdx
   ;-- IF: rdx == 0
   ;-- WK: we reach the end of the linked list
   je find_notFound
   ;-- EL: rdx == 0
   ;-- WK: we have a word to look up
   ;-- DO: look the type field of this word
   mov rax, [rdx + CellWidth]
   and rax, WordType_HiddenMask
   ;-- IF: type::0 of this word =/= 0
   ;-- WK: this word is hidden
   jnz find_lookNextPoint
   ;-- EL: type::0 of this word == 0
   ;-- WK: this word is not hidden
   ;; get word length into rax
   mov TemporaryRegister, [rdx + (2 * CellWidth)]
   mov rax, [TemporaryRegister]
   cmp rax, rcx
   ;-- IF: rax =/= rcx
   ;-- WK: length is not the same
   jne find_lookNextPoint
   ;-- EL: rax == rcx
   ;-- WK: length is the same
   ;-- DO: compare the strings in detail
   pushArgumtStack rcx                       ;; save the length
   pushArgumtStack rdi                       ;; save the address (repe cmpsb will move this pointer)
   lea rsi, [TemporaryRegister + CellWidth]  ;; dictionary string we are checking against.
   ;; >< 下面这个命令的参数是 rsi rdi rcx
   ;; 分别是两个地址和需要被比较的长度
   repe cmpsb                                ;; compare the strings.
   popArgumtStack rdi
   popArgumtStack rcx
   ;-- IF: not the same
   jne find_lookNextPoint
   ;-- EL: the strings are the same
   ;-- DO: return the address of link of this word in rax
   mov rax, rdx
   ;; popArgumtStack rsi
   ret

find_lookNextPoint:
   ;; move back through the link field to the previous word
   mov rdx, [rdx]
   ;; jump back
   jmp find_lookThisPoint

find_notFound:
   ;; return 0
   xor rax, rax
   ;; popArgumtStack rsi
   ret


;; usage;
;; 1 2 readWord + find wordLinkToWordExplainer execute . ( 3 )
defWord "wordLinkToWordExplainer", wordLinkToWordExplainer
   ;; (* word[address of link] -- word[address of explainer] or Zero *)
   xx add8, add8, add8
   xx Exit
defWordEnd wordLinkToWordExplainer
defWord "appendNumberToHere", appendNumberToHere
   ;; (* a 64 bits number -- *)
   ;; reset ``Here'', which points next free memory
   xx Here, fetch
   xx save
   xx Here, fetch, add8
   xx Here ,save
   xx Exit
defWordEnd appendNumberToHere

;; note that:
;; a string in stack is string[address, length]
;; a string in memory is ||  1 : length  ||  n : string  ||
defWord "appendStringToHere", appendStringToHere
   ;; (* string[address, length] -- *)
   ;; leave a length behind, for update Here
   xx dup, xxswapx
   ;;   ||  1 : length  ||
   xx dup, appendNumberToHere
   ;;   ||  n : string  ||
   xx Here, fetch, swap, copyByteString
   ;; update Here
   xx Here, fetch, addition, Here, save
   xx Exit
defWordEnd appendStringToHere

;; test: appendNumberToHere
;; 6 , Here fetch sub8 fetch .


defWord "createWordHeader", createWordHeader
   ;; (* byString *)
   ;; (* string[address, length] -- word[address of link] *)
   xx Here, fetch, xxswapx ;; for address-of-name-string-header
   xx appendStringToHere
   xx Here, fetch, appendNumberToHere ;; (* identification *)
   xx Here, fetch ;; (* leave the word[link] *)
   xx Zero, appendNumberToHere ;; (* link *)
   xx Zero, appendNumberToHere ;; (* type *)
   xx swap
   xx appendNumberToHere ;; address-of-name-string-header
   xx Exit
defWordEnd createWordHeader


defWord "createWordHeaderForFunction", createWordHeaderForFunction
   ;; (* string[address, length] -- word[address of link] *)
   xx Here, fetch, xxswapx ;; for address-of-name-string-header
   xx appendStringToHere
   xx Zero, appendNumberToHere ;; (* SizeOfFunctionBody *)
   xx Here, fetch, appendNumberToHere ;; (* identification *)
   xx Here, fetch ;; (* leave the word[link] *)
   xx Zero, appendNumberToHere ;; (* link *)
   xx Zero, appendNumberToHere ;; (* type *)
   xx swap
   xx appendNumberToHere ;; address-of-name-string-header
   xx Exit
defWordEnd createWordHeaderForFunction



defWord "appendWordDescriptionToHere", appendWordDescriptionToHere
   ;; (* wordList[address, the number of words] -- *)
   xx dup, zero?branch, 16;-- GOTO: drop2
   xx tailAndHeadOfWordList
   xx dup2, stringDenoteNumber?
   xx false?branch, 6;-- GOTO: find
   ;; reading-error reported by ``number'' is not handled
   xx number, drop, appendNumberToHere
   xx branch, -12;-- GOTO: the beginning

   xx find, wordLinkToWordExplainer, appendNumberToHere
   xx branch, -17;-- GOTO: the beginning

   xx drop2
   xx Exit
defWordEnd appendWordDescriptionToHere

defWord "addNewWordToDictionary", addNewWordToDictionary
   ;; reset FirstWordInDictionary to point to the newly defined word
   ;; (* word[address of link] -- *)
   xx dup
   xx FirstWordInDictionary, fetch
   xx swap
   xx save
   xx FirstWordInDictionary, save
   xx Exit
defWordEnd addNewWordToDictionary

defWord "setTheSizeOfFunctionBody", setTheSizeOfFunctionBody
   ;; (* wordList[address, the number of words], word[address of link] --
   ;;    wordList[address, the number of words], word[address of link] *)
   xx dup
   xx sub8, sub8
   xx xoverxx
   xx swap
   xx save
   xx Exit
defWordEnd setTheSizeOfFunctionBody

defWord "defineFunction", defineFunction
   ;; (* wordList[address, the number of words] -- *)
   ;; to create a new word
   ;; is to use some words to describe the new word,
   ;; and let an explainer to explain the description of the new word.
   ;; to define a new word
   ;; is to add the new created word to the dictionary.
   xx tailAndHeadOfWordList
   xx createWordHeaderForFunction
   xx FunctionBodyExplainer, appendNumberToHere
   xx setTheSizeOfFunctionBody
   xx xxswapx
   xx appendWordDescriptionToHere
   xx addNewWordToDictionary
   xx Exit
defWordEnd defineFunction
defWord "basicREPL", basicREPL
   ;; (* unknown -- unknown *)
   xx TheReturnStackTop, resetReturnStackPointer
   xx TheArgumtStackTop, resetArgumtStackPointer
   xx readWordForRuntime
   xx executeWord
   xx branch, -3
   ;; must not end with Exit here
defWordEnd basicREPL


defWord "executeWord", executeWord
   ;; (* unknown -- unknown *)
   xx dup2, stringDenoteNumber?
   xx false?branch, 4;-- GOTO: find, dup, zero?branch

   ;; about number, no error handling
   xx number, drop
   xx Exit

   ;; about non-number
   xx find, dup, zero?branch, 4;-- GOTO: drop, printErrorInfoForExecuteWord
   xx wordLinkToWordExplainer, execute
   xx Exit

   xx drop, printErrorInfoForExecuteWord
   xx Exit
defWordEnd executeWord


defWord "printErrorInfoForExecuteWord", printErrorInfoForExecuteWord
   ;; (* -- *)
   xx Ten, writeChar
   xx literal, 32, writeChar
   xx literal, 32, writeChar
   xx literal, 'u', writeChar
   xx literal, 'n', writeChar
   xx literal, 'd', writeChar
   xx literal, 'e', writeChar
   xx literal, 'f', writeChar
   xx literal, 'i', writeChar
   xx literal, 'n', writeChar
   xx literal, 'e', writeChar
   xx literal, 'd', writeChar
   xx literal, 32, writeChar
   xx Exit
defWordEnd printErrorInfoForExecuteWord
segment readable executable
cicada_begin:

        cld ;; set DF = 0, then rsi and rdi are incremented

;; [rsp+8*0]=N           argc number of arguments
;; [rsp+8*1]             argv0 name of executable (e.g. ./a00)
;; [rsp+8*2]             argv1 (if any) - 1st param after name of executable
;; ...
;; [rsp+8*N]             argvN - Nth param
;; qword [rsp+8*(N+1)]=0 end of arguments
;; [rsp+8*(N+2)]         envp environment
;; ...
;; qword [rsp+....]=0    end of environment

    ;; the Address we want is stored in [rsp] but not rsp
    ;; because rsp is the standard-stack-pointer
    ;; the Address we want is pushed into the standard-stack

        ;; beware of the way
        ;;   to use the ``Const'' or ``Var'' in assembly

        mov [LinuxProgramHeaderAddress + CellWidth], rsp


        mov ArgumtStackPointer,   ArgumtStackTop
        mov GreyPairStackPointer, GreyPairStackTop
        mov ReturnStackPointer,   ReturnStackTop

        ;; initialize the variable ``Here''
        ;; to point at beginning of DataSegment
        mov TemporaryRegister, UserDataSegment
        mov [Here + CellWidth], TemporaryRegister
        mov NextWordPointer, BeginCicada
        next



segment readable writeable
BeginCicada:

        xx get_cicada_core, loadCoreFile
        xx basicREPL
        ;; xx assemblyDebug

defConst "LinuxProgramHeaderAddress", 0, LinuxProgramHeaderAddress

;; test:
;; LinuxProgramHeaderAddress fetch . cr
;; LinuxProgramHeaderAddress CellWidth 1 * + fetch
;;   20 printString cr
;; LinuxProgramHeaderAddress CellWidth 2 * + fetch
;;   3 printString cr
defConst "ArgumtStackTop",    ArgumtStackTop,    TheArgumtStackTop
defConst "ArgumtStackBottom", ArgumtStackBottom, TheArgumtStackBottom

SizeOfArgumtStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
ArgumtStackBottom:
        rq SizeOfArgumtStack
ArgumtStackTop:
        rq 100


SizeOfReturnStack = 100 * 1024 ;; unit: CellWidth

defConst "ReturnStackTop",    ReturnStackTop,    TheReturnStackTop
defConst "ReturnStackBottom", ReturnStackBottom, TheReturnStackBottom

segment readable writeable
ReturnStackBottom:
        rq SizeOfReturnStack
ReturnStackTop:
        rq 100
SizeOfUserDataSegment = 1024 * 1024 ;; unit: byte
segment readable writeable
UserDataSegment:
        rb SizeOfUserDataSegment
EndOfUserDataSegment:

defConst "UserDataSegment", UserDataSegment, TheUserDataSegment
defConst "EndOfUserDataSegment", EndOfUserDataSegment, TheEndOfUserDataSegment
;;   (unit : byte)
;; ========================
;;   ||  1 : color     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ========================

ClrBytesSize = 1
CarBytesSize = 16
CdrBytesSize = 16
ConsBytesSize = ClrBytesSize + CarBytesSize + CdrBytesSize
;; NumberOfPairConstructions = 1024
NumberOfPairConstructions = 100 * 1000 ;; about 3.3M

defConst "ClrBytesSize"  , ClrBytesSize  , TheClrBytesSize
defConst "CarBytesSize"  , CarBytesSize  , TheCarBytesSize
defConst "CdrBytesSize"  , CdrBytesSize  , TheCdrBytesSize
defConst "ConsBytesSize" , ConsBytesSize , TheConsBytesSize

segment readable writeable
        rb ClrBytesSize
InFrontOfTheFirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        rb ClrBytesSize
FirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        ;; ==========================
        rb (NumberOfPairConstructions - 2) * ConsBytesSize
        ;; ==========================

        rb ClrBytesSize
LastPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

defConst "NumberOfPairConstructions", NumberOfPairConstructions, TheNumberOfPairConstructions

defConst "InFrontOfTheFirstPairConstruction", InFrontOfTheFirstPairConstruction, TheInFrontOfTheFirstPairConstruction
defConst "FirstPairConstruction", FirstPairConstruction, TheFirstPairConstruction
defConst "LastPairConstruction",  LastPairConstruction,  TheLastPairConstruction

defVar "CurrFreePairConstruction", FirstPairConstruction, CurrFreePairConstruction
SizeOfGreyPairStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
GreyPairStackBottom:
        rq SizeOfGreyPairStack
GreyPairStackTop:
        rq 1
;; a SymbolEntry (unit : byte)
;; ===========================
;;  ||   8 : SymbolValue   ||
;; ---------------------------
;;  ||   1 : SymbolLength  ||
;; ---------------------------
;;  || 56+ : SymbolString  ||
;; ===========================

SymbolLengthBytesSize = 1
SymbolValueBytesSize  = 8
SymbolStringBytesSize = 56+0
SymbolMaxLength       = 56
SymbolEntryBytesSize = SymbolValueBytesSize + SymbolLengthBytesSize + SymbolStringBytesSize
;; NumberOfSymbolEntrys = 1000003
;; NumberOfSymbolEntrys = 1000033
;; NumberOfSymbolEntrys = 1000333
;; NumberOfSymbolEntrys = 100003
NumberOfSymbolEntrys = 100333
;; NumberOfSymbolEntrys = 997
;; NumberOfSymbolEntrys = 499
;; NumberOfSymbolEntrys = 230 ;; for a special test


defConst "NumberOfSymbolEntrys",  NumberOfSymbolEntrys,  TheNumberOfSymbolEntrys
defConst "SymbolValueBytesSize",  SymbolValueBytesSize,  TheSymbolValueBytesSize
defConst "SymbolLengthBytesSize", SymbolLengthBytesSize, TheSymbolLengthBytesSize
defConst "SymbolStringBytesSize", SymbolStringBytesSize, TheSymbolStringBytesSize
defConst "SymbolMaxLength",       SymbolMaxLength,       TheSymbolMaxLength
defConst "SymbolEntryBytesSize",  SymbolEntryBytesSize,  TheSymbolEntryBytesSize

segment readable writeable

FirstSymbolEntry:
        rb SymbolEntryBytesSize

        ;; ========================
        rb (NumberOfSymbolEntrys - 2) * SymbolEntryBytesSize
        ;; ========================

LastSymbolEntry:
        rb SymbolEntryBytesSize


defConst "FirstSymbolEntry", FirstSymbolEntry, TheFirstSymbolEntry
defConst "LastSymbolEntry",  LastSymbolEntry,  TheLastSymbolEntry
SizeOfStringHeap = 5 * 1024 * 1024 ;; unit: byte
segment readable writeable
StringHeap1:
        rb SizeOfStringHeap
EndOfStringHeap1:
segment readable writeable
StringHeap2:
        rb SizeOfStringHeap
EndOfStringHeap2:

defConst "SizeOfStringHeap", SizeOfStringHeap, TheSizeOfStringHeap

defConst "StringHeap1", StringHeap1, TheStringHeap1
defConst "StringHeap2", StringHeap2, TheStringHeap2
SizeOfLambdaStack = 10 * 1024 ;; unit: CellWidth
segment readable writeable
LambdaStackBottom:
        rq SizeOfLambdaStack
LambdaStackTop:
        rq 1

defConst "LambdaStackBottom", LambdaStackBottom, TheLambdaStackBottom
defConst "LambdaStackTop", LambdaStackTop, TheLambdaStackTop
SizeOfBufferForLoadFile = 1024 * 1024 ;; unit : byte

defConst "BufferForLoadFile", BufferForLoadFile, TheBufferForLoadFile
defConst "SizeOfBufferForLoadFile", SizeOfBufferForLoadFile, TheSizeOfBufferForLoadFile

segment readable writeable
BufferForLoadFile:
         rb SizeOfBufferForLoadFile
SizeOfStackForEvalString = 1024 ;; unit: CellWidth
segment readable writeable
StackForEvalStringBottom:
        rq SizeOfStackForEvalString
StackForEvalStringTop:
        rq 1

defConst "StackForEvalStringBottom", StackForEvalStringBottom, TheStackForEvalStringBottom
defConst "StackForEvalStringTop", StackForEvalStringTop, TheStackForEvalStringTop
SizeOfFileNameBufferForOpenFile = 1024 ;; unit : byte

defConst "FileNameBufferForOpenFile", FileNameBufferForOpenFile, TheFileNameBufferForOpenFile

segment readable writeable
FileNameBufferForOpenFile:
         rb SizeOfFileNameBufferForOpenFile
defWord ".", printLittleNumber
   xx literal, '0'
   xx addition, writeChar
   xx literal, 32
   xx writeChar
   xx literal, 32
   xx writeChar
   xx Exit
defWordEnd printLittleNumber

defCode "exitWithTOS", exitWithTOS
   popArgumtStack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall

defWord "assemblyDebug", assemblyDebug
   ;; xx ><><><
   xx exitWithTOS
defWordEnd assemblyDebug
;; this word helps to initialize FirstWordInDictionary
defConst "TheLatestWordInAssembly", 0, TheLatestWordInAssembly
