#+TITLE: cicada language
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com

* ==================================================
* prepare
** linux_syscalls
   #+begin_src fasm :tangle ./play/linux_syscalls.fasm
   ;; see /usr/include/asm/unistd_64.h (on archlinux)
   
   ;; parameters order of syscall:
   define sys_6_r8  r8
   define sys_5_r9  r9
   define sys_4_r10 r10
   define sys_3_rdx rdx
   define sys_2_rsi rsi
   define sys_1_rdi rdi
   define sys_n_rax rax
   
   ;; syscall number:
   define syscall_read                      0
   define syscall_write                     1
   define syscall_open                      2
   define syscall_close                     3
   
   define syscall_stat                      4
   define syscall_fstat                     5
   define syscall_lstat                     6
   define syscall_poll                      7
   define syscall_lseek                     8
   define syscall_mmap                      9
   define syscall_mprotect                  10
   define syscall_munmap                    11
   define syscall_brk                       12
   define syscall_rt_sigaction              13
   define syscall_rt_sigprocmask            14
   define syscall_rt_sigreturn              15
   define syscall_ioctl                     16
   define syscall_pread64                   17
   define syscall_pwrite64                  18
   define syscall_readv                     19
   define syscall_writev                    20
   define syscall_access                    21
   define syscall_pipe                      22
   define syscall_select                    23
   define syscall_sched_yield               24
   define syscall_mremap                    25
   define syscall_msync                     26
   define syscall_mincore                   27
   define syscall_madvise                   28
   define syscall_shmget                    29
   define syscall_shmat                     30
   define syscall_shmctl                    31
   define syscall_dup2                       32
   define syscall_dup2                      33
   define syscall_pause                     34
   define syscall_nanosleep                 35
   define syscall_getitimer                 36
   define syscall_alarm                     37
   define syscall_setitimer                 38
   define syscall_getpid                    39
   define syscall_sendfile                  40
   define syscall_socket                    41
   define syscall_connect                   42
   define syscall_accept                    43
   define syscall_sendto                    44
   define syscall_recvfrom                  45
   define syscall_sendmsg                   46
   define syscall_recvmsg                   47
   define syscall_shutdown                  48
   define syscall_bind                      49
   define syscall_listen                    50
   define syscall_getsockname               51
   define syscall_getpeername               52
   define syscall_socketpair                53
   define syscall_setsockopt                54
   define syscall_getsockopt                55
   define syscall_clone                     56
   define syscall_fork                      57
   define syscall_vfork                     58
   define syscall_execve                    59
   
   define syscall_exit                      60
   
   define syscall_wait4                     61
   define syscall_kill                      62
   define syscall_uname                     63
   define syscall_semget                    64
   define syscall_semop                     65
   define syscall_semctl                    66
   define syscall_shmdt                     67
   define syscall_msgget                    68
   define syscall_msgsnd                    69
   define syscall_msgrcv                    70
   define syscall_msgctl                    71
   define syscall_fcntl                     72
   define syscall_flock                     73
   define syscall_fsync                     74
   define syscall_fdatasync                 75
   define syscall_truncate                  76
   define syscall_ftruncate                 77
   define syscall_getdents                  78
   define syscall_getcwd                    79
   define syscall_chdir                     80
   define syscall_fchdir                    81
   define syscall_rename                    82
   define syscall_mkdir                     83
   define syscall_rmdir                     84
   define syscall_creat                     85
   define syscall_link                      86
   define syscall_unlink                    87
   define syscall_symlink                   88
   define syscall_readlink                  89
   define syscall_chmod                     90
   define syscall_fchmod                    91
   define syscall_chown                     92
   define syscall_fchown                    93
   define syscall_lchown                    94
   define syscall_umask                     95
   define syscall_gettimeofday              96
   define syscall_getrlimit                 97
   define syscall_getrusage                 98
   define syscall_sysinfo                   99
   define syscall_times                     100
   define syscall_ptrace                    101
   define syscall_getuid                    102
   define syscall_syslog                    103
   define syscall_getgid                    104
   define syscall_setuid                    105
   define syscall_setgid                    106
   define syscall_geteuid                   107
   define syscall_getegid                   108
   define syscall_setpgid                   109
   define syscall_getppid                   110
   define syscall_getpgrp                   111
   define syscall_setsid                    112
   define syscall_setreuid                  113
   define syscall_setregid                  114
   define syscall_getgroups                 115
   define syscall_setgroups                 116
   define syscall_setresuid                 117
   define syscall_getresuid                 118
   define syscall_setresgid                 119
   define syscall_getresgid                 120
   define syscall_getpgid                   121
   define syscall_setfsuid                  122
   define syscall_setfsgid                  123
   define syscall_getsid                    124
   define syscall_capget                    125
   define syscall_capset                    126
   define syscall_rt_sigpending             127
   define syscall_rt_sigtimedwait           128
   define syscall_rt_sigqueueinfo           129
   define syscall_rt_sigsuspend             130
   define syscall_sigaltstack               131
   define syscall_utime                     132
   define syscall_mknod                     133
   define syscall_uselib                    134
   define syscall_personality               135
   define syscall_ustat                     136
   define syscall_statfs                    137
   define syscall_fstatfs                   138
   define syscall_sysfs                     139
   define syscall_getpriority               140
   define syscall_setpriority               141
   define syscall_sched_setparam            142
   define syscall_sched_getparam            143
   define syscall_sched_setscheduler        144
   define syscall_sched_getscheduler        145
   define syscall_sched_get_priority_max    146
   define syscall_sched_get_priority_min    147
   define syscall_sched_rr_get_interval     148
   define syscall_mlock                     149
   define syscall_munlock                   150
   define syscall_mlockall                  151
   define syscall_munlockall                152
   define syscall_vhangup                   153
   define syscall_modify_ldt                154
   define syscall_pivot_root                155
   define syscall__sysctl                   156
   define syscall_prctl                     157
   define syscall_arch_prctl                158
   define syscall_adjtimex                  159
   define syscall_setrlimit                 160
   define syscall_chroot                    161
   define syscall_sync                      162
   define syscall_acct                      163
   define syscall_settimeofday              164
   define syscall_mount                     165
   define syscall_umount2                   166
   define syscall_swapon                    167
   define syscall_swapoff                   168
   define syscall_reboot                    169
   define syscall_sethostname               170
   define syscall_setdomainname             171
   define syscall_iopl                      172
   define syscall_ioperm                    173
   define syscall_create_module             174
   define syscall_init_module               175
   define syscall_delete_module             176
   define syscall_get_kernel_syms           177
   define syscall_query_module              178
   define syscall_quotactl                  179
   define syscall_nfsservctl                180
   define syscall_getpmsg                   181
   define syscall_putpmsg                   182
   define syscall_afs_syscall               183
   define syscall_tuxcall                   184
   define syscall_security                  185
   define syscall_gettid                    186
   define syscall_readahead                 187
   define syscall_setxattr                  188
   define syscall_lsetxattr                 189
   define syscall_fsetxattr                 190
   define syscall_getxattr                  191
   define syscall_lgetxattr                 192
   define syscall_fgetxattr                 193
   define syscall_listxattr                 194
   define syscall_llistxattr                195
   define syscall_flistxattr                196
   define syscall_removexattr               197
   define syscall_lremovexattr              198
   define syscall_fremovexattr              199
   define syscall_tkill                     200
   define syscall_time                      201
   define syscall_futex                     202
   define syscall_sched_setaffinity         203
   define syscall_sched_getaffinity         204
   define syscall_set_thread_area           205
   define syscall_io_setup                  206
   define syscall_io_destroy                207
   define syscall_io_getevents              208
   define syscall_io_submit                 209
   define syscall_io_cancel                 210
   define syscall_get_thread_area           211
   define syscall_lookup_dcookie            212
   define syscall_epoll_create              213
   define syscall_epoll_ctl_old             214
   define syscall_epoll_wait_old            215
   define syscall_remap_file_pages          216
   define syscall_getdents64                217
   define syscall_set_tid_address           218
   define syscall_restart_syscall           219
   define syscall_semtimedop                220
   define syscall_fadvise64                 221
   define syscall_timer_create              222
   define syscall_timer_settime             223
   define syscall_timer_gettime             224
   define syscall_timer_getoverrun          225
   define syscall_timer_delete              226
   define syscall_clock_settime             227
   define syscall_clock_gettime             228
   define syscall_clock_getres              229
   define syscall_clock_nanosleep           230
   define syscall_exit_group                231
   define syscall_epoll_wait                232
   define syscall_epoll_ctl                 233
   define syscall_tgkill                    234
   define syscall_utimes                    235
   define syscall_vserver                   236
   define syscall_mbind                     237
   define syscall_set_mempolicy             238
   define syscall_get_mempolicy             239
   define syscall_mq_open                   240
   define syscall_mq_unlink                 241
   define syscall_mq_timedsend              242
   define syscall_mq_timedreceive           243
   define syscall_mq_notify                 244
   define syscall_mq_getsetattr             245
   define syscall_kexec_load                246
   define syscall_waitid                    247
   define syscall_add_key                   248
   define syscall_request_key               249
   define syscall_keyctl                    250
   define syscall_ioprio_set                251
   define syscall_ioprio_get                252
   define syscall_inotify_init              253
   define syscall_inotify_add_watch         254
   define syscall_inotify_rm_watch          255
   define syscall_migrate_pages             256
   define syscall_openat                    257
   define syscall_mkdirat                   258
   define syscall_mknodat                   259
   define syscall_fchownat                  260
   define syscall_futimesat                 261
   define syscall_newfstatat                262
   define syscall_unlinkat                  263
   define syscall_renameat                  264
   define syscall_linkat                    265
   define syscall_symlinkat                 266
   define syscall_readlinkat                267
   define syscall_fchmodat                  268
   define syscall_faccessat                 269
   define syscall_pselect6                  270
   define syscall_ppoll                     271
   define syscall_unshare                   272
   define syscall_set_robust_list           273
   define syscall_get_robust_list           274
   define syscall_splice                    275
   define syscall_tee                       276
   define syscall_sync_file_range           277
   define syscall_vmsplice                  278
   define syscall_move_pages                279
   define syscall_utimensat                 280
   define syscall_epoll_pwait               281
   define syscall_signalfd                  282
   define syscall_timerfd_create            283
   define syscall_eventfd                   284
   define syscall_fallocate                 285
   define syscall_timerfd_settime           286
   define syscall_timerfd_gettime           287
   define syscall_accept4                   288
   define syscall_signalfd4                 289
   define syscall_eventfd2                  290
   define syscall_epoll_create1             291
   define syscall_dup3                      292
   define syscall_pipe2                     293
   define syscall_inotify_init1             294
   define syscall_preadv                    295
   define syscall_pwritev                   296
   define syscall_rt_tgsigqueueinfo         297
   define syscall_perf_event_open           298
   define syscall_recvmmsg                  299
   define syscall_fanotify_init             300
   define syscall_fanotify_mark             301
   define syscall_prlimit64                 302
   define syscall_name_to_handle_at         303
   define syscall_open_by_handle_at         304
   define syscall_clock_adjtime             305
   define syscall_syncfs                    306
   define syscall_sendmmsg                  307
   define syscall_setns                     308
   define syscall_getcpu                    309
   define syscall_process_vm_readv          310
   define syscall_process_vm_writev         311
   define syscall_kcmp                      312
   define syscall_finit_module              313
   
   
   STDIN  = 0
   STDOUT = 1
   STDERR = 2
   
   open_read         = 0
   open_write        = 1
   open_readAndWrite = 2
   
   open_creat      = 0100o
   open_rewrite    = 1000o ;; rewrite if file exist
   open_append     = 2000o
   
   open_excl       = 0200o ;; ensure that THIS call creates the file
   open_noctty     = 0400o
   open_nonblock   = 4000o
   open_nondelay   = open_nonblock
   open_sync       = 10000o
   open_async      = 20000o
   open_direct     = 40000o
       ;; to minimize cache effects of the I/O to and from this file.
   open_largefile  = 100000o
   open_directory  = 200000o
   open_nofollow   = 400000o ;; If pathname is a symbolic link, then the open fails.
   #+end_src
** include
   #+begin_src fasm :tangle ./play/cicada.fasm
   include "./linux_syscalls.fasm"
   #+end_src
** equ
   #+begin_src fasm :tangle ./play/cicada.fasm
   ;; in fasm, ``dup'' is a reserved word
   dup equ duplicate
   ;; 64-bits
   xx equ dq
   CellWidth equ 8
   #+end_src
** format header and entry
   #+begin_src fasm :tangle ./play/cicada.fasm
   format elf64 executable 3
   entry cicada_begin
   #+end_src
** registers & pop & push
   #+begin_src fasm :tangle ./play/cicada.fasm
   ;define CellWidth 8 ;; (unit : byte)
   
   ;; if you want to extend cicada in assembly,
   ;; the following four registers must not be used
   ;; =================================
   define NextWordPointer      r15
   define ReturnStackPointer   r14
   define ArgumtStackPointer   r13
   define GreyPairStackPointer r12
   ;; =================================
   
   define ExplainerPointer     rax
   define TemporaryRegister    r11
   define TemporaryRegister2   r10
   
   
   ;; ``ReturnStackPointer'' always stores the address of TOC (top-of-stack),
   ;; NOT the address of first-free-place in the stack
   
   ;; macro pushReturnStack Register {
   ;;    sub ReturnStackPointer, CellWidth
   ;;    mov [ReturnStackPointer], Register
   ;;    }
   ;; macro popReturnStack Register {
   ;;    mov Register, [ReturnStackPointer]
   ;;    add ReturnStackPointer, CellWidth
   ;;    }
   
   ;;;; can't use the following macro
   ;;;; do not know why ...
   ;; macro pushArgumtStack Register {
   ;;    sub ArgumtStackPointer, CellWidth
   ;;    mov [ArgumtStackPointer], Register
   ;;    }
   ;; macro popArgumtStack Register {
   ;;    mov Register, [ArgumtStackPointer]
   ;;    add ArgumtStackPointer, CellWidth
   ;;    }
   
   
   
   macro pushReturnStack Register {
      lea ReturnStackPointer, [ReturnStackPointer - CellWidth]
      mov [ReturnStackPointer], Register
      }
   macro popReturnStack Register {
      mov Register, [ReturnStackPointer]
      lea ReturnStackPointer, [ReturnStackPointer + CellWidth]
      }
   
   macro pushArgumtStack Register {
      lea ArgumtStackPointer, [ArgumtStackPointer - CellWidth]
      mov [ArgumtStackPointer], Register
      }
   macro popArgumtStack Register {
      mov Register, [ArgumtStackPointer]
      lea ArgumtStackPointer, [ArgumtStackPointer + CellWidth]
      }
   #+end_src
* the dictionary
** note
   1. there are many lexicographers,
      they work together to define words into the dictionary
   2. to create a new word is to use some words to describe the new word,
      and set an explainer to explain the description of the new word.
   3. to define a new word,
      we just need to add the new created word to the dictionary.
   4. when someone try to find a word in the dictionary,
      the explainer of that word explains the word for him
   5. due to the constrain of fasm's syntax,
      the ``names'' of some words varys between fasm and forth
      here are some warnings:
      1) for syntax sugar :
         defWord ":", readWordListForLexicographer
         defCode "x|swap|xx", xswapxx
         defWord ".", printLittleNumber
      2) for already used label-name :
         defConst "ReturnStackTop", ReturnStackTop, TheReturnStackTop
** *next* & word-types & explainers & execute
   1. every word-type needs a explainer (or elucidator)
   2. a explainer may explain more then one word-types
   #+begin_src fasm :tangle ./play/cicada.fasm
   ;; notations :
   ;; 1. ``the dictionary'' as a datastructure is a single-linked-list
   ;; 2. an entry in ``the dictionary'' is ``a word''
   ;; 3. ``a word'' as a datastructure looks like the following :
   ;;       (unit : CellWidth)
   ;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
   ;;    ||  m : name-string  ||
   ;;    ||  1 : SizeOfFunctionBody  ||
   ;;    ||  1 : identification  ||
   ;;    ||  1 : link  ||
   ;;    ||  1 : type  ||
   ;;    ||  1 : address-of-name-string-header  ||
   ;;    ||  1 : address-of-explainer  ||
   ;;    ||  n : body  ||
   ;; 4. so, I adopt two notations to represent ``a word'' :
   ;;    word[link]      == address in a word where the link is stored
   ;;    word[explainer] == address in a word where the address-of-explainer is stored
   ;;    word[explainer] == address in a word before the function-body
   ;;    word[explainer] == address in a word as the head of a function-body
   
   
   ;; note that:
   ;;   there are only two ways to jump to a explainer
   ;;   1. next
   ;;   2. execute
   
   
   ;; not matter what way you use to set :
   ;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
   ;; then :
   ;;   jmp qword[ExplainerPointer]
   ;; it will works just well !!!
   
   ;; specially, about ``next'',
   ;; the way we use to set :
   ;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
   ;; is to find the address-of-explainer by :
   ;;    NextWordPointer  == an address in a function-body
   ;;   [NextWordPointer] == word-to-jump[explainer]
   ;; so, NextWordPointer is all that ``next'' needed
   ;; set [NextWordPointer] == word-to-jump[explainer]  correctly
   ;; then call ``next''
   ;; it will works just well !!!
   
   
   ;; 1. this ``next'' do tail-call-optimization
   ;; 2. in the following FASM marco, anonymous label of FASM is used
   ;;    (of course, label in marco must be anonymous !)
   ;;    hence, when using anonymous labels in assembly,
   ;;    they can not across ``next'' !
   
   
   ;; macro next {
   ;;    ;== NEED:
   ;;    ;==     NextWordPointer  points at an address in a function-body
   ;;    ;==    [NextWordPointer] == word-to-jump[explainer]
   ;;    ;== CHNG:
   ;;    ;==     NextWordPointer  points at next address in a function-body
   ;;    ;==    [NextWordPointer] == new-word-to-jump[explainer]
   ;;    ;==     ExplainerPointer  points at the address in a word
   ;;    ;==                      where the address-of-explainer is stored
   ;;    ;==    [ExplainerPointer] == address-of-explainer (of word-to-jump)
   ;;    mov ExplainerPointer, [NextWordPointer]
   ;;    add NextWordPointer, CellWidth
   ;;    ;; why not: cmp qword[NextWordPointer], Exit  ???
   ;;    cmp dword[NextWordPointer], Exit
   ;;    ;-- IF: [NextWordPointer] =/= Exit
   ;;    jne @f
   ;;    ;-- EL: [NextWordPointer] == Exit
   ;;    popReturnStack NextWordPointer
   ;; @@:
   ;;    jmp qword[ExplainerPointer]
   ;;    }
   ;;    ;; maybe need more optimization,
   ;;    ;; for the above ``popReturnStack NextWordPointer'' may be
   ;;    ;; followed by ``pushReturnStack NextWordPointer'' (in explainFunctionBody)
   
   
   
   
   macro next {
     mov ExplainerPointer, [NextWordPointer]
     add NextWordPointer, CellWidth
     ;; mov TemporaryRegister2, Exit
     ;; cmp qword[NextWordPointer], TemporaryRegister2
     cmp dword[NextWordPointer], Exit
     je @f
     cmp dword[NextWordPointer], 已矣
     je @f
     jmp qword[ExplainerPointer]
   @@:
     popReturnStack NextWordPointer
     jmp qword[ExplainerPointer]
     }
   
   
   
   
   ;; initial Link to point to NULL
   Link = 0
   
   
   ;; example of macro expanding :
   ;; defWord "double", double
   ;;    xx dup
   ;;    xx plus
   ;;    xx Exit
   ;; ==expand to==>
   ;; WordStringHeaderOfdouble:
   ;;         xx (EndOfdouble - WordStringOfdouble)
   ;; WordStringOfdouble:
   ;;         db "double"
   ;; EndOfWordStringOfdouble:
   ;; LinkOfdouble:
   ;;         xx Link
   ;;         Link = LinkOfdouble
   ;; TypeOfdouble:
   ;;         xx 0
   ;; AddressOfWordStringHeaderOfdouble:
   ;;         xx WordStringHeaderOfdouble
   ;; double:
   ;;         xx explainFunctionBody
   ;;         xx dup
   ;;         xx plus
   ;;         xx Exit
   
   
   macro defWord WordString, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   SizeOfFunctionBodyOf#Word:
           xx (EndOfFunctionBodyOf#Word - Word)/8 - 1
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainFunctionBody
   ;;--------------------------------------
           ;; here follows a list of word[explainer]
           }
   macro defWordEnd Word {
   EndOfFunctionBodyOf#Word:
   }
   
   
   ;; 1. if ``next'' meet ``Exit'',
   ;;    ``next'' will ``popReturnStack NextWordPointer''
   ;; 2. on the other hand,
   ;;    explainFunctionBody is the only explainer
   ;;    who ``pushReturnStack NextWordPointer''
   ;; 3. so, it is these two functions, ``next'' and ``explainFunctionBody'',
   ;;    which handle the nested function calls
   segment readable executable
   explainFunctionBody:
      ;== SAVE:
      ;==     NextWordPointer  points at an old address in a function-body
      ;==    [NextWordPointer] == old-word-to-jump[explainer]
      ;== NEED:
      ;==    ExplainerPointer == current-word[explainer]
      ;==        this value can be used to calculate
      ;==        the address in a word where the function-body is stored
      ;== CHNG:
      ;==    [ExplainerPointer] == new-word-to-jump[explainer]
      ;==    [NextWordPointer] == new-word-to-jump[explainer]
      pushReturnStack NextWordPointer
      ;; to calculate the address in a word where the function-body is stored
      ;; this address is as an ``argumt'' of explainFunctionBody
      add ExplainerPointer, CellWidth
      mov NextWordPointer, ExplainerPointer
      next
   
   
   
   ;; assembly code have no explainer
   macro defCode WordString, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx AssemblerCodeOf#Word
   ;;--------------------------------------
   segment readable executable
   AssemblerCodeOf#Word:
           ;; here follows the assembly code
           }
   
   
   
   
   defCode "execute", execute
     ;; ( word[address of explainer] -- )
     popArgumtStack ExplainerPointer
     jmp qword[ExplainerPointer]
   
   ;; not matter what way you use to set :
   ;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
   ;; then :
   ;;   jmp qword[ExplainerPointer]
   ;; it will works just well !!!
   
   
   
   macro defVar WordString, InitialValue, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainVar
   ;;--------------------------------------
           xx InitialValue
   ;;--------------------------------------
           }
   
   
   segment readable executable
   explainVar:
      ;; ( -- address )
      add ExplainerPointer, CellWidth
      pushArgumtStack ExplainerPointer
      next
   
   
   
   macro defConst WordString, InitialValue, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainConst
   ;;--------------------------------------
           xx InitialValue
   ;;--------------------------------------
           }
   
   segment readable executable
   explainConst:
      ;; ( -- value )
      add ExplainerPointer, CellWidth
      mov TemporaryRegister, [ExplainerPointer]
      pushArgumtStack TemporaryRegister
      next
   
   
   
   
   ;; in stack:
   ;;   string[address, length]
   ;; in memory:
   ;;   ||  1 : length  ||
   ;;   ||  n : string  ||
   macro defConstString WordString, ConstStringValue, Word {
   segment readable writeable
   ;;--------------------------------------
   WordStringHeaderOf#Word:
           xx (EndOfWordStringOf#Word - WordStringOf#Word)
   ;;--------------------------------------
   WordStringOf#Word:
           db WordString
   EndOfWordStringOf#Word:
   ;;--------------------------------------
   IdentificationOf#Word:
           xx IdentificationOf#Word
   ;;--------------------------------------
   LinkOf#Word:
           xx Link
           Link = LinkOf#Word
   ;;--------------------------------------
   TypeOf#Word:
           xx 0
   ;;--------------------------------------
   AddressOfWordStringHeaderOf#Word:
           xx WordStringHeaderOf#Word
   ;;======================================
   Word:   xx explainConstString
   ;;--------------------------------------
           xx (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
   ;;--------------------------------------
   ConstStringValueOf#Word:
           db ConstStringValue
   EndOfConstStringValueOf#Word:
   ;;--------------------------------------
           }
   
   
   segment readable executable
   explainConstString:
      ;; ( -- string[address, length] )
      add ExplainerPointer, CellWidth
      mov TemporaryRegister, [ExplainerPointer]
      add ExplainerPointer, CellWidth
      pushArgumtStack ExplainerPointer
      pushArgumtStack TemporaryRegister
      next
   
   
   
   ;; the following Exit helps tail-call-optimization
   ;; it just let you decide where is the end of FunctionBody
   ;; in a FunctionBody, the ``Exit'' as a word will never be called
   defConst "Exit", Exit, Exit
   ;; (* so, the following numbers are the same :
   ;;   Exit
   ;;   readWord Exit find wordLinkToWordExplainer
   ;;   *)
   
   ;; the following is the chinese version of ``Exit''
   defConst "已矣", 已矣, 已矣
   
   defConst "FunctionBodyExplainer", explainFunctionBody, FunctionBodyExplainer
   defConst "VarExplainer",          explainVar,          VarExplainer
   defConst "ConstExplainer",        explainConst,        ConstExplainer
   defConst "ConstStringExplainer",  explainConstString,  ConstStringExplainer
   #+end_src
** Var
   #+begin_src fasm :tangle ./play/cicada.fasm
   defVar "Base", 10, Base
   defVar "Here",  0, Here
   
   defVar "FirstWordInDictionary", LinkOfTheLatestWordInAssembly , FirstWordInDictionary
   ;; note that:
   ;;   the above is LinkOfTheLatestWordInThisFile
   ;;   NOT TheLatestWordInThisFile
   #+end_src
** Const
   #+begin_src fasm :tangle ./play/cicada.fasm
   defConst "CellWidth", CellWidth, TheCellWidth
   
   defConst "Zero",  0, Zero
   defConst "One",   1, One
   defConst "Two",   2, Two
   defConst "Three", 3, Three
   defConst "Four",  4, Four
   defConst "Five",  5, Five
   defConst "Six",   6, Six
   defConst "Seven", 7, Seven
   defConst "Eight", 8, Eight
   defConst "Nine",  9, Nine
   defConst "Ten",  10, Ten
   
   defConst "False", 0, False
   defConst "True",  1, True
   
   defConst "BinBase", 2,  BinBase
   defConst "OctBase", 8,  OctBase
   defConst "DecBase", 10, DecBase
   defConst "HexBase", 16, HexBase
   defConst "AphBase", 36, AphBase
   ;; test:
   ;; BinBase Base save
   ;; 101 011 bitwiseAnd . (* 1 *)
   ;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . (* 1 *)
   ;; DecBase Base save
   #+end_src
** primitive functions
*** stack processing
**** note
     1. ``two'' as a prefix
        likes a map to a list (the stack)
     2. ``two'' as a postfix
        likes a argument
**** drop & dup
     #+begin_src fasm :tangle ./play/cicada.fasm
     defCode "drop", drop
        ;; (* a -- *)
        popArgumtStack rax
        next
     
     defCode "drop2", drop2
        ;; (* a b -- *)
        popArgumtStack rax
        popArgumtStack rax
        next
     
     defCode "dup", dup
        ;; (* a -- a a *)
        mov  rax, [ArgumtStackPointer]
        pushArgumtStack rax
        next
     
     defCode "dup2", dup2
        ;; (* a b -- a b a b *)
        mov  rbx, [ArgumtStackPointer]
        mov  rax, [ArgumtStackPointer + CellWidth]
        pushArgumtStack rax
        pushArgumtStack rbx
        next
     #+end_src
**** over
     #+begin_src fasm :tangle ./play/cicada.fasm
     defCode "over", over
        ;; (* a b -- a b | a *)
        mov  rax, [ArgumtStackPointer + CellWidth]
        pushArgumtStack rax
        next
     
     defCode "x|over|xx", xoverxx
        ;; (* a | b c -- a | b c | a *)
        mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
        pushArgumtStack rax
        next
     
     defCode "xx|over|x", xxoverx
        ;; (* a b | c -- a b | c | a b *)
        mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
        pushArgumtStack rax
        mov  rax, [ArgumtStackPointer + (2 * CellWidth)] ;; not (1 * CellWidth)
        pushArgumtStack rax
        next
     
     defCode "xx|over|xx", xxoverxx
        ;; (* a b | c d -- a b | c d | a b *)
        mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
        pushArgumtStack rax
        mov  rax, [ArgumtStackPointer + (3 * CellWidth)] ;; not (2 * CellWidth)
        pushArgumtStack rax
        next
     
     defCode "x|over|xxx", xoverxxx
        ;; (* a | b c d -- a | b c d | a *)
        mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
        pushArgumtStack rax
        next
     
     defCode "xx|over|xxxx", xxoverxxxx
        ;; (* a b | c d e f -- a b | c d e f | a b *)
        mov  rax, [ArgumtStackPointer + (5 * CellWidth)]
        pushArgumtStack rax
        mov  rax, [ArgumtStackPointer + (5 * CellWidth)] ;; not (4 * CellWidth)
        pushArgumtStack rax
        next
     #+end_src
**** tuck
     #+begin_src fasm :tangle ./play/cicada.fasm
     defCode "tuck", tuck
        ;; (* a b -- b | a b *)
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rax
        pushArgumtStack rbx
        next
     
     defCode "x|tuck|xx", xtuckxx
        ;; (* a | b c -- b c | a | b c *)
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        next
     
     defCode "xx|tuck|x", xxtuckx
        ;; (* a b | c -- c | a b | c *)
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rcx
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        next
     
     defCode "xx|tuck|xx", xxtuckxx
        ;; (* a b | c d -- c d | a b | c d *)
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rcx
        pushArgumtStack rdx
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rdx
        next
     
     defCode "xxx|tuck|x", xxxtuckx
        ;; (* a b c | d -- d | a b c | d *)
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rdx
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rdx
        next
     #+end_src
**** swap
     #+begin_src fasm :tangle ./play/cicada.fasm
     defCode "swap", swap
        ;; (* a b -- b a *)
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rax
        next
     
     defCode "x|swap|xx", xswapxx
        ;; (* a | b c -- b c | a *)
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rax
        next
     
     defCode "xx|swap|x", xxswapx
        ;; (* a b | c -- c | a b *)
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rcx
        pushArgumtStack rax
        pushArgumtStack rbx
        next
     
     defCode "x|swap|xxx", xswapxxx
        ;; (* a | b c d -- b c d | a *)
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rdx
        pushArgumtStack rax
        next
     
     defCode "xxx|swap|x", xxxswapx
        ;; (* a b c | d -- d | a b c *)
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rdx
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        next
     
     defCode "xx|swap|xx", xxswapxx
        ;; (* a b | c d -- c d | a b *)
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rcx
        pushArgumtStack rdx
        pushArgumtStack rax
        pushArgumtStack rbx
        next
     
     
     defCode "x|swap|xxxx", xswapxxxx
        ;; (* a | b c d e -- b c d e | a *)
        popArgumtStack r8 ;; e
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rdx
        pushArgumtStack r8 ;; e
        pushArgumtStack rax
        next
     
     defCode "xxxx|swap|x", xxxxswapx
        ;; (* a b c d | e --  e | a b c d *)
        popArgumtStack r8 ;; e
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack r8 ;; e
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rdx
        next
     
     
     defCode "xx|swap|xxxx", xxswapxxxx
        ;; (* a b | c d e f -- c d e f | a b *)
        popArgumtStack r9 ;; f
        popArgumtStack r8 ;; e
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack rcx
        pushArgumtStack rdx
        pushArgumtStack r8 ;; e
        pushArgumtStack r9 ;; f
        pushArgumtStack rax
        pushArgumtStack rbx
        next
     
     defCode "xxxx|swap|xx", xxxxswapxx
        ;; (* a b c d | e f --  e f | a b c d *)
        popArgumtStack r9 ;; f
        popArgumtStack r8 ;; e
        popArgumtStack rdx
        popArgumtStack rcx
        popArgumtStack rbx
        popArgumtStack rax
        pushArgumtStack r8 ;; e
        pushArgumtStack r9 ;; f
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        pushArgumtStack rdx
        next
     #+end_src
**** ohters
     #+begin_src fasm :tangle ./play/cicada.fasm
     defCode "|123->321|", abcTOcba
        popArgumtStack rax
        popArgumtStack rbx
        popArgumtStack rcx
        pushArgumtStack rax
        pushArgumtStack rbx
        pushArgumtStack rcx
        next
     #+end_src
*** fixnum
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "add1", add1
   ;; (* n -- n+1 *)
   inc qword[ArgumtStackPointer]
   next

defCode "add2", add2
   ;; (* n -- n+1 *)
   add qword[ArgumtStackPointer], 2
   next

defCode "add3", add3
   ;; (* n -- n+1 *)
   add qword[ArgumtStackPointer], 3
   next

defCode "add4", add4
   ;; (* n -- n+4 *)
   add qword[ArgumtStackPointer], 4
   next

defCode "add8", add8
   ;; (* n -- n+8 *)
   add qword[ArgumtStackPointer], 8
   next


defCode "sub1", sub1
   ;; (* n -- n-1 *)
   dec qword[ArgumtStackPointer]
   next

defCode "sub2", sub2
   ;; (* n -- n-1 *)
   sub qword[ArgumtStackPointer], 2
   next

defCode "sub3", sub3
   ;; (* n -- n-1 *)
   sub qword[ArgumtStackPointer], 3
   next

defCode "sub4", sub4
   ;; (* n -- n-4 *)
   sub qword[ArgumtStackPointer], 4
   next

defCode "sub8", sub8
   ;; (* n -- n-8 *)
   sub qword[ArgumtStackPointer], 8
   next


defCode "+", addition
   ;; (* a b -- a+b *)
   popArgumtStack rax
   add qword[ArgumtStackPointer], rax
   next

defCode "-", subtraction
   ;; (* a b -- a-b *)
   popArgumtStack rax
   sub qword[ArgumtStackPointer], rax
   next

defCode "*", multiple
   ;; (* a b -- a*b *)
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   imul rbx, rax
   ;; imul will ignore overflow
   ;; when there are two registers as arg
   ;; imul will save the result into the first register
   pushArgumtStack rbx
   next

defCode "mod/", divmod
   ;; (* a, b -- a mod b, a/b *)
   ;; (* dividend, divisor -- remainder, quotient *)
   ;; the arg of idiv is divisor
   ;; the lower half of dividend is taken from rax
   ;; the upper half of dividend is taken from rdx
   xor  rdx, rdx   ;; high-part of dividend is not used
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   idiv rbx
   ;; the remainder is stored in rdx
   ;; the quotient  is stored in rax
   pushArgumtStack rdx ;; remainder
   pushArgumtStack rax ;; quotient
   next
#+end_src
*** memory
#+begin_src fasm :tangle ./play/cicada.fasm
;; ``save'' and ``fetch'' default to a CellWidth (== 8 bytes)
;; the rule of ``fetch2'' and so on are:
;;   in memory:
;;     ||  1 : value-1  ||
;;     ||  1 : value-2  ||
;;     ||  1 : value-3  ||
;;     ...
;;   on stack:
;;     [ ... , value-3, value-2, value-1]
;; of course we have:
;;   fetch2 : memory=copy=>stack
;;   save2  : stack->memory

defCode "save", save
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   next

defCode "save2", save2
   ;; ( value-2, value-1, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   popArgumtStack rax
   mov qword[rbx + CellWidth], rax
   next



defCode "fetch", fetch
   ;; ( address -- value )
   popArgumtStack  rbx
   mov rax, qword[rbx]
   pushArgumtStack rax
   next

defCode "fetch2", fetch2
   ;; ( address -- value-1, value-2 )
   popArgumtStack  rbx
   mov rax, qword[rbx + CellWidth]
   pushArgumtStack rax
   mov rax, qword[rbx]
   pushArgumtStack rax
   next



defCode "addSave", addSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   add qword[rbx], rax
   next

defCode "subSave", subSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   sub qword[rbx], rax
   next



defCode "saveByte", saveByte
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov byte[rbx], al
   next

defCode "fetchByte", fetchByte
   ;; ( address -- value )
   popArgumtStack rbx
   xor rax, rax
   mov al, byte[rbx]
   pushArgumtStack rax
   next




defCode "copyByte", copyByte
   ;; ( source address, destination address --
   ;;   source address + 1, destination address + 1 )
   mov rbx, [ArgumtStackPointer + CellWidth] ;; source address
   mov al,  byte[rbx]                        ;; get a char from source address
   popArgumtStack rdi                        ;; destination address
   stosb                                     ;; copy to destination
   pushArgumtStack rdi                       ;; destination address is incremented by stosb
   inc qword[ArgumtStackPointer + CellWidth] ;; increment source address
   next

defCode "copyByteString", copyByteString
   ;; ( source address, destination address, length -- )
   popArgumtStack rcx
   popArgumtStack rdi
   popArgumtStack rsi
   rep movsb
   next
#+end_src
*** string
#+begin_src fasm :tangle ./play/cicada.fasm
;; return false when length == 0
defCode "compareString?", compareString?
   ;; (* address of string-1, address of string-2, length -- True or False *)
   popArgumtStack rcx
   popArgumtStack rdi
   popArgumtStack rsi
   repe cmpsb
   sete al
   movzx rax, al
   pushArgumtStack rax
   next


defWord "equalString?", equalString?
   ;; (* string-1[address-1, length-1], string-2[address-2, length-2]
   ;;   -- True or False *)
   xx xoverxx, equal?, false?branch, 4
   xx swap, compareString?, Exit
   xx drop, drop, drop, False
   xx Exit
defWordEnd equalString?
#+end_src
*** predicates
1. 0 as False
   1 as True
2. there can not be bool-type in low-level forth-like-language
3. ``notFalse?'' is NOT ``true?''
4. ``false?'' is ``zero?''
   ``true?'' is ``one?''
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "==", equal?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   sete  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "=/=", notEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   setne al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "<", lessThan?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setl  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">", greaterThan?
   popArgumtStack   rbx
   popArgumtStack   rax
   cmp   rax, rbx
   setg  al
   movzx rax, al
   pushArgumtStack  rax
   next

defCode "<=", lessOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setle al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">=", greaterOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "zero?", zero?
   popArgumtStack rax
   test  rax,rax
   setz  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "notZero?", notZero?
   popArgumtStack rax
   test  rax,rax
   setnz al
   movzx rax, al
   pushArgumtStack rax
   next


defWord "one?", one?
   xx One, equal?
   xx Exit
defWordEnd one?

defWord "true?", true?
   xx one?
   xx Exit
defWordEnd true?

defWord "false?", false?
   xx zero?
   xx Exit
defWordEnd false?
#+end_src
*** bitwise operations
1. ``bitwiseAnd'' and ``bitwiseOr'' handle 64 bits value
2. x y bitwiseAnd
   ==
   x bitwiseInvert y bitwiseInvert bitwiseOr bitwiseInvert
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "bitwiseAnd", bitwiseAnd
   ;; ( a, b -- a and b )
   popArgumtStack rbx
   and [ArgumtStackPointer], rbx
   next

defCode "bitwiseOr", bitwiseOr
   ;; ( a, b -- a or b )
   popArgumtStack rbx
   or  [ArgumtStackPointer], rbx
   next

defCode "bitwiseXor", bitwiseXor
   ;; ( a, b -- a xor b )
   popArgumtStack rbx
   xor [ArgumtStackPointer], rbx
   next

defCode "bitwiseInvert", bitwiseInvert
   ;; ( a -- invert a )
   not qword[ArgumtStackPointer]
   next
#+end_src
*** single bit operations
1. offset is of LSB
2. offset in [0, ..., 63]
3. step   in [1, ..., 64]
#+begin_src fasm :tangle ./play/cicada.fasm
;; BT copies a bit from a given register to the carry flag
defCode "fetchBit", fetchBit
   ;; ( fixnum, offset -- bit )
   popArgumtStack rbx
   popArgumtStack rax
   bt rax, rbx
   setc al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "setBit", setBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   bts rax, rbx
   pushArgumtStack rax
   next

defCode "clearBit", clearBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btr rax, rbx
   pushArgumtStack rax
   next

defCode "invertBit", invertBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btc rax, rbx
   pushArgumtStack rax
   next



;; "bsf" "bsr"
;; instructions scan a word or double word for first set bit
;; and store the index of this bit into destination operand
;; which must be general register
;; The bit string being scanned is specified by source operand
;; it may be either general register or memory
;; The ZF flag is set if the entire string is zero (no set bits are found)
;; otherwise it is cleared

;; If no set bit is found
;; the value of the destination register is undefined
;; "bsf" scans from low order to high order (starting from bit index zero)
;; "bsr" scans from high order to low order


;; note that:
;; if can not find ``SetBit''
;; the following functions will return -1

defCode "findLowestSetBit", findLowestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsf rax, rax
   jz tryToFindLowestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindLowestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next

defCode "findHighestSetBit", findHighestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsr rax, rax
   jz tryToFindHighestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindHighestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next
#+end_src
*** test single bit operations
#+begin_src cicada
BinBase Base save
010
DecBase Base save
dup
  1 fetchBit . (* 1 *)
dup
  2 fetchBit . (* 0 *)
dup
  0 fetchBit . (* 0 *)
drop


BinBase Base save
10
DecBase Base save
dup
  0 setBit . (* 3 *)
dup
  1 setBit . (* 2 *)
dup
  2 setBit . (* 6 *)
drop


BinBase Base save
11
DecBase Base save
dup
  0 clearBit . (* 2 *)
dup
  1 clearBit . (* 1 *)
dup
  2 clearBit . (* 3 *)
drop


BinBase Base save
101
DecBase Base save
dup
  0 invertBit . (* 4 *)
dup
  1 invertBit . (* 7 *)
dup
  2 invertBit . (* 1 *)
drop


BinBase Base save
101
findLowestSetBit . (* 0 *)
101
findHighestSetBit . (* 2 *)
00101010
findLowestSetBit . (* 1 *)
00101010
findHighestSetBit . (* 5 *)
DecBase Base save


BinBase Base save
000000000
findHighestSetBit 111 + . (* 6 *)
000000000
findLowestSetBit 111 + . (* 6 *)
DecBase Base save
#+end_src
*** bits shift & rotate
#+begin_src fasm :tangle ./play/cicada.fasm
;; "shl"
;; shifts the destination operand left
;; by the number of bits specified in the second operand
;; The destination operand can be general register or memory
;; The second operand can be an immediate value or the CL register
;; as bits exit from the left, zeros in from the right
;; The last bit that exited is stored in CF
;; "sal" is a synonym for "shl"
defCode "shiftLeft", shiftLeft
   ;; ( fixnum, step -- fixnum * 2^step )
   popArgumtStack rcx
   shl qword[ArgumtStackPointer], cl
   next

defCode "shiftRight", shiftRight
   ;; ( fixnum, step -- fixnum / 2^step )
   popArgumtStack rcx
   shr qword[ArgumtStackPointer], cl
   next

defCode "shiftRightPreserveSign", shiftRightPreserveSign
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   sar qword[ArgumtStackPointer], cl
   next



;; note that:
;; ``double'' is 128 bit value here

;; "shld"
;; shifts bits of the destination operand to the left
;; by the number of bits specified in third operand,
;; while shifting
;; move high order bits from the source operand
;; into the destination operand on the right.
;; The source operand remains unmodified.
;; The destination operand can be a word or double word general register or memory,
;; the source operand must be a general register,
;; third operand can be an immediate value or the CL register.
defCode "doubleShiftLeft", doubleShiftLeft
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rax
   shld qword[ArgumtStackPointer], rax, cl
   shl rax, cl
   pushArgumtStack rax
   next


;; "shrd"
;; shifts bits of the destination operand to the right,
;; while shifting
;; move low order bits from the source operand
;; into the destination operand on the left.
;; The source operand remains unmodified.
;; Rules for operands are the same as for the "shld" instruction.
defCode "doubleShiftRight", doubleShiftRight
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   shr rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "doubleShiftRightPreserveSign", doubleShiftRightPreserveSign
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   sar rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next




defCode "rotateLeft", rotateLeft
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   rol qword[ArgumtStackPointer], cl
   next

defCode "rotateRight", rotateRight
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   ror qword[ArgumtStackPointer], cl
   next
#+end_src

test:
#+begin_src cicada
BinBase Base save
00100
1 shiftLeft . (* 8 *)
00101
1 shiftRight . (* 2 *)
00100
1 shiftRightPreserveSign . (* 2 *)
-100
1 shiftRightPreserveSign 111 + . (* 5 *)
-101
1 shiftRightPreserveSign 111 + . (* not 5 *) (* but 4 *)
-111
1 shiftRightPreserveSign 111 + . (* not 4 *) (* but 3 *)
-111
10 shiftRightPreserveSign 11 + . (* not 2 *) (* but 1 *)
DecBase Base save



BinBase Base save
10 10
1 doubleShiftLeft . . (* 4 4 *)
11 10
1 doubleShiftRight . . (* 1 1 *)
11 10
1 doubleShiftRight
  HexBase Base save 8000000000000001 == . . (* 1 1 *)
DecBase Base save


HexBase Base save
1 ffffffffffffffff
1 doubleShiftLeft ffffffffffffffff 1 - == . . (* 1 3 *)
DecBase Base save


1 64 rotateRight . (* 1 *)
1 64 rotateLeft . (* 1 *)
1 64 2 * rotateLeft . (* 1 *)
1 63 rotateRight . (* 2 *)
1 65 rotateLeft . (* 2 *)
#+end_src
*** about ReturnStack
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "pushReturnStack", toPushReturnStack
   ;; (* address --> ReturnStack: address *)
   popArgumtStack  rax
   pushReturnStack rax
   next

defCode "popReturnStack", toPopReturnStack
   ;; (* ReturnStack: address --> address *)
   popReturnStack  rax
   pushArgumtStack rax
   next

;; up to now
;; the above two class classic forth words
;; have not been used by cicada yet


defCode "fetchReturnStackPointer", fetchReturnStackPointer
   ;; (* -- an address in the ReturnStack *)
   pushArgumtStack ReturnStackPointer
   next

defCode "resetReturnStackPointer", resetReturnStackPointer
   ;; (* an address in the ReturnStack -- *)
   popArgumtStack ReturnStackPointer
   next

defCode "dropReturnStack", dropReturnStack
   ;; (* -- *)
   add ReturnStackPointer, CellWidth
   next
#+end_src
*** about ArgumtStack
#+begin_src fasm :tangle ./play/cicada.fasm
;; to know why the following funny thing happens,
;; see the definition of the macro ``pushArgumtStack'',
defCode "makeSelfReferenceValue", makeSelfReferenceValue
   ;; ( -- address )
   pushArgumtStack ArgumtStackPointer
   next

defWord "fetchArgumtStackPointer", fetchArgumtStackPointer
   xx makeSelfReferenceValue, add8, Exit
defWordEnd fetchArgumtStackPointer

defCode "resetArgumtStackPointer", resetArgumtStackPointer
   ;; ( address -- )
   popArgumtStack ArgumtStackPointer
   next
#+end_src
*** about GreyPairStack
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "pushGreyPairStack", pushGreyPairStack
   ;; (* pair[address] --> GreyPairStack: pair[address] *)
   popArgumtStack rax
   lea GreyPairStackPointer, [GreyPairStackPointer - CellWidth]
   mov [GreyPairStackPointer], rax
   next

defCode "popGreyPairStack", popGreyPairStack
   ;; (* GreyPairStack: pair[address] --> pair[address] *)
   mov rax, [GreyPairStackPointer]
   lea GreyPairStackPointer, [GreyPairStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "emptyGreyPairStack?", emptyGreyPairStack?
   ;; (* -- True or False *)
   mov rax, GreyPairStackTop
   cmp GreyPairStackPointer, rax
   ;; note that:
   ;; GreyPairStackPointer >= GreyPairStackTop
   ;; means stack over flow
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

;; test:
;; emptyGreyPairStack? . (* 1 *)
;; 6 pushGreyPairStack emptyGreyPairStack? . (* 0 *)
;; popGreyPairStack . (* 6 *)
;; emptyGreyPairStack? . (* 1 *)
#+end_src
*** WordList
WordList is returned by readWordListForLexicographer
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "tailOfWordList", tailOfWordList
   ;; (* wordList[address, the number of words] --
   ;;    wordList[new address, number - 1] *)
   popArgumtStack rcx
   popArgumtStack rsi
   lodsq
   add rsi, rax
   pushArgumtStack rsi
   dec rcx
   pushArgumtStack rcx
   next

defCode "headOfWordList", headOfWordList
   ;; (* wordList[address, the number of words] --
   ;;    wordString[address, length] *)
   popArgumtStack rbx ;; do not need this arg
   popArgumtStack rsi
   mov rcx, qword[rsi]
   add rsi, CellWidth
   pushArgumtStack rsi
   pushArgumtStack rcx
   next

defWord "tailAndHeadOfWordList", tailAndHeadOfWordList
   ;; (* wordList[address, the number of words] --
   ;;    wordList[new address, number - 1], wordString[address, length] *)
   xx dup2
   xx tailOfWordList
   xx xxswapxx
   xx headOfWordList
   xx Exit
defWordEnd tailAndHeadOfWordList
#+end_src
*** linux syscall
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "syscallWithZoreArgument", syscallWithZoreArgument
   ;; (* callNumber -- return value *)
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithOneArgument", syscallWithOneArgument
   ;; (* arg-1, callNumber -- return value *)
   popArgumtStack sys_n_rax
   popArgumtStack sys_1_rdi
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithTwoArguments", syscallWithTwoArguments
   ;; (* arg-2, arg-1, callNumber -- return value *)
   popArgumtStack sys_n_rax
   popArgumtStack sys_1_rdi
   popArgumtStack sys_2_rsi
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithThreeArguments", syscallWithThreeArguments
   ;; (* arg-3, arg-2, arg-1, callNumber -- return value *)
   popArgumtStack sys_n_rax
   popArgumtStack sys_1_rdi
   popArgumtStack sys_2_rsi
   popArgumtStack sys_3_rdx
   syscall
   pushArgumtStack rax
   next
#+end_src
** [NOT USING] special key words
   special key words are not functions
   but all about defineFunction is to use old functions to make new function
   so, more appropriately,
   when using ``literal'' or ``branch''
   we are making new functions,
   in a way, which is different from function-composition.
   hence :
   1. ``literal'' is a set of function,
      ``literal 666'' is a function in this set.
      or ``literal'' is a function
      which takes ``666'' as an argumt, and returns a function.
   2. ``branch'' by itself has no function-semantic.
   3. it is obvious that,
      how ``== false?branch 6 ... ...'' is a means
      to make new function out of old functions.
   4. note that to achieve the function-semantic,
      we have to constrain ourself when using these special key words,
      for example, ``infinite-loop'' built by ``branch''
      is definitely has no function-semantic.
    
    :tangle ./play/cicada.fasm
   #+begin_src fasm
   defCode "literal", literal
      mov  rax, [NextWordPointer]
      add  NextWordPointer, CellWidth
      pushArgumtStack rax
    
      ;; why not: cmp qword[NextWordPointer], Exit  ???
      cmp dword[NextWordPointer], Exit
      ;-- IF: [NextWordPointer] =/= Exit
      jne @f
      ;-- EL: [NextWordPointer] == Exit
      popReturnStack NextWordPointer
   @@:
    
      next
    
    
   defCode "branch", branch
      ;; usage(in assembly): xx branch, number
      ;; the number denotes an offset
      ;; the base point of the offset is the place where the number stored
      ;; note that: in the function branch, [NextWordPointer] = offset
      mov  TemporaryRegister, [NextWordPointer]
      imul TemporaryRegister, CellWidth
      add  NextWordPointer, TemporaryRegister
    
      ;; why not: cmp qword[NextWordPointer], Exit  ???
      cmp dword[NextWordPointer], Exit
      ;-- IF: [NextWordPointer] =/= Exit
      jne @f
      ;-- EL: [NextWordPointer] == Exit
      popReturnStack NextWordPointer
   @@:
    
      next
    
    
   defCode "zero?branch", zero?branch
      ;; ( n -- )
      popArgumtStack rax
      test rax, rax
      jnz zero?branch_toBranch
      mov  TemporaryRegister, [NextWordPointer]
      imul TemporaryRegister, CellWidth
      add  NextWordPointer, TemporaryRegister
      jmp zero?branch_help_toBranch
   zero?branch_toBranch:
      add NextWordPointer, CellWidth
   zero?branch_help_toBranch:
    
      ;; why not: cmp qword[NextWordPointer], Exit  ???
      cmp dword[NextWordPointer], Exit
      ;-- IF: [NextWordPointer] =/= Exit
      jne @f
      ;-- EL: [NextWordPointer] == Exit
      popReturnStack NextWordPointer
   @@:
    
      next
    
   defCode "false?branch", false?branch
      ;; ( n -- )
      ;; false?branch is identical to zero?branch
      ;; but we can not use defWord to define false?branch by false?branch
      ;; for it is a special key word
      popArgumtStack rax
      test rax, rax
      jnz false?branch_toBranch
      mov  TemporaryRegister, [NextWordPointer]
      imul TemporaryRegister, CellWidth
      add  NextWordPointer, TemporaryRegister
      jmp false?branch_help_toBranch
   false?branch_toBranch:
      add NextWordPointer, CellWidth
   false?branch_help_toBranch:
    
      ;; why not: cmp qword[NextWordPointer], Exit  ???
      cmp dword[NextWordPointer], Exit
      ;-- IF: [NextWordPointer] =/= Exit
      jne @f
      ;-- EL: [NextWordPointer] == Exit
      popReturnStack NextWordPointer
   @@:
    
      next
    
   defCode "notFalse?branch", notFalse?branch
      ;; ( n -- )
      popArgumtStack rax
      test rax, rax
      jz notFalse?branch_toBranch
      mov  TemporaryRegister, [NextWordPointer]
      imul TemporaryRegister, CellWidth
      add  NextWordPointer, TemporaryRegister
      jmp notFalse?branch_help_toBranch
   notFalse?branch_toBranch:
      add NextWordPointer, CellWidth
   notFalse?branch_help_toBranch:
    
      ;; why not: cmp qword[NextWordPointer], Exit  ???
      cmp dword[NextWordPointer], Exit
      ;-- IF: [NextWordPointer] =/= Exit
      jne @f
      ;-- EL: [NextWordPointer] == Exit
      popReturnStack NextWordPointer
   @@:
    
      next
   #+end_src
** special key words (with chinese support)
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "literal", literal
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumtStack rax
   cmp dword[NextWordPointer], Exit
   je literal_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je literal_meet_Exit
   next
literal_meet_Exit:
   popReturnStack NextWordPointer
   next


defCode "branch", branch
   ;; usage(in assembly): xx branch, number
   ;; the number denotes an offset
   ;; the base point of the offset is the place where the number stored
   ;; note that: in the function branch, [NextWordPointer] = offset
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   cmp dword[NextWordPointer], Exit
   je branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je branch_meet_Exit
   next
branch_meet_Exit:
   popReturnStack NextWordPointer
   next


defCode "zero?branch", zero?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz zero?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp zero?branch_help_toBranch
zero?branch_toBranch:
   add NextWordPointer, CellWidth
zero?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je zero?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je zero?branch_meet_Exit
   next
zero?branch_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "false?branch", false?branch
   ;; ( n -- )
   ;; false?branch is identical to zero?branch
   ;; but we can not use defWord to define false?branch by false?branch
   ;; for it is a special key word
   popArgumtStack rax
   test rax, rax
   jnz false?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp false?branch_help_toBranch
false?branch_toBranch:
   add NextWordPointer, CellWidth
false?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je false?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je false?branch_meet_Exit
   next
false?branch_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "notFalse?branch", notFalse?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jz notFalse?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp notFalse?branch_help_toBranch
notFalse?branch_toBranch:
   add NextWordPointer, CellWidth
notFalse?branch_help_toBranch:
   cmp dword[NextWordPointer], Exit
   je notFalse?branch_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je notFalse?branch_meet_Exit
   next
notFalse?branch_meet_Exit:
   popReturnStack NextWordPointer
   next
#+end_src
** chinese key words
#+begin_src fasm :tangle ./play/cicada.fasm
defCode "即", 即
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumtStack rax
   cmp dword[NextWordPointer], Exit
   je 即_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 即_meet_Exit
   next
即_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "转", 转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   cmp dword[NextWordPointer], Exit
   je 转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 转_meet_Exit
   next
转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "零则转", 零则转
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz 零则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 零则转_help_去转
零则转_去转:
   add NextWordPointer, CellWidth
零则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 零则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 零则转_meet_Exit
   next
零则转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "假则转", 假则转
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz 假则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 假则转_help_去转
假则转_去转:
   add NextWordPointer, CellWidth
假则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 假则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 假则转_meet_Exit
   next
假则转_meet_Exit:
   popReturnStack NextWordPointer
   next

defCode "非假则转", 非假则转
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jz 非假则转_去转
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp 非假则转_help_去转
非假则转_去转:
   add NextWordPointer, CellWidth
非假则转_help_去转:
   cmp dword[NextWordPointer], Exit
   je 非假则转_meet_Exit
   cmp dword[NextWordPointer], 已矣
   je 非假则转_meet_Exit
   next
非假则转_meet_Exit:
   popReturnStack NextWordPointer
   next
#+end_src
** ioctl for terminal
#+begin_src fasm :tangle ./play/cicada.fasm
;; /usr/include/asm-generic/termbits.h
;; /usr/include/asm-generic/ioctls.h

VMIN = 6

ICRNL   =       0000400o
IXON    =       0002000o
ICANON  =       0000002o
ISIG    =       0000001o
ECHO    =       0000010o


segment readable writeable

termios:
termios.c_iflag:       rd 1
termios.c_oflag:       rd 1
termios.c_cflag:       rd 1
termios.c_lflag:       rd 1
termios.c_line:        rb 1
termios.c_cc:          rb 19 ;; NCCS
termios_size = ($ - termios)

termios_orig:
termios_orig.c_iflag:       rd 1
termios_orig.c_oflag:       rd 1
termios_orig.c_cflag:       rd 1
termios_orig.c_lflag:       rd 1
termios_orig.c_line:        rb 1
termios_orig.c_cc:          rb 19 ;; NCCS


ScreenSize:  rw 1


defCode "setTerminalToReadKey", setTerminalToReadKey
   ;; (* -- *)
   mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
   mov sys_2_rsi, 5401h        ;; TERMIOS_GET, TCGETS
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall

   mov rsi, termios_orig
   mov rdi, termios
   mov rcx, termios_size
   cld
   rep movsb

   mov byte [termios.c_cc + VMIN], 1
   ;; icanon off, isig (^C) off, echo off
   and byte [termios.c_lflag + 0], ((- ICANON) and (- ISIG) and (- ECHO))
   ;; ixon off,   icrnl off
   and byte [termios.c_iflag + 1], ((- (IXON shr 8)) or (- (ICRNL shr 8)))
   mov rdx, termios     ;; termios or WinSize structure ptr
   mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall
   next


defCode "setTerminalBackToReadLine", setTerminalBackToReadLine
   ;; (* -- *)
   mov sys_3_rdx, termios_orig ;; termios or WinSize structure ptr
   mov sys_2_rsi, 5402h ;; TERMIOS_SET, TCSETS
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall
   next


defCode "getScreenSize", getScreenSize
   ;; (* -- rows, cols *)
   mov sys_3_rdx, ScreenSize
   ;; [ScreenSize] == for example col=88,row=26 :: 00880026
   mov sys_2_rsi, 5413h ;; TERMIOS_WSIZE, TIOCGWINSZ
   mov sys_1_rdi, STDIN
   mov sys_n_rax, syscall_ioctl
   syscall
   ;; xor rax, rax
   mov ax, word[ScreenSize]
   pushArgumtStack rax
   mov ax, word[ScreenSize + 2]
   pushArgumtStack rax
   next
#+end_src
** loadCoreFile
*** note
    1. no fancy stuffs here
       there should be ONLY ONE core-file
       fancy stuffs will be written in cicada
*** implementation
    #+begin_src fasm :tangle ./play/cicada.fasm
    defConstString "LinuxEnvName.cicada_core_path", "cicada_core_path=", LinuxEnvName.cicada_core_path
    defConstString "LinuxEnvName.cicada_core", "cicada_core=", LinuxEnvName.cicada_core
    
    
    defWord "getLinuxEnvHeaderAddress", getLinuxEnvHeaderAddress
       ;; (* -- [address of zero-ending-string] *)
       xx LinuxProgramHeaderAddress, fetch
       xx LinuxProgramHeaderAddress, addition, add1
       xx Exit
    defWordEnd getLinuxEnvHeaderAddress
    
    
    defWord "getNextLinuxEnvAddress", getNextLinuxEnvAddress
       ;; (* [address of zero-ending-string] -- next-address *)
       xx add1, dup
       xx fetchByte, Zero, equal?, false?branch, 3
       xx   add1
       xx   Exit
       xx getNextLinuxEnvAddress
       xx Exit
    defWordEnd getNextLinuxEnvAddress
    
    
    defWord "help_getLinuxEnvValue", help_getLinuxEnvValue
       ;; (* [address, length],
       ;;    [address of zero-ending-string] --
       ;;    [address of zero-ending-string] *)
       xx dup
       xx xxoverxx, compareString?, false?branch, 6
       xx   xxswapx
       xx   swap, drop
       xx   addition
       xx   Exit
       xx getNextLinuxEnvAddress
       xx help_getLinuxEnvValue
       xx Exit
    defWordEnd help_getLinuxEnvValue
    
    defWord "getLinuxEnvValue", getLinuxEnvValue
       ;; the string used to get EnvVar must ending with `='
       ;; (* [address, length] -- [address of zero-ending-string] *)
       xx getLinuxEnvHeaderAddress
       xx help_getLinuxEnvValue
       xx Exit
    defWordEnd getLinuxEnvValue
    
    
    defWord "LinuxEnvValue.cicada_core_path", LinuxEnvValue.cicada_core_path
       ;; (*  -- [address of zero-ending-string] *)
       xx LinuxEnvName.cicada_core_path, getLinuxEnvValue
       xx Exit
    defWordEnd LinuxEnvValue.cicada_core_path
    
    
    defWord "LinuxEnvValue.cicada_core", LinuxEnvValue.cicada_core
       ;; (*  -- [address of zero-ending-string] *)
       xx LinuxEnvName.cicada_core, getLinuxEnvValue
       xx Exit
    defWordEnd LinuxEnvValue.cicada_core
    
    
    
    defWord "lengthOfZeroEndingString", lengthOfZeroEndingString
       ;; (* ZeroEndingString[address] -- length *)
       xx Zero
       xx swap
       ;; (* length, ZeroEndingString[address] *)
       xx dup, fetchByte, Zero, equal?, false?branch, 3
       xx   drop
       xx   Exit
       xx add1, swap, add1
       ;; (* ZeroEndingString[address + 1], length + 1 *)
       xx branch, -13
       xx Exit
    defWordEnd lengthOfZeroEndingString
    
    
    segment readable writeable
    BufferFor_get_cicada_core:
       rb 512
    
    defWord "get_cicada_core", get_cicada_core
       ;; (* -- [address of zero-ending-string] *)
       xx LinuxEnvValue.cicada_core_path
       xx   dup, lengthOfZeroEndingString
       xx   literal, BufferFor_get_cicada_core
       xx   swap
       xx   copyByteString
       xx literal, '/'
       xx   literal, BufferFor_get_cicada_core
       xx   LinuxEnvValue.cicada_core_path, lengthOfZeroEndingString
       xx   addition, saveByte
       xx LinuxEnvValue.cicada_core
       xx   dup, lengthOfZeroEndingString
       xx   literal, BufferFor_get_cicada_core
       xx   LinuxEnvValue.cicada_core_path, lengthOfZeroEndingString
       xx   addition, add1
       xx   swap
       xx   copyByteString
       xx literal, BufferFor_get_cicada_core
       xx Exit
    defWordEnd get_cicada_core
    
    
    ;; just syscall_read to read file into InputBuffer
    defCode "loadCoreFile", loadCoreFile
       ;; (* [address of zero-ending-string] --  *)
       popArgumtStack sys_1_rdi
       mov     sys_3_rdx, 110100100b
       mov     sys_2_rsi, open_read
       mov     sys_n_rax, syscall_open
       syscall
       mov     sys_3_rdx, SizeOfBufferForLoadFile
       mov     sys_2_rsi, BufferForLoadFile
       mov     sys_1_rdi, rax
       mov     sys_n_rax, syscall_read
       syscall
       ;; reset [CurrentReading + CellWidth]
       mov TemporaryRegister, BufferForLoadFile
       mov [CurrentReading + CellWidth], TemporaryRegister
       ;; reset [ReadingBoundary + CellWidth]
       add TemporaryRegister, rax
       mov [ReadingBoundary + CellWidth], TemporaryRegister
       next
    #+end_src
** IO
*** note
the words about IO are all very special
they often have ``read'' or ``write'' as prefix
*** basic IO : writeChar & readChar
#+begin_src fasm :tangle ./play/cicada.fasm
segment readable writeable
ScratchUsedByWriteChar:
   rb 1

defCode "writeChar", writeChar
   ;; ( char --  ) write a char to stdin
   ;; just calls the Linux write system call
   popArgumtStack rax
   call writeChar_helperFunction
   next
writeChar_helperFunction:
   mov sys_1_rdi, 1 ;; stdout
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [ScratchUsedByWriteChar], al
   mov sys_2_rsi, ScratchUsedByWriteChar  ;; address
   mov sys_3_rdx, 1                       ;; max length to be write, just 1
   mov sys_n_rax, syscall_write
   syscall
   ret




defConst "InputBufferSize", InputBufferSize, TheInputBufferSize
defConst "InputBuffer", InputBuffer, TheInputBuffer

;; Buffer for Linux syscall read
InputBufferSize = 3 * 1024 * 1024 ; bytes
;; InputBufferSize = 1 ; bytes
segment readable writeable
InputBuffer:
   rb InputBufferSize
EndOfInputBuffer:

;; two global variables for reading
;; I can easily support `evalString' by change these two variables
defVar "CurrentReading", InputBuffer, CurrentReading
defVar "ReadingBoundary", InputBuffer, ReadingBoundary


defCode "readChar", readChar
   ;; read a char from stdin, return it into the ArgumtStack as following
   ;; (*  -- char *)
   ;; readChar calls the Linux read system call to fill InputBuffer
   ;; The other thing that readChar does is
   ;; if it detects that stdin has closed, it exits the program
   ;; which is why when you hit C-d, the system exits
   call _readChar
   ;; _readChar will save the return value in rax
   pushArgumtStack rax
   next


_readChar:
   ;; TemporaryRegister is a helper-register for ``cmp''
   mov TemporaryRegister, [CurrentReading + CellWidth]
   cmp TemporaryRegister, [ReadingBoundary + CellWidth]
   ;-- IF: [CurrentReading + CellWidth] < [ReadingBoundary + CellWidth]
   ;-- WK: there is still some chars in the InputBuffer to be processed
   jl readChar_stillSomeChars
   ;-- EL: [CurrentReading + CellWidth] >= [ReadingBoundary + CellWidth]
   ;-- WK: all chars in InputBuffer have been processed
   mov rax, EndOfInputBuffer
   cmp TemporaryRegister, rax
   jg readChar_addBlankAtTheEnding
   mov rax, InputBuffer
   cmp TemporaryRegister, rax
   jl readChar_addBlankAtTheEnding
   jmp readChar_fetchMoreCharsFromStdinToInputBuffer
readChar_addBlankAtTheEnding:
   ;; otherwise,  when the a string not ending with blank
   ;; `evalString' will not work correctly
   mov rax, InputBuffer
   mov [CurrentReading + CellWidth], rax
   mov [ReadingBoundary + CellWidth], rax
   xor rax, rax
   mov al, 10
   ret
readChar_stillSomeChars:
   ;; for the following will just uses the al part of rax
   ;; it is necessary to clear rax
   xor rax, rax
   ;-- DO: fetch a char from InputBuffer to rax
   ;-- NT: after _readChar return rax will be pushArgumtStack
   mov al, byte[TemporaryRegister]
   ;-- DO: increment [CurrentReading + CellWidth]
   inc TemporaryRegister
   mov [CurrentReading + CellWidth], TemporaryRegister
   ret
;; note that, in the following subroutine
;; set [CurrentReading + CellWidth]  == InputBuffer
;; set [ReadingBoundary + CellWidth] == InputBuffer + length of string that was input (NULL not counted)
readChar_fetchMoreCharsFromStdinToInputBuffer:
   ;; read to fetch more input chars from STDIN to InputBuffer
   mov sys_3_rdx,     InputBufferSize    ;; max length to be read
   mov sys_2_rsi,     InputBuffer        ;; buffer address
   ;; reset [CurrentReading + CellWidth] to InputBuffer
   mov [CurrentReading + CellWidth], sys_2_rsi
   xor sys_1_rdi,     sys_1_rdi          ;; stdin
   mov sys_n_rax,     syscall_read
   syscall
   ;; the return value of syscall read
   ;; is a count of the number of bytes transferred
   test rax, rax
   ;-- IF: rax <= 0
   ;-- WK: there is an error or it is end of input
   ;-- DO: exit
   jz readChar_exit
   js readChar_exit
   ;-- EL: rax > 0
   ;-- WK: there are some chars has been fetched by syscall read
   ;-- DO: set [ReadingBoundary + CellWidth] to the right place
   ;--     ReadingBoundary = InputBuffer + the count of the number of bytes transferred
   ;-- NT: sys_2_rsi = InputBuffer
   ;--     rax = the count of the number of bytes transferred
   add sys_2_rsi, rax
   mov [ReadingBoundary + CellWidth], sys_2_rsi
   ;-- DO: jump back
   jmp _readChar


readChar_exit:
   ;; exit with exit code = the value syscall_read returned
   xor sys_1_rdi, sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall
#+end_src
*** readFirstNonBlankChar & readNonBlankChar
#+begin_src fasm :tangle ./play/cicada.fasm
defWord "readFirstNonBlankChar", readFirstNonBlankChar
   ;; (* -- FirstNonBlankChar *)
   xx readChar, dup
   xx literal, 32 ;; ascii.space
   xx greaterThan?, false?branch, 2
   xx   Exit
   xx drop
   xx branch, -10
defWordEnd readFirstNonBlankChar

defWord "readNonBlankChar", readNonBlankChar
   ;; (* -- FirstNonBlankChar or Zero *)
   xx readChar, dup
   xx literal, 32 ;; ascii.space
   xx greaterThan?, false?branch, 2
   xx   Exit
   xx drop
   xx Zero
   xx Exit
defWordEnd readNonBlankChar
#+end_src
*** readWord
#+begin_src fasm :tangle ./play/cicada.fasm
define MaxWordLength 1024

segment readable writeable
BufferForReadWord:
   ;; note that, Subsequent calls will overwrite BufferForReadWord
   ;; this is why there is another function ``readWordForRuntime''
   rb MaxWordLength

defWord "readWord", readWord
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   xx literal, BufferForReadWord ;; (* leave return one of the values *)
   xx Zero                       ;; (* leave length counter *)

   xx literal, BufferForReadWord
   xx readFirstNonBlankChar
   xx over, saveByte, add1
   xx swap, add1, swap

   xx readNonBlankChar, dup, zero?branch, 9
   xx   over, saveByte, add1
   xx   swap, add1, swap
   xx   branch, -11

   xx drop2
   xx Exit
defWordEnd readWord


segment readable writeable
BufferForReadWordForRuntime:
   rb MaxWordLength

defWord "readWordForRuntime", readWordForRuntime
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   xx literal, BufferForReadWordForRuntime ;; (* leave return one of the values *)
   xx Zero                                 ;; (* leave length counter *)

   xx literal, BufferForReadWordForRuntime
   xx readFirstNonBlankChar
   xx over, saveByte, add1
   xx swap, add1, swap

   xx readNonBlankChar, dup, zero?branch, 9
   xx   over, saveByte, add1
   xx   swap, add1, swap
   xx   branch, -11

   xx drop2
   xx Exit
defWordEnd readWordForRuntime
#+end_src
*** readStringInToBuffer
#+begin_src fasm :tangle ./play/cicada.fasm
define MaxStringLength 1024*1024 ;; unit : byte

defConst "BasicStringBuffer", BasicStringBuffer, TheBasicStringBuffer

segment readable writeable
BasicStringBuffer:
   ;; note that, Subsequent calls will overwrite BasicStringBuffer
   rb MaxStringLength

defWord "readStringInToBuffer", readStringInToBuffer
   ;; (*  -- string[address of BasicStringBuffer, length] *)
   xx literal, BasicStringBuffer ;; (* leave return one of the values *)
   xx Zero                         ;; (* leave length counter *)

   xx literal, BasicStringBuffer

   xx readChar, dup
   xx literal, 34 ;; ascii.doublequote
   xx equal?, notFalse?branch, 9
   xx   over, saveByte, add1
   xx   swap, add1, swap
   xx   branch, -14

   xx drop2
   xx Exit
defWordEnd readStringInToBuffer
#+end_src
*** number
    #+begin_src fasm :tangle ./play/cicada.fasm
    ;; The function uses the variable "Base" as the radix
    ;; If the word starts with a '-' character then the returned value is negative
     
    ;; If the string can't be parsed as a number
    ;; or contains characters outside the current BASE
    ;; then we need to return an error indication.
    ;; So we let NUMBER returns two items on the stack.
     
    defCode "number", number
       ;; (* wordString[address, length] --
       ;;    parsed number, length of unparsed string *)
       popArgumtStack  rcx        ;; length  of string
       popArgumtStack  rdi        ;; address of string
       call number_helperFunction
       pushArgumtStack rax        ;; parsed number
       pushArgumtStack rcx        ;; length of unparsed string (0 = no error)
       next
     
    number_helperFunction:
       xor  rax, rax
       xor  rbx, rbx
     
       test rcx, rcx
       ;-- IF: rcx == 0
       ;-- WK: trying to parse a zero-length string, it is an error
       ;-- DO: but will return 0
       jz number_return
       ;-- EL: rcx =/= 0
       ;-- WK: we have a non-empty string to be parsed
       ;-- DO: parse this non-empty string
       ;; copy the the variable Base into dl (rdx)
       ;; the following shows how to use a forth-variable-word in assembler code
       mov rdx, [Base + CellWidth]
       ;; fetch a char
       mov bl,  byte[rdi]
       inc rdi
       ;; sign-indicater
       ;; top of ArgumtStack == 0,  indicating positive
       ;; top of ArgumtStack =/= 0, indicating negative
       ;; initialize sign-indicater
       pushArgumtStack rax     ;; top of ArgumtStack == 0, indicating positive
       cmp bl, '-'
       ;-- IF: bl =/= '-'
       ;-- WK: maybe positive number, maybe error
       ;-- DO: try to convert the number
       jnz number_convert
       ;-- EL: bl == '-'
       ;-- DO: reset sign-indicater
       ;--     update the counter
       ;--     go into a loop to read all the chars
       popArgumtStack  rax
       pushArgumtStack rbx     ;; top of ArgumtStack =/= 0, indicating negative
       dec rcx                 ;; update the counter
       jnz number_fetchNextDigits
       popArgumtStack  rbx     ;; error: string is only '-'.
       mov rcx, 1
       ret
     
    number_update_the_counter_and_fetchNextDigits:
       dec rcx
    number_fetchNextDigits:
       mov bl,  byte[rdi]     ;; bl = next character in string
       inc rdi
     
    number_convert:
       cmp bl, '_'
       je number_update_the_counter_and_fetchNextDigits
     
       ;; from low to high along the ascii
       sub bl, '0'
       ;-- IF: char < '0'
       jb number_endThisParse
       cmp bl, 10
       ;-- IF: '0' <= char <= '9'
       jb number_tryToAddDigitUp
     
       ;-- EL: '9' < char
       sub bl, ('A' - '0')
       ;-- IF: '9'< char < 'A'
       jb number_endThisParse
       cmp bl, 26
       ;-- NOTE-THAT: if bl == 0, char == 'A'
       ;-- IF: 'Z' < char
       jge @f
       ;-- EL: 'A' <= char <= 'Z'
       add bl, 10 ;; for 'A' =Hex= 10
       jb number_tryToAddDigitUp
     
    @@:;-- IF: 'Z' < char
       sub bl, ('a' - 'A')
       ;-- IF: 'Z' < char < 'a'
       jb number_endThisParse
       cmp bl, 26
       ;-- NOTE-THAT: if bl == 0, char == 'a'
       ;-- IF: 'z' < char
       jge number_endThisParse
       ;-- EL: 'a' <= char <= 'a'
       add bl, 10 ;; for 'a' =Hex= 10
       ;; jb number_tryToAddDigitUp
     
     
    number_tryToAddDigitUp:
       cmp bl, dl
       ;-- IF: bl >= dl
       ;-- WK: this digit >= Base
       jge number_endThisParse
       ;-- EL: bl < dl
       ;-- WK: this is a good digit
       ;-- DO: so add it to rax and loop
       imul rax, rdx   ;; (set! rax (* Base rax))
       add  rax, rbx
       dec  rcx
       jnz  number_fetchNextDigits
     
    number_endThisParse:
    ;; negate the result according to the sign-indicater on the top of ArgumtStack
       popArgumtStack rbx
       test rbx, rbx
       jz   number_return
       neg  rax
    number_return:
       ret
     
     
    ;; the following kinds of strings denote number,
    ;; because the function ``number'' can handle them.
    ;; 1. string with '0' - '9' as first char
    ;; 2. string with '-' as first char and with '0' - '9' as second char
    ;; so "-->", "_0" do not denote number.
    ;; under HexBase,
    ;; "feed" does not denote number, but "0feed", "0_feed" denote number
     
    defCode "stringDenoteNumber?", stringDenoteNumber?
       ;; ( wordString[address, length] -- true or false )
       popArgumtStack  rcx        ;; length  of string
       popArgumtStack  rdi        ;; address of string
       call stringDenoteNumber?_helperFunction
       pushArgumtStack rax        ;; true or false
       next
     
    stringDenoteNumber?_helperFunction:
       xor rbx, rbx
     
       test rcx, rcx
       ;-- IF: rcx == 0
       ;-- WK: trying to parse a zero-length string, it is an error
       jz stringDenoteNumber?_returnFalse
       ;-- EL: rcx =/= 0
       ;-- WK: we have a non-empty string to be parsed
       mov bl,  byte[rdi]
       cmp bl, '-'
       ;-- IF: bl =/= '-'
       ;-- WK: maybe positive number, maybe error
       jnz @f
       ;-- EL: bl == '-'
       inc rdi
       dec rcx                 ;; update the counter
       test rcx, rcx
       ;-- IF: rcx == 0
       ;-- WK: string is only '-'
       jz stringDenoteNumber?_returnFalse
       ;; fetch next digit
       mov  bl,  byte[rdi]
       inc  rdi
     
    @@:
       sub bl, '0'
       ;-- IF: char < '0'
       jb stringDenoteNumber?_returnFalse
       cmp bl, 10
       ;-- IF: '0' <= char <= '9'
       jb stringDenoteNumber?_returnTrue
       ;-- EL: returnFalse
     
    stringDenoteNumber?_returnFalse:
       xor rax, rax
       ret
     
    stringDenoteNumber?_returnTrue:
       xor rax, rax
       mov rax, qword 1
       ret
    #+end_src
*** comment
#+begin_src fasm :tangle ./play/cicada.fasm
defConstString "CommentBeginWordString",  "(*", CommentBeginWordString
defConstString "CommentEndingWordString", "*)", CommentEndingWordString

defWord "ignoreComment", ignoreComment
   ;; (* -- *)
   ;; (* ignore a list of comment words from stdin *)
   xx readWord
   xx dup2, CommentBeginWordString, equalString?, false?branch, 5
   xx   drop2, ignoreComment, branch, -9
   ;; beware of the tail-call-optimization
   ;; a tail-recursive-call is really a loop
   xx CommentEndingWordString, equalString?, false?branch, -13
   xx   Exit
defWordEnd ignoreComment


defWord "(*", comment
   xx ignoreComment
   xx Exit
defWordEnd comment

;; test:
;; (* ok (* ok *) ok *) ok
#+end_src
*** readWordListForLexicographer
#+begin_src fasm :tangle ./play/cicada.fasm
;; a WordList (unit : CellWidth = 8 bytes)
;;   ||  1 : length-of-Word-1     ||
;;   ||  a : Word-1--as-a-string  ||
;;   ||  1 : length-of-Word-2     ||
;;   ||  b : Word-2--as-a-string  ||
;;   ...

;; note that:
;;    Subsequent calls will overwrite BufferForReadWordListForLexicographer
segment readable writeable
BufferForReadWordListForLexicographer:
   rb 1024*1024

defConstString "EndingWordForReadWordListForLexicographer", ";", EndingWordForReadWordListForLexicographer
defConstString "ChineseEndingWordForReadWordListForLexicographer", "者", ChineseEndingWordForReadWordListForLexicographer

defVar "NextWordForReadWordListForLexicographer", BufferForReadWordListForLexicographer, NextWordForReadWordListForLexicographer

defWord "readWordListForLexicographer", readWordListForLexicographer
   ;; (* read a WordList from stdin (ForLexicographer) *)
   ;; (* -- wordList[address, the number of words] *)

   ;; (* initialize NextWordForReadWordListForLexicographer *)
   xx literal, BufferForReadWordListForLexicographer
   xx NextWordForReadWordListForLexicographer
   xx save

   ;; (* leave return value: [buffer-address, counter] *)
   xx literal, BufferForReadWordListForLexicographer
   xx Zero

   xx readWord

   xx dup2
   xx CommentBeginWordString, equalString?, false?branch, 5
   xx drop2, ignoreComment, branch, -9

   xx dup2
   xx EndingWordForReadWordListForLexicographer, equalString?, false?branch, 3
   xx drop2
   xx Exit

   xx dup2
   xx ChineseEndingWordForReadWordListForLexicographer, equalString?, false?branch, 3
   xx drop2
   xx Exit

   xx addWordToListForLexicographer
   xx add1
   xx branch, -27
defWordEnd readWordListForLexicographer

defWord ":", BeginningWordForReadWordListForLexicographer
   xx readWordListForLexicographer
   xx Exit
defWordEnd BeginningWordForReadWordListForLexicographer

defWord "夫", ChineseBeginningWordForReadWordListForLexicographer
   xx readWordListForLexicographer
   xx Exit
defWordEnd ChineseBeginningWordForReadWordListForLexicographer


defWord "addWordToListForLexicographer", addWordToListForLexicographer
   ;; ( wordString[address, length] -- )
   ;; leave a length behind, for update NextWordForReadWordListForLexicographer at the end
   xx dup, xxswapx
   ;;   ||  1 : length-of-Word-1     ||
   xx dup, NextWordForReadWordListForLexicographer, fetch, save
   ;; update NextWordForReadWordListForLexicographer
   xx NextWordForReadWordListForLexicographer, fetch, add8, NextWordForReadWordListForLexicographer, save
   ;;   ||  a : Word-1--as-a-string  ||
   xx NextWordForReadWordListForLexicographer, fetch, swap, copyByteString
   ;; update NextWordForReadWordListForLexicographer again
   xx NextWordForReadWordListForLexicographer, addSave
   xx Exit
defWordEnd addWordToListForLexicographer
#+end_src
** dictionary look up
#+begin_src fasm :tangle ./play/cicada.fasm
;; recall
;; a word in the dictionary (unit : CellWidth = 8 bytes)
;; ==
;;   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;   ||  m : name-string  ||
;;   ||  1 : link  ||
;;   ||  1 : type  ||
;;   ||  1 : address-of-name-string-header  ||
;;   ||  1 : address-of-explainer  ||
;;   ||  n : body  ||
;; where
;;   ||  1 : type  ||
;; ==
;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
;; type-bit-0 is for HiddenWord
define WordType_HiddenMask 00000001h


;; defWord "wordLinkToWordString", wordLinkToWordString
;;    ;; (* link[address] -- string[address, length] *)
;;    xx literal, CellWidth
;;    xx Two, multiple
;;    xx addition
;;    xx fetch
;;    xx dup, literal, CellWidth, addition
;;    xx swap, fetch
;;    xx Exit
;; defWordEnd wordLinkToWordString

;; defWord "help,find", help_find
;;    ;; (* wordString[address, length], link[address] -- word[address of link] or Zero *)
;;    xx dup, zero?, false?branch, 4
;;    xx   xxswapx, drop2
;;    xx   Exit
;;    xx xxtuckx, wordLinkToWordString, xxoverxx, equalString?, false?branch, 3
;;    xx   drop2
;;    xx   Exit
;;    xx xswapxx, fetch
;;    xx help_find
;;    xx Exit
;; defWordEnd help_find

;; defWord "find", find
;;    ;; (* wordString[address, length] -- word[address of link] or Zero *)
;;    xx FirstWordInDictionary, fetch
;;    xx help_find
;;    xx Exit
;; defWordEnd find



defCode "find", find
   ;; (* wordString[address, length] -- word[address of link] or Zero *)
   ;; find doesn't find dictionary entries which are flagged as hidden
   popArgumtStack  rcx     ;; length
   popArgumtStack  rdi     ;; address
   call find_helperFunction
   ;; returns the address of the address of the link of the word in the dictionary (or null)
   pushArgumtStack rax
   next

find_helperFunction:
   ;; ><><>< if rsi is used somewhere else,
   ;; the following will be necessary.
   ;; pushArgumtStack rsi    ;; save rsi so we can use it in string comparison
   ;; initialize the searching point
   mov rdx, [FirstWordInDictionary + CellWidth]

find_lookThisPoint:
   test rdx, rdx
   ;-- IF: rdx == 0
   ;-- WK: we reach the end of the linked list
   je find_notFound
   ;-- EL: rdx == 0
   ;-- WK: we have a word to look up
   ;-- DO: look the type field of this word
   mov rax, [rdx + CellWidth]
   and rax, WordType_HiddenMask
   ;-- IF: type::0 of this word =/= 0
   ;-- WK: this word is hidden
   jnz find_lookNextPoint
   ;-- EL: type::0 of this word == 0
   ;-- WK: this word is not hidden
   ;; get word length into rax
   mov TemporaryRegister, [rdx + (2 * CellWidth)]
   mov rax, [TemporaryRegister]
   cmp rax, rcx
   ;-- IF: rax =/= rcx
   ;-- WK: length is not the same
   jne find_lookNextPoint
   ;-- EL: rax == rcx
   ;-- WK: length is the same
   ;-- DO: compare the strings in detail
   pushArgumtStack rcx                       ;; save the length
   pushArgumtStack rdi                       ;; save the address (repe cmpsb will move this pointer)
   lea rsi, [TemporaryRegister + CellWidth]  ;; dictionary string we are checking against.
   ;; >< 下面这个命令的参数是 rsi rdi rcx
   ;; 分别是两个地址和需要被比较的长度
   repe cmpsb                                ;; compare the strings.
   popArgumtStack rdi
   popArgumtStack rcx
   ;-- IF: not the same
   jne find_lookNextPoint
   ;-- EL: the strings are the same
   ;-- DO: return the address of link of this word in rax
   mov rax, rdx
   ;; popArgumtStack rsi
   ret

find_lookNextPoint:
   ;; move back through the link field to the previous word
   mov rdx, [rdx]
   ;; jump back
   jmp find_lookThisPoint

find_notFound:
   ;; return 0
   xor rax, rax
   ;; popArgumtStack rsi
   ret


;; usage;
;; 1 2 readWord + find wordLinkToWordExplainer execute . ( 3 )
defWord "wordLinkToWordExplainer", wordLinkToWordExplainer
   ;; (* word[address of link] -- word[address of explainer] or Zero *)
   xx add8, add8, add8
   xx Exit
defWordEnd wordLinkToWordExplainer
#+end_src
** the basic lexicographer
#+begin_src fasm :tangle ./play/cicada.fasm
defWord "appendNumberToHere", appendNumberToHere
   ;; (* a 64 bits number -- *)
   ;; reset ``Here'', which points next free memory
   xx Here, fetch
   xx save
   xx Here, fetch, add8
   xx Here ,save
   xx Exit
defWordEnd appendNumberToHere

;; note that:
;; a string in stack is string[address, length]
;; a string in memory is ||  1 : length  ||  n : string  ||
defWord "appendStringToHere", appendStringToHere
   ;; (* string[address, length] -- *)
   ;; leave a length behind, for update Here
   xx dup, xxswapx
   ;;   ||  1 : length  ||
   xx dup, appendNumberToHere
   ;;   ||  n : string  ||
   xx Here, fetch, swap, copyByteString
   ;; update Here
   xx Here, fetch, addition, Here, save
   xx Exit
defWordEnd appendStringToHere

;; test: appendNumberToHere
;; 6 , Here fetch sub8 fetch .


defWord "createWordHeader", createWordHeader
   ;; (* byString *)
   ;; (* string[address, length] -- word[address of link] *)
   xx Here, fetch, xxswapx ;; for address-of-name-string-header
   xx appendStringToHere
   xx Here, fetch, appendNumberToHere ;; (* identification *)
   xx Here, fetch ;; (* leave the word[link] *)
   xx Zero, appendNumberToHere ;; (* link *)
   xx Zero, appendNumberToHere ;; (* type *)
   xx swap
   xx appendNumberToHere ;; address-of-name-string-header
   xx Exit
defWordEnd createWordHeader


defWord "createWordHeaderForFunction", createWordHeaderForFunction
   ;; (* string[address, length] -- word[address of link] *)
   xx Here, fetch, xxswapx ;; for address-of-name-string-header
   xx appendStringToHere
   xx Zero, appendNumberToHere ;; (* SizeOfFunctionBody *)
   xx Here, fetch, appendNumberToHere ;; (* identification *)
   xx Here, fetch ;; (* leave the word[link] *)
   xx Zero, appendNumberToHere ;; (* link *)
   xx Zero, appendNumberToHere ;; (* type *)
   xx swap
   xx appendNumberToHere ;; address-of-name-string-header
   xx Exit
defWordEnd createWordHeaderForFunction



defWord "appendWordDescriptionToHere", appendWordDescriptionToHere
   ;; (* wordList[address, the number of words] -- *)
   xx dup, zero?branch, 16;-- GOTO: drop2
   xx tailAndHeadOfWordList
   xx dup2, stringDenoteNumber?
   xx false?branch, 6;-- GOTO: find
   ;; reading-error reported by ``number'' is not handled
   xx number, drop, appendNumberToHere
   xx branch, -12;-- GOTO: the beginning

   xx find, wordLinkToWordExplainer, appendNumberToHere
   xx branch, -17;-- GOTO: the beginning

   xx drop2
   xx Exit
defWordEnd appendWordDescriptionToHere

defWord "addNewWordToDictionary", addNewWordToDictionary
   ;; reset FirstWordInDictionary to point to the newly defined word
   ;; (* word[address of link] -- *)
   xx dup
   xx FirstWordInDictionary, fetch
   xx swap
   xx save
   xx FirstWordInDictionary, save
   xx Exit
defWordEnd addNewWordToDictionary

defWord "setTheSizeOfFunctionBody", setTheSizeOfFunctionBody
   ;; (* wordList[address, the number of words], word[address of link] --
   ;;    wordList[address, the number of words], word[address of link] *)
   xx dup
   xx sub8, sub8
   xx xoverxx
   xx swap
   xx save
   xx Exit
defWordEnd setTheSizeOfFunctionBody

defWord "defineFunction", defineFunction
   ;; (* wordList[address, the number of words] -- *)
   ;; to create a new word
   ;; is to use some words to describe the new word,
   ;; and let an explainer to explain the description of the new word.
   ;; to define a new word
   ;; is to add the new created word to the dictionary.
   xx tailAndHeadOfWordList
   xx createWordHeaderForFunction
   xx FunctionBodyExplainer, appendNumberToHere
   xx setTheSizeOfFunctionBody
   xx xxswapx
   xx appendWordDescriptionToHere
   xx addNewWordToDictionary
   xx Exit
defWordEnd defineFunction
#+end_src
** basicREPL
   REPL for cicada is ``read execute (maybe print) loop''
   #+begin_src fasm :tangle ./play/cicada.fasm
   defWord "basicREPL", basicREPL
      ;; (* unknown -- unknown *)
      xx TheReturnStackTop, resetReturnStackPointer
      xx TheArgumtStackTop, resetArgumtStackPointer
      xx readWordForRuntime
      xx executeWord
      xx branch, -3
      ;; must not end with Exit here
   defWordEnd basicREPL
   
   
   defWord "executeWord", executeWord
      ;; (* unknown -- unknown *)
      xx dup2, stringDenoteNumber?
      xx false?branch, 4;-- GOTO: find, dup, zero?branch
   
      ;; about number, no error handling
      xx number, drop
      xx Exit
   
      ;; about non-number
      xx find, dup, zero?branch, 4;-- GOTO: drop, printErrorInfoForExecuteWord
      xx wordLinkToWordExplainer, execute
      xx Exit
   
      xx drop, printErrorInfoForExecuteWord
      xx Exit
   defWordEnd executeWord
   
   
   defWord "printErrorInfoForExecuteWord", printErrorInfoForExecuteWord
      ;; (* -- *)
      xx Ten, writeChar
      xx literal, 32, writeChar
      xx literal, 32, writeChar
      xx literal, 'u', writeChar
      xx literal, 'n', writeChar
      xx literal, 'd', writeChar
      xx literal, 'e', writeChar
      xx literal, 'f', writeChar
      xx literal, 'i', writeChar
      xx literal, 'n', writeChar
      xx literal, 'e', writeChar
      xx literal, 'd', writeChar
      xx literal, 32, writeChar
      xx Exit
   defWordEnd printErrorInfoForExecuteWord
#+end_src
* cicada_begin
  and LinuxProgramHeaderAddress
  #+begin_src fasm :tangle ./play/cicada.fasm
  segment readable executable
  cicada_begin:
  
          cld ;; set DF = 0, then rsi and rdi are incremented
  
  ;; [rsp+8*0]=N           argc number of arguments
  ;; [rsp+8*1]             argv0 name of executable (e.g. ./a00)
  ;; [rsp+8*2]             argv1 (if any) - 1st param after name of executable
  ;; ...
  ;; [rsp+8*N]             argvN - Nth param
  ;; qword [rsp+8*(N+1)]=0 end of arguments
  ;; [rsp+8*(N+2)]         envp environment
  ;; ...
  ;; qword [rsp+....]=0    end of environment
  
      ;; the Address we want is stored in [rsp] but not rsp
      ;; because rsp is the standard-stack-pointer
      ;; the Address we want is pushed into the standard-stack
  
          ;; beware of the way
          ;;   to use the ``Const'' or ``Var'' in assembly
  
          mov [LinuxProgramHeaderAddress + CellWidth], rsp
  
  
          mov ArgumtStackPointer,   ArgumtStackTop
          mov GreyPairStackPointer, GreyPairStackTop
          mov ReturnStackPointer,   ReturnStackTop
  
          ;; initialize the variable ``Here''
          ;; to point at beginning of DataSegment
          mov TemporaryRegister, UserDataSegment
          mov [Here + CellWidth], TemporaryRegister
          mov NextWordPointer, BeginCicada
          next
  
  
  
  segment readable writeable
  BeginCicada:
  
          xx get_cicada_core, loadCoreFile
          xx basicREPL
          ;; xx assemblyDebug
  
  defConst "LinuxProgramHeaderAddress", 0, LinuxProgramHeaderAddress
  
  ;; test:
  ;; LinuxProgramHeaderAddress fetch . cr
  ;; LinuxProgramHeaderAddress CellWidth 1 * + fetch
  ;;   20 printString cr
  ;; LinuxProgramHeaderAddress CellWidth 2 * + fetch
  ;;   3 printString cr
#+end_src
* memory allocation
** ReturnStack & ArgumtStack
1. after push the first value into ArgumtStack
   ArgumtStackPointer will point to the address of this value
2. before push the first value into ArgumtStack
   ArgumtStackPointer point to StackTop
   and StackTop will never be used
4. beware to understanding ``StackBottom'' and ``StackTop''
#+begin_src fasm :tangle ./play/cicada.fasm

defConst "ArgumtStackTop",    ArgumtStackTop,    TheArgumtStackTop
defConst "ArgumtStackBottom", ArgumtStackBottom, TheArgumtStackBottom

SizeOfArgumtStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
ArgumtStackBottom:
        rq SizeOfArgumtStack
ArgumtStackTop:
        rq 100


SizeOfReturnStack = 100 * 1024 ;; unit: CellWidth

defConst "ReturnStackTop",    ReturnStackTop,    TheReturnStackTop
defConst "ReturnStackBottom", ReturnStackBottom, TheReturnStackBottom

segment readable writeable
ReturnStackBottom:
        rq SizeOfReturnStack
ReturnStackTop:
        rq 100
#+end_src
** UserDataSegment
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfUserDataSegment = 1024 * 1024 ;; unit: byte
segment readable writeable
UserDataSegment:
        rb SizeOfUserDataSegment
EndOfUserDataSegment:

defConst "UserDataSegment", UserDataSegment, TheUserDataSegment
defConst "EndOfUserDataSegment", EndOfUserDataSegment, TheEndOfUserDataSegment
#+end_src
** PairConstructionsArray
#+begin_src fasm :tangle ./play/cicada.fasm
;;   (unit : byte)
;; ========================
;;   ||  1 : color     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ========================

ClrBytesSize = 1
CarBytesSize = 16
CdrBytesSize = 16
ConsBytesSize = ClrBytesSize + CarBytesSize + CdrBytesSize
;; NumberOfPairConstructions = 1024
NumberOfPairConstructions = 100 * 1000 ;; about 3.3M

defConst "ClrBytesSize"  , ClrBytesSize  , TheClrBytesSize
defConst "CarBytesSize"  , CarBytesSize  , TheCarBytesSize
defConst "CdrBytesSize"  , CdrBytesSize  , TheCdrBytesSize
defConst "ConsBytesSize" , ConsBytesSize , TheConsBytesSize

segment readable writeable
        rb ClrBytesSize
InFrontOfTheFirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        rb ClrBytesSize
FirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        ;; ==========================
        rb (NumberOfPairConstructions - 2) * ConsBytesSize
        ;; ==========================

        rb ClrBytesSize
LastPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

defConst "NumberOfPairConstructions", NumberOfPairConstructions, TheNumberOfPairConstructions

defConst "InFrontOfTheFirstPairConstruction", InFrontOfTheFirstPairConstruction, TheInFrontOfTheFirstPairConstruction
defConst "FirstPairConstruction", FirstPairConstruction, TheFirstPairConstruction
defConst "LastPairConstruction",  LastPairConstruction,  TheLastPairConstruction

defVar "CurrFreePairConstruction", FirstPairConstruction, CurrFreePairConstruction
#+end_src
** GreyPairStack
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfGreyPairStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
GreyPairStackBottom:
        rq SizeOfGreyPairStack
GreyPairStackTop:
        rq 1
#+end_src
** HashTableForSymbol
using linear probing
so, the load factor must be lower then 0.5
#+begin_src fasm :tangle ./play/cicada.fasm
;; a SymbolEntry (unit : byte)
;; ===========================
;;  ||   8 : SymbolValue   ||
;; ---------------------------
;;  ||   1 : SymbolLength  ||
;; ---------------------------
;;  || 56+ : SymbolString  ||
;; ===========================

SymbolLengthBytesSize = 1
SymbolValueBytesSize  = 8
SymbolStringBytesSize = 56+0
SymbolMaxLength       = 56
SymbolEntryBytesSize = SymbolValueBytesSize + SymbolLengthBytesSize + SymbolStringBytesSize
;; NumberOfSymbolEntrys = 1000003
;; NumberOfSymbolEntrys = 1000033
;; NumberOfSymbolEntrys = 1000333
;; NumberOfSymbolEntrys = 100003
NumberOfSymbolEntrys = 100333
;; NumberOfSymbolEntrys = 997
;; NumberOfSymbolEntrys = 499
;; NumberOfSymbolEntrys = 230 ;; for a special test


defConst "NumberOfSymbolEntrys",  NumberOfSymbolEntrys,  TheNumberOfSymbolEntrys
defConst "SymbolValueBytesSize",  SymbolValueBytesSize,  TheSymbolValueBytesSize
defConst "SymbolLengthBytesSize", SymbolLengthBytesSize, TheSymbolLengthBytesSize
defConst "SymbolStringBytesSize", SymbolStringBytesSize, TheSymbolStringBytesSize
defConst "SymbolMaxLength",       SymbolMaxLength,       TheSymbolMaxLength
defConst "SymbolEntryBytesSize",  SymbolEntryBytesSize,  TheSymbolEntryBytesSize

segment readable writeable

FirstSymbolEntry:
        rb SymbolEntryBytesSize

        ;; ========================
        rb (NumberOfSymbolEntrys - 2) * SymbolEntryBytesSize
        ;; ========================

LastSymbolEntry:
        rb SymbolEntryBytesSize


defConst "FirstSymbolEntry", FirstSymbolEntry, TheFirstSymbolEntry
defConst "LastSymbolEntry",  LastSymbolEntry,  TheLastSymbolEntry
#+end_src
** two StringHeaps
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfStringHeap = 5 * 1024 * 1024 ;; unit: byte
segment readable writeable
StringHeap1:
        rb SizeOfStringHeap
EndOfStringHeap1:
segment readable writeable
StringHeap2:
        rb SizeOfStringHeap
EndOfStringHeap2:

defConst "SizeOfStringHeap", SizeOfStringHeap, TheSizeOfStringHeap

defConst "StringHeap1", StringHeap1, TheStringHeap1
defConst "StringHeap2", StringHeap2, TheStringHeap2
#+end_src
** LambdaStack
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfLambdaStack = 10 * 1024 ;; unit: CellWidth
segment readable writeable
LambdaStackBottom:
        rq SizeOfLambdaStack
LambdaStackTop:
        rq 1

defConst "LambdaStackBottom", LambdaStackBottom, TheLambdaStackBottom
defConst "LambdaStackTop", LambdaStackTop, TheLambdaStackTop
#+end_src
** BufferForLoadFile
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfBufferForLoadFile = 1024 * 1024 ;; unit : byte

defConst "BufferForLoadFile", BufferForLoadFile, TheBufferForLoadFile
defConst "SizeOfBufferForLoadFile", SizeOfBufferForLoadFile, TheSizeOfBufferForLoadFile

segment readable writeable
BufferForLoadFile:
         rb SizeOfBufferForLoadFile
#+end_src
** ------------------------------------------
** StackForEvalString
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfStackForEvalString = 1024 ;; unit: CellWidth
segment readable writeable
StackForEvalStringBottom:
        rq SizeOfStackForEvalString
StackForEvalStringTop:
        rq 1

defConst "StackForEvalStringBottom", StackForEvalStringBottom, TheStackForEvalStringBottom
defConst "StackForEvalStringTop", StackForEvalStringTop, TheStackForEvalStringTop
#+end_src
** FileNameBufferForOpenFile
#+begin_src fasm :tangle ./play/cicada.fasm
SizeOfFileNameBufferForOpenFile = 1024 ;; unit : byte

defConst "FileNameBufferForOpenFile", FileNameBufferForOpenFile, TheFileNameBufferForOpenFile

segment readable writeable
FileNameBufferForOpenFile:
         rb SizeOfFileNameBufferForOpenFile
#+end_src
* assemblyDebug
#+begin_src fasm :tangle ./play/cicada.fasm
defWord ".", printLittleNumber
   xx literal, '0'
   xx addition, writeChar
   xx literal, 32
   xx writeChar
   xx literal, 32
   xx writeChar
   xx Exit
defWordEnd printLittleNumber

defCode "exitWithTOS", exitWithTOS
   popArgumtStack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall

defWord "assemblyDebug", assemblyDebug
   ;; xx ><><><
   xx exitWithTOS
defWordEnd assemblyDebug
#+end_src
* TheLatestWordInAssembly
#+begin_src fasm :tangle ./play/cicada.fasm
;; this word helps to initialize FirstWordInDictionary
defConst "TheLatestWordInAssembly", 0, TheLatestWordInAssembly
#+end_src
* ==================================================
* TEN COMMANDMENTS OF CICADA
  1. you can break any commandment when necessary
  2. in cicada every function can be redefined
     the later definition will override the former definition
     the order of function definition is very important
  3. in cicada, a ``word'' can not begin with [0-9]
     and can not begin with a `-' follows [0-9]
  4. ``The whole point of Forth was that
     you didn't write programs in Forth
     you wrote vocabularies in Forth.
     When you devised an application
     you wrote a hundred words or so that discussed the application
     and you used those hundred words
     to write a one line definition to solve the application.
     It is not easy to find those hundred words,
     but they exist,
     they always exist.''
* --------------------------------------------------
* defineVar & defineConst (new lexicographers)
** implementation
   #+begin_src cicada :tangle ./core/english.ccd
   : defineVar,byString
     (* initial-value, String[address, length] -- *)
     createWordHeader
     VarExplainer appendNumberToHere
     swap (* leave wordHeader *)
     appendNumberToHere (* the initial-value of Var *)
     addNewWordToDictionary
     Exit
   ; defineFunction
    
   : defineVar (* byWordList *)
     (* initial-value, WordList[address, the number of words] -- *)
     headOfWordList
     defineVar,byString
     Exit
   ; defineFunction
    
   : defineConst,byString
     (* initial-value, WordList[address, the number of words] -- *)
     createWordHeader
     ConstExplainer appendNumberToHere
     swap (* leave wordHeader *)
     appendNumberToHere (* the initial-value of Const *)
     addNewWordToDictionary
     Exit
   ; defineFunction
    
   : defineConst (* byWordList *)
     (* initial-value, WordList[address, the number of words] -- *)
     headOfWordList
     defineConst,byString
     Exit
   ; defineFunction
   #+end_src
** test
   #+begin_src cicada
   0 : Yi ; defineVar
    
   Yi fetch . (* 0 *) cr
   1 Yi save
   Yi fetch . (* 1 *) cr
    
   7 : Qi ; defineConst
   Qi . (* 7 *) cr
    
   : QiJiaYi (* -- *)
     Qi Yi fetch + .
     Exit
   ; defineFunction
   QiJiaYi (* 8 *) cr
   #+end_src
* fixnum
** implementation
   #+begin_src cicada :tangle ./core/english.ccd
   : /mod (* a, b -- quotient, a mod b *)
     mod/ swap
     Exit
   ; defineFunction
    
   : / (* a, b -- a mod b *)
     /mod drop
     Exit
   ; defineFunction
    
   : mod (* a, b -- a mod b *)
     mod/ drop
     Exit
   ; defineFunction
    
   : negate (* n --  -n *)
     Zero swap -
     Exit
   ; defineFunction
   #+end_src
** test
   #+begin_src cicada
   10 3 / . (* 3 *)
   10 3 mod . (* 1 *)
   #+end_src
* ascii chars
  #+begin_src cicada :tangle ./core/english.ccd
  9   : 'tab'      ; defineConst
  10  : 'linefeed' ; defineConst
  10  : 'newline'  ; defineConst
  27  : 'esc'      ; defineConst
  27  : 'escape'   ; defineConst
  32  : 'space'    ; defineConst
  127 : 'delete'   ; defineConst
   
  33 : '!' ; defineConst
  34 : '"' ; defineConst
  35 : '#' ; defineConst
  36 : '$' ; defineConst
  37 : '%' ; defineConst
  38 : '&' ; defineConst
  39 : ''' ; defineConst
  40 : '(' ; defineConst
  41 : ')' ; defineConst
  42 : '*' ; defineConst
  43 : '+' ; defineConst
  44 : ',' ; defineConst
  45 : '-' ; defineConst
  46 : '.' ; defineConst
  47 : '/' ; defineConst
   
  48 : '0' ; defineConst
  49 : '1' ; defineConst
  50 : '2' ; defineConst
  51 : '3' ; defineConst
  52 : '4' ; defineConst
  53 : '5' ; defineConst
  54 : '6' ; defineConst
  55 : '7' ; defineConst
  56 : '8' ; defineConst
  57 : '9' ; defineConst
   
  58 : ':' ; defineConst
  59 : ';' ; defineConst
  60 : '<' ; defineConst
  61 : '=' ; defineConst
  62 : '>' ; defineConst
  63 : '?' ; defineConst
  64 : '@' ; defineConst
   
  65 : 'A' ; defineConst
  66 : 'B' ; defineConst
  67 : 'C' ; defineConst
  68 : 'D' ; defineConst
  69 : 'E' ; defineConst
  70 : 'F' ; defineConst
  71 : 'G' ; defineConst
  72 : 'H' ; defineConst
  73 : 'I' ; defineConst
  74 : 'J' ; defineConst
  75 : 'K' ; defineConst
  76 : 'L' ; defineConst
  77 : 'M' ; defineConst
  78 : 'N' ; defineConst
  79 : 'O' ; defineConst
  80 : 'P' ; defineConst
  81 : 'Q' ; defineConst
  82 : 'R' ; defineConst
  83 : 'S' ; defineConst
  84 : 'T' ; defineConst
  85 : 'U' ; defineConst
  86 : 'V' ; defineConst
  87 : 'W' ; defineConst
  88 : 'X' ; defineConst
  89 : 'Y' ; defineConst
  90 : 'Z' ; defineConst
   
  91 : '[' ; defineConst
  92 : '\' ; defineConst
  93 : ']' ; defineConst
  94 : '^' ; defineConst
  95 : '_' ; defineConst
  96 : '`' ; defineConst
   
  97  : 'a' ; defineConst
  98  : 'b' ; defineConst
  99  : 'c' ; defineConst
  100 : 'd' ; defineConst
  101 : 'e' ; defineConst
  102 : 'f' ; defineConst
  103 : 'g' ; defineConst
  104 : 'h' ; defineConst
  105 : 'i' ; defineConst
  106 : 'j' ; defineConst
  107 : 'k' ; defineConst
  108 : 'l' ; defineConst
  109 : 'm' ; defineConst
  110 : 'n' ; defineConst
  111 : 'o' ; defineConst
  112 : 'p' ; defineConst
  113 : 'q' ; defineConst
  114 : 'r' ; defineConst
  115 : 's' ; defineConst
  116 : 't' ; defineConst
  117 : 'u' ; defineConst
  118 : 'v' ; defineConst
  119 : 'w' ; defineConst
  120 : 'x' ; defineConst
  121 : 'y' ; defineConst
  122 : 'z' ; defineConst
   
  123 : '{' ; defineConst
  124 : '|' ; defineConst
  125 : '}' ; defineConst
  126 : '~' ; defineConst
  #+end_src
* linux syscall : read & write
  #+begin_src cicada :tangle ./core/english.ccd
  0 : Syscall,read  ; defineConst
  1 : Syscall,write ; defineConst
   
  0 : STDIN  ; defineConst
  1 : STDOUT ; defineConst
  2 : STDERR ; defineConst
  #+end_src
* string & defineConstString (new lexicographer)
** implementation
   #+begin_src cicada :tangle ./core/english.ccd
   (* ><><>< string of 0 length is a not handled  error *)
   : headOfString (* string[address, length] -- first char *)
     drop fetchByte
     Exit
   ; defineFunction
    
   : tailOfString (* string[address, length] -- string[address + 1, length - 1] *)
     sub1 swap add1 swap
     Exit
   ; defineFunction
    
   : tailAndHeadOfString
     (* string[address, length] --
        string[address + 1, length - 1], first char *)
     dup2 tailOfString xx|swap|xx headOfString
     Exit
   ; defineFunction
    
   : printString (* string[address, length] -- *)
     swap
     STDOUT
     Syscall,write
     syscallWithThreeArguments
     drop (* length is returned by this syscall *)
     Exit
   ; defineFunction
    
    
   : :" (* -- string[address of BasicStringBuffer, length] *)
     readStringInToBuffer
     Exit
   ; defineFunction
    
   : ." (* -- string[address of BasicStringBuffer, length] *)
     readStringInToBuffer printString
     Exit
   ; defineFunction
    
   : defineConstString,byString
     (* initial-string[address, length],
        string[address, length], the number of words] -- *)
     createWordHeader
     ConstStringExplainer appendNumberToHere
     xx|swap|x (* leave wordHeader *)
     appendStringToHere (* initial-string *)
     addNewWordToDictionary
     Exit
   ; defineFunction
    
   : defineConstString (* byWordList *)
     (* string[address, length],
        wordList[address, the number of words] -- *)
     headOfWordList
     defineConstString,byString
     Exit
   ; defineFunction
   #+end_src
** test
   #+begin_src cicada
   :" xxx"
   : k ; defineConstString
   k printString (* xxx *)
   #+end_src
* recursive Function & decision (new lexicographers)
** note
   one predicate can make two branchs
   three predicates can make four branchs
   three predicates may only make three branchs
   but indeed there must be an invisible branch
** implementation
   bug:
   if there is one ``if,then'' pair mismatch
   there will be crazy bug which is very hard to test !!
   #+begin_src cicada :tangle ./core/english.ccd
   : defineRecursiveFunction (* wordList[address, the number of words] -- *)
     tailAndHeadOfWordList
     createWordHeaderForFunction
     setTheSizeOfFunctionBody
     addNewWordToDictionary
     FunctionBodyExplainer appendNumberToHere
     appendWordDescriptionToHere
     Exit
   ; defineFunction
    
   :" if"    : String,KeyWord,if   ; defineConstString
   :" else"  : String,KeyWord,else ; defineConstString
   :" then"  : String,KeyWord,then ; defineConstString
    
   : appendWordDescriptionToHereWith:if&then
     (* wordList[address, the number of words] -- *)
       dup zero? false?branch 3
         drop2 Exit
    
       tailAndHeadOfWordList
    
       dup2 String,KeyWord,if equalString? false?branch 12
         drop2
         literal false?branch appendNumberToHere
         Here fetch xx|swap|x
         Zero appendNumberToHere (* leave a place *)
         appendWordDescriptionToHereWith:if&then Exit
    
       dup2 String,KeyWord,then equalString? false?branch 13
         drop2
         x|swap|xx
         Here fetch over -  CellWidth /
         swap save
         appendWordDescriptionToHereWith:if&then Exit
    
       dup2 stringDenoteNumber? false?branch 6
         number drop appendNumberToHere
         appendWordDescriptionToHereWith:if&then Exit
    
         find wordLinkToWordExplainer appendNumberToHere
         appendWordDescriptionToHereWith:if&then Exit
   ; defineRecursiveFunction
    
   : defineRecursiveFunctionWith:if&then
     (* wordList[address, the number of words] -- *)
       tailAndHeadOfWordList
       createWordHeaderForFunction
       setTheSizeOfFunctionBody
       addNewWordToDictionary
       FunctionBodyExplainer appendNumberToHere
       appendWordDescriptionToHereWith:if&then
       Exit
   ; defineFunction
    
    
   (* redefine appendWordDescriptionToHere add `else' *)
    
   : appendWordDescriptionToHere
     (* wordList[address, the number of words] -- *)
       dup zero? if
         drop2 Exit
       then
       tailAndHeadOfWordList
       dup2 String,KeyWord,if equalString? if
         drop2
         literal false?branch appendNumberToHere
         Here fetch xx|swap|x
         Zero appendNumberToHere (* leave a place *)
         appendWordDescriptionToHere Exit
       then
       dup2 String,KeyWord,else equalString? if
         drop2
         literal branch appendNumberToHere
         Here fetch xxx|swap|x
         Zero appendNumberToHere (* leave a place *)
         x|swap|xx
         Here fetch over -  CellWidth /
         swap save
         appendWordDescriptionToHere Exit
       then
       dup2 String,KeyWord,then equalString? if
         drop2
         x|swap|xx
         Here fetch over -  CellWidth /
         swap save
         appendWordDescriptionToHere Exit
       then
       dup2 stringDenoteNumber? if
         number drop appendNumberToHere
         appendWordDescriptionToHere Exit
       then
         find wordLinkToWordExplainer appendNumberToHere
         appendWordDescriptionToHere Exit
   ; defineRecursiveFunctionWith:if&then
    
    
   (* redefine defineRecursiveFunction & defineFunction *)
    
   : defineFunction
     (* wordList[address, the number of words] -- *)
       tailAndHeadOfWordList
       createWordHeaderForFunction
       setTheSizeOfFunctionBody
       xx|swap|x
       FunctionBodyExplainer appendNumberToHere
       appendWordDescriptionToHere
       addNewWordToDictionary
       Exit
   ; defineFunction
    
   : defineRecursiveFunction
     (* wordList[address, the number of words] -- *)
       tailAndHeadOfWordList
       createWordHeaderForFunction
       setTheSizeOfFunctionBody
       addNewWordToDictionary
       FunctionBodyExplainer appendNumberToHere
       appendWordDescriptionToHere
       Exit
   ; defineFunction
   #+end_src
** test
   #+begin_src cicada
   : factorial 
     (* n -- n! *)
     dup one? if
       Exit
     then
     dup sub1 factorial * Exit
   ; defineRecursiveFunction
     
    
   1 factorial .
   2 factorial .
   3 factorial .
   4 factorial .
   5 factorial .
   6 factorial .
   7 factorial .
   8 factorial .
   9 factorial .
   10 factorial .
   11 factorial .
   12 factorial .
   13 factorial .
   14 factorial .
   15 factorial .
   16 factorial .
   17 factorial .
   18 factorial .
   19 factorial .
   20 factorial .
    
    
    
   : .12 (* 1 2 -- *)
     Two == if
       '2' writeChar
       One == if
         '1' writeChar
       else
         '_' writeChar
       then
     else
       '_' writeChar
       One == if
         '1' writeChar
       else
         '_' writeChar
       then
     then
     Exit
   ; defineFunction
    
   1 2 .12 cr
   6 2 .12 cr
   1 6 .12 cr
   6 6 .12 cr
   #+end_src
* predicates
  #+begin_src cicada :tangle ./core/english.ccd
  : specialKeyWord? (* word[explainer] -- True or False *)
    dup literal literal          == if drop True Exit then
    dup literal branch           == if drop True Exit then
    dup literal zero?branch      == if drop True Exit then
    dup literal false?branch     == if drop True Exit then
    dup literal notFalse?branch  == if drop True Exit then
    drop False
    Exit
  ; defineFunction
  #+end_src
* NOTE ABOUT reader
  when you want to read,
  say, hex based number in a REPL
  just set the variable ``Base'', and restore it after then.
* writers of number
** note
   1. it is great if want a reader can read
      is identical to what a writer would write
      and what a writer write
      could be read by reader without any changes
      I will try to achieve this
   2. due to the lack of the ``semantic of substitution''
      to achieve the following functions
      I have to copy lots of code
      instead of just using lambda-abstraction
** implementation
*** writeDecNumber
    #+begin_src cicada :tangle ./core/english.ccd
    : writeDecNumberChar (* byte -- *)
      '0' + writeChar
      Exit
    ; defineFunction
     
    : help,writeDecNumber,pushChars
      (* ... , number of small DecNumbers, fixnum --
         ... , number of small DecNumbers *)
      DecBase mod/
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help,writeDecNumber,pushChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeDecNumber,writeChars
      (* ... , number of small DecNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeDecNumberChar
      help,writeDecNumber,writeChars
      Exit
    ; defineRecursiveFunction
     
    : writeDecNumber (* fixnum -- *)
      Zero swap
      help,writeDecNumber,pushChars
      help,writeDecNumber,writeChars
      Exit
    ; defineFunction
     
    : writeDecNumber,signed (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeDecNumber
      Exit
    ; defineFunction
    #+end_src
*** writeBinNumber
    #+begin_src cicada :tangle ./core/english.ccd
    : writeBinNumberChar (* byte -- *)
      '0' + writeChar
      Exit
    ; defineFunction
     
    : help,writeBinNumber,pushChars
      (* ... , number of small BinNumbers, fixnum --
         ... , number of small BinNumbers *)
      BinBase mod/
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help,writeBinNumber,pushChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeBinNumber,writeChars
      (* ... , number of small BinNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeBinNumberChar
      help,writeBinNumber,writeChars
      Exit
    ; defineRecursiveFunction
     
    : writeBinNumber (* fixnum -- *)
      Zero swap
      help,writeBinNumber,pushChars
      help,writeBinNumber,writeChars
      Exit
    ; defineFunction
     
    : writeBinNumber,signed (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeBinNumber
      Exit
    ; defineFunction
    #+end_src
*** writeOctNumber
    #+begin_src cicada :tangle ./core/english.ccd
    : writeOctNumberChar (* byte -- *)
      '0' + writeChar
      Exit
    ; defineFunction
     
    : help,writeOctNumber,pushChars
      (* ... , number of small OctNumbers, fixnum --
         ... , number of small OctNumbers *)
      OctBase mod/
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help,writeOctNumber,pushChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeOctNumber,writeChars
      (* ... , number of small OctNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeOctNumberChar
      help,writeOctNumber,writeChars
      Exit
    ; defineRecursiveFunction
     
    : writeOctNumber (* fixnum -- *)
      Zero swap
      help,writeOctNumber,pushChars
      help,writeOctNumber,writeChars
      Exit
    ; defineFunction
     
    : writeOctNumber,signed (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeOctNumber
      Exit
    ; defineFunction
    #+end_src
*** writeHexNumber
    #+begin_src cicada :tangle ./core/english.ccd
    : writeHexNumberChar (* byte -- *)
      dup Ten < if
        '0' + writeChar Exit
      then
      Ten -
      'a' + writeChar
      Exit
    ; defineFunction
     
    : writeHexNumberChar,capital (* byte -- *)
      dup Ten < if
        '0' + writeChar Exit
      then
      Ten -
      'A' + writeChar
      Exit
    ; defineFunction
     
    : help,writeHexNumber,pushChars
      (* ... , number of small HexNumbers, fixnum --
         ... , number of small HexNumbers *)
      HexBase mod/
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help,writeHexNumber,pushChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeHexNumber,writeChars
      (* ... , number of small HexNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeHexNumberChar
      help,writeHexNumber,writeChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeHexNumber,writeChars,capital
      (* ... , number of small HexNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeHexNumberChar,capital
      help,writeHexNumber,writeChars,capital
      Exit
    ; defineRecursiveFunction
     
    : writeHexNumber (* fixnum -- *)
      Zero swap
      help,writeHexNumber,pushChars
      help,writeHexNumber,writeChars
      Exit
    ; defineFunction
     
    : writeHexNumber,capital (* fixnum -- *)
      Zero swap
      help,writeHexNumber,pushChars
      help,writeHexNumber,writeChars,capital
      Exit
    ; defineFunction
     
    : writeHexNumber,signed (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeHexNumber
      Exit
    ; defineFunction
     
    : writeHexNumber,signed,capital (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeHexNumber,capital
      Exit
    ; defineFunction
    #+end_src
*** writeAphNumber
    #+begin_src cicada :tangle ./core/english.ccd
    : writeAphNumberChar (* byte -- *)
      dup Ten < if
        '0' + writeChar Exit
      then
      Ten -
      'a' + writeChar
      Exit
    ; defineFunction
     
    : writeAphNumberChar,capital (* byte -- *)
      dup Ten < if
        '0' + writeChar Exit
      then
      Ten -
      'A' + writeChar
      Exit
    ; defineFunction
     
    : help,writeAphNumber,pushChars
      (* ... , number of small AphNumbers, fixnum --
         ... , number of small AphNumbers *)
      AphBase mod/
      dup zero? if
        drop swap add1 Exit
      then
      xx|swap|x xx|swap|x add1 swap
      help,writeAphNumber,pushChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeAphNumber,writeChars
      (* ... , number of small AphNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeAphNumberChar
      help,writeAphNumber,writeChars
      Exit
    ; defineRecursiveFunction
     
    : help,writeAphNumber,writeChars,capital
      (* ... , number of small AphNumbers -- *)
      dup zero? if drop Exit
      then
      sub1 swap writeAphNumberChar,capital
      help,writeAphNumber,writeChars,capital
      Exit
    ; defineRecursiveFunction
     
    : writeAphNumber (* fixnum -- *)
      Zero swap
      help,writeAphNumber,pushChars
      help,writeAphNumber,writeChars
      Exit
    ; defineFunction
     
    : writeAphNumber,capital (* fixnum -- *)
      Zero swap
      help,writeAphNumber,pushChars
      help,writeAphNumber,writeChars,capital
      Exit
    ; defineFunction
     
    : writeAphNumber,signed (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeAphNumber
      Exit
    ; defineFunction
     
    : writeAphNumber,signed,capital (* fixnum -- *)
      dup Zero < if
        '-' writeChar
        negate
      then
      writeAphNumber,capital
      Exit
    ; defineFunction
    #+end_src
*** usage
    #+begin_src cicada :tangle ./core/english.ccd
    : .unsigned (* fixnum -- *)
      writeDecNumber
      'space' writeChar
      Exit
    ; defineFunction
     
    : .signed (* fixnum -- *)
      writeDecNumber,signed
      'space' writeChar
      Exit
    ; defineFunction
     
     
    : . .signed Exit ; defineFunction
     
     
    : .bin (* fixnum -- *)
      writeBinNumber
      'space' writeChar
      Exit
    ; defineFunction
     
    : .bin,signed (* fixnum -- *)
      writeBinNumber,signed
      'space' writeChar
      Exit
    ; defineFunction
     
    : .oct (* fixnum -- *)
      writeOctNumber
      'space' writeChar
      Exit
    ; defineFunction
     
    : .oct,signed (* fixnum -- *)
      writeOctNumber,signed
      'space' writeChar
      Exit
    ; defineFunction
     
    : .hex (* fixnum -- *)
      writeHexNumber
      'space' writeChar
      Exit
    ; defineFunction
     
    : .hex,signed (* fixnum -- *)
      writeHexNumber,signed
      'space' writeChar
      Exit
    ; defineFunction
     
    : .hex,capital (* fixnum -- *)
      writeHexNumber,capital
      'space' writeChar
      Exit
    ; defineFunction
     
    : .hex,signed,capital (* fixnum -- *)
      writeHexNumber,signed,capital
      'space' writeChar
      Exit
    ; defineFunction
     
     
    : .aph (* fixnum -- *)
      writeAphNumber
      'space' writeChar
      Exit
    ; defineFunction
     
    : .aph,signed (* fixnum -- *)
      writeAphNumber,signed
      'space' writeChar
      Exit
    ; defineFunction
     
    : .aph,capital (* fixnum -- *)
      writeAphNumber,capital
      'space' writeChar
      Exit
    ; defineFunction
     
    : .aph,signed,capital (* fixnum -- *)
      writeAphNumber,signed,capital
      'space' writeChar
      Exit
    ; defineFunction
     
    : cr (* -- *)
      'newline' writeChar Exit
    ; defineFunction
     
     
    : writeSpace (* -- *)
      'space' writeChar Exit
    ; defineFunction
     
    : writeSomeSpace (* n -- *)
      dup zero? if
        drop Exit
      then
      sub1
      writeSpace
      writeSomeSpace
      Exit
    ; defineRecursiveFunction
    #+end_src
** test
   #+begin_src cicada
   123 321 123321 . . .
   -123 321 -123321 . . .
   -123 321 -123321 .signed .signed .signed
   -123 321 -123321 .unsigned .unsigned .unsigned
    
   123 321 123321 .bin .bin .bin
   -123 321 -123321 .bin,signed .bin,signed .bin,signed
    
   123 321 123321 .oct .oct .oct
   -123 321 -123321 .oct,signed .oct,signed .oct,signed
    
   123 321 123321 .hex .hex .hex
   123 321 123321 .hex,capital .hex,capital .hex,capital
   -123 321 -123321 .hex,signed .hex,signed .hex,signed
   -123 321 -123321 .hex,signed,capital .hex,signed,capital .hex,signed,capital
    
   123 321 123321 .aph .aph .aph
   123 321 123321 .aph,capital .aph,capital .aph,capital
   -123 321 -123321 .aph,signed .aph,signed .aph,signed
   -123 321 -123321 .aph,signed,capital .aph,signed,capital .aph,signed,capital
   #+end_src
* debugerREPL & traceFunction
** note
   1. after type tag encoding
      we should handle type error as possible as we could
   2. the ``IdentificationOf#Word'' in ``def*'' macros is for ``debuger''
** implementation
#+begin_src cicada :tangle ./core/english.ccd
: countReturnStack (* -- the length of ReturnStack *)
  ReturnStackTop fetchReturnStackPointer -
  Eight /
  sub1 (* for we are in this function call *)
  Exit
; defineFunction

: countArgumtStack (* -- the length of ArgumtStack *)
  ArgumtStackTop fetchArgumtStackPointer -
  Eight /
  Exit
; defineFunction


0 : ReturnStackPosition ; defineVar
0 : ArgumtStackPosition ; defineVar

(* the following two function are as interface *)
: debuger,fetchFromReturnStack (* n -- *)
  sub1 Eight *
  ReturnStackPosition fetch +
  fetch
  Exit
; defineFunction

: debuger,fetchFromArgumtStack (* n -- *)
  sub1 Eight *
  ArgumtStackPosition fetch +
  fetch
  Exit
; defineFunction


:" bye"
: String,bye ; defineConstString

: executeWord (* string[address, length] -- unknown *)
  dup2
  stringDenoteNumber? if
    number drop Exit
  then
    find dup notZero? if
      wordLinkToWordExplainer execute Exit
    then
      drop printErrorInfoForExecuteWord Exit
; defineFunction

: debugerREPL (* unknown -- unknown *)
  readWordForRuntime
  dup2
  String,bye equalString? if
    drop2
    Exit
  then
  executeWord
  debugerREPL
  Exit
; defineRecursiveFunction

:" debuger said: ``Welcome! Hope you find what's wrong.''"
: String,debuger,Welcome ; defineConstString

:" the length of ReturnStack is: "
: String,debuger,theLengthOfReturnStack ; defineConstString

:" the length of ArgumtStack is: "
: String,debuger,theLengthOfArgumtStack ; defineConstString

:" debuger said: ``Good bye! The computation will go on!''"
: String,debuger,Goodbye ; defineConstString

: debuger (* unknown -- unknown *)
  String,debuger,Welcome printString cr
  Three writeSomeSpace String,debuger,theLengthOfReturnStack printString
    countReturnStack writeDecNumber cr
  Three writeSomeSpace String,debuger,theLengthOfArgumtStack printString
    countArgumtStack writeDecNumber cr
  fetchReturnStackPointer ReturnStackPosition save
  fetchArgumtStackPointer ArgumtStackPosition save
  InputBuffer CurrentReading save
  InputBuffer ReadingBoundary save
  debugerREPL
  String,debuger,Goodbye printString cr
  Exit
; defineFunction

(* ><><>< bug ><><>< *)
(* ``1 fetch'' will cause core dump *)
: identificationOfWord? (* an address in a word -- *)
  dup fetch ==
  Exit
; defineFunction

(* ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 ,* || m(bytes) : name-string  ||
 ,* ||  1 : size of function body  ||
 ,* ||  1 : identification  ||
 ,* ||  1 : link  ||
 ,* ||  1 : type  ||
 ,* ||  1 : address-of-name-string-header  ||
 ,* ||  1 : address-of-explainer  ||
 ,* ||  n : body  ||
 ,*)

: word,body->id
  (* [an address of a cell in a word] -- word[identification] *)
  dup
  identificationOfWord? if
    Exit
  then
  CellWidth -
  word,body->id
  Exit
; defineRecursiveFunction

: word,id->name
  (* word[identification] -- string[address, length] *)
  CellWidth Three * +
  fetch dup
  add8 swap
  fetch
  Exit
; defineFunction

: word,id->explainer
  (* word[identification] -- explainer *)
  CellWidth Four * +
  fetch
  Exit
; defineFunction

: word,id->body-size
  (* word[identification] -- body-size *)
  CellWidth -
  fetch
  Exit
; defineFunction

: word,id->body-list
  (* word[identification] -- body-list[address, length] *)
  dup
    CellWidth Five * +
  swap
  word,id->body-size
  Exit
; defineFunction

: printNameOfExplainer (* explainer -- *)
  dup FunctionBodyExplainer == if
    literal FunctionBodyExplainer
    word,body->id
    word,id->name
    printString
    drop Exit
  then
  dup VarExplainer == if
    literal VarExplainer
    word,body->id
    word,id->name
    printString
    drop Exit
  then
  dup ConstExplainer == if
    literal ConstExplainer
    word,body->id
    word,id->name
    printString
    drop Exit
  then
  dup ConstStringExplainer == if
    literal ConstStringExplainer
    word,body->id
    word,id->name
    printString
    drop Exit
  then
  drop
  Exit
; defineFunction

: printFunctionBodyList (* body-list[address, length] -- *)
  dup zero? if
    drop2 Exit
  then
  Six writeSomeSpace
  over fetch word,body->id word,id->name printString cr
  sub1 swap
  CellWidth + swap
  printFunctionBodyList
  Exit
; defineRecursiveFunction

:"  -->  "
: String,_-->__ ; defineConstString

(* the following function is the first function
   on which I must use ``if,else,then'' *)
: withPointer,printFunctionBodyList
  (* [an address of a cell in a word], body-list[address, length] -- *)
  dup zero? if
    drop2 drop Exit
  then
  x|over|xx x|over|xx == if
    String,_-->__ printString
  else
    Six writeSomeSpace
  then
  over
  dup fetch specialKeyWord? if
    fetch word,body->id word,id->name printString cr
    sub2 swap
    dup
    Six writeSomeSpace
    CellWidth + fetch writeDecNumber cr
    CellWidth Two * + swap
    withPointer,printFunctionBodyList
    Exit
  then
  fetch word,body->id word,id->name printString cr
  sub1 swap
  CellWidth + swap
  withPointer,printFunctionBodyList
  Exit
; defineRecursiveFunction


:" traceFunction said: ``Ya! Let's trace a function!''"
: String,traceFunction,Welcome ; defineConstString

:" The function we use to trace is:"
: String,traceFunction,FunctionToTrace ; defineConstString

:" The function be traced to is:"
: String,traceFunction,FunctionBeTracedTo ; defineConstString

:" The size of the body of this function is:"
: String,traceFunction,FunctionBodySize ; defineConstString

:" The body of this function is:"
: String,traceFunction,FunctionBody ; defineConstString

:" traceFunction said: ``The end of a tracing.''"
: String,traceFunction,Goodbye ; defineConstString

: traceFunction
  (* [an address of a cell in a word] -- *)
  String,traceFunction,Welcome printString cr
  dup
    Three writeSomeSpace String,traceFunction,FunctionToTrace printString cr
    Six writeSomeSpace fetch word,body->id word,id->name printString cr
  dup (* withPointer,printFunctionBodyList still uses original arg *)
  word,body->id
    dup
      Three writeSomeSpace String,traceFunction,FunctionBeTracedTo printString cr
      Six writeSomeSpace word,id->name printString cr
    dup
      Three writeSomeSpace String,traceFunction,FunctionBodySize printString cr
      Six writeSomeSpace word,id->body-size writeDecNumber cr
    Three writeSomeSpace String,traceFunction,FunctionBody printString cr
    word,id->body-list withPointer,printFunctionBodyList
  String,traceFunction,Goodbye printString cr
  Exit
; defineFunction
#+end_src
** simple trace
#+begin_src cicada :tangle ./core/english.ccd
: trace (* n -- *)
  debuger,fetchFromReturnStack
  traceFunction
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
(* test: traceFunction *)

: xxx (* n, m -- *)
   debuger
   +
   literal 666 .
   .
   Exit
; defineFunction

10 1 xxx
  1 debuger,fetchFromReturnStack  traceFunction
  2 debuger,fetchFromReturnStack  traceFunction
  bye
(* 666 11 *)


: factorial (* n -- n! *)
    dup one? if
      debuger
      Exit
    then
    dup sub1 factorial * Exit
; defineRecursiveFunction

10 factorial
  1 debuger,fetchFromReturnStack
    traceFunction
  9 debuger,fetchFromReturnStack
    traceFunction
  10 debuger,fetchFromReturnStack
    traceFunction
  bye
. (* 3628800 *)



(* about tail call *)
: writeSomeSpace (* n -- *)
    dup zero? if
      drop Exit
    then
    sub1
    'space' writeChar
    debuger
    writeSomeSpace
    Exit
; defineRecursiveFunction

100 writeSomeSpace
  1 debuger,fetchFromReturnStack
    traceFunction
  2 debuger,fetchFromReturnStack
    traceFunction
  bye
(* Ya! you can never say ``bye'' to this call of ``debuger'' *)
(* when ever you call ``debuger'' in front of a recursive call, this happens *)
basicREPL
countArgumtStack . (* 0 *)
countReturnStack . (* 0 *)
#+end_src
* new lexicographers with debuger
** note
1. the following redefined ``appendWordDescriptionToHere''
   will call debuger if it meets a undefined word
2. there will be syntax-check after the implementation of ``list''
** implementation
#+begin_src cicada :tangle ./core/english.ccd
: printWordList (* WordList[address, the number of words] -- *)
  dup zero? if
    drop2
    cr Exit
  then
  Three writeSomeSpace
  tailAndHeadOfWordList printString cr
  printWordList
  Exit
; defineRecursiveFunction


:" an error occurs!
appendWordDescriptionToHere said:
   ``I am a tail-recursive-function.
     My function-type is (* WordList[address, the number of words] -- *)
     `defineRecursiveFunction' and `defineFunction' call me.
     The following word is undefined.
     I will print the rest of the WordList and call debuger.''
   --> "
: String,appendWordDescriptionToHere,meetUndefinedWord
; defineConstString

:" The length of the rest of the WordList is: "
: String,appendWordDescriptionToHere,LengthOfTheRestOfTheWordList
; defineConstString

:" The rest of the WordList is: "
: String,appendWordDescriptionToHere,TheRestOfTheWordList
; defineConstString


: appendWordDescriptionToHere
  (* WordList[address, the number of words] -- *)
  dup zero? if
    drop2 Exit
  then
  tailAndHeadOfWordList
    dup2 String,KeyWord,if equalString? if
      drop2
      literal false?branch appendNumberToHere
      Here fetch xx|swap|x
      Zero appendNumberToHere (* leave a place *)
      appendWordDescriptionToHere Exit
    then
    dup2 String,KeyWord,else equalString? if
      drop2
      literal branch appendNumberToHere
      Here fetch xxx|swap|x
      Zero appendNumberToHere (* leave a place *)
      x|swap|xx
      Here fetch over -  CellWidth /
      swap save
      appendWordDescriptionToHere Exit
    then
    dup2 String,KeyWord,then equalString? if
      drop2
      x|swap|xx
      Here fetch over -  CellWidth /
      swap save
      appendWordDescriptionToHere Exit
    then
    dup2 stringDenoteNumber? if
      number drop appendNumberToHere
      appendWordDescriptionToHere Exit
    then
    dup2
    find dup notZero? if
      wordLinkToWordExplainer appendNumberToHere
      drop2 (* drop the string[address, length], which is for debuger *)
      appendWordDescriptionToHere
      Exit
    then
    drop (* drop the Zero *)
  String,appendWordDescriptionToHere,meetUndefinedWord printString
  printString cr
  String,appendWordDescriptionToHere,LengthOfTheRestOfTheWordList
  printString dup writeDecNumber cr
  String,appendWordDescriptionToHere,TheRestOfTheWordList printString cr
  printWordList
  debuger
  Exit
; defineRecursiveFunction


: defineFunction
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    xx|swap|x
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    addNewWordToDictionary
    Exit
; defineFunction

: defineRecursiveFunction
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    addNewWordToDictionary
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    Exit
; defineFunction
#+end_src
* --------------------------------------------------
* index-hashback->string & string-hash->index
** note
1. ``string-hash->index index-hashback->string''
   is a identity function
   and if the argumt is a index returned by ``string-hash->index''
   ``index-hashback->string string-hash->index''
   also is a identity function
2. you can set a 8 bytes value
   to every symbol in this hash-table
   by:
   [value, index] index->address save
   dynamic type system make use of it
   for I implement type-tag as a special symbol
   but you should NOT set a pair to a symbol
   for I can not afford to let gc scan the whole hash-table to mark it
3. hash-function (string)
   ==> (sum-up [byte_n * 2^n]) mod NumberOfSymbolEntrys
   + where:
     0 <= n < SymbolMaxLength
     and the NumberOfSymbolEntrys is a prime number
   after sum-up, the greatest number < 2^(SymbolMaxLength + 8)
   so I let SymbolMaxLength == 64 - 8 == 56
   only first SymbolMaxLength of the string is used by the hash-function
** string-hash->index & index-hashback->string
#+begin_src cicada :tangle ./core/english.ccd
(* a SymbolEntry [unit : byte]
 ,* ==========================
 ,*  ||   8 : SymbolValue   ||
 ,* --------------------------
 ,*  ||   1 : SymbolLength  ||
 ,* --------------------------
 ,*  || 56+ : SymbolString  ||
 ,* ==========================
 ,* where SymbolMaxLength = 56 *)

:" an error occurs!
index->address said:
   ``My function-type is (* index -- address *)
     The following unsign-number is not a index of the hash-table
     I will not touch it and call debuger.''
   --> "
: String,index->address,error ; defineConstString

: index->address (* index -- address *)
  dup NumberOfSymbolEntrys >= if
    String,index->address,error printString
    dup writeDecNumber cr
    debuger Exit
  then
  dup Zero < if
    String,index->address,error printString
    dup writeDecNumber cr
    debuger Exit
  then
  SymbolEntryBytesSize *
  FirstSymbolEntry +
  Exit
; defineFunction

: index-hashback->string
  (* index -- string[address, length] *)
  index->address Eight +
  dup add1 swap
  fetchByte
  Exit
; defineFunction


: help,string-hash->index,sum-up
  (* sum-up , string[address, length] -- sum-up *)
  dup zero? if
    drop2 Exit
  then
  tailAndHeadOfString
  over shiftLeft
  x|swap|xxx  +  xx|swap|x
  help,string-hash->index,sum-up
  Exit
; defineRecursiveFunction

: help,string-hash->index,find-old-or-creat-new
  (* string[address, length], index -- index *)
  xx|tuck|x
  index-hashback->string
  (* index, string[address, length], string-2[address, length] *)
  dup zero? if  (* creat-new *)
    drop
    (* index, string[address, length], destination-address *)
    over over
    (* index, string[address, length], destination-address, length, address *)
    sub1 saveByte
    swap
    (* index,, source-address, destination-address, length *)
    copyByteString
    Exit
  then
  (* index, string[address, length], string-2[address, length] *)
  xx|over|xx equalString? if (* found old *)
    drop2 Exit
  then
  x|swap|xx (* to get next-index *)
  (* string[address, length], index *)
  dup index->address LastSymbolEntry == if
    drop
    Zero
    help,string-hash->index,find-old-or-creat-new
    Exit
  then
  add1
  help,string-hash->index,find-old-or-creat-new
  Exit
; defineRecursiveFunction

: help,string-hash->index,sum-up->index
  (* sum-up -- index *)
  NumberOfSymbolEntrys mod
  Exit
; defineFunction

: string-hash->index
  (* string[address, length] -- index *)
  dup2
    dup SymbolMaxLength > if
      drop SymbolMaxLength
      (* this means only first SymbolMaxLength of the string is used by the hash-function *)
    then
    Zero xx|swap|x
    help,string-hash->index,sum-up
    help,string-hash->index,sum-up->index
  help,string-hash->index,find-old-or-creat-new
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
NumberOfSymbolEntrys 1 -
index->address LastSymbolEntry == . (* 1 *)

-1 index->address
basicREPL
1000000000 index->address
basicREPL

:" a" string-hash->index . cr
:" b" string-hash->index . cr
:" c" string-hash->index . cr

:" k" string-hash->index . cr
:" kk" string-hash->index . cr
:" xxx" string-hash->index . cr
:" xxxk" string-hash->index . cr
:" xxxkk" string-hash->index . cr
:" xxxxxx" string-hash->index . cr
:" xxxxxxk" string-hash->index . cr
:" xxxxxxkk" string-hash->index . cr
:" xxxxxxxxx" string-hash->index . cr
:" xxxxxxxxxk" string-hash->index . cr
:" xxxxxxxxxkk" string-hash->index . cr
:" xxxxxxxxxxxx" string-hash->index . cr
:" xxxxxxxxxxxxk" string-hash->index . cr
:" xxxxxxxxxxxxkk" string-hash->index . cr
:" xxxxxxxxxxxxxxx" string-hash->index . cr
:" xxxxxxxxxxxxxxxk" string-hash->index . cr
:" xxxxxxxxxxxxxxxkk" string-hash->index . cr


(* NumberOfSymbolEntrys : 10_0333 , 10_0003
   97      97
   98      98
   99      99
   107     107
   321     321
   749     749
   1605    1605
   3317    3317
   6741    6741
   13589   13589
   27285   27285
   54677   54677
   9128    9458
   18363   19023
   36833   38153
   73773   76413
   47320   52930
   94747   5964
   89268   12035
   78310   24177
 ,*)


(* test: collision *)
(*  'A'*2 + 'c' = 'B'*2 + 'a' *)
:" Ac" string-hash->index . cr (* 229 *)
:" Ba" string-hash->index . cr (* 230 *)

:" A"
  string-hash->index index-hashback->string
printString

:" Ac"
  string-hash->index index-hashback->string
printString

:" Ba"
  string-hash->index index-hashback->string
printString

(* test: rounding *)

(* when: NumberOfSymbolEntrys = 10_0003 *)
10_0003 .bin (* 11000011010100011 *)

(* when: NumberOfSymbolEntrys = 10_0333 *)
10_0333 .bin (* 11000011111101101 *)


(* I do not want to solve two funny equations about ascii-chars,
 ,* just to test the two ``NumberOfSymbolEntrys'' above !!!???
 ,* so, to test this, I reset ``NumberOfSymbolEntrys'' to 230, in assembler,
 ,* then the greatest index == 229,
 ,* then to test collision is to test rounding
 ,*)


:" Ac" string-hash->index . cr (* 229 *)
:" Ba" string-hash->index . cr (* 0 *)

:" Ac"
  string-hash->index index-hashback->string
printString

:" Ba"
  string-hash->index index-hashback->string
printString
#+end_src
* dynamic type system
** note
1. I make the following stipulations about creating cicada words:
   1) constants and variables are nouns,
      the first letter of them should be capitalized.
      (just as in Deutsch)
   2) functions are verbs,
      the first letter of them should be NOT capitalized.
   3) I use compoundWordByCamelCase
      when the word is about non-typed value.
      examples:
      Base printString printTypeTag defineFunction
   4) I use compound-word-with-dashes
      when the word is about typed value.
      examples:
      cons car cdr set-car! set-cdr! list-copy
   5) I use <this-kind-of-word>
      when the word is about type.
      examples:
      <pair> <pair-like>? <graph> <lambda> <fixnum> <type>
   6) I do not use compound_word_with_underscores
2. atom :
   TypedValue[valus, type tag]
3. non-atom :
   TypedValue[address, type tag]
4. this is really a flexible and dangerous way to use dynamic-type-value
5. this is dangerous,
   for you can meet semantic overload sometimes
   for example,
   True-Bool == [1, <bool>]
   True == 1
   that means you have two syntaxes to denote one semantic
   then, how should you implement ``if,else,then'' ???
   this is really not acceptable !!!
6. this is flexible,
   for you can easily define different kinds of <pair-like> values:
   1) <list>
   2) <alist> (associated-list)
   3) <dalin> (double-linked-list)
   4) <wodyli> (wodyli)
   5) <graph>
   6) and more
7. to implement gc
   one have to (and only have to)
   be able to distinguish <pair> and <non-pair>
8. every new data type implemented by <pair>
   have to be handled by gc as <pair>
9. I do not need type-inherit at all
   for I can easily convert one type to another
   say, I have <xxx-list>
   a function apply on <list> will not apply on <xxx-list>
   but if I use <xxx-list> as a list
   which every cdr is of type <list>
   only the first type is change from <list> to <xxx-list>
   then, when I want to treat this <xxx-list> as a <list>
   I just ``drop <list>''
** implementation
#+begin_src cicada :tangle ./core/english.ccd
(* if 1 is setted to a symbol, this symbol is a fixnum like data type
   if 2 is setted to a symbol, this symbol is a pair like data type *)

: defineDataType
  (* wordList[address, the number of words] -- *)
  dup2
    headOfWordList
    string-hash->index
    dup
      index->address One swap save
    xx|swap|x
  defineConst
  Exit
; defineFunction

: definePairLikeDataType
  (* wordList[address, the number of words] -- *)
  dup2
    headOfWordList
    string-hash->index
    dup
      index->address Two swap save
    xx|swap|x
  defineConst
  Exit
; defineFunction


(* every word can be used as a name of a data type
   the following are my convention *)

: <fixnum>    ; defineDataType
: <bool>      ; defineDataType
: <type>      ; defineDataType
: <char>      ; defineDataType
: <symbol>    ; defineDataType
: <substring> ; defineDataType
: <null>      ; defineDataType


: <fixnum-like>? (* type -- True or False *)
    index->address fetch One ==
    Exit
; defineFunction


0 : Null ; defineConst

: null Null <null> Exit ; defineFunction

: null? (* [value, type] -- True or False *)
  <null> == if
    Null == if
      True Exit
    then
    False Exit
  then
  drop False Exit
; defineFunction




: True-Bool  True  <bool> Exit ; defineFunction
: False-Bool False <bool> Exit ; defineFunction



: <pair>    ; definePairLikeDataType
: <string>  ; definePairLikeDataType
: <list>    ; definePairLikeDataType

: <dalin>   ; definePairLikeDataType

: <wody>           ; definePairLikeDataType
: <bound-variable> ; definePairLikeDataType
: <wodyli>         ; definePairLikeDataType


: <pair-like>? (* type -- True or False *)
    index->address fetch Two ==
    Exit
; defineFunction

: <not-pair-like>? (* type -- True or False *)
    index->address fetch Two =/=
    Exit
; defineFunction


: <dalin-like>? (* type -- True or False *)
  dup <dalin> == if
    drop True Exit
  then
  dup <wodyli> == if
    drop True Exit
  then
  drop False Exit
; defineFunction


: <not-dalin-like>? (* type -- True or False *)
  dup <dalin> == if
    drop False Exit
  then
  dup <wodyli> == if
    drop False Exit
  then
  drop True Exit
; defineFunction




:" an error occurs!
printTypeTag said:
   ``My function-type is (* type-tag[index of hash-table] -- *)
     The following index is not a type-tag
     I will not touch it and call debuger.''
   --> "
: String,printTypeTag,error ; defineConstString

: printTypeTag
  (* type-tag[index of hash-table] -- *)
  dup
  index->address fetch One == if
    index-hashback->string printString Exit
  then
  dup
  index->address fetch Two == if
    index-hashback->string printString Exit
  then
  String,printTypeTag,error printString
  writeDecNumber cr
  debuger Exit
; defineFunction


: eq? (* [value, type], [value, type] -- True or False *)
  x|over|xx =/= if
    drop drop2 False Exit
  then
  x|over|xx =/= if
    drop2 False Exit
  then
  drop2 True Exit
; defineFunction
#+end_src
* dictionary operations
** >< note
** implementation
#+begin_src cicada :tangle ./core/english.ccd
(*
 ,* a word in the dictionary [unit : CellWidth = 8 bytes]
 ,*   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 ,*   ||  m : name-string  ||
 ,*   ||  1 : SizeOfFunctionBody ||
 ,*   ||  1 : identification  ||
 ,*   ||  1 : link  ||
 ,*   ||  1 : type  ||
 ,*   ||  1 : address-of-name-string-header  ||
 ,*   ||  1 : address-of-explainer  ||
 ,*   ||  n : body  ||
 ,* where
 ,*   ||  1 : type  ||
 ,* ==
 ,*   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
 ,* type-bit-0 is for HiddenWord
 ,* type-bit-1 is for VariableOfTypedValue [DynamicVar]
 ,*)

: lastWordInTheDictionary? (* word[address of link] -- True or False *)
    zero? Exit
; defineFunction

: nextWordInTheDictionary
  (* word[address of link] -- next-word[address of link] *)
    fetch Exit
; defineFunction

: fetchWordType (* word[address of link] -- WordType *)
    add8 fetch
    Exit
; defineFunction

: saveWordType (* word[address of link], WordType -- *)
    swap add8 save
    Exit
; defineFunction


0 : offsetForHiddenWord          ; defineConst
1 : offsetForDynamicVariableWord ; defineConst

: dynamicVariableWord? (* word[address of link] -- True or False *)
    fetchWordType offsetForDynamicVariableWord fetchBit one?
    Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
: ~ (* word[address of link] -- word[address of link] *)
    dup dynamicVariableWord? .
    (* dup lastWordInTheDictionary? . *)
    nextWordInTheDictionary
  Exit
; defineFunction

FirstWordInDictionary fetch

~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~

#+end_src
* interface of LambdaStack & ready
** note
1. note that
   not to much stack-processing is needed here
2. LambdaStack can be used to save the faked-local-vars
3. instead of allocate this stack in assembly
   I can also use list-processing to implement it
** implementation
#+begin_src cicada :tangle ./core/english.ccd
LambdaStackTop : LambdaStackPointer ; defineVar

: pushLambdaStack
  (* ArgumtStack::  value -->
     LambdaStack::  value *)
  CellWidth LambdaStackPointer addSave
  LambdaStackPointer fetch save
  Exit
; defineFunction

: popLambdaStack
  (* LambdaStack::  value -->
     ArgumtStack::  value *)
  LambdaStackPointer fetch fetch
  CellWidth LambdaStackPointer subSave
  Exit
; defineFunction


: ready (* or twoPushLambdaStack *)
  (* ArgumtStack::  value-a, value-b -->
     LambdaStack::  value-a, value-b *)
  swap pushLambdaStack pushLambdaStack
  Exit
; defineFunction

: getBack (* or twoPopLambdaStack *)
  (* LambdaStack::  value-a, value-b -->
     ArgumtStack::  value-a, value-b *)
  popLambdaStack popLambdaStack swap
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
1 2 . . (* 2 1 *)
1 2 ready getBack . . (* 2 1 *)
#+end_src
* *incremental-gc* & <pair> & <string>
** note
1. this gc is a incremental-gc
   a marking-gc for pair
   a copy-gc for string
2. if StringHeap is used up
   before PairConstructionsArray is used up
   gc must be restart
   so StringHeap should be large to avoid this
3. there are two way to represent string now:
   1) [address, length]
   2) [address, <string>]
      in this one,
      there must be 4-bytes in address-4
      to save the length of the string
** dynamic-allocation of string
*** try,copy-substring,from->to
#+begin_src cicada :tangle ./core/english.ccd
(* example of a substring stored in StringHeap :
   || 4 : length of substring  ||
   || n : substring  ||
 ,*)

StringHeap1 : Variable,StringHeap,from ; defineVar
StringHeap2 : Variable,StringHeap,to   ; defineVar

StringHeap1 : CurrFreeStringAddress,from ; defineVar
StringHeap2 : CurrFreeStringAddress,to   ; defineVar

(*
 ,* little experiment:
 ,*   HexBase Base save
 ,*     10_10_00_00 fetchArgumtStackPointer
 ,*     dup
 ,*       1 swap saveByte
 ,*     dup
 ,*       1 swap add1 saveByte
 ,*     fetch .hex .hex
 ,*   DecBase Base save
 ,*)

: fetchFourBytes (* address -- value *)
  Zero fetchArgumtStackPointer
  x|over|xx swap
  Four copyByteString
  swap drop
  Exit
; defineFunction

: saveFourBytes (* value, address -- *)
  swap fetchArgumtStackPointer
  x|over|xx
  Four copyByteString
  drop2
  Exit
; defineFunction

(*
 ,* test:
 ,*   HexBase Base save
 ,*    10__10_10_00_00 fetchArgumtStackPointer
 ,*    dup
 ,*      1 swap saveByte
 ,*    dup
 ,*      1 swap add1 saveByte
 ,*    fetchFourBytes .hex .hex
 ,*    10__10_10_00_00 fetchArgumtStackPointer
 ,*    dup
 ,*      22_22_22_22 swap saveFourBytes
 ,*    fetchFourBytes .hex .hex
 ,*   DecBase Base save
 ,*)

: getLengthOfString (* string[address] -- length *)
  sub4 fetchFourBytes
  Exit
; defineFunction

: stringIn?StringHeap,from (* string[address] -- True or False *)
  Variable,StringHeap,from fetch
  over over
  SizeOfStringHeap +  <
  xx|swap|x  >=
  bitwiseAnd
  Exit
; defineFunction

: stringIn?StringHeap,to (* string[address] -- True or False *)
  Variable,StringHeap,to fetch
  over over
  SizeOfStringHeap +  <
  xx|swap|x  >=
  bitwiseAnd
  Exit
; defineFunction

: withLength,copyByteString
  (* source address, destination address, length -- *)
  dup x|over|xx saveFourBytes
  swap add4 swap
  copyByteString
  Exit
; defineFunction

: try,copy-substring,from->to
  (* [address, <substring>] -- [address, <substring>] *)
  (*
   ,* dup <substring> =/= if
   ,*   Exit
   ,* then
   ,*)
  over dup
  stringIn?StringHeap,to if
    drop Exit
  then
  CurrFreeStringAddress,to fetch
  over getLengthOfString
  withLength,copyByteString
  (* set return value *)
  CurrFreeStringAddress,to fetch add4
  |123->321|
  (* update CurrFreeStringAddress,to *)
  getLengthOfString add4
  CurrFreeStringAddress,to addSave
  Exit
; defineFunction

(* test: *)
(*
 ,* CurrFreeStringAddress,to fetch
 ,*   s" xxx " dup2 printString (\* xxx *\)
 ,*   drop <substring>
 ,*   try,copy-substring,from->to
 ,*   drop2
 ,* add4 dup
 ,* getLengthOfString
 ,* printString (\* xxx *\)
 ,*)


: try,copy-substring,from->to,forCar
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  over fetch2 (* this line is as car *)
  dup <substring> =/= if
    drop2 (* drop car *)
    Exit
  then
  try,copy-substring,from->to
  x|over|xxx save2 (* this line is as set-car! *)
  Exit
; defineFunction

: try,copy-substring,from->to,forCdr
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  over CarBytesSize + fetch2 (* this line is as cdr *)
  dup <substring> =/= if
    drop2 (* drop cdr *)
    Exit
  then
  try,copy-substring,from->to
  x|over|xxx CarBytesSize + save2 (* this line is as set-cdr! *)
  Exit
; defineFunction


(*
 ,* {* s" xxx" drop <substring>
 ,*    s" ppp" drop <substring> *}
 ,*
 ,* dup2
 ,*   car printTypeTag cr (\* <substring> *\)
 ,*   dup getLengthOfString
 ,*   printString cr (\* xxx *\)
 ,* dup2
 ,*   cdr printTypeTag cr (\* <substring> *\)
 ,*   dup getLengthOfString
 ,*   printString cr (\* ppp *\)
 ,*
 ,* dup2
 ,*   car drop .hex cr (\* >< *\)
 ,* dup2
 ,*   cdr drop .hex cr (\* >< *\)
 ,*
 ,* dup2
 ,*   try,copy-substring,from->to,forCar
 ,*   try,copy-substring,from->to,forCdr
 ,*
 ,* dup2
 ,*   car printTypeTag cr (\* <substring> *\)
 ,*   dup getLengthOfString
 ,*   printString cr (\* xxx *\)
 ,* dup2
 ,*   cdr printTypeTag cr (\* <substring> *\)
 ,*   dup getLengthOfString
 ,*   printString cr (\* ppp *\)
 ,*
 ,* (\* the two hex numbers must be different *\)
 ,* dup2
 ,*   car drop .hex cr (\* >< *\)
 * dup2
 *   cdr drop .hex cr (\* >< *\)
 *
 * drop2
 *)
#+end_src
*** readString
#+begin_src cicada :tangle ./core/english.ccd
: readNonStringEndingChar (* -- FirstNonBlankChar or Zero *)
  readChar
  dup '"' == if
    drop Zero
  then Exit
; defineFunction

: help,readString,loop (* begin-address -- end-address *)
  readNonStringEndingChar
  dup zero? if
    drop Exit
  then
  over saveByte
  add1
  help,readString,loop
  Exit
; defineRecursiveFunction

: readString (* -- string[address, length] *)
  CurrFreeStringAddress,from fetch add4
  dup (* leave begin-address *)
    help,readString,loop
  dup (* leave end-address *)
    CurrFreeStringAddress,from save
  over -
  dup (* return: length *)
  x|over|xx (* return: address *)
  sub4 saveFourBytes
  Exit
; defineFunction

: s" (* -- string[address, length] *)
  readString Exit
; defineFunction

(* test: *)
(* s" 123 xxx aaa !!! @@@ ###" printString *)
#+end_src
** gc & <pair> & <string>
*** notation
Lisp was originally implemented on the IBM 704 computer, in the late 1950s.
The 704 hardware had special support for
splitting a 36-bit machine word into four parts:
1. address part   : 15 bits
2. decrement part : 15 bits
3. prefix part    : 3 bits
4. tag part       : 3 bits
Precursors to Lisp included the following functions:
(The term "register" in the following context refers to "memory location")
1. car : Contents of the Address part of Register number
2. cdr : Contents of the Decrement part of Register number
3. cpr : Contents of the Prefix part of Register number
4. ctr : Contents of the Tag part of Register number
--------------------------------------------------------
in my cicada, for my PairConstruction
I introduce the following c*r functions:
(maybe more in the future, if needed)
1. clr : color byte
   for garbage-collection
2. car : contents of the address part of a PairConstruction
   as the first typed-value of a pair
3. cdr : contents of the decrement part of a PairConstruction
   as the second typed-value of a pair
*** the construction & clr, car, cdr
#+begin_src cicada :tangle ./core/english.ccd
(* the construction of pair : [unit : byte]
 ,* clr:
 ,*     ||  1 : color     ||
 ,* car:
 ,*     ||  8 : type tag  ||
 ,*     ||  8 : value     ||
 ,* cdr:
 ,*     ||  8 : type tag  ||
 ,*     ||  8 : value     ||
 ,*)

(* the following constants are defined in assembler:
 ,* ConsBytesSize == 33
 ,* ClrBytesSize  ==  1
 ,* CarBytesSize  == 16
 ,* CdrBytesSize  == 16
 ,*)

:" clr said:
   ``My function-type is (* [address, <pair-like>] -- color-byte *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,clr,type-error ; defineConstString
: clr (* [address, <pair-like>] -- color-byte *)
  dup <not-pair-like>? if
    String,clr,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  sub1 fetchByte Exit
; defineFunction


:" car said:
   ``My function-type is (* [address, <pair-like>] -- [value, type] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,car,type-error ; defineConstString
: car (* [address, <pair-like>] -- [value, type] *)
  dup <not-pair-like>? if
    String,car,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  fetch2 Exit
; defineFunction


:" cdr said:
   ``My function-type is (* [address, <pair-like>] -- [value, type] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,cdr,type-error ; defineConstString
: cdr (* [address, <pair-like>] -- [value, type] *)
  dup <not-pair-like>? if
    String,cdr,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  CarBytesSize + fetch2 Exit
; defineFunction
#+end_src
*** color & set-clr!
two colors is enough
a black pair in GreyPairStackTop is as a ``grey'' pair
a grey-pair denotes front of the spreading black sub-graph
these nodes maybe at the junction of black and white (maybe not)
#+begin_src cicada :tangle ./core/english.ccd
0 : White ; defineConst
1 : Black ; defineConst

(* set three offsets used by fetchByte, setBit, clearBit *)
0 : VariableColorOffsetForFinding  ; defineVar
1 : VariableColorOffsetForMarking  ; defineVar
2 : VariableColorOffsetForCleaning ; defineVar
: ColorOffsetForFinding  VariableColorOffsetForFinding  fetch Exit ; defineFunction
: ColorOffsetForMarking  VariableColorOffsetForMarking  fetch Exit ; defineFunction
: ColorOffsetForCleaning VariableColorOffsetForCleaning fetch Exit ; defineFunction

:" set-clr! said:
   ``My function-type is (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,set-clr!,type-error ; defineConstString
: set-clr! (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
  over dup  <not-pair-like>? if
    String,set-clr!,type-error printString
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  x|over|xx sub1 saveByte Exit
; defineFunction
#+end_src
*** marking
#+begin_src cicada :tangle ./core/english.ccd
: whiteColorForMarking? (* color-byte -- True or False *)
  ColorOffsetForMarking fetchBit White == Exit
; defineFunction

: blackColorForMarking? (* color-byte -- True or False *)
  ColorOffsetForMarking fetchBit Black == Exit
; defineFunction

: black-<pair>? (* [address, <pair-like>] -- True or False *)
  clr blackColorForMarking? Exit
; defineFunction


(* the following function is the only function who pushGreyPairStack
 ,* and this function is called by one,grey->black and so on *)
:" try,white->grey said:
   ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,try,white->grey,type-error ; defineConstString
: try,white->grey (* [address, <pair-like>] -- [address, <pair-like>] *)
  dup <not-pair-like>? if
    String,try,white->grey,type-error printString
    dup printTypeTag cr
    debuger
    Exit
  then
  dup2 clr
  dup
  whiteColorForMarking? if
    ColorOffsetForMarking setBit set-clr!

    try,copy-substring,from->to,forCar
    try,copy-substring,from->to,forCdr
    over pushGreyPairStack
    Exit
  then
  drop (* drop the color-byte *) Exit
; defineFunction


: one,try,grey->black (* -- *)
  emptyGreyPairStack? if
    Exit
  then
  popGreyPairStack dup
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
    CarBytesSize +
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
  Exit
; defineFunction


(* the following is a help-function of all,grey->black
 ,* the GreyPairStack must not be empty when it is called *)

: one,grey->black (* -- *)
  popGreyPairStack dup
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
    CarBytesSize +
    fetch2 dup <pair-like>? if
      try,white->grey
    then drop2
  Exit
; defineFunction

: all,grey->black (* -- *)
  emptyGreyPairStack? if
    Exit
  then
  one,grey->black
  all,grey->black Exit
; defineRecursiveFunction
#+end_src
*** set!, set-car!, set-cdr!
in cicada, to make the gc to be incremental
there are many strategies you can use
the following shows one of them
#+begin_src cicada :tangle ./core/english.ccd
: set!
  (* VarForTypedValue[address], [value, type] -- VarForTypedValue[address] *)
  dup <pair-like>? if
    all,grey->black (* to be incremental-gc is to call this function here *)
    try,white->grey
  then
  x|over|xx save2
  Exit
; defineFunction


: help,set-car!&set-cdr!,for-black-<pair>
  (* [valus, type] -- [valus, type] *)
  dup <pair-like>? if
    all,grey->black (* to be incremental-gc is to call this function here *)
    try,white->grey
  then
  Exit
; defineFunction


:" set-car! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car!,type-error ; defineConstString

: set-car!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    String,set-car!,type-error printString
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help,set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx save2
  Exit
; defineFunction


:" set-cdr! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,set-cdr!,type-error ; defineConstString

: set-cdr!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    String,set-cdr!,type-error printString
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help,set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx CarBytesSize + save2
  Exit
; defineFunction


(* ------------------------------------------------- *)


:" [cons,car]! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,[cons,car]!,type-error ; defineConstString

: [cons,car]!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    String,[cons,car]!,type-error printString
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help,set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx save2
  Exit
; defineFunction


:" [cons,cdr]! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,[cons,cdr]!,type-error ; defineConstString

: [cons,cdr]!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx dup  <not-pair-like>? if
    String,[cons,cdr]!,type-error printString
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help,set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx CarBytesSize + save2
  Exit
; defineFunction


(* ------------------------------------------------- *)


:" [car,cons]! said:
   ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
     If I view the first argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,[car,cons]!,type-error ; defineConstString

: [car,cons]!
  (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
  (* you can read this as ``car-cons-set'' *)
  dup <not-pair-like>? if
    String,[car,cons]!,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2 black-<pair>? if
    xx|swap|xx help,set-car!&set-cdr!,for-black-<pair> xx|swap|xx
  then
  xx|tuck|xx
  drop save2
  Exit
; defineFunction


:" [cdr,cons]! said:
   ``My function-type is (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
     If I view the first argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,[cdr,cons]!,type-error ; defineConstString

: [cdr,cons]!
  (* [value, type], [address, <pair-like>] -- [address, <pair-like>] *)
  (* you can read this as ``cdr-cons-set'' *)
  dup <not-pair-like>? if
    String,[cdr,cons]!,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2 black-<pair>? if
    xx|swap|xx help,set-car!&set-cdr!,for-black-<pair> xx|swap|xx
  then
  xx|tuck|xx
  drop CarBytesSize + save2
  Exit
; defineFunction
#+end_src
*** marking & define
define and set! are the interface of dynamic-typed-value
#+begin_src cicada :tangle ./core/english.ccd
(* recall
 ,* a word in the dictionary [unit : CellWidth = 8 bytes]
 ,*   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 ,*   ||  m : name-string  ||
 ,*   ||  1 : SizeOfFunctionBody  ||
 ,*   ||  1 : identification  ||
 ,*   ||  1 : link  ||
 ,*   ||  1 : type  ||
 ,*   ||  1 : address-of-name-string-header  ||
 ,*   ||  1 : address-of-explainer  ||
 ,*   ||  n : body  ||
 ,* where
 ,*   ||  1 : type  ||
 ,* ==
 ,*   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
 ,* type-bit-0 is for HiddenWord
 ,* type-bit-1 is for VariableOfTypedValue
 ,*)

: createWordHeaderForTypedValue
  (* string[address, length] -- word[address of link] *)
  Here fetch xx|swap|x (* address-of-name-string-header *)
  appendStringToHere
  Here fetch appendNumberToHere (* identification *)
  Here fetch (* leave the word[link] *)
  Zero appendNumberToHere (* link *)
  Two appendNumberToHere  (* type *)
  swap
  appendNumberToHere (* address-of-name-string-header *)
  Exit
; defineFunction

: define,byString
  (* [value, type], string[address, length] -- *)
  createWordHeaderForTypedValue
  VarExplainer appendNumberToHere
  xx|swap|x  (* leave wordHeader *)
  dup <pair-like>? if
    try,white->grey
  then
  appendNumberToHere appendNumberToHere
  addNewWordToDictionary
  Exit
; defineFunction

: define
  (* [value, type], wordList[address, the number of words] -- *)
  headOfWordList
  define,byString
  Exit
; defineFunction
#+end_src
*** finding & cons : constructor of <pair>
#+begin_src cicada :tangle ./core/english.ccd
(* the following functions are helping cons *)

: clearColorBitOfPairForCleaning (* pair[address] -- pair[address] *)
    <pair>
    dup2 clr
    ColorOffsetForCleaning clearBit
    set-clr!
    drop
    Exit
; defineFunction

: whiteColorForFinding? (* color-byte -- True or False *)
    ColorOffsetForFinding fetchBit White ==
    Exit
; defineFunction

: findNextFreePairConstruction
  (* pair[address] -- Zero or NextFreePairConstruction[address] *)
    dup LastPairConstruction == if
      drop Zero Exit
    then
    ConsBytesSize +
    clearColorBitOfPairForCleaning
    dup <pair> clr
    whiteColorForFinding? if
      Exit
    then
    findNextFreePairConstruction
    Exit
; defineRecursiveFunction



(* a cyclic permutation
 ,* of the two three period cyclic permutation
 ,* in the third-order permutation group
 VariableColorOffsetForFinding  --> VariableColorOffsetForCleaning
 VariableColorOffsetForMarking  --> VariableColorOffsetForFinding
 VariableColorOffsetForCleaning --> VariableColorOffsetForMarking
 ,*)
: resetColorOffsets (* -- *)
    VariableColorOffsetForFinding  fetch
    VariableColorOffsetForMarking  fetch
    VariableColorOffsetForCleaning fetch
    VariableColorOffsetForMarking  save
    VariableColorOffsetForFinding  save
    VariableColorOffsetForCleaning save
    Exit
; defineFunction


: dynamicVariableWordFor<pair-like>? (* word[address of link] -- True or False *)
    dup dynamicVariableWord? if
    wordLinkToWordExplainer execute fetch2
    swap drop
    <pair-like>?
    Exit
    then
    drop False Exit
; defineFunction

: help,pushAllRootNodeIntoGreyPairStack (* word[address of link] -- *)
    dup lastWordInTheDictionary? if
      drop Exit
    then
    dup dynamicVariableWordFor<pair-like>? if
    dup wordLinkToWordExplainer execute fetch2
    try,white->grey drop2
    then
    nextWordInTheDictionary
    help,pushAllRootNodeIntoGreyPairStack
    Exit
; defineRecursiveFunction

: pushAllRootNodeIntoGreyPairStack (* -- *)
    FirstWordInDictionary fetch
    help,pushAllRootNodeIntoGreyPairStack
    Exit
; defineFunction



(* the following function is not intrinsic
   but I have to use it this way *)

(* a value meet the following three conditions is an AddressOfPair
 ,*  (the following is infix notations)
 ,* 1. Value >= FirstPairConstruction
 ,* 2. Value <= LastPairConstruction
 ,* 3. [Value - FirstPairConstruction] mod ConsBytesSize == 0
 ,*)

: addressOfPair? (* value -- True or False *)
    dup FirstPairConstruction < if
      drop False Exit
    then
    dup LastPairConstruction > if
      drop False Exit
    then
    FirstPairConstruction - ConsBytesSize mod zero?
    Exit
; defineFunction



: help,allPairsInArgumtStack,try,white->grey
  (* address of a Cell in ArgumtStack -- *)
    dup ArgumtStackTop > if
      drop Exit
    then
    dup fetch addressOfPair? if
      dup fetch
      <pair> try,white->grey
      drop2
    then
    CellWidth +
    help,allPairsInArgumtStack,try,white->grey
    Exit
; defineRecursiveFunction
: allPairsInArgumtStack,try,white->grey (* -- *)
    fetchArgumtStackPointer
    help,allPairsInArgumtStack,try,white->grey
    Exit
; defineFunction


: help,allPairsInLambdaStack,try,white->grey
  (* address of a Cell in LambdaStack -- *)
    dup LambdaStackTop > if
      drop Exit
    then
    dup fetch addressOfPair? if
      dup fetch
      <pair> try,white->grey
      drop2
    then
    CellWidth +
    help,allPairsInLambdaStack,try,white->grey
    Exit
; defineRecursiveFunction
: allPairsInLambdaStack,try,white->grey (* -- *)
    LambdaStackPointer fetch
    help,allPairsInLambdaStack,try,white->grey
    Exit
; defineFunction



: resetVariablesAboutString (* -- *)
  CurrFreeStringAddress,to fetch CurrFreeStringAddress,from save
  Variable,StringHeap,from fetch CurrFreeStringAddress,to   save
  Variable,StringHeap,to   fetch Variable,StringHeap,from   save
  CurrFreeStringAddress,to fetch Variable,StringHeap,to     save
  Exit
; defineFunction


:"  :gc: "
: String,gc ; defineConstString

:" cons said: ``Memory for cons is used up! No value is returned!''"
: String,cons,MemoryIsUsedUp ; defineConstString

: cons (* -- [address, <pair>] *)
    CurrFreePairConstruction fetch <pair> (* leave the return <value> *)
    CurrFreePairConstruction fetch findNextFreePairConstruction
    dup notZero? (* Zero denotes fail to find *) if
      CurrFreePairConstruction save
      Exit
    then drop (* drop the Zero, which denotes fail to find, need gc *)
    allPairsInArgumtStack,try,white->grey
    all,grey->black
    resetColorOffsets resetVariablesAboutString (* note the timing to reset *)
    pushAllRootNodeIntoGreyPairStack
    InFrontOfTheFirstPairConstruction findNextFreePairConstruction
    dup notZero? if
      CurrFreePairConstruction save
      String,gc printString
      Exit
    then drop
    (* if after gc still fail to find, we know the memory is used up *)
    drop2
    String,cons,MemoryIsUsedUp printString cr
    debuger
    Exit
; defineFunction
#+end_src
*** substring & string : constructor of <substring> & <string>
#+begin_src cicada :tangle ./core/english.ccd
: read-string (* -- [address, <string>] *)
  cons drop (* drop <pair> *) <string>
  s" drop (* drop length *) <substring>
  set-car!
  null set-cdr!
  Exit
; defineFunction

: ::" (* -- [address, <string>] *)
  read-string Exit
; defineFunction


:" write-string said:
   ``My function-type is ( [address, <string>] -- ).
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,write-string,type-error ; defineConstString

: write-string (* [address, <string>] -- *)
  dup <string> =/= if
    String,write-string,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  car drop (* drop <substring> *)
  dup getLengthOfString printString
  Exit
; defineFunction

: substring (* length -- address *)
  (* allocate a substring of the given length *)
  CurrFreeStringAddress,from fetch add4 swap (* leave begin-address *)
  dup CurrFreeStringAddress,from fetch saveFourBytes
  Four + CurrFreeStringAddress,from addSave
  Exit
; defineFunction

: string (* length -- [address, <string>] *)
  (* allocate a string of the given length *)
  substring <substring>
  null
  cons drop <string>
  [cdr,cons]!
  [car,cons]!
  Exit
; defineFunction
#+end_src
*** about test
#+begin_src cicada :tangle ./core/english.ccd
(* for test *)
: printTypeOfIt (* type -- *)
  printTypeTag ':' writeChar writeSpace Exit
; defineFunction

(* test: gc *)
: ask-for-lots-of-cons (* n -- *)
    dup zero? if drop Exit
    then
    sub1
    cons
      literal 555 <fixnum> set-car!
      literal 666 <fixnum> set-cdr!
    drop2
    ask-for-lots-of-cons
    Exit
; defineRecursiveFunction

: ask-for-lots-of-cons,leave-them-on-the-ArgumtStack (* n -- *)
    dup zero? if drop Exit
    then
    sub1
    cons
      literal 555 <fixnum> set-car!
      literal 666 <fixnum> set-cdr!
    x|swap|xx
    ask-for-lots-of-cons,leave-them-on-the-ArgumtStack
    Exit
; defineRecursiveFunction
#+end_src
** test
#+begin_src cicada
: {* cons Exit ; defineFunction
: *} xx|swap|xxxx [cdr,cons]! [car,cons]! Exit ; defineFunction


(* test: define *)
6 <fixnum> : Liu-fixnum ; define
Liu-fixnum fetch2 printTypeOfIt . cr (* <fixnum>: 6 *)

(* test: cons *)
cons 9 <fixnum> set-car!
     8 <fixnum> set-cdr!
dup2
  car printTypeOfIt . cr (* <fixnum>: 9 *)
dup2
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
drop2

{* 9 <fixnum>  8 <fixnum> *}
dup2
  car printTypeOfIt . cr (* <fixnum>: 9 *)
dup2
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
drop2

(* test: cons *)
9 <fixnum>  8 <fixnum>  cons
[cdr,cons]! [car,cons]!
dup2
  car printTypeOfIt . cr (* <fixnum>: 9 *)
dup2
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
drop2


(* test: define a pair *)
cons 9 <fixnum> set-car!
     8 <fixnum> set-cdr!
: Simple-pair ; define
Simple-pair fetch2
dup2
  car printTypeOfIt . cr (* <fixnum>: 9 *)
dup2
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
drop2


(* test: set-car! & set-cdr! *)
Simple-pair fetch2
  {* 7 <fixnum>   6 <fixnum> *}
set-car!
dup2
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
dup2
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
drop2




Simple-pair fetch2
  {* 5 <fixnum>
     {* 4 <fixnum>  3 <fixnum> *} *}
set-cdr!

dup2
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
dup2
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
dup2
  cdr car printTypeOfIt . cr (* <fixnum>: 5 *)
dup2
  cdr cdr car printTypeOfIt . cr (* <fixnum>: 4 *)
dup2
  cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
drop2




(* test: all,grey->black *)
  emptyGreyPairStack? . cr (* 0 *)
  all,grey->black
  emptyGreyPairStack? . cr (* 1 *)


(* test: marking *)
  Simple-pair fetch2
  cdr cdr clr ColorOffsetForMarking fetchBit . cr (* 1 *)




all,grey->black


(* test: reset set-cdr! *)
Simple-pair fetch2
  {* 1 <fixnum>
     {* 2 <fixnum>  3 <fixnum> *} *}
set-cdr!

dup2
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
dup2
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)

dup2
  cdr car printTypeOfIt . cr (* <fixnum>: 1 *)
dup2
  cdr cdr car printTypeOfIt . cr (* <fixnum>: 2 *)
dup2
  cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
drop2



(* test: gc *)
: ask-for-lots-of-cons (* n -- *)
    dup zero? if drop Exit
    then
    sub1
    {* literal 555 <fixnum>
       literal 666 <fixnum> *}
    drop2
    ask-for-lots-of-cons
    Exit
; defineRecursiveFunction


NumberOfPairConstructions ask-for-lots-of-cons

NumberOfPairConstructions 30 * ask-for-lots-of-cons




(* after gc the Simple-pair must still be ok *)
Simple-pair fetch2

dup2
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
dup2
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
dup2
  cdr car printTypeOfIt . cr (* <fixnum>: 1 *)
dup2
  cdr cdr car printTypeOfIt . cr (* <fixnum>: 2 *)
dup2
  cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
drop2



(* ----------------------------------------------------------- *)
(* after gc the values in the stack must still be ok *)

{* {* 147 <fixnum>
      258 <fixnum> *}
   369 <fixnum> *}

NumberOfPairConstructions 30 * ask-for-lots-of-cons

dup2

cr
dup2
   car car printTypeOfIt . cr (* <fixnum>: 147 *)
dup2
   car cdr printTypeOfIt . cr (* <fixnum>: 258 *)
dup2
   cdr printTypeOfIt . cr (* <fixnum>: 369 *)
drop2
ok

NumberOfPairConstructions 30 * ask-for-lots-of-cons

cr
dup2
   car car printTypeOfIt . cr (* <fixnum>: 147 *)
dup2
   car cdr printTypeOfIt . cr (* <fixnum>: 258 *)
dup2
   cdr printTypeOfIt . cr (* <fixnum>: 369 *)
drop2
ok





(* ----------------------------------------------------------- *)
(* about string *)
(* after gc the values in the stack must still be ok *)


::" 111 "
NumberOfPairConstructions  ask-for-lots-of-cons
::" 222 "
NumberOfPairConstructions  ask-for-lots-of-cons
::" 333 "
NumberOfPairConstructions  ask-for-lots-of-cons
NumberOfPairConstructions  ask-for-lots-of-cons
cr ok

write-string write-string write-string (* 333 222 111 *)
cr


::" aaa "
: Simple-string ; define
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "
::" AAA "
::" AAA "
NumberOfPairConstructions 20 * ask-for-lots-of-cons
ok (* yse *)

Simple-string fetch2 write-string (* aaa *)

NumberOfPairConstructions  ask-for-lots-of-cons
write-string write-string write-string (* AAA AAA AAA *)
cr
NumberOfPairConstructions  ask-for-lots-of-cons
write-string write-string write-string (* AAA AAA AAA *)
cr





(* ----------------------------------------------------------- *)
(* about using up memory *)


(*
 ,* NumberOfPairConstructions
 ,* ask-for-lots-of-cons,leave-them-on-the-ArgumtStack
 ,*
 ,*
 ,* (\* in debugerREPL: *\)
 ,*   1 debuger,fetchFromReturnStack traceFunction
 ,*   2 debuger,fetchFromReturnStack traceFunction
 ,*
 ,* basicREPL countArgumtStack . cr (\* 0 *\)
 *)
#+end_src
* --------------------------------------------------
* about list-processing
** note
1. but the value you put into a list or a dalin
   should always be converted to dynamic-typed-value
   while they should always be read as simple as possible
2. I found out that to parse post-lambda expression easily
   we have to always use dalin
   so dalin should be the default-list used in cicada
3. so I have the following notations about list-processing :
   | { } | list   | single-linked-list |
   | [ ] | dalin  | double-linked-list |
   | ( ) | wodyli | wordy-list         |
4. if I define ``['' and ``{'' as readers
   then, as functions the have to call each other
   due to the semantic of cicada
   this calls can not be compiled into the function-bodys of them
   unless I introduce new syntaxes
** implementation
#+begin_src cicada :tangle ./core/english.ccd
:" {" : String,begining-list ; defineConstString
:" }" : String,ending-list   ; defineConstString

:" ." : String,dot           ; defineConstString

:" (esc" : String,begining-list-escape ; defineConstString
:" )"    : String,ending-list-escape   ; defineConstString

:" [" : String,begining-*dalin ; defineConstString
:" ]" : String,ending-*dalin   ; defineConstString

:" (" : String,begining-wodyli ; defineConstString
:" )" : String,ending-wodyli   ; defineConstString
#+end_src
* write
** implementation
#+begin_src cicada :tangle ./core/english.ccd
:" write-list"    : String,write-list   ; defineConstString
:" write-*dalin"  : String,write-*dalin ; defineConstString
:" write-wodyli"  : String,write-wodyli ; defineConstString
:" write-wody-or-bound-variable"
: String,write-wody-or-bound-variable ; defineConstString

:" null"  : String,null ; defineConstString

:" write said:
   ``I do not know how to write the following type of value,
     I will not touch it and call debuger.''
   --> "
: String,write,type-error ; defineConstString

: write (* [value, type] -- *)
  dup <fixnum> == if drop (* drop type-tag *)
    writeDecNumber  writeSpace
    Exit
  then
  dup <symbol> == if drop (* drop type-tag *)
    index-hashback->string printString  writeSpace
    Exit
  then
  dup <null> == if drop (* drop type-tag *)
    drop
    String,null printString writeSpace
    Exit
  then
  dup <list> == if
    String,write-list find wordLinkToWordExplainer execute
    Exit
  then
  dup <dalin> == if
    String,write-*dalin find wordLinkToWordExplainer execute
    Exit
  then
  dup <wody> ==
  over <bound-variable> ==
  bitwiseOr if
    String,write-wody-or-bound-variable find wordLinkToWordExplainer execute
    Exit
  then
  dup <wodyli> == if
    String,write-wodyli find wordLinkToWordExplainer execute
    Exit
  then
  String,write,type-error printString
  dup printTypeTag cr
  debuger Exit
; defineFunction
#+end_src
* read-list & write-list
** note
1. this is the old good lisp-like single-linked-list
2. like the language shen
   I do not use '() to quote a list (as in LISP)
   but use {} and []
   [ 1 (esc + 1 1 ) 3 ] or
   { 1 (esc + 1 1 ) 3 } as
   `(1 ,(+ 1 1) 3) in LISP
   because ``quote'' in LISP is just to provide you
   a convenient mechanism to read a list
3. the good about LISP's way is that
   you can quote a symbol out side the list as 'a-symbol
   otherwise the symbol will be treated as a variable
4. while in shen
   if one type ``a-symbol'' into the REPL
   it will be treated as a symbol
   you have to use a explicit way
   to treat it as a variable, i.e. ``(value a-symbol)''
5. in cicada things are very different
   no analogy should be drawed here
6. the ``list-escape'' is very interesting
   it is to call a another reader in a list-reader
   and get back to the list-reader when finished
   it looks like the classic forth REPL
   which have two modes
   at first in the implementation of cicada
   I try to avoid many modes in REPL
   but now the list-leader brings me back to the classic forth
** executeWord,for-list-reader
#+begin_src cicada :tangle ./core/english.ccd
: stringDenoteListReader?
  (* string[address, length] -- True or False *)
  dup2 String,begining-list equalString? if
    drop2 True Exit
  then
  dup2 String,begining-list-escape equalString? if
    drop2 True Exit
  then
  dup2 String,begining-*dalin equalString? if
    drop2 True Exit
  then
  dup2 String,begining-wodyli equalString? if
    drop2 True Exit
  then
  drop2 False Exit
; defineFunction

(* then we need mutually recursive call *)
: executeWord,for-list-reader
  (* string[address, length] -- [value, type] *)
  dup2 stringDenoteListReader? if
    find wordLinkToWordExplainer execute
    Exit
  then
  dup2 stringDenoteNumber? if
    number drop <fixnum>
    Exit
  then
  dup2 String,null equalString? if
    drop2 null
    Exit
  then
  string-hash->index <symbol>
  Exit
; defineFunction
#+end_src
** list-escape-REPL
#+begin_src cicada :tangle ./core/english.ccd
: list-escape-REPL
  (* could  be: unknown -- unknown *)
  (* should be:  -- [value, type] *)
  readWordForRuntime
  dup2
  stringDenoteNumber? if
    number drop
    list-escape-REPL
    Exit
  then
  dup2
  String,ending-list-escape equalString? if
    drop2
    Exit
  then
  find dup notZero? if
    wordLinkToWordExplainer execute
    list-escape-REPL
    Exit
  then
  drop
  printErrorInfoForExecuteWord
  list-escape-REPL
  Exit
; defineRecursiveFunction

: (esc list-escape-REPL Exit ; defineFunction
#+end_src
** read-list
#+begin_src cicada :tangle ./core/english.ccd
: read-list (* -- [address, <list>] *)
  readWord
  dup2 String,ending-list equalString? if
    drop2
    null Exit
  then
  dup2 String,dot equalString? if
    drop2
    read-list car
    (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
    Exit
  then
  executeWord,for-list-reader
  cons drop <list>
    xx|swap|xx  set-car!
    read-list   set-cdr!
  Exit
; defineRecursiveFunction

: { read-list Exit ; defineFunction
#+end_src
** write-list
#+begin_src cicada :tangle ./core/english.ccd
: help,write-list (* [address, <list>] or [Null, <null>] -- *)
  dup <null> == if
    drop2 Exit
  then
  dup <pair-like>? if
    dup2
    car write
    cdr help,write-list
    Exit
  then
  String,dot printString writeSpace
  write
  Exit
; defineRecursiveFunction


:" write-list said:
   ``My function-type is (* [address, <list>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: String,write-list,type-error ; defineConstString

: write-list (* [address, <list>] -- *)
  dup <list> =/= if
    String,write-list,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  String,begining-list printString writeSpace
  help,write-list
  String,ending-list printString writeSpace
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
{ 1
  { 1 2 3 4 5   { 1 2 3 4 5  6 }  6  }
    xxx 3 4 5
  { 1 2 3 4 5  6 } 6 }
write-list

{ 1 . 2 } write-list
{ 1 2 3 4 5 6 7 8 9 . 0 } write-list
{ 1 . { 1 . 2 } } write-list
{ 1 . { 1 . (esc 2 <fixnum> ) } } write-list
{ 1 . { 1 . (esc 2 <fixnum> ) } } write


(* beware of the following,
   error will not occurs ! *)

{ 1 . 2 3 }
write-list  (* { 1 . 2 } *)

{ 1 . 2 { 1 . 2 3 } }
write-list  (* { 1 . 2 } *)


(* test: mutually recursive call *)
{ 1 [ 1 2 3 ] { 1 . (esc 2 <fixnum> ) } } write
{ 1 [ 1 2 3 ] . { 1 . (esc 2 <fixnum> ) } } write
#+end_src
* set-*!
** >< note
the name of the following functions should be changed
** implementation
#+begin_src cicada :tangle ./core/english.ccd
:" set-car-to-{car}! said:
   ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car-to-{car}!,type-error ; defineConstString
(* [car.cdr]->[[car].cdr] *)
: set-car-to-{car}!
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  dup <not-pair-like>? if
    String,set-car-to-{car}!,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2
  car cons
    xx|swap|xx set-car!
    null set-cdr!
  set-car!
  Exit
; defineFunction


:" set-car-to-{cdr}! said:
   ``My function-type is (* [address, <pair-like>] -- [address, <pair-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car-to-{cdr}!,type-error ; defineConstString
(* [car.cdr]->[car.[cdr]] *)
: set-cdr-to-{cdr}!
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  dup <not-pair-like>? if
    String,set-car-to-{cdr}!,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2
  cdr cons
    xx|swap|xx set-car!
    null set-cdr!
  set-cdr!
  Exit
; defineFunction




:" set-car-to-{car.x}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car-to-{car.x}!,type-error ; defineConstString

: set-car-to-{car.x}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    String,set-car-to-{car.x}!,type-error printString
    x|over|xx printTypeTag cr
    debuger Exit
  then
  xx|over|xx
  car cons
    xx|swap|xx set-car!
    xx|swap|xx set-cdr!
  set-car!
  Exit
; defineFunction


:" set-car-to-{cdr.x}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car-to-{cdr.x}!,type-error ; defineConstString

(* [car.cdr],x->[car.[cdr.x]]! *)
: set-cdr-to-{cdr.x}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    String,set-car-to-{cdr.x}!,type-error printString
    x|over|xx printTypeTag cr
    debuger Exit
  then
  xx|over|xx
  cdr cons
    xx|swap|xx set-car!
    xx|swap|xx set-cdr!
  set-cdr!
  Exit
; defineFunction


:" set-car-to-{x.car}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car-to-{x.car}!,type-error ; defineConstString

: set-car-to-{x.car}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    String,set-car-to-{x.car}!,type-error printString
    x|over|xx printTypeTag cr
    debuger Exit
  then
  xx|over|xx
  car cons
    xx|swap|xx set-cdr!
    xx|swap|xx set-car!
  set-car!
  Exit
; defineFunction


:" set-car-to-{x.cdr}! said:
   ``My function-type is
    (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
     If I view the second argument as a type-tag,
     It will be the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car-to-{x.cdr}!,type-error ; defineConstString

: set-cdr-to-{x.cdr}!
  (* [address, <pair-like>], [value, type] -- [address, <pair-like>] *)
  x|over|xx <not-pair-like>? if
    String,set-car-to-{x.cdr}!,type-error printString
    x|over|xx printTypeTag cr
    debuger Exit
  then
  xx|over|xx
  cdr cons
    xx|swap|xx set-cdr!
    xx|swap|xx set-car!
  set-cdr!
  Exit
; defineFunction
#+end_src
* dalin processing
** <- & ->
#+begin_src cicada :tangle ./core/english.ccd
:" <- said:
   ``My function-type is (* [address, <dalin-like>] -- [address, <dalin>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,<-,type-error ; defineConstString

: <- (* [address, <dalin-like>] -- [address, <dalin>] *)
  dup <not-dalin-like>? if
    String,<-,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  cdr car Exit
; defineFunction


:" -> said:
   ``My function-type is (* [address, <dalin-like>] -- [address, <dalin>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,->,type-error ; defineConstString

: -> (* [address, <dalin-like>] -- [address, <dalin>] *)
  dup <not-dalin-like>? if
    String,->,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  cdr cdr Exit
; defineFunction
#+end_src
** list->dalin
#+begin_src cicada :tangle ./core/english.ccd
(* note that:
   in the following, I am using side-effect to change a existed list
   but NOT to form a new dalin from scratch *)

: help,list->dalin
  (* [address, <dalin>], left[address, <dalin>] -- [address, <dalin>] *)
  (* or *)
  (* [address, <dalin>], [value, <non-dalin>] -- [address, <dalin>] *)
  set-cdr-to-{x.cdr}! (* set the ``left'' *)
  dup2 cdr
    dup2 cdr <not-pair-like>? if
      drop (* drop the non-pair-value *)
      null set-cdr!
      (* this means the 3 in { 1 2 . 3 } will be droped *)
      drop2 Exit
    then
    (* change the type-tag of the cdr of the old list, from <list> to <dalin> *)
    (* the pair-like-value is still here *) <dalin> set-cdr!
    cdr
  (* [address, <dalin>], [address, <pair-like>] *)
  xx|swap|xx
  help,list->dalin
  Exit
; defineRecursiveFunction


:" list->*dalin* said:
   ``My function-type is
     (* [address, <list>] -- head[address, <dalin>], tail[address, <dalin>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,list->*dalin*,type-error ; defineConstString

: list->*dalin*
  (* [address, <list>] -- head[address, <dalin>], tail[address, <dalin>] *)
  dup <list> =/= if
    String,list->*dalin*,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop <dalin>
  dup2 (* leave the return value *)
  null
  help,list->dalin
  Exit
; defineFunction


:" list->dalin* said:
   ``My function-type is (* [address, <list>] -- tail[address, <dalin>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,list->dalin*,type-error ; defineConstString

: list->dalin*
  (* [address, <list>] -- tail[address, <dalin>] *)
  dup <list> =/= if
    String,list->dalin*,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop <dalin>
  null
  help,list->dalin
  Exit
; defineFunction


:" list->*dalin said:
   ``My function-type is (* [address, <list>] -- head[address, <dalin>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,list->*dalin,type-error ; defineConstString

: list->*dalin
  (* [address, <list>] -- head[address, <dalin>] *)
  dup <list> =/= if
    String,list->*dalin,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop <dalin>
  dup2 (* leave the return value *)
  null
  help,list->dalin
  drop2
  Exit
; defineFunction
#+end_src
** *dalin? & dalin*?
#+begin_src cicada :tangle ./core/english.ccd
: *dalin? (* [address, <dalin>] -- True or False *)
  <- null? if
    True Exit
  then
  False Exit
; defineFunction

: dalin*? (* [address, <dalin>] -- True or False *)
  -> null? if
    True Exit
  then
  False Exit
; defineFunction
#+end_src
** nested-list->dalin
#+begin_src cicada :tangle ./core/english.ccd
: help,nested-list->dalin
  (* [address, <dalin>], left[address, <dalin>] -- [address, <dalin>] *)
  (* or *)
  (* [address, <dalin>], [value, <non-dalin>] -- [address, <dalin>] *)
  set-cdr-to-{x.cdr}! (* set the ``left'' *)
  dup2 car dup <list> == if
    list->*dalin set-car!
  else
    drop2
  then
  dup2 cdr
    dup2 cdr <not-pair-like>? if
      drop (* drop the non-pair-value *)
      null set-cdr!
      (* this means the 3 in { 1 2 . 3 } will be droped *)
      drop2 Exit
    then
    (* change the type-tag of the cdr of the old list, from <list> to <dalin> *)
    (* the pair-like-value is still here *) <dalin> set-cdr!
    cdr
  (* [address, <dalin>], [address, <pair-like>] *)
  xx|swap|xx
  help,nested-list->dalin
  Exit
; defineRecursiveFunction


:" nested-list->*dalin said:
   ``My function-type is (* [address, <list>] -- head[address, <dalin>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,nested-list->*dalin,type-error ; defineConstString

: nested-list->*dalin
  (* [address, <list>] -- head[address, <dalin>] *)
  dup <list> =/= if
    String,nested-list->*dalin,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop <dalin>
  dup2 (* leave the return value *)
  null
  help,nested-list->dalin
  drop2
  Exit
; defineFunction
#+end_src
** dalin->tail & head<-dalin
#+begin_src cicada :tangle ./core/english.ccd
:" dalin->tail said:
   ``My function-type is
     (* [address, <dalin-like>] -- tail[address, <dalin-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,dalin->tail,type-error ; defineConstString

: dalin->tail
  (* [address, <dalin-like>] -- tail[address, <dalin-like>] *)
  dup <not-dalin-like>? if
    String,dalin->tail,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2 dalin*? if
    Exit
  then
  ->  dalin->tail
  Exit
; defineRecursiveFunction


:" head<-dalin said:
   ``My function-type is
     (* [address, <dalin-like>] -- head[address, <dalin-like>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,head<-dalin,type-error ; defineConstString

: head<-dalin
  (* [address, <dalin-like>] -- head[address, <dalin-like>] *)
  dup <not-dalin-like>? if
    String,head<-dalin,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2 *dalin? if
    Exit
  then
  <-  head<-dalin
  Exit
; defineRecursiveFunction
#+end_src
** [value,dalin]-associate & [value,dalin]-member?
#+begin_src cicada :tangle ./core/english.ccd
:" [value,dalin]-associate said:
   ``My function-type is
     (* [value, type], head[address, <dalin-like>] --
        associate-pair[address, <pair-like>] or [Null, <null>] *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,[value,dalin]-associate,type-error,at-first
; defineConstString

:" [value,dalin]-associate said:
   ``My function-type is
     (* [value, type], head[address, <dalin-like>] --
        associate-pair[address, <pair-like>] or [Null, <null>] *)
     But in the middle of recursion
     I found the dalin is not an associated-dalin
     the following is what I found
     I will not touch it and call debuger''
   --> "
: String,[value,dalin]-associate,type-error,in-the-middle
; defineConstString

: help,[value,dalin]-associate
  (* [value, type], head[address, <dalin-like>], or [Null, <null>] --
     associate-pair[address, <pair-like>] or [Null, <null>] *)
  dup <null> == if
    (* if associate fail, return null *)
    xx|swap|xx drop2 Exit
  then
  dup2
  car dup <not-pair-like>? if
    String,[value,dalin]-associate,type-error,in-the-middle printString
    dup printTypeTag cr
    debuger Exit
  then
  car
  (* [value, type], head[address, <dalin-like>], car-car[value, type] *)
  xx|over|xxxx eq? if
    xx|swap|xx drop2
    car Exit
  then
  ->  help,[value,dalin]-associate
  Exit
; defineRecursiveFunction

: [value,dalin]-associate
  (* [value, type], head[address, <dalin-like>] --
     associate-pair[address, <pair-like>] or [Null, <null>] *)
  dup <not-dalin-like>? if
    String,[value,dalin]-associate,type-error,at-first printString
    dup printTypeTag cr
    debuger Exit
  then
  help,[value,dalin]-associate
  Exit
; defineFunction



: [value,dalin]-member?
  (* [value, type], [address, <dalin-like>] -- True or False *)
  dup <null> == if
    drop2 drop2 False Exit
  then
  dup2 car
  xx|over|xxxx eq? if
    drop2 drop2 True Exit
  then
  ->  [value,dalin]-member?
  Exit
; defineRecursiveFunction
#+end_src
** ^_^
the following function is very important
it for dalin is as the ``cons'' for list
but also really different
#+begin_src cicada :tangle ./core/english.ccd
:" ^_^ said:
   ``My function-type is
     (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
         rigth[address, <dalin-like>] *)
     If I view the 1st argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,^_^,1st-type-error ; defineConstString

:" ^_^ said:
   ``My function-type is
     (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
         rigth[address, <dalin-like>] *)
     If I view the 3rd argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,^_^,3rd-type-error ; defineConstString


(* the following ``little-smile-face'' is ``link-dalin'' *)
: ^_^
  (*  left[address, <dalin-like>], rigth[address, <dalin-like>] --
     rigth[address, <dalin-like>] *)
  (* where: left[address, <dalin-like>] could be a null *)
  dup <not-dalin-like>? if
    String,^_^,1st-type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  x|over|xx <null> == if
    xx|tuck|xx (* leave the return value *)
    cdr xx|over|xx set-car! drop2
    drop2
    Exit
  then
  x|over|xx <not-dalin-like>? if
    String,^_^,3rd-type-error printString
    x|over|xx printTypeTag cr
    debuger Exit
  then
  xx|tuck|xx (* leave the return value *)
  cdr xx|over|xx set-car! drop2
  cdr xx|over|xx set-cdr! drop2
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
cr

{ 1 2 3 } list->*dalin*
dup printTypeTag (* <dalin> *) cr


(* test: tail[address, <dalin>] *) cr
dup2
  ,*dalin? . (* 0 *) cr
dup2
  dalin*? . (* 1 *) cr
dup2
  car printTypeTag writeSpace . (* <fixnum> 3 *) cr
dup2
  ->
  printTypeTag writeSpace . (* <null> 0 *) cr
dup2
  <-
  car printTypeTag writeSpace . (* <fixnum> 2 *) cr
dup2
  <-
  <-
  car printTypeTag writeSpace . (* <fixnum> 1 *) cr
dup2
  <-
  <-
  ->
  car printTypeTag writeSpace . (* <fixnum> 2 *) cr
drop2


(* test: head[address, <dalin>] *) cr
dup2
  ,*dalin? . (* 1 *) cr
dup2
  dalin*? . (* 0 *) cr
dup2
  car printTypeTag writeSpace . (* <fixnum> 1 *) cr
dup2
  <-
  printTypeTag writeSpace . (* <null> 0 *) cr
dup2
  ->
  car printTypeTag writeSpace . (* <fixnum> 2 *) cr
dup2
  ->
  ->
  car printTypeTag writeSpace . (* <fixnum> 3 *) cr
dup2
  ->
  ->
  <-
  car printTypeTag writeSpace . (* <fixnum> 2 *) cr
dup2
  ->
  ->
  <-
  <-
  car printTypeTag writeSpace . (* <fixnum> 1 *) cr
drop2


(* ----------------------------------------------------- *)

(* test: nested-list *) cr
{ 1 { 2 3 } 4 } nested-list->*dalin
dup printTypeTag (* <dalin> *) cr


(* test: head[address, <dalin>] *) cr
dup2
  ,*dalin? . (* 1 *) cr
dup2
  dalin*? . (* 0 *) cr
dup2
  car printTypeTag writeSpace . (* <fixnum> 1 *) cr
dup2
  <-
  printTypeTag writeSpace . (* <null> 0 *) cr

dup2
  ->
  ->
  car printTypeTag writeSpace . (* <fixnum> 4 *) cr

dup2
  ->
  ->
  <-
  <-
  car printTypeTag writeSpace . (* <fixnum> 1 *) cr

dup2
  ->
  car
  dup printTypeTag (* <dalin> *) cr
  dup2
    ,*dalin? . (* 1 *) cr
  dup2
    car printTypeTag writeSpace . (* <fixnum> 2 *) cr
  dup2
    <-
    printTypeTag writeSpace . (* <null> 0 *) cr
  dup2
    ->
    car printTypeTag writeSpace . (* <fixnum> 3 *) cr
  dup2
    ->
    <-
    ->
    car printTypeTag writeSpace . (* <fixnum> 3 *) cr

drop2



(* ----------------------------------------------- *)
(* the following test must be done after read-*dalin *)
(* test: [value,dalin]-associate *)
2 <fixnum>
[ { 1 . a } { 2 . b } { 3 . b } ]
[value,dalin]-associate
  dup printTypeTag (* <list> *) cr
  car  printTypeTag (* <fixnum> *) cr
  writeDecNumber (* 2 *) cr

(* the following test must be done in symbolREPL *)
::x
[ { 1 . a } { ::x . xxx } { 3 . b } ]
[value,dalin]-associate
  cdr write (* xxx *)
#+end_src
* read-dalin & write-dalin
** read-*dalin
#+begin_src cicada :tangle ./core/english.ccd
: help,read-*dalin
  (* tail[address, <dalin>] -- head[address, <dalin>] *)
  (* where:
       the <- of ``tail'' is setted,
       need to set the -> of ``tail'' *)
  readWord
  dup2 String,ending-*dalin equalString? if
    drop2
    dup <null> == if
      Exit (* so [ ] null will be read as null *)
    then
    dup2
      cdr
        null  set-cdr!
      drop2
    head<-dalin
    Exit
  then
  executeWord,for-list-reader
  cons drop <dalin>
    xx|swap|xx  set-car!
    cons        set-cdr!
  ^_^
  help,read-*dalin
  Exit
; defineRecursiveFunction


: read-*dalin (* -- head[address, <dalin>] *)
  null
  help,read-*dalin
  Exit
; defineFunction

: [ read-*dalin Exit ; defineFunction
#+end_src
** write-*dalin
#+begin_src cicada :tangle ./core/english.ccd
: help,write-*dalin
  (* [address, <dalin>] -- *)
  dup2 dalin*? if
    car write Exit
  then
  dup2
    car write
  -> help,write-*dalin Exit
; defineRecursiveFunction


:" write-*dalin said:
   ``My function-type is (* [address, <dalin>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: String,write-*dalin,type-error ; defineConstString

: write-*dalin (* [address, <dalin>] -- *)
  dup <dalin> =/= if
    String,write-*dalin,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  String,begining-*dalin printString writeSpace
  help,write-*dalin
  String,ending-*dalin printString writeSpace
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
[ ] printTypeTag (* <null> *) cr
writeDecNumber (* 0 *) cr

[ 1 ] write-*dalin

[ 1 2 3 4 5 6 7 8 9 0 ] write-*dalin

[ 1
  [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
    xxx 3 4 5
  [ 1 2 3 4 5  6 ] 6 ]
write-*dalin

[ 1
  [ 1 2 3 4 5   [ 1 2 3 4 5  6 ]  6  ]
    xxx 3 4 5
  { a b c }
  [ 1 2 3 4 5  6 ] 6 ]
write-*dalin

[ a [ a b c ]
  b [ a b c ]
  c [ a b c
        [ a [ a b c ] [ a b c ] lambda
          b [ a b c ]
          c [ a b c ] ] ] ]
write-*dalin

[ [ a b c ] a b c ]
write-*dalin

[ [ [ [ :x ] ] ] ]
write-*dalin

[ [ [ :x ] ]
  [ [ :x ] ] ]
write-*dalin

[ [ [ [ :x ] ] ]
  [ [ [ :x ] ] ] ]
write-*dalin

[ [ [ [ :x :x @ ] :x :x @ ] lambda :y @ ]
  [ [ :x :x @ ] lambda :y @ ] ]
write-*dalin

[ 1 { 2 . 3 } 4 ]
dup2 write
-> car
dup printTypeTag (* <list> *) cr
car printTypeTag (* <fixnum> *) cr
writeDecNumber (* 2 *) cr
#+end_src
* stack & list & dalin
** note
it is hard to convert a list of value in the ArgumtStack
say, [1, 2, 3], to a real list { 3 2 1 }
for during recursive calls
there will be lots ``cons'' leaved in the ArgumtStack
or:
1. you convert [1, 2, 3] to { 1 2 3 }
2. you use LambdaStack for help
3. you use dalin but not list
------------------------------------------
I implement the following:
1. FIAF denotes first in at first
2. LIAF denotes last in at first
   LIAF version uses the LambdaStack
   which is very funny
** stack->list
#+begin_src cicada :tangle ./core/english.ccd
: help,stack-LIAF->list
  (* ..., number --  *)
  (* LambdaStack::
     [address, <list>] -- *)
  dup zero? if
    drop (* drop Zero *)
    getBack null set-cdr!
    drop2 Exit
  then
  sub1
  swap <fixnum>  cons drop <list>  [car,cons]!
  dup2
    getBack [cdr,cons]! drop2
  ready
  help,stack-LIAF->list
  Exit
; defineRecursiveFunction

: stack-LIAF->list
  (* ..., number -- [address, <list>] *)
  dup zero? if
    drop null Exit
  then
  sub1
  swap <fixnum>  cons drop <list>  [car,cons]!
  dup2 ready (* leave the return *)
  ready
    help,stack-LIAF->list
  getBack Exit
; defineFunction


: help,stack-FIAF->list
  (* ..., number -- *)
  (* LambdaStack::
     [address, <list>] -- [address, <list>] *)
  dup zero? if
    drop (* drop Zero *)
    Exit
  then
  sub1
  swap <fixnum>  cons drop <list>  [car,cons]!
  getBack [cons,cdr]! ready
  help,stack-FIAF->list
  Exit
; defineRecursiveFunction

: stack-FIAF->list
  (* ..., number -- [address, <list>] *)
  dup zero? if
    drop null Exit
  then
  null
  ready
    help,stack-FIAF->list
  getBack
  Exit
; defineFunction
#+end_src
** stack->dalin
#+begin_src cicada :tangle ./core/english.ccd
: help,stack-LIAF->dalin
  (* ..., number -- [address, <list>] *)
  (* LambdaStack::
     [address, <list>] -- *)
  dup zero? if
    drop (* drop Zero *)
    getBack
    dup2 cdr
    null set-cdr!
    drop2
    head<-dalin
    Exit
  then
  sub1
  swap <fixnum>  cons drop <dalin>  [car,cons]!
  cons  [cons,cdr]!
  getBack
    xx|swap|xx ^_^
  ready
  help,stack-LIAF->dalin
  Exit
; defineRecursiveFunction

: stack-LIAF->dalin
  (* ..., number -- [address, <dalin>] *)
  dup zero? if
    drop null Exit
  then
  null
  ready
  help,stack-LIAF->dalin
  Exit
; defineFunction


: help,stack-FIAF->dalin
  (* ..., number -- [address, <list>] *)
  (* LambdaStack::
     [address, <list>] -- *)
  dup zero? if
    drop (* drop Zero *)
    getBack
    dup2 cdr
    null set-car!
    drop2 Exit
  then
  sub1
  swap <fixnum>  cons drop <dalin>  [car,cons]!
  cons  [cons,cdr]!
  getBack
    ^_^ <-
  ready
  help,stack-FIAF->dalin
  Exit
; defineRecursiveFunction

: stack-FIAF->dalin
  (* ..., number -- [address, <dalin>] *)
  (* ..., number -- [address, <dalin>] *)
  dup zero? if
    drop null Exit
  then
  sub1
  swap <fixnum>  cons drop <dalin>
  [car,cons]!
    null set-cdr-to-{cdr.x}!
  ready
  help,stack-FIAF->dalin
  Exit
; defineFunction
#+end_src
** list->stack
#+begin_src cicada :tangle ./core/english.ccd
:" stack<-FIAF-list said:
   ``My function type is (* [address, <list>] -- ... *)
     the list should be a list of <not-pair-like> value
     But in the middle of recursion
     the following is what I found
     I will not touch it and call debuger''
   --> "
: String,stack<-FIAF-list,error ; defineConstString

:" stack<-FIAF-list said:
   ``My function type is (* [address, <list>] -- ... *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,stack<-FIAF-list,type-error ; defineConstString

: help,stack<-FIAF-list
  (* -- ... *)
  (* LambdaStack::
     [address, <list>] -- *)
  getBack
  dup <null> == if
    drop2 Exit
  then
  dup2
    cdr ready
  car
  dup <pair-like>? if
    String,stack<-FIAF-list,error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop a <not-pair-like> type-tag *)
  (* leave the value of the [value, <not-pair-like>] *)
  help,stack<-FIAF-list
  Exit
; defineRecursiveFunction

: stack<-FIAF-list
  (* [address, <list>] -- ... *)
  dup <list> =/= if
    String,stack<-FIAF-list,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  ready
  help,stack<-FIAF-list
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
cr
666
  1 2 3 4 5 6 7 8 9 0
  10 stack-LIAF->list write (* { 0 9 8 7 6 5 4 3 2 1 } *) cr
. (* 666 *) cr
1  1 stack-LIAF->list write (* { 1 } *) cr
cr

666
  1 2 3 4 5 6 7 8 9 0
  10 stack-FIAF->list write (* { 1 2 3 4 5 6 7 8 9 0 } *) cr
. (* 666 *) cr
1  1 stack-FIAF->list write (* { 1 } *) cr
cr

666
  1 2 3 4 5 6 7 8 9 0
  10 stack-LIAF->dalin write (* [ 0 9 8 7 6 5 4 3 2 1 ] *) cr
. (* 666 *) cr
1  1 stack-LIAF->dalin write (* [ 1 ] *) cr
cr

666
  1 2 3 4 5 6 7 8 9 0
  10 stack-FIAF->dalin write (* [ 1 2 3 4 5 6 7 8 9 0 ] *) cr
. (* 666 *) cr
1  1 stack-FIAF->dalin write (* [ 1 ] *) cr
cr

666 { 1 } stack<-FIAF-list
 . (* 1 *) . (* 666 *) cr
666 { 1 2 3 4 } stack<-FIAF-list
 . . . . (* 4 3 2 1 *) . (* 666 *) cr
cr
#+end_src
* symbol types
** helper funciton
#+begin_src cicada :tangle ./core/english.ccd
: charDenoteNumberOrAlphabetOrOutOfAscii?
  (* char -- True of False *)
  dup literal 48 < if     drop False Exit
  then
  dup literal 57 <= if    drop True Exit
  then
  dup literal 65 < if     drop False Exit
  then
  dup literal 90 <= if    drop True Exit
  then
  dup literal 97 < if     drop False Exit
  then
  dup literal 122 <= if   drop True Exit
  then
  dup literal 128 < if    drop False Exit
  then
  drop True Exit
; defineFunction
#+end_src
** BoundVariable
#+begin_src cicada :tangle ./core/english.ccd
(* `:' followed by a number or alphabet is a symbolDenoteBoundVariable
   ascii: 48 -- 57, 65 -- 90, 97 -- 122, 128 -- ...
   this set maybe change in the future *)

: stringDenoteBoundVariableOne?
  (* [address, length] -- True or False *)
  tailAndHeadOfString
  ':' =/= if
    drop2 False (* Exit *)
  else
    dup Zero == if
      drop2 False (* Exit *)
    else
      tailAndHeadOfString
      charDenoteNumberOrAlphabetOrOutOfAscii? if
        drop2 True (* Exit *)
      else
        drop2 False (* Exit *)
      then
    then
  then
  Exit
; defineFunction

:" an error occurs!
symbolDenoteBoundVariableOne? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteBoundVariableOne?,type-error ; defineConstString
: symbolDenoteBoundVariableOne?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteBoundVariableOne?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteBoundVariableOne?
  Exit
; defineFunction



: stringDenoteBoundVariableTwo?
  (* [address, length] -- True or False *)
  dup Two <= if
    drop2 False Exit
  then
  tailAndHeadOfString ':' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableOne? Exit
  Exit
; defineFunction

:" an error occurs!
symbolDenoteBoundVariableTwo? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteBoundVariableTwo?,type-error ; defineConstString
: symbolDenoteBoundVariableTwo?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteBoundVariableTwo?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteBoundVariableTwo?
  Exit
; defineFunction




: stringDenoteBoundVariableThree?
  (* [address, length] -- True or False *)
  dup Three <= if
    drop2 False Exit
  then
  tailAndHeadOfString ':' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableTwo? Exit
  Exit
; defineFunction

:" an error occurs!
symbolDenoteBoundVariableThree? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteBoundVariableThree?,type-error ; defineConstString
: symbolDenoteBoundVariableThree?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteBoundVariableThree?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteBoundVariableThree?
  Exit
; defineFunction



: stringDenoteBoundVariableFour?
  (* [address, length] -- True or False *)
  dup Four <= if
    drop2 False Exit
  then
  tailAndHeadOfString ':' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableThree? Exit
  Exit
; defineFunction

:" an error occurs!
symbolDenoteBoundVariableFour? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteBoundVariableFour?,type-error ; defineConstString
: symbolDenoteBoundVariableFour?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteBoundVariableFour?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteBoundVariableFour?
  Exit
; defineFunction




: stringDenoteBoundVariable?
  (* [address, length] -- True or False *)
  dup2 stringDenoteBoundVariableOne? if
    drop2 True Exit
  then
  dup2 stringDenoteBoundVariableTwo? if
    drop2 True Exit
  then
  dup2 stringDenoteBoundVariableThree? if
    drop2 True Exit
  then
  dup2 stringDenoteBoundVariableFour? if
    drop2 True Exit
  then
  drop2 False Exit
; defineFunction

:" an error occurs!
symbolDenoteBoundVariable? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteBoundVariable?,type-error ; defineConstString
: symbolDenoteBoundVariable?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteBoundVariable?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteBoundVariable?
  Exit
; defineFunction
#+end_src
** Wody
#+begin_src cicada :tangle ./core/english.ccd
(* string begin with a number or alphabet
   and end with `:' following a number or alphabet
   is a symbolDenoteWody *)

: stringDenoteWody?
  (* [address, length] -- True or False *)
  dup Two < if
    drop2 False Exit
  then
  dup2 headOfString
  charDenoteNumberOrAlphabetOrOutOfAscii? false? if
    drop2 False Exit
  then
  dup2  sub1 +  fetchByte ':' =/= if
    drop2 False Exit
  then
  dup2  sub2 +  fetchByte
  charDenoteNumberOrAlphabetOrOutOfAscii? false? if
    drop2 False Exit
  then
  drop2 True Exit
; defineFunction

:" an error occurs!
symbolDenoteWody? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteWody?,type-error ; defineConstString
: symbolDenoteWody?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteWody?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteWody?
  Exit
; defineFunction
#+end_src
** LambdaArgument
#+begin_src cicada :tangle ./core/english.ccd
(* `<' plus a stringDenoteBoundVariableOne *)
: stringDenoteLambdaArgumentOne?
  (* [address, length] -- True or False *)
  dup Two <= if
    drop2 False Exit
  then
  tailAndHeadOfString '<' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableOne? Exit
; defineFunction

:" an error occurs!
symbolDenoteLambdaArgumentOne? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteLambdaArgumentOne?,type-error ; defineConstString
: symbolDenoteLambdaArgumentOne?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteLambdaArgumentOne?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteLambdaArgumentOne?
  Exit
; defineFunction



(* `<' plus a stringDenoteBoundVariableTwo *)
: stringDenoteLambdaArgumentTwo?
  (* [address, length] -- True or False *)
  dup Three <= if
    drop2 False Exit
  then
  tailAndHeadOfString '<' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableTwo? Exit
; defineFunction

:" an error occurs!
symbolDenoteLambdaArgumentTwo? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteLambdaArgumentTwo?,type-error ; defineConstString
: symbolDenoteLambdaArgumentTwo?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteLambdaArgumentTwo?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteLambdaArgumentTwo?
  Exit
; defineFunction




(* `<' plus a stringDenoteBoundVariableThree *)
: stringDenoteLambdaArgumentThree?
  (* [address, length] -- True or False *)
  dup Four <= if
    drop2 False Exit
  then
  tailAndHeadOfString '<' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableThree? Exit
; defineFunction

:" an error occurs!
symbolDenoteLambdaArgumentThree? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteLambdaArgumentThree?,type-error ; defineConstString
: symbolDenoteLambdaArgumentThree?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteLambdaArgumentThree?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteLambdaArgumentThree?
  Exit
; defineFunction




(* `<' plus a stringDenoteBoundVariableFour *)
: stringDenoteLambdaArgumentFour?
  (* [address, length] -- True or False *)
  dup Five <= if
    drop2 False Exit
  then
  tailAndHeadOfString '<' =/= if
    drop2 False Exit
  then
  stringDenoteBoundVariableFour? Exit
; defineFunction

:" an error occurs!
symbolDenoteLambdaArgumentFour? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteLambdaArgumentFour?,type-error ; defineConstString
: symbolDenoteLambdaArgumentFour?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteLambdaArgumentFour?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteLambdaArgumentFour?
  Exit
; defineFunction



: stringDenoteLambdaArgument?
  (* [address, length] -- True or False *)
  dup2 stringDenoteLambdaArgumentOne? if
    drop2 True Exit
  then
  dup2 stringDenoteLambdaArgumentTwo? if
    drop2 True Exit
  then
  dup2 stringDenoteLambdaArgumentThree? if
    drop2 True Exit
  then
  dup2 stringDenoteLambdaArgumentFour? if
    drop2 True Exit
  then
  drop2 False Exit
; defineFunction

:" an error occurs!
symbolDenoteLambdaArgument? said:
   ``My function-type is (* [index, <symbol>] -- True or False *)
     But the type I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,symbolDenoteLambdaArgument?,type-error ; defineConstString
: symbolDenoteLambdaArgument?
  (* [index, <symbol>] -- True or False *)
  dup <symbol> =/= if
    String,symbolDenoteLambdaArgument?,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  index-hashback->string
  stringDenoteLambdaArgument?
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
:" xxx"   string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 0 *) cr
:" :xxx"  string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 1 *) cr
:" ::"    string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 0 *) cr
:" :"     string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 0 *) cr
:" :1"    string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 1 *) cr
:" :中文" string-hash->index <symbol> symbolDenoteBoundVariableOne? . (* 1 *) cr
cr
:" :xxx"   string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 0 *) cr
:" ::xxx"  string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 1 *) cr
:" :::"    string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 0 *) cr
:" ::"     string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 0 *) cr
:" ::1"    string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 1 *) cr
:" ::中文" string-hash->index <symbol> symbolDenoteBoundVariableTwo? . (* 1 *) cr
cr
:" xxx"   string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" :xxx"  string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" ::"    string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" :"     string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" :1"    string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" :中文" string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
cr
:" xxx::" string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" xxx:"  string-hash->index <symbol> symbolDenoteWody? . (* 1 *) cr
:" 1:"    string-hash->index <symbol> symbolDenoteWody? . (* 1 *) cr
:" :1:"   string-hash->index <symbol> symbolDenoteWody? . (* 0 *) cr
:" 中文:" string-hash->index <symbol> symbolDenoteWody? . (* 1 *) cr
cr
:" <:xxx::" string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
:" <:xxx:"  string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
:" <:1:"    string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
:" <::1:"   string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 0 *) cr
:" <:中文:" string-hash->index <symbol> symbolDenoteLambdaArgumentOne? . (* 1 *) cr
cr
:" <:xxx::" string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
:" <:xxx:"  string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
:" <:1:"    string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
:" <::1:"   string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 1 *) cr
:" <:中文:" string-hash->index <symbol> symbolDenoteLambdaArgumentTwo? . (* 0 *) cr
cr

(* ----------------------------------------------------- *)
cr
:" xxx"    stringDenoteBoundVariableOne? . (* 0 *) cr
:" :xxx"   stringDenoteBoundVariableOne? . (* 1 *) cr
:" ::"     stringDenoteBoundVariableOne? . (* 0 *) cr
:" :"      stringDenoteBoundVariableOne? . (* 0 *) cr
:" :1"     stringDenoteBoundVariableOne? . (* 1 *) cr
:" :中文"  stringDenoteBoundVariableOne? . (* 1 *) cr
cr
:" :xxx"    stringDenoteBoundVariableTwo? . (* 0 *) cr
:" ::xxx"   stringDenoteBoundVariableTwo? . (* 1 *) cr
:" :::"     stringDenoteBoundVariableTwo? . (* 0 *) cr
:" ::"      stringDenoteBoundVariableTwo? . (* 0 *) cr
:" ::1"     stringDenoteBoundVariableTwo? . (* 1 *) cr
:" ::中文"  stringDenoteBoundVariableTwo? . (* 1 *) cr
cr
:" xxx"    stringDenoteWody? . (* 0 *) cr
:" :xxx"   stringDenoteWody? . (* 0 *) cr
:" ::"     stringDenoteWody? . (* 0 *) cr
:" :"      stringDenoteWody? . (* 0 *) cr
:" :1"     stringDenoteWody? . (* 0 *) cr
:" :中文"  stringDenoteWody? . (* 0 *) cr
cr
:" xxx::"  stringDenoteWody? . (* 0 *) cr
:" xxx:"   stringDenoteWody? . (* 1 *) cr
:" 1:"     stringDenoteWody? . (* 1 *) cr
:" :1:"    stringDenoteWody? . (* 0 *) cr
:" 中文:"  stringDenoteWody? . (* 1 *) cr
cr
:" <:xxx::"  stringDenoteLambdaArgumentOne? . (* 1 *) cr
:" <:xxx:"   stringDenoteLambdaArgumentOne? . (* 1 *) cr
:" <:1:"     stringDenoteLambdaArgumentOne? . (* 1 *) cr
:" <::1:"    stringDenoteLambdaArgumentOne? . (* 0 *) cr
:" <:中文:"  stringDenoteLambdaArgumentOne? . (* 1 *) cr
cr
:" <:xxx::"  stringDenoteLambdaArgumentTwo? . (* 0 *) cr
:" <:xxx:"   stringDenoteLambdaArgumentTwo? . (* 0 *) cr
:" <:1:"     stringDenoteLambdaArgumentTwo? . (* 0 *) cr
:" <::1:"    stringDenoteLambdaArgumentTwo? . (* 1 *) cr
:" <:中文:"  stringDenoteLambdaArgumentTwo? . (* 0 *) cr
cr
(* ----------------------------------------------------- *)

(* test: type-error *)
null symbolDenoteWody?          basicREPL
null symbolDenoteBoundVariableOne?  basicREPL
#+end_src
* read-wodyli & write-wodyli
** note
1. wodyli denotes wordy-list
2. wodyli is a dalin of list
3. lambda will use ``bound-variable-wodyli''
** read-wodyli
#+begin_src cicada :tangle ./core/english.ccd
: help,with-word,read-wody-or-bound-variable
  (* -- [address, <list>] *)
  (* LambdaStack::
     -- wody[address, length] *)
  readWord
  dup2 stringDenoteWody? if
    ready
    null Exit
  then
  dup2 stringDenoteBoundVariable? if
    ready
    null Exit
  then
  dup2 String,ending-wodyli equalString? if
    ready
    null Exit
  then
  dup2 String,dot equalString? if
    drop2
    help,with-word,read-wody-or-bound-variable car
    (* this means { 1 . 2 3 } will be read as { 1 . 2 } *)
    Exit
  then
  executeWord,for-list-reader
  cons drop <list>
    xx|swap|xx  set-car!
      help,with-word,read-wody-or-bound-variable
    set-cdr!
  Exit
; defineRecursiveFunction


: with-word,read-wody-or-bound-variable
  (* word[address, length] -- [address, <wody>], word[address, length] *)
  (* LambdaStack:: <wody> -- *)
  (* or *)
  (* word[address, length] -- [address, <bound-variable>], word[address, length] *)
  (* LambdaStack:: <bound-variable> -- *)
  string-hash->index <symbol>
  cons drop popLambdaStack
    [car,cons]!
      help,with-word,read-wody-or-bound-variable
    [cons,cdr]!
  getBack
  (* return the next ``wody'' word
     it must be handled in help,read-wodyli *)
  Exit
; defineFunction



:" help,read-wodyli said:
   ``My function type is
     (* [address, <wodyli>], word[address, length] -- head[address, <wodyli>] *)
     the `word' must be `)' or denotes `wody' or denotes `bound-variable'
     But the following is what I meet
     I will not touch it and call debuger''
   --> "
: String,help,read-wodyli,error ; defineConstString

(* a ``with-word'' reader *)
: help,read-wodyli
  (* [address, <wodyli>], word[address, length] -- head[address, <wodyli>] *)
  (* where:
       the <- of [address, <wodyli>] is setted,
       need to set the -> of [address, <wodyli>] *)
  dup2 String,ending-wodyli equalString? if
    drop2
    dup2
      cdr
        null  set-cdr!
      drop2
    head<-dalin
    Exit
  then
  dup2 stringDenoteWody? if
    <wody> pushLambdaStack
  else
    dup2 stringDenoteBoundVariable? if
      <bound-variable> pushLambdaStack
    else
      String,help,read-wodyli,error printString
      printString cr
      debuger Exit
    then
  then
  with-word,read-wody-or-bound-variable
  (* [address, <wodyli>], [address, <wody>], word[address, length] *)
  (* or *)
  (* [address, <wodyli>], [address, <bound-variable>], word[address, length] *)
  xxxx|swap|xx
  cons drop <wodyli>
    xx|swap|xx  set-car!
    cons        set-cdr!
  ^_^
  xx|swap|xx
  help,read-wodyli
  Exit
; defineRecursiveFunction



: read-wodyli (* -- head[address, <wodyli>] *)
  null
  readWord
  dup2 String,ending-wodyli equalString? if
    (* return ``null'' on ( ) *)
    drop2 Exit
  then
  help,read-wodyli
  Exit
; defineFunction

: ( read-wodyli Exit ; defineFunction
#+end_src
** write-wody & write-wodyli
#+begin_src cicada :tangle ./core/english.ccd
:" write-wody-or-bound-variable said:
   ``My function-type is (* [address, <wody> or <bound-variable>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: String,write-wody-or-bound-variable,type-error ; defineConstString

: write-wody-or-bound-variable
  (* [address, <wody> or <bound-variable>] -- *)
  dup <wody> =/=
  over <bound-variable> =/=
  bitwiseAnd if
    String,write-wody-or-bound-variable,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  dup2
    car write
  cdr help,write-list
  Exit
; defineFunction



: help,write-wodyli
  (* [address, <wodyli>] -- *)
  dup <null> == if
    drop2 Exit
  then
  dup2
    car write
  -> help,write-wodyli Exit
; defineRecursiveFunction


:" write-wodyli said:
   ``My function-type is (* [address, <wodyli>] -- *)
     But the 1st argument is the following
     I will not touch it and call debuger.''
   --> "
: String,write-wodyli,type-error ; defineConstString

: write-wodyli
  (* [address, <wodyli>] -- *)
  dup <wodyli> =/= if
    String,write-wodyli,type-error printString
    dup printTypeTag cr
    debuger Exit
  then
  String,begining-wodyli printString writeSpace
  help,write-wodyli
  String,ending-wodyli printString writeSpace
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
( x: ( a: 1 2 3 b: 4 5 6 )
  a: 1 2 3
  b: 4 5 6 )
 write

( a: b: 6 ) write-wodyli

( :a 1 :b 2 ) write-wodyli
#+end_src
* ><><>< wodyli processing
* executeWord [redefine] & symbolREPL & lambda-argument
** note
1. to read different types of symbols
2. to handle <:x <::x <:::x <::::x
3. print better ErrorInfo for ExecuteWord
** implementation
#+begin_src cicada :tangle ./core/english.ccd
: <lambda-argument-one>   ; definePairLikeDataType
: <lambda-argument-two>   ; definePairLikeDataType
: <lambda-argument-three> ; definePairLikeDataType
: <lambda-argument-four>  ; definePairLikeDataType

: <lambda-argument>?
  (* type-tag -- True or False *)
  dup <lambda-argument-one> == if
    drop True Exit
  then
  dup <lambda-argument-two> == if
    drop True Exit
  then
  dup <lambda-argument-three> == if
    drop True Exit
  then
  dup <lambda-argument-four> == if
    drop True Exit
  then
  drop False Exit
; defineFunction

:"   UNDEFINED WORD: "
: String,executeWord,error,undefinedWord ; defineConstString

(* ><><>< the following comment should be rewritten *)
(* redefine executeWord to handle the following symbols
   <:x   ::    value       -- [{ :x  . { ... } }, <lambda-argument-one>]
   <::x  ::  [value, type] -- [{ ::x . { ... } }, <lambda-argument-two>]
   ...
   examples:
   [{ :x       . { 1 } },             <lambda-argument-one>]
   [{ ::null   . { Null <null> } },   <lambda-argument-two>]
   [{ ::number . { 666 <fixnum> } },  <lambda-argument-two>]
   note that:
     every value in list must have a type
     so in every list above, type of a car is setted to <fixnum>
 ,*)

: executeWord (* string[address, length] -- unknown *)
  dup2
  stringDenoteNumber? if
    number drop Exit
  then

  dup2 stringDenoteBoundVariableOne? if
    string-hash->index <symbol> Exit
  then
  dup2 stringDenoteBoundVariableTwo? if
    string-hash->index <symbol> Exit
  then
  dup2 stringDenoteBoundVariableThree? if
    string-hash->index <symbol> Exit
  then
  dup2 stringDenoteBoundVariableFour? if
    string-hash->index <symbol> Exit
  then

  dup2 stringDenoteLambdaArgumentOne? if
    tailOfString
    string-hash->index <symbol>
    cons drop <lambda-argument-one>
      xx|swap|xx set-car!
      ready
        One stack-FIAF->list
      getBack
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 stringDenoteLambdaArgumentTwo? if
    tailOfString
    string-hash->index <symbol>
    cons drop <lambda-argument-two>
      xx|swap|xx set-car!
      ready
        Two stack-FIAF->list
      getBack
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 stringDenoteLambdaArgumentThree? if
    tailOfString
    string-hash->index <symbol>
    cons drop <lambda-argument-three>
      xx|swap|xx set-car!
      ready
        Three stack-FIAF->list
      getBack
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 stringDenoteLambdaArgumentFour? if
    tailOfString
    string-hash->index <symbol>
    cons drop <lambda-argument-four>
      xx|swap|xx set-car!
      ready
        Four stack-FIAF->list
      getBack
      xx|swap|xx set-cdr!
    Exit
  then
  dup2 find dup notZero? if
    xx|swap|x drop2
    wordLinkToWordExplainer execute Exit
  then
  drop (* drop the Zero that denotes finding-error *)
  String,executeWord,error,undefinedWord printString
  printString (* print the word *) cr
  Exit
; defineFunction

(* if wished
 ,*   one needs to use help,symbolREPL to do the recursive
 ,*   and reset the two pointers in symbolREPL
 ,* TheReturnStackTop resetReturnStackPointer
 ,* TheArgumtStackTop resetArgumtStackPointer *)

: symbolREPL (* unknown -- unknown *)
  readWordForRuntime
  executeWord
  symbolREPL
  Exit
; defineRecursiveFunction
#+end_src
** test
#+begin_src cicada
symbolREPL 1 2 + . (* 3 *) cr
cr

:xxx printTypeTag (* <symbol> *) cr
index-hashback->string printString (* :xxx *) cr
cr

::xxx printTypeTag (* <symbol> *) cr
index-hashback->string printString (* ::xxx *) cr
cr

:::xxx printTypeTag (* <symbol> *) cr
index-hashback->string printString (* :::xxx *) cr
cr

::::xxx printTypeTag (* <symbol> *) cr
index-hashback->string printString (* ::::xxx *) cr
cr
#+end_src
* using the symbolREPL now !
#+begin_src cicada :tangle ./core/english.ccd
symbolREPL
#+end_src
* ><><><><><><><><><><><><><><><><><><><><><><><><><
* lambda
** note
*** ABOUT lambda-calculus
    1. lambda is a function which uses two dalin
       to compose a anonymous function
       (not compile to the dictionary)
       apply is a function which
       explain (or eval) the anonymous function composed by lambda
    2. ``compose(撰写)'' is different from ``compile(编撰)''
    3. the essence is
       ``compose and explain''
       or ``compile and explain''
       1) what(syntax) to be composed ?
       2) compose to what ?
       3) how to explain(or eval) the result of the composition
    4. in cicada
       apply is linear
       lambda is almost linear
       ``linear'' means a loop walk through a dalin
       but not a recursive function traverse a nested dalin
       only the function that calculates the scope of a lambda is recursive
    5. a bound-variable of a lambda function
       is used to label the place in the lambda-body
       into where you want to substitute a argument
       when lambda-body is nested
       the scope of bound-variables need to be handled
       scheme use closure to handle this
       cicada use simple graph processing to handle this
    6. during lambda-application,
       one <lambda-argument-N> substitute into
       one <bound-variable>
    7. from lisp to cicada
       I am dispersing the works of parsing all the time
*** ABOUT lazy-eval
    1. in cicada use explicit lazy-eval
       use ()lambda or ()λ
       to make a lambda-function without arguments
       to use explicit lazy-eval
    2. lazy-eval has better theoretical feature in lambda-calculus
       but it makes computation unpredictable
*** ABOUT substitution
    note that you can only use bound-variable (such as ::x :n) in a lambda-body
    bot NOT a dalin or list or wodyli
** data-types
   #+begin_src cicada :tangle ./core/english.ccd
   : <lambda>               ; definePairLikeDataType
   : <explainer-pair>       ; definePairLikeDataType
   : <explainer>            ; defineDataType
   #+end_src
** helper functions
   used to decide the type error of lambda
   and to decide when I need to calculate lambda-scope
   #+begin_src cicada :tangle ./core/english.ccd
   : bound-variable-wodyli?
     (* head[address, <wodyli>] -- True or False *)
     dup <wodyli> =/= if
       drop2 False Exit
     then
     dup2 car  swap drop
     <bound-variable> =/= if
       drop2 False Exit
     then
     dup2 dalin*? if
       drop2 True Exit
     then
     ->  bound-variable-wodyli?
     Exit
   ; defineRecursiveFunction
   
   
   (*
    ,* the following function return `True'
    ,* on the following dalin as a tail
    ,*   [ [address, <dalin>]
    ,*     bound-variable-wodyli[address, <wodyli>]
    ,*    ]
    ,* and
    ,*   [ [address, <dalin>]
    ,*     null
    ,*    ]
    ,*)
   
   : meet-lambda-abstraction-in-lambda-body-dalin?
     (* tail[address, <dalin>] -- True or False *)
     dup <dalin> =/= if
       drop2 False Exit
     then
     dup2 car
     dup2       bound-variable-wodyli?
     xx|swap|x  null?
     bitwiseOr if
       <- dup <dalin> =/= if
         drop2 False Exit
       then
         car <dalin> =/= if
           drop False Exit
         then
           drop True Exit
     then
     drop2 False Exit
   ; defineFunction
   
   (*
    ,* test:
    ,*
    ,* [ [ 1 ] ( :x ) ] dalin->tail
    ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
    ,* [ [ 1 ] null ] dalin->tail
    ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
    ,* [ [ 1 ] ( ) ] dalin->tail
    ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 1 *\) cr
    ,* cr
    ,* [ [ 1 ] ( x: ) ] dalin->tail
    ,* meet-lambda-abstraction-in-lambda-body-dalin? . (\* 0 *\) cr
    *)
   #+end_src
** bound-variable-wodyli-subtraction (for calculating lambda-scope)
   #+begin_src cicada :tangle ./core/english.ccd
   : help,bound-variable-wodyli-subtraction
     (* LambdaStack::
        (a-b) [address, <wodyli>] -- *)
     (* b [address, <wodyli>], a [address, <wodyli>] --
        (a-b) [address, <wodyli>] *)
     dup <null> == if
       drop2 drop2
       getBack
       dup <null> == if
         Exit
       then
       dup2 cdr null [cons,cdr]! drop2
       head<-dalin
       Exit
     then
     dup2
       car car   xx|over|xxxx
       [value,dalin]-associate
       dup <null> =/= if
       (* if this bound-variable is ``blocked'',
          it should not be ``cons'' to the new bound-variable-wodyli *)
       drop2 (* drop the associate-pair *)
       ->  help,bound-variable-wodyli-subtraction Exit
     then
     drop2 (* drop the associate-pair *)
     (* b [address, <wodyli>], a [address, <wodyli>] *)
     dup2 car
     (* a wody as a whole is ``cons''ed to the new bound-variable-wodyli *)
     cons drop <wodyli>
       [car,cons]!
       cons [cons,cdr]!
     getBack
       xx|swap|xx  ^_^
       (* so the order of bound-variable-wodyli will be preserved *)
     ready
     ->  help,bound-variable-wodyli-subtraction Exit
   ; defineRecursiveFunction
   
   
   (* the following function will creat a new wodyli, maybe ``null'' *)
   : bound-variable-wodyli-subtraction
     (* a [address, <wodyli>], b [address, <wodyli>] --
        (a-b) [address, <wodyli>] *)
     x|over|xx <null> == if
       (* a == null, (a-b) == a == null *)
       drop2 Exit
     then
     dup <null> == if
       (* b == null, (a-b) == a *)
       drop2 Exit
     then
     null ready
     xx|swap|xx
     (* b [address, <wodyli>], a [address, <wodyli>] *)
     (* LambdaStack::  [Null, <null>] *)
     help,bound-variable-wodyli-subtraction
     Exit
   ; defineFunction
   
   
   (*
    ,*  test:
    ,*
    ,* 666
    ,* ( ::a ::b ::c )
    ,* ( ::a ::c ::x )
    ,* bound-variable-wodyli-subtraction
    ,* write (\* ( ::b )  *\)
    ,*
    ,* . (\* 666 *\)
    *)
   #+end_src
** lambda
   #+begin_src cicada :tangle ./core/english.ccd
   :" lambda" string-hash->index
   : SymbolIndex,lambda ; defineConst
   
   :" λ" string-hash->index
   : SymbolIndex,λ ; defineConst
   
   
   (* the following two functions are side-effects through a dalin
    ,* in the direction of ``<-''
   
    ,* some special-types of elements in the lambda-body
    ,* should be setted for ``apply''
   
    ,* note that: (currently)
    ,*   <fixnum> <list> <dalin> <wodyli> <symbol>
    ,*   are the only types of value
    ,*   that could be readed into a dalin
   
    ,*   only all <symbol> in this dalin
    ,*   and some <symbol> that denote-bound-variable nestedly existed in this dalin
    ,*   will be handled by the following functions
   
    ,*   while
    ,*   in the ``apply''
    ,*   when meet [666, <fixnum>]
    ,*     666 ( ONLY ONE VALUE ) will be push to ArgumtStack
    ,*   when meet [address, <list>]
    ,*     [address, <list>] will be push to ArgumtStack
    ,*   when meet [address, <dalin>]
    ,*     [address, <dalin>] will be push to ArgumtStack
    ,*   when meet [address, <wodyli>]
    ,*     [address, <wodyli>] will be push to ArgumtStack
    ,*)
   
   
   : help,lambda,set-bound-variables (* calculating lambda-scope *)
     (* [address, <wodyli>], [address, <dalin>] -- *)
     dup <null> == if
       (* drop all the arguments here *)
       drop2 drop2 Exit
     then
     dup2 car
   
     (* [address, <wodyli>], [address, <dalin>], car[value, type] *)
     dup <symbol> =/= if
       (* types of value other then <symbol>
          will be leaved in the lambda-body as they are *)
       drop2
       <-  help,lambda,set-bound-variables Exit
     then
   
     (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
     dup2 symbolDenoteBoundVariable? if
       xx|over|xxxx
       dup <null> == if
         (* when bound-variable-wodyli is null
            symbolDenoteBoundVariable can not be bound by this lambda
            just leave them in the lambda-body as they are *)
         drop2 (* drop [Null, <null>] *)
         drop2 (* drop [index, <symbol>] *)
         <-  help,lambda,set-bound-variables Exit
       then
       [value,dalin]-associate
       dup <null> == if
         (* symbolDenoteBoundVariable that can not be bound by this lambda
            will be leaved in the lambda-body as they are *)
         drop2
         <-  help,lambda,set-bound-variables Exit
       then
       (* [address, <wodyli>], [address, <dalin>], [address, <bound-variable>] *)
       [cons,car]!
       <-  help,lambda,set-bound-variables Exit
     then
   
     (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
     dup2 drop
       dup   SymbolIndex,lambda ==
       swap  SymbolIndex,λ ==
     bitwiseOr if
       drop2
       <-
       (* make a special treatment only when
          ``meet-lambda-abstraction-in-lambda-body-dalin'' *)
       dup2
       meet-lambda-abstraction-in-lambda-body-dalin?
       false? if
         help,lambda,set-bound-variables Exit
       then
       (* [address, <wodyli>], [address, <dalin>] *)
         (* prepare the arguments for a non-tail-recursive call of help,lambda,set-bound-variables *)
         xx|over|xx xx|over|xx
           car bound-variable-wodyli-subtraction
         xx|over|xx
           (* note that: the 2ed arg of help,lambda,set-bound-variables is a tail-dalin *)
           <-  car  dalin->tail
         help,lambda,set-bound-variables
         (* after then : *)
         <- <-  help,lambda,set-bound-variables Exit
     then
   
     (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
     (* here is general symbol *)
     drop2
     <-  help,lambda,set-bound-variables Exit
   ; defineRecursiveFunction
   
   
   : help,lambda,set-function-body
     (* [address, <wodyli>], [address, <dalin>] -- *)
     dup <null> == if
       (* drop all the arguments here *)
       drop2 drop2 Exit
     then
     dup2 car
     (* [address, <wodyli>], [address, <dalin>], car[value, type] *)
     dup <symbol> =/= if
       (* types of value other then <symbol>
          will be leaved in the lambda-body as they are *)
       drop2
       <-  help,lambda,set-function-body Exit
     then
     (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
     dup2 symbolDenoteLambdaArgument? if
       (* i.e. symbols like ``<:x''
          will be leaved in the lambda-body as they are
          they will be handled by ``apply'' *)
       drop2
       <-  help,lambda,set-function-body Exit
     then
     (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
     dup2 symbolDenoteBoundVariable? if
       (* i.e. symbols like ``:x''
          will be leaved in the lambda-body as they are
          ``help,lambda,set-bound-variables'' take care of them
          when ``apply'' is executed there should be none of them *)
       drop2
       <-  help,lambda,set-function-body Exit
     then
     (* [address, <wodyli>], [address, <dalin>], [index, <symbol>] *)
     (* here is general symbol *)
     over
       index-hashback->string
       find (* ><><>< error handling when not found *)
       wordLinkToWordExplainer
       <explainer>
     cons drop <explainer-pair>
       [cdr,cons]!  [car,cons]!
     [cons,car]!
     <-  help,lambda,set-function-body Exit
   ; defineRecursiveFunction
   
   
   
   
   : help,lambda,make-lambda-function
     (* [address, <wodyli>], [address, <dalin>] --
        [address, <lambda>] *)
     cons drop <lambda>
       xx|swap|xx set-cdr!
       xx|swap|xx set-car!
     Exit
   ; defineFunction
   
   
   
   
   :" lambda said:
      ``My function type is
        (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
        (* or *)
        (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
        But the 1st argument is the following
        I will not touch it and call debuger''
      --> "
   : String,lambda,type-error,1st ; defineConstString
   
   :" lambda said:
      ``My function type is
        (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
        (* or *)
        (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
        The 1st argument is a wodyli but not a bound-variable-wodyli
        I will not touch it and call debuger''"
   : String,lambda,type-error,1st,not-bound-variable-wodyli
   ; defineConstString
   
   :" lambda said:
      ``My function type is
        (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
        (* or *)
        (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
        But the 3rd argument is the following
        I will not touch it and call debuger''
      --> "
   : String,lambda,type-error,3rd ; defineConstString
   
   : lambda
     (* [address, <dalin>], [address, <wodyli>] -- [address, <lambda>] *)
     (* or *)
     (* [address, <dalin>], [Null, <null>] -- [address, <lambda>] *)
     dup <wodyli> =/=
     over <null> =/=
     bitwiseAnd if
       String,lambda,type-error,1st printString
       dup printTypeTag cr
       debuger Exit
     then
     dup <wodyli> ==
     xx|over|x bound-variable-wodyli? false?
     bitwiseAnd if
       String,lambda,type-error,1st,not-bound-variable-wodyli
       printString cr
       debuger Exit
     then
     x|over|xx <dalin> =/= if
       String,lambda,type-error,3rd printString
       x|over|xx printTypeTag cr
       debuger Exit
     then
     xx|tuck|xx  xx|over|xx
     dalin->tail
     (* [address, <wodyli>], [address, <dalin>],
        [address, <wodyli>], tail[address, <dalin>] *)
     xx|over|xx  xx|over|xx
     help,lambda,set-bound-variables
     (* multi-pass *)
     help,lambda,set-function-body
     (* [address, <wodyli>], [address, <dalin>] *)
     help,lambda,make-lambda-function
     Exit
   ; defineFunction
   
   : λ lambda Exit ; defineFunction
   #+end_src
** test
   #+begin_src cicada
   [              :b negate
       4 :a :c * *
           :b :b *  -  ><><><sqrt  +
                       2 :a  *  / ] dup2 write cr
   ( :a :b :c ) dup2 write cr
   lambda
   drop2
   
   
   [ ::y
     [ ::x ::x ::x ]
     ( ::x ) lambda ] dup2 write cr
   ( ) dup2 write cr
   lambda
   drop2
   
   
   [ ::y
     [ ::x ::x ::x ]
     ( ) lambda ] dup2 write cr
   ( ) dup2 write cr
   lambda
   drop2
   
   
   [ ::y
     [ ::x ::x ::x ]
     ( ::x ) lambda ] dup2 write cr
   ( ::y ) dup2 write cr
   lambda
   drop2
   
   
   [ [ ::x ::x ::x ] ( ::x ) lambda ] dup2 write cr
   ( ::y ) dup2 write cr
   lambda
   drop2
   
   
   [ [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda
      ::y
     [ [ ::x ::x ] ( ::x ) lambda ] ( ::x ) lambda  ] dup2 write cr
   ( ::y ) dup2 write cr
   lambda
   drop2
   
   
   [ [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda ::y
     [ [ ::x ::x @ ] lambda ::y @ ] ( ::x ) lambda @ ] dup2 write cr
   ( ::y ) dup2 write cr
   lambda
   drop2
   #+end_src
* apply
** note
   1. 对lambda-body的正确求值
      是依赖于``绑定''对这个lambda所作的副作用的
      那么在作用的过程中就不能破坏(更改)对这些约束变元的绑定
      只要每次lambda的作用都会更新 <lambda> pair 中的约束变元dalin
      也就是说在一个lambda-body中不能引用这个lambda-body本身
      这也许是合理的
   2. 并且上面的特点所带来的一个效果就是
      每个lambda都会保存着它上次作用时进行的绑定
      也许这种效果能被有趣地利用起来
   3. maybe I can support cc here !
** lambda-body-stack
   #+begin_src cicada :tangle ./core/english.ccd
   (* note that:
        when a explainer is been executed
        only the arguments of the word to be explained
        should be in the ArgumtStack or LambdaStack *)
   
   (* a stack as list
      list of dalin
      in which a dalin denotes a lambda-body *)
   null : lambda-body-stack ; define
   
   : push,lambda-body-stack
     (* [address, <wodyli>] -- *)
     cons drop <list>  [car,cons]!
     lambda-body-stack fetch2
     [cons,cdr]!
     lambda-body-stack save2
     Exit
   ; defineFunction
   
   : drop,lambda-body-stack
     (* -- *)
     lambda-body-stack fetch2
     cdr
     lambda-body-stack save2
     Exit
   ; defineFunction
   #+end_src
** help,apply,eval-lambda-body
   #+begin_src cicada :tangle ./core/english.ccd
   (* the following function
      do side-effect to the car of the lambda-body-stack *)
   
   : <end-of-one-lambda-body> ; defineDataType
   : <end-of-all-lambda-body> ; defineDataType
   
   : lambda-forth
     (* -- [value, type] or <end-of-lambda-body> or <>] *)
     lambda-body-stack fetch2
     dup <null> == if
       drop2
       <end-of-all-lambda-body>
       Exit
     then
     dup2 car
       (* [address, <list>], [address, <dalin>] or null *)
       dup <null> == if
       drop2 drop2
       <end-of-one-lambda-body>
       drop,lambda-body-stack
       Exit
     then
     (* [address, <list>], [address, <dalin>] *)
     xx|tuck|xx
     (* [address, <dalin>],
        [address, <list>], [address, <dalin>] *)
     ->  (* up date the 1st lambda-body in lambda-body-stack *)
     [cons,car]! drop2
     car
     Exit
   ; defineFunction
   
   
   :" help,apply,eval-lambda-body said:
      ``My function type is (* unknow -- unknow *)
        I call `lambda-forth' to do side-effect on lambda-body-stack
        The symbol I meet should always DenoteLambdaArgument
        But I meet the following symbol
        I will not touch it and call debuger''
      --> "
   : String,help,apply,eval-lambda-body,error,symbol
   ; defineConstString
   
   : help,apply,eval-lambda-body
     (* unknow -- unknow *)
     lambda-forth
     dup <end-of-one-lambda-body> == if
       drop Exit
     then
   
     (* examples:
          [{ :x  . { 100 } }, <bound-variable>]
          [{ ::x . { 666 <fixnum> } }, <bound-variable>] *)
     dup <bound-variable> == if
       cdr
       stack<-FIAF-list
       help,apply,eval-lambda-body
       Exit
     then
   
     (* example:
          [{ word-name . word-explainer }, <explainer-pair>] *)
     dup <explainer-pair> == if
       cdr
       drop (* drop type-tag: <explainer> *)
       execute
       help,apply,eval-lambda-body
       Exit
     then
   
     (* example:
          [index, <symbol>] *)
     dup <symbol> == if
       dup2 symbolDenoteLambdaArgument? if
         drop (* drop <symbol> *)
         index-hashback->string
         executeWord
         help,apply,eval-lambda-body
         Exit
       then
       String,help,apply,eval-lambda-body,error,symbol printString
       dup2 write cr
       debuger
       Exit
     then
   
     (* example:
          [666, <fixnum>] *)
     dup <fixnum> == if
       drop (* drop type-tag: <fixnum> *)
       help,apply,eval-lambda-body
       Exit
     then
   
     (* examples:
          [address, <list>]
          [address, <dalin>]
          [address, <wodyli>]
        and all other types
        leave the value and the type in the stack *)
     help,apply,eval-lambda-body
     Exit
   ; defineRecursiveFunction
   #+end_src
** apply
   #+begin_src cicada :tangle ./core/english.ccd
   (* examples of <lambda-argument>:
        { :x       . { 1 } }
        { ::null   . { Null <null> } }
        { ::number . { 666 <fixnum> } }
      example of bound-variable-wodyli
        ( :a ::b :::c )
        [ { :a    . ... }
          { ::b   . ... }
          { ::::c . ... } ]
    ,*)
   
   
   : help-to-rec,help,apply,set-variables
     (* ArgumtStack::
        ..., [address, <lambda-argument-N>] -- *)
     (* LambdaStack::
        [address, <wodyli>] -- [address, <wodyli>] *)
     dup <lambda-argument>? false? if
       Exit
     then
     dup2   car    getBack dup2 ready
     (* [address, <lambda-argument-N>], [index, <symbol>], [address, <wodyli>] *)
     [value,dalin]-associate
     dup <null> == if
       drop2 Exit
     then
     (* [address, <lambda-argument-N>], [..., <bound-variable>] *)
     xx|swap|xx   cdr
     [cons,cdr]!  drop2
     help-to-rec,help,apply,set-variables
     Exit
   ; defineRecursiveFunction
   
   
   : help,apply,set-variables
     (* ..., [address, <lambda-argument>], [address, <wodyli>] -- *)
     ready
       help-to-rec,help,apply,set-variables
     getBack drop2 Exit
   ; defineFunction
   
   
   
   :" apply said:
      ``My function type is
        (* LambdaStack::  [address, <lambda>] -- unknow *)
        (* ArgumtStack::  ..., [address, <lambda-argument>] -- unknow *)
        But the value in the LambdaStack is of the following type
        I will not touch it and call debuger''
      --> "
   : String,apply,type-error ; defineConstString
   : apply
     (* LambdaStack::  [address, <lambda>] -- unknow *)
     (* ArgumtStack::  ..., [address, <lambda-argument>] -- unknow *)
     getBack dup2 ready
     dup <lambda> == if
       car dup <null> == if
         drop2
       else
         help,apply,set-variables
       then
       getBack  cdr
       push,lambda-body-stack
       help,apply,eval-lambda-body
       Exit
     then
     String,apply,type-error printString
     printTypeTag cr
     drop (* drop the the value been getted back *)
     debuger Exit
   ; defineFunction
#+end_src
** syntax sugar
#+begin_src cicada :tangle ./core/english.ccd
: @
  (* ...,
     [address, <lambda-argument>],
     [address, <lambda>]
     ---------------------------
     unknow *)
  ready apply Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
[ :x 1 + ]  (* push a dalin to ArgumentStack *)
( :x )      (* push a symbol `:x' to ArgumentStack *)
λ           (* digests some symbols and a dalin in the ArgumentStack,
               and return a lambda-function by them *)
ready (* pop ArgumentStack, push the lambda-function to LambdaStack *)

3   (* push 3 into the ArgumentStack *)
<:x (* make a typed value of type : <lambda-argument-one> *)

apply (* apply a lambda-function in the LambdaStack function
         to the ArgumentStack,
         the arguments of the above lambda-function is labeled with a symbol `:x',
         so if there are many arguments, order will be not important *)

writeDecNumber (* 4 *) cr

(* -------------------------------------------------------------- *)

[ + + + ] ( :x ) λ ready
1 2 3 4  apply
writeDecNumber (* 10 *) cr

[ :x 1 2 3 * + + ] ( :x ) λ ready
100 <:x
apply
writeDecNumber (* 107 *) cr

[ 1 :x 2 3 + + + ] ( :x ) λ ready
100 <:x
apply
writeDecNumber (* 106 *) cr

[ 1 2 3 + :x + + ] ( :x ) λ ready
100 <:x
apply
writeDecNumber (* 106 *) cr

[ :::x + + ] ( :::x ) λ ready
1 2 3 <:::x
apply
writeDecNumber (* 6 *) cr

[ ::x + ] ( ::x ) λ ready
1 2 <::x
apply
writeDecNumber (* 3 *) cr

[ :x * + + ] ( :x ) λ ready
1 2 3
100 <:x
apply
writeDecNumber (* 303 *) cr

[ :x + + + ] ( :x ) λ ready
1 2 3
100 <:x
apply
writeDecNumber (* 106 *) cr


(* ------------------------------------ *)
(* the following tests are with scope *)

[ [ :x + + + ] ( :x ) λ ready
  1 2 3
  100 <:x
  apply :y + ]
( :y ) λ ready
10 <:y
apply
writeDecNumber (* 116 *) cr

[ 1 2 3
  100 <:x [ :x + + + ] ( :x ) λ @
  :y + ]
( :y ) λ ready
10 <:y
apply
writeDecNumber (* 116 *) cr

[ 1 2 3
  100 <:x [ :x :x + + + + ] ( :x ) λ @
  :y + ]
( :y ) λ ready
10 <:y
apply
writeDecNumber (* 216 *) cr

[ 1 2 3
  100 <:x [ :y + + + ] ( :x ) λ @
  :y + ]
( :y ) λ ready
10 <:y
apply
writeDecNumber (* 26 *) cr

[ 1 2 3
  100 <:x [ :y :x + + + + ] ( :x ) λ @
  :y + ]
( :y ) λ ready
10 <:y
apply
writeDecNumber (* 126 *) cr

[ 1 2 3
  100 <:x [ :x :y + + + + ] ( :x ) λ @
  :y + ]
( :y ) λ ready
10 <:y
apply
writeDecNumber (* 126 *) cr

[ 1 2 3
  100 <:x [ :y :y + + + + ] ( :x ) λ @
  :y + ]
( :y ) λ ready
10 <:y
apply writeDecNumber (* 36 *) cr

[ 1 2 3 [ :y :y + + + + . ] null λ @ ]
( :y ) λ ready
1000 <:y
apply  (* 2006 *) cr


[ 1 2 3 [ :y :y + + + + ] null λ @ ]
( :y ) λ ready
1000 <:y
apply writeDecNumber (* 2006 *) cr

[ 1 2 3 [ :y :y + + + + ] ( ) λ @ ]
( :y ) λ ready
1000 <:y
apply writeDecNumber (* 2006 *) cr


(* ----------------------------------- *)
(* explicit lazy-eval  *)
666
1 2 3 4
 [ + + + ] ( ) λ @
 . (* 10 *) cr
. (* 666 *) cr

666
1 2 3 4
 [ + + + ] null λ @
 . (* 10 *) cr
. (* 666 *) cr


(* ============================================== *)


(* ----------------------------------- *)
(* the following tests need flow-point-number
   for we need to define ``sqrt'' *)

(*
 ,* the following shows the problem that people argued at:
 ,* http://lambda-the-ultimate.org/node/900

 ,* -b  +/- sqrt(b^2 - 4 * a * c)
 ,* -----------------------------
 ,*            2 * a
 ,*)


(*
 ,* [              :b negate
 ,*     4 :a :c * *
 ,*         :b :b *  -  sqrt  +
 ,*                     2 :a  *  / ] dup2 write
 ,* ( :a :b :c ) dup2 write
 ,* λ ready
 ,*
 ,* 1 <:a  2 <:b  1 <:c
 ,*
 ,* apply writeDecNumber cr (\* -1 *\)
 *)
#+end_src
* play with lambda
** note
1. it is very important to remember
   that lazy-eval must be explicit
2. and again
   about substitution
   note that you can only use bound-variable (such as ::x :n) in a lambda-body
   bot NOT a dalin or list or wodyli
** play
#+begin_src cicada
[ ::x ]
( ::x 3 4 ) λ
: Var,I ; define
: I Var,I fetch2 Exit ; defineFunction

1 2 I @
. . . . (* 4 3 2 1 *) cr
cr

1 2 <::x I @
. . (* 2 1 *) cr
cr

1 2 I @
. . . . (* 2 1 2 1 *) cr
cr


[ ::x ]
( ::x 3 4 ) λ
: I ; define
: I I fetch2 Exit ; defineFunction

1 2 I @
. . . . (* 4 3 2 1 *) cr
cr

1 2 <::x I @
. . (* 2 1 *) cr
cr

1 2 I @
. . . . (* 2 1 2 1 *) cr
cr



[ [ ::T @ ]
  ( ::F ) λ ]
( ::T ) λ
: Var,T ; define
: T Var,T fetch2 Exit ; defineFunction

[ 1 2 3 . . . ] ( ) λ <::T
T @ ready
[ 7 8 9 . . . ] ( ) λ <::F
apply (* 3 2 1 *) cr

[ 1 2 3 . . . ] null λ <::T
[ 7 8 9 . . . ] null λ <::F
T @ @ (* 3 2 1 *) cr

[ 7 8 9 . . . ] ( ) λ <::F
[ 1 2 3 . . . ] ( ) λ <::T
T @ @ (* 3 2 1 *) cr

cr

[ [ ::F @ ]
  ( ::F ) λ ]
( ::T ) λ
: Var,F ; define
: F Var,F fetch2 Exit ; defineFunction

[ 1 2 3 . . . ] null λ <::T
F @ ready
[ 7 8 9 . . . ] null λ <::F
apply (* 9 8 7 *) cr

cr


: make-lambda-bool
  (* True or False -- T or F *)
  true? if
    T Exit
  then F Exit
; defineFunction

[ [ ::true <::T :if make-lambda-bool @ ready
    ::false <::F apply ]
  ( :if ) λ ]
( ::true ::false ) λ
: Var,IF ; define
: IF Var,IF fetch2 Exit ; defineFunction

True <:if
[ 1 2 3 . . . ] null λ <::true
[ 7 8 9 . . . ] null λ <::false
  IF @
@ (* 3 2 1 *) cr

[ 1 2 3 . . . ] null λ <::true
[ 7 8 9 . . . ] null λ <::false
  IF @ ready
True <:if apply (* 3 2 1 *) cr

[ 7 8 9 . . . ] null λ <::false
[ 1 2 3 . . . ] null λ <::true
  IF @ ready
True <:if apply (* 3 2 1 *) cr

[ 7 8 9 . . . ] null λ <::false
[ 1 2 3 . . . ] null λ <::true
  IF @ ready
False <:if apply (* 9 8 7 *) cr

cr

(* Y-combinator
   using explicit lazy-eval
   for cicada's semantic is eager-eval
   because lazy-eval is not natural to postfix-notation
 ,*)

(*
 ,* in λ-cal:
 ,* Y = (λy.(λx.y(xx))(λx.y(xx)))
 ,*
 ,* in daedalus:
 ,* (def Y
 ,*   (λ (y)
 ,*     ((λ (x) (y (x x)))
 ,*      (λ (x) (y (x x))))))
 ,*)

(* in cicada: *)


[ [ [ ::x <::x ::x @ ] null λ <::rec ::y @ ]  ( ::x ) λ <::x
  [ [ ::x <::x ::x @ ] null λ <::rec ::y @ ]  ( ::x ) λ @ ]
( ::y ) λ
: Var,Y ; define
: Y Var,Y fetch2 Exit ; defineFunction


[ [ [ One ] null λ <::true
    [ :n :n sub1 <:n ::rec @ @ * ] null λ <::false
     IF @ ready
    :n one? <:if apply ]
  ( :n ) λ ]
( ::rec ) λ  <::y  Y @
: Var,factorial ; define
: factorial Var,factorial fetch2 Exit ; defineFunction

1 <:n factorial @ .
2 <:n factorial @ .
3 <:n factorial @ .
4 <:n factorial @ .
5 <:n factorial @ .
6 <:n factorial @ .
7 <:n factorial @ .
8 <:n factorial @ .
cr

(* ================================================== *)
(* TODO the heuristic about Y *)

[ [ One ] null λ <::true
  [ :n :n sub1

      <:n
      [ [ One ] null λ <::true
        [ :n :n sub1

        <:n
        [ [ One ] null λ <::true
          [ :n :n sub1

              ,* ]
        null λ <::false
           IF @ ready
          :n one? <:if apply ]
        ( :n ) λ @

            ,* ]
      null λ <::false
         IF @ ready
        :n one? <:if apply ]
      ( :n ) λ @

         ,* ]
   null λ <::false
   IF @ ready
  :n one? <:if apply ]
( :n ) λ

dup2 ready
1 <:n apply . (* 1 *) cr
dup2 ready
2 <:n apply . (* 2 *) cr
dup2 ready
3 <:n apply . (* 3 *) cr
drop2
cr
#+end_src
* >< interface for lambda
** note
** implementation
#+begin_src cicada
[ ::x ]
( ::x 3 4 ) λ
: I ; defineLambda


: Var,I ; define
: I Var,I fetch2 Exit ; defineFunction


: defineLambda,byString
  (* [value, type], string[address, length] -- *)

  Exit
; defineFunction

: defineLambda,byString
  (* [value, type], wordlist[address, number of words] -- *)
  headOfWordList
  defineLambda,byString
  Exit
; defineFunction
#+end_src
* --------------------------------------------------
* >< memory allocation
** note
make good use of lambda
** implementation (new lexicographers)
#+begin_src cicada
constants:
(StackName),Size (* unit: CellWidth *)
(StackName),Bottom
(StackName),Top

variables:
(StackName),Pointer

functions:
push,(StackName)
pop,(StackName)
empty?(StackName)



: defineStack (*  -- *)
; defineFunction

: defineHeap (*  -- *)
; defineFunction

: defineArray (*  -- *)
; defineFunction

: defineBuffer (*  -- *)
; defineFunction
#+end_src
* --------------------------------------------------
* linux syscall : open & close
#+begin_src cicada :tangle ./core/english.ccd
2  : Syscall,open  ; defineConst
3  : Syscall,close ; defineConst
60 : Syscall,exit  ; defineConst

0 : Syscall,open,read         ; defineConst
1 : Syscall,open,write        ; defineConst
2 : Syscall,open,readAndWrite ; defineConst

OctBase Base save
0100 : Syscall,open,creat    ; defineConst
1000 : Syscall,open,rewrite  ; defineConst  (* rewrite if file exist *)
2000 : Syscall,open,append   ; defineConst
DecBase Base save
#+end_src
* basic file processing & other syscalls
** note
note that : one needs zero-ending-string in linux
** implementation
#+begin_src cicada :tangle ./core/english.ccd
: sys,open
  (* arg-3, arg-2, string[address, length] -- file-descriptor *)
  tuck
    FileNameBufferForOpenFile
    swap
    copyByteString
  FileNameBufferForOpenFile +
    Zero swap saveByte
  FileNameBufferForOpenFile
  Syscall,open
  syscallWithThreeArguments
  Exit
; defineFunction

BinBase Base save
110_100_100 : RW_R__R__ ; defineConst
100_100_100 : R__R__R__ ; defineConst
DecBase Base save

: open,file,rewrite
  (* string[address, length] -- file-descriptor *)
  RW_R__R__
  Syscall,open,readAndWrite
  Syscall,open,creat bitwiseOr
  Syscall,open,rewrite bitwiseOr
  xx|swap|xx
  sys,open
  Exit
; defineFunction

: open,file,append
  (* string[address, length] -- file-descriptor *)
  RW_R__R__
  Syscall,open,readAndWrite
  Syscall,open,creat bitwiseOr
  Syscall,open,append bitwiseOr
  xx|swap|xx
  sys,open
  Exit
; defineFunction


: open,file,read
  (* string[address, length] -- file-descriptor *)
  R__R__R__
  Syscall,open,read
  xx|swap|xx
  sys,open
  Exit
; defineFunction



: sys,read
  (* arg-3[length],
     arg-2[address],
     arg-1[file-descriptor]
     --------------------
     length been readed *)
  Syscall,read
  syscallWithThreeArguments
  Exit
; defineFunction


: sys,write
  (* arg-3[length],
     arg-2[address],
     arg-1[file-descriptor]
     --------------------
     length been written *)
  Syscall,write
  syscallWithThreeArguments
  Exit
; defineFunction


: sys,close (* not very useful *)
  (* arg-1[file-descriptor]
     --------------------
      0 on success
     -1 on error *)
  Syscall,close
  syscallWithOneArgument
  Exit
; defineFunction


: sys,exit
  (* arg-1[exit number] -- THE END *)
  Syscall,exit
  syscallWithOneArgument
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
s" kkk" swap
  :" xxx~" open,file,rewrite
    dup writeDecNumber (* file-descriptor *) cr
sys,write
  writeDecNumber (* length been written *) cr

s" ppp" swap
  :" xxx~" open,file,append
    dup writeDecNumber (* file-descriptor *) cr
sys,write
  writeDecNumber (* length been written *) cr
#+end_src
* readFileToBuffer & evalString & evalBuffer
** note
1. to eval a buffer is to
   pretend it is the InputBuffer
2. evalBuffer == evalString
** readFileToBuffer
#+begin_src cicada :tangle ./core/english.ccd
:"    --> "
: String,___-->_ ; defineConstString

:" readFileToBuffer said:
   ``My function type is
     (* file-name-string[address, length], buffer[address, size] --
        buffer[address, length been readed] *)
     `sys,read' fail,
     the return value of `sys,read'
     and the file-name-string
     and the buffer[address, size]
     are the following
     I will call debuger''"
: String,readFileToBuffer,error ; defineConstString
: readFileToBuffer (* looks like copyByteString *)
  (* file-name-string[address, length], buffer[address, size] --
     buffer[address, length been readed] *)
  dup2 ready
  xx|over|xx ready
  swap
  xxx|tuck|x
  xx|swap|xx open,file,read
  sys,read
  dup Zero > if
    getBack drop2
    getBack drop2
    Exit
  then
  swap drop (* drop the address of buffer *)
  String,readFileToBuffer,error printString cr
  String,___-->_ printString writeDecNumber,signed cr
  String,___-->_ printString getBack printString cr
  String,___-->_ printString
    getBack swap
    '[' writeChar
    writeDecNumber
    ',' writeChar writeSpace
    writeDecNumber
    ']' writeChar
    cr
  Exit
; defineFunction
#+end_src
** helper functions
#+begin_src cicada :tangle ./core/english.ccd
(* nonBlankChar : 33 -- 126, 128+ *)
: nonBlankChar?
  (* char -- True or False *)
  dup literal 33 < if
    drop False Exit
  then
  literal 127 == if
    False Exit
  then
    True Exit
  Exit
; defineFunction

: blankChar?
  (* char -- True or False *)
  nonBlankChar? false? Exit
; defineFunction


: cutToNonBlank
  (* [address, length] -- [address, length] or [Null, <null>] *)
  dup zero? if
    drop2  null
    Exit
  then
  over fetchByte nonBlankChar? if
    Exit
  then
  sub1 swap add1 swap
  cutToNonBlank
  Exit
; defineRecursiveFunction

: cutToBlank
  (* [address, length] -- [address, length] or [Null, <null>] *)
  dup zero? if
    drop2  null
    Exit
  then
  over fetchByte blankChar? if
    Exit
  then
  sub1 swap add1 swap
  cutToBlank
  Exit
; defineRecursiveFunction


: headWordOfString
  (* string[address, length] -- headWord[address, length] *)
  (* or *)
  (* string[address, length] -- [Null, <null>] *)
  cutToNonBlank
  dup2 null? if
    Exit
  then
  dup2 cutToBlank
  dup2 null? if
    drop2 Exit
  then
  swap drop -
  Exit
; defineFunction


: headWordAndTailOfString
  (* string[address, length] --
     headWord[address, length], tail[address, length] *)
  (* there the length of the tail might be 0 *)
  (* or *)
  (* string[address, length] -- [Null, <null>] *)
  dup2 headWordOfString
  dup2 null? if
    drop2 drop2
    null Exit
  then
  xx|swap|xx
  (* headWord[address, length], string[address, length] *)
  x|over|xxx x|over|xx - -
  x|over|xx - (* length of tail *)
  xx|over|xx + (* address of tail *)
  swap x|swap|xx drop
  Exit
; defineFunction

: stringContainNoWord?
  (* string[address, length] -- True or False *)
  headWordOfString null?
  if True Exit
  then False Exit
; defineFunction
#+end_src
** interface of StackForEvalString
1. not to much stack-processing is needed here
2. instead of allocate this stack in assembly
   I can also use list-processing to implement it
#+begin_src cicada :tangle ./core/english.ccd
StackForEvalStringTop : StackForEvalStringPointer ; defineVar

: pushStackForEvalString
  (* ArgumtStack::  value -->
     StackForEvalString::  value *)
  CellWidth StackForEvalStringPointer addSave
  StackForEvalStringPointer fetch save
  Exit
; defineFunction

: popStackForEvalString
  (* StackForEvalString::  value -->
     ArgumtStack::  value *)
  StackForEvalStringPointer fetch fetch
  CellWidth StackForEvalStringPointer subSave
  Exit
; defineFunction
#+end_src
** evalString & evalBuffer
#+begin_src cicada :tangle ./core/english.ccd
: evalStringREPL
  (* unknown -- unknown *)
  ReadingBoundary fetch
  CurrentReading fetch
  tuck -
  stringContainNoWord? if
    Exit
  then
  readWordForRuntime
  executeWord
  evalStringREPL
  Exit
; defineRecursiveFunction

: evalString
  (* string[address, length] -- unknow *)
  ReadingBoundary fetch pushStackForEvalString
  CurrentReading fetch pushStackForEvalString
    over CurrentReading save
    + ReadingBoundary save
    evalStringREPL
  popStackForEvalString CurrentReading  save
  popStackForEvalString ReadingBoundary save
  Exit
; defineFunction

: evalBuffer evalString Exit ; defineFunction
#+end_src
** test
#+begin_src cicada
s" 123 . " evalString
s" 123 ." evalString

s" 123 . (* 123 3 2 1 (* 123 3 2 1 *) *) " evalString

1 2 3
  s" 123 . (* 123 3 2 1 (* 123 3 2 1 *) *) " evalString
. . . (* 123 3 2 1 *) cr

s" ./test/terminal-escape-sequences.ccd"
BufferForLoadFile
SizeOfBufferForLoadFile
readFileToBuffer
evalString


s" 123 ." : string-2 ; defineConstString
s" 123 .  string-2 evalString" : string-1 ; defineConstString
s" 123 .  string-1 evalString" evalString ok
#+end_src
* --------------------------------------------------
* ok & bye
  for the REPL is actually a REL which does not print
  so I provide a word to check that the cicada is working properly
  #+begin_src cicada :tangle ./core/english.ccd
  :" yes"
  : String,yes ; defineConstString
  : ok (* -- *)
    String,yes printString
    writeSpace
    Exit
  ; defineFunction
  
  :" byebye ^_^"
  : String,byebye ; defineConstString
  : bye (* -- THE END *)
    writeSpace
    String,byebye printString
    Zero sys,exit
    Exit
  ; defineFunction
  #+end_src
* ==================================================
* loadFile
** note
1. to load a file is to
   read the file into a buffer and eval the buffer
** implementation
#+begin_src cicada :tangle ./core/english.ccd
: loadFile
  (* file-name-string[address, length] --
     buffer[address, length been readed] *)
  BufferForLoadFile
  SizeOfBufferForLoadFile
  readFileToBuffer
  evalString
  Exit
; defineFunction
#+end_src
** test
#+begin_src cicada
s" ./test/terminal-escape-sequences.ccd"
loadFile
#+end_src
* loadInitFile (at the end of core loading)
** note
1. init files are specified by command line arguments
** implementation
#+begin_src cicada :tangle ./core/english.ccd
: NumberOfCommandLineArguments (* -- number *)
  LinuxProgramHeaderAddress fetch One -
  Exit
; defineFunction


:" getCommandLineArgument said:
   ``My function type is (* number -- [address, length] *)
     but the following number is biger than the NumberOfCommandLineArguments
     I will not touch it and call debuger''
   --> "
: String,getCommandLineArgument,error
; defineConstString

: getCommandLineArgument
  (* number -- [address, length] *)
  dup NumberOfCommandLineArguments > if
    String,getCommandLineArgument,error printString
    dup writeDecNumber
    writeSpace '>' writeChar writeSpace
    NumberOfCommandLineArguments writeDecNumber
    cr
    debuger Exit
  then
  LinuxProgramHeaderAddress
  CellWidth x|swap|xx add1 * + fetch
  dup lengthOfZeroEndingString
  Exit
; defineFunction


One : Count,loadInitFile ; defineVar

: loadInitFile
  (* -- unknown *)
  Count,loadInitFile fetch
  NumberOfCommandLineArguments > if
    Exit
  then
  Count,loadInitFile fetch
  dup
  add1 Count,loadInitFile save
    getCommandLineArgument loadFile
  loadInitFile
  Exit
; defineRecursiveFunction

loadInitFile
#+end_src
** test
#+begin_src cicada
NumberOfCommandLineArguments . cr
1 getCommandLineArgument printString cr
2 getCommandLineArgument printString cr
3 getCommandLineArgument printString cr
4 getCommandLineArgument printString cr
#+end_src
* ==================================================
* key->numberREPL
  #+begin_src cicada :tangle ./core/english.ccd
  :" key->numberREPL said: ``Goodbye! ^_^''"
  : String,key->numberREPL,Goodbye ; defineConstString
  
  :" key->numberREPL said:
     ``Welcome to this key->numberREPL ^_^
       I will help you to find out that
         what number or sequence of numbers
         your computer send to your terminal
         when you press a key.
       If you want to exit this REPL, please press `enter'. '' "
  : String,key->numberREPL,Welcome ; defineConstString
  
  
  : help,key->numberREPL (* -- *)
    readChar
    dup literal 10 == if
      drop
      String,key->numberREPL,Goodbye printString cr
      cr
      Exit
    then
    writeSpace writeSpace writeDecNumber cr
    help,key->numberREPL
    Exit
  ; defineRecursiveFunction
  
  : key->numberREPL (* -- *)
    cr
    String,key->numberREPL,Welcome printString cr
    setTerminalToReadKey
    help,key->numberREPL
    setTerminalBackToReadLine
    Exit
  ; defineFunction
  #+end_src
* terminal
** esc
#+begin_src cicada :tangle ./core/english.ccd
(*
   esc%            Start sequence selecting character set
   esc%@                      Select default (ISO 646 / ISO 8859-1)
   esc%G                      Select UTF-8
   esc%8                      Select UTF-8 (obsolete)

   esc(            Start sequence defining G0 character set
   esc(B                      Select default (ISO 8859-1 mapping)
   esc(0                      Select VT100 graphics mapping
   esc(U                      Select null mapping - straight to character ROM
   esc(K                      Select user mapping - the map that is loaded by the utility mapscrn(8).

   esc)            Start sequence defining G1 (followed by one of B, 0, U, K, as above).

 ,*)


(*
 ,* 'esc' writeChar  'c' writeChar  (\* Reset *\)
 ,* 'esc' writeChar  'M' writeChar  (\* Reverse linefeed *\)
 ,*)

: esc[ (* -- *)
  'esc' writeChar '[' writeChar Exit
; defineFunction

: crazy-E (* -- *)
  (* screen alignment test - fill screen with E's *)
  'esc' writeChar '#' writeChar '8' writeChar  Exit
; defineFunction
#+end_src
** move cursor
#+begin_src cicada :tangle ./core/english.ccd
: save-cursor-location (* -- *)
  (* esc[s or esc7 *)
  esc[ 's' writeChar Exit
; defineFunction

: fetch-cursor-location (* -- *)
  (* esc[u or esc8 *)
  esc[ 'u' writeChar Exit
; defineFunction



: move-cursor-up (* number -- *)
  (* esc[_A *)
  esc[  writeDecNumber  'A' writeChar  Exit
; defineFunction

: move-cursor-down (* number -- *)
  (* esc[_B or esc[_e *)
  esc[  writeDecNumber  'B' writeChar  Exit
; defineFunction

: move-cursor-right (* number -- *)
  (* esc[_C or esc[_a *)
  esc[  writeDecNumber  'C' writeChar  Exit
; defineFunction

: move-cursor-left (* number -- *)
  (* esc[_D *)
  esc[  writeDecNumber  'D' writeChar  Exit
; defineFunction


(* to the following two functions,
   Zero as arg is the same as One *)
: move-cursor-down-&-to-the-begin-of-line (* number -- *)
  (* esc[_E *)
  esc[  writeDecNumber  'E' writeChar  Exit
; defineFunction

: move-cursor-up-&-to-the-begin-of-line (* number -- *)
  (* esc[_F *)
  esc[  writeDecNumber  'F' writeChar  Exit
; defineFunction



(* the following indexes are begin at 1 *)

: move-cursor-to-col (* col-index -- *)
  (* esc[_` or esc[_G *)
  esc[  writeDecNumber  '`' writeChar  Exit
; defineFunction

: move-cursor-to-row (* row-index -- *)
  (* esc[_d *)
  esc[  writeDecNumber  'd' writeChar  Exit
; defineFunction

: move-cursor-to-row-&-col (* row-index, col-index -- *)
  (* esc[_;_H or esc[_;_f *)
  esc[
  swap writeDecNumber  ';' writeChar
  writeDecNumber  'H' writeChar
  Exit
; defineFunction
#+end_src
** erase & delete
#+begin_src cicada :tangle ./core/english.ccd
(* the position of the cursor
 ,* is also as an argument of the following functions
 ,* but the cursor do not move when these functions are executed
 ,*)

: erase-chars (* number -- *)
  (* esc[_X *)
  esc[  writeDecNumber  'X' writeChar  Exit
; defineFunction



: delete-chars (* number -- *)
  (* esc[_P *)
  esc[  writeDecNumber  'P' writeChar  Exit
; defineFunction

: delete-lines (* number -- *)
  (* esc[_M *)
  esc[  writeDecNumber  'M' writeChar  Exit
; defineFunction



: erase-half-screen-to-end (* -- *)
  (* esc[0J *)
  esc[ '0' writeChar 'J' writeChar  Exit
; defineFunction

: erase-half-screen-to-start (* -- *)
  (* esc[1J *)
  esc[ '1' writeChar 'J' writeChar  Exit
; defineFunction

: erase-screen (* -- *)
  (* esc[2J *)
  esc[ '2' writeChar 'J' writeChar  Exit
; defineFunction



: erase-half-line-to-end (* -- *)
  (* esc[0K *)
  esc[ '0' writeChar 'K' writeChar  Exit
; defineFunction

: erase-half-line-to-start (* -- *)
  (* esc[1K *)
  esc[ '1' writeChar 'K' writeChar  Exit
; defineFunction

: erase-line (* -- *)
  (* esc[2K *)
  esc[ '2' writeChar 'K' writeChar  Exit
; defineFunction
#+end_src
** set*
#+begin_src cicada :tangle ./core/english.ccd
(* the default of the following three are `off' *)

: set-display-mode,to-display-control-chars (* -- *)
  (* esc[3h *)
  esc[ '3' writeChar 'h' writeChar  Exit
; defineFunction

: set-display-mode,to-insert-mode
  (* esc[4h *)
  esc[ '4' writeChar 'h' writeChar  Exit
; defineFunction

: set-display-mode,to-auto-follow-echo
  (* esc[20h *)
  esc[ '2' writeChar '0' writeChar 'h' writeChar  Exit
; defineFunction



: set-scrolling-row-region (* top, bottom -- *)
  (* esc[_;_r *)
  (* the cursor will be set to 1,1 after then *)
  esc[
  swap  writeDecNumber ';' writeChar
  writeDecNumber 'r' writeChar
  Exit
; defineFunction



: set-display-attribute (* number -- *)
  (* esc[_m *)
  esc[ writeDecNumber 'm' writeChar Exit
; defineFunction

0  : DisplayAttribute,set,all-to-default ; defineConst

1  : DisplayAttribute,set,bold ; defineConst
22 : DisplayAttribute,off,bold ; defineConst

3  : DisplayAttribute,set,italicized ; defineConst
23 : DisplayAttribute,off,italicized ; defineConst

2  : DisplayAttribute,set,half-bright ; defineConst
21 : DisplayAttribute,off,half-bright ; defineConst
(* >< no use in xterm or urxvt ??? *)

4  : DisplayAttribute,set,underscore  ; defineConst
24 : DisplayAttribute,off,underscore  ; defineConst
(* simulated with color on a color display
   the colors used to simulate half-bright or underline are set using esc]___ *)

5  : DisplayAttribute,set,blink ; defineConst
25 : DisplayAttribute,off,blink ; defineConst

7  : DisplayAttribute,set,reverse-color ; defineConst
27 : DisplayAttribute,off,reverse-color ; defineConst

8  : DisplayAttribute,set,hidden ; defineConst
28 : DisplayAttribute,off,hidden ; defineConst


(*
 ,* 10
 ,* reset selected mapping, display control flag, and toggle meta flag (ECMA-48 says "primary font").
 ,* 11
 ,* select null mapping, set display control flag, reset toggle meta flag (ECMA-48 says "first alternate font").
 ,* 12
 ,* select null mapping, set display control flag, set toggle meta flag (ECMA-48 says "second alternate font").
 ,*
 ,* The toggle meta flag causes the high bit of a byte to be toggled before the mapping table translation is done.
 ,*)


(* color test:

 ,* (\* foreground :: *\)
 ,* 30 esc[_m black
 ,* 31 esc[_m red
 ,* 32 esc[_m green
 ,* 33 esc[_m brown
 ,* 34 esc[_m blue
 ,* 35 esc[_m magenta
 ,* 36 esc[_m cyan
 ,* 37 esc[_m white
 ,* 38 esc[_m default-color & underscore on
 ,* 39 esc[_m default-color & underscore off
 ,* (\* 16-color foreground :: *\)
 ,* 90 esc[_m black
 ,* 91 esc[_m red
 ,* 92 esc[_m green
 ,* 93 esc[_m yellow
 ,* 94 esc[_m blue
 ,* 95 esc[_m magenta
 ,* 96 esc[_m cyan
 ,* 97 esc[_m white

 ,* (\* background :: *\)
 ,* 40 esc[_m black
 ,* 41 esc[_m red
 ,* 42 esc[_m green
 ,* 43 esc[_m yellow
 ,* 44 esc[_m blue
 ,* 45 esc[_m magenta
 ,* 46 esc[_m cyan
 ,* 47 esc[_m white
 ,* 49 esc[_m default color
 ,* (\* 16-color background :: *\)
 ,* 100 esc[_m black
 ,* 101 esc[_m red
 ,* 102 esc[_m green
 ,* 103 esc[_m yellow
 ,* 104 esc[_m blue
 ,* 105 esc[_m magenta
 * 106 esc[_m cyan
 * 107 esc[_m white

 *)
#+end_src
** test
#+begin_src cicada
:" cicada language is interesting ^_^"
: String,cicada-language-is-interesting ; defineConstString

: cicada-language-is-interesting (* -- *)
  erase-screen
  Six Six move-cursor-to-row-&-col
    literal 93 set-display-attribute (* foreground yellow *)
    DisplayAttribute,set,blink set-display-attribute
    DisplayAttribute,set,underscore set-display-attribute
  String,cicada-language-is-interesting printString cr
    DisplayAttribute,off,underscore set-display-attribute
    DisplayAttribute,off,blink set-display-attribute
    literal 39 set-display-attribute (* foreground default-color *)
  Exit
; defineFunction

cicada-language-is-interesting
#+end_src
* >< cicada-editor
** note
   1. the loop :
      1) read a key (a char)
      2) according to some global variables
         dispatch a key to a function and execute
         the execution of a function
         will edit the datastructure for text
         and  edit the datastructure for display
      3) update display
      4) loop
      so it is a ``REDL''
   2. two datastructures for cicada-editor
      one for text
      one for display
   3. key binding :
      every key can be bound to any function
** string->line-dalin
   as a parser of fundamental-mode
   #+begin_src cicada :tangle ./core/english.ccd
   : find-char-address
     (* char, [address, length] -- address or -1 *)
     dup zero? if
       drop2 drop
       One negate
       Exit
     then
     tailAndHeadOfString
     x|over|xxx == if
       drop swap drop
       sub1 Exit
     then
     find-char-address
     Exit
   ; defineRecursiveFunction
   
   : find-char-index
     (* char, [address, length] -- index or -1 *)
     (* index start from Zero *)
     over
     xxx|swap|x
     find-char-address
     dup Zero < if
       swap drop Exit
     then
     swap -
     Exit
   ; defineFunction
   
   
   (* little test:
    ,* 'k' s" k" find-char-index . (\* 0 *\) cr
    ,* 'k' s" kkk" find-char-index . (\* 0 *\) cr
    ,* 'k' s" skkk" find-char-index . (\* 1 *\) cr
    ,* 'k' s"  kkk" find-char-index . (\* 1 *\) cr
    ,* 'k' s" 0123456789k" find-char-index . (\* 10 *\) cr
    ,* 'k' s" 0123456789" find-char-index . (\* -1 *\) cr
    ,*)
   
   
   
   : help,string->line-dalin
     (* [address, length] -- head[address, <dalin>] *)
     (* LambdaStack:: [address, <dalin>] -- *)
     dup zero? if
       getBack
       dup2
         cdr null [cons,cdr]!
         drop2
       head<-dalin
       Exit
     then
     dup2
     'linefeed' xx|over|x find-char-index
     dup Zero < if
       (* this means if a string is not end with 'linefeed'
          a 'linefeed' will be added at the end *)
       drop
       dup substring
       xx|tuck|x
       swap copyByteString
       <substring>
       cons drop <dalin>
       [car,cons]!
         cons null [cons,cdr]!
       [cons,cdr]!
       getBack
       xx|swap|xx
       ^_^
       head<-dalin
       Exit
     then
     (* [address, length], index-of-linefeed *)
     x|over|xx over + add1
     xxx|swap|x (* leave the new address *)
     swap over - sub1
     xx|swap|x (* leave the new length *)
     (* [new address, new length], address, index-of-linefeed *)
     dup zero? if
       (* 'linefeed' is the 1st char of the string
          so we meet an empty line, it will be stored as `null' in dalin *)
       drop2
       null
     else
       (* index-of-linefeed is just the length of substring *)
       dup substring
       xx|tuck|x
       swap copyByteString
       <substring>
     then
     cons drop <dalin>
     [car,cons]!
       cons null [cons,cdr]!
     [cons,cdr]!
     getBack
       xx|swap|xx
       ^_^
     ready
     help,string->line-dalin
     Exit
   ; defineRecursiveFunction
   
   : string->line-dalin
     (* [address, length] -- head[address, <dalin>] *)
     (* which parses a string and return a dalin of substring
        one substring denotes one line of text
        empty line is stored as `null' in dalin *)
     null ready
     help,string->line-dalin
     Exit
   ; defineFunction
   #+end_src
** test: string->line-dalin
   #+begin_src cicada
   s" kkk" string->line-dalin
   car printTypeTag (* <substring> *) cr
   dup getLengthOfString
   printString (* kkk *) cr
   
   s" kkk
   " string->line-dalin
   dup2 dalin*? . (* 1 *) cr
   car printTypeTag (* <substring> *) cr
   dup getLengthOfString
   printString (* kkk *) cr
   
   s" kkk
   aaa" string->line-dalin
   dup2 dalin*? . (* 0 *) cr
   dup2
   car printTypeTag (* <substring> *) cr
   dup getLengthOfString
   printString (* kkk *) cr
   ->
   car printTypeTag (* <substring> *) cr
   dup getLengthOfString
   printString (* aaa *) cr
   
   s" kkk
   aaa
   " string->line-dalin
   dup2 dalin*? . (* 0 *) cr
   dup2
   car printTypeTag (* <substring> *) cr
   dup getLengthOfString
   printString (* kkk *) cr
   ->
   car printTypeTag (* <substring> *) cr
   dup getLengthOfString
   printString (* aaa *) cr
   #+end_src
** >< reduce text-editing to line-editing
   #+begin_src cicada
   (* buffer: ==
        [address]
      line: ==
        buffer[address, length], cursors[address, <list>]
      where:
        cursor is a Zero-based-index, from Zero to length *)
   
   
   0 : Var,LineBuffer ; defineVar
   
   Here fetch Var,LineBuffer save
   1000 Here addSave
   
   : LineBuffer (*  -- buffer[address] *)
     Var,LineBuffer fetch
     Exit
   ; defineFunction
   
   
   0 : Var,Tmp,LineBuffer ; defineVar
   
   Here fetch Var,Tmp,LineBuffer save
   1000 Here addSave
   
   : Tmp,LineBuffer (*  -- buffer[address] *)
     Var,Tmp,LineBuffer fetch
     Exit
   ; defineFunction
   
   
   : copyStringToBuffer
     (* string[address, length], buffer[address] --
        buffer[address, length] *)
     pushLambdaStack
     tuck
     popLambdaStack dup pushLambdaStack
     swap copyByteString
     popLambdaStack
     swap
     Exit
   ; defineFunction
   
   : copyStringToLine
     (* string[address, length], buffer[address] --
        buffer[address, length], cursors[address, <list>] *)
     copyStringToBuffer
     cons drop <list>
     Zero <fixnum>
     [cons,car]!
     Exit
   ; defineFunction
   
   
   : line,move-cursor-right
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|over|x car drop (* drop <fixnum> *)
     +  <fixnum> [cons,car]!
     Exit
   ; defineFunction
   
   : line,move-cursor-left
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|over|x car drop (* drop <fixnum> *)
     -  <fixnum> [cons,car]!
     Exit
   ; defineFunction
   
   : line,move-cursor-to-col
     (* buffer[address, length], cursors[address, <list>], index --
        buffer[address, length], cursors[address, <list>] *)
     <fixnum> [cons,car]!
     Exit
   ; defineFunction
   
   
   (* ><><><
      the following two functions need better factoring *)
   
   : insertString
     (* string[address, length],
        buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     dup2 ready
     xx|over|xx ready
     car drop (* drop <fixnum> *)
     tuck -
     xx|swap|x +
       dup pushLambdaStack (* address of middle buffer *)
     swap
     Tmp,LineBuffer copyStringToBuffer
     xx|swap|xx
     popLambdaStack copyStringToBuffer
       dup pushLambdaStack (* length of string *)
     + copyStringToBuffer
     drop2
     popLambdaStack
     getBack x|swap|xx dup pushLambdaStack
     +
     popLambdaStack
     getBack
     x|tuck|xx car drop (* <fixnum> *)
     + <fixnum> [cons,car]!
     Exit
   ; defineFunction
   
   (*
    ,* test:
    ,* s"  xxx "
    ,* s"  kkk " LineBuffer copyStringToLine
    ,* 2 line,move-cursor-right
    ,* insertString
    ,* car write (\* 7 *\) cr
    ,* printString (\*  k xxx kk  *\) cr
    ,*)
   
   : insertChar
     (* char,
        buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     dup2 ready
     xx|over|xx ready
     car drop (* drop <fixnum> *)
     tuck -
     xx|swap|x +
       dup pushLambdaStack (* address of middle buffer *)
     swap
     Tmp,LineBuffer copyStringToBuffer
     x|swap|xx
     popLambdaStack tuck saveByte
     add1
     copyStringToBuffer
     drop2
     getBack add1
     getBack dup2 car drop (* <fixnum> *)
     add1 <fixnum> [cons,car]!
     Exit
   ; defineFunction
   
   
   (*
    ,* test:
    ,* 'x'
    ,* s"  kkk " LineBuffer copyStringToLine
    ,* 2 line,move-cursor-right
    ,* insertChar
    ,* car write (\* 3 *\) cr
    ,* printString (\*  kxkk  *\) cr
    ,*)
   
   
   : deleteChars
     (* buffer[address, length], cursors[address, <list>], number --
        buffer[address, length], cursors[address, <list>] *)
     xx|tuck|x
     xx|swap|x dup2 ready
     car drop (* drop <fixnum> *)
     +
     (* buffer[address, length], number, number + cursors *)
     xx|swap|x  -
     (* buffer[address], number + cursors, length - number *)
     x|over|xx swap ready
     (* buffer[address], number + cursors *)
     +
     xx|swap|x
   
     Exit
   ; defineFunction
   
   : line,kill-line (* erase-half-line-to-end *)
     (* buffer[address, length], cursors[address, <list>] --
        buffer[address, length], cursors[address, <list>] *)
     Exit
   ; defineFunction
   
   
   
   
   
   
   
   (*
    ,* : text,move-cursor-up (\* number -- *\)
    ,* ; defineFunction
    ,*
    ,* : text,move-cursor-down (\* number -- *\)
    ,* ; defineFunction
    ,*
    ,* : text,move-cursor-down-&-to-the-begin-of-line (\* number -- *\)
    ,* ; defineFunction
    ,*
    ,* : text,move-cursor-up-&-to-the-begin-of-line (\* number -- *\)
    ,* ; defineFunction
    ,*)
   
   
   
   
   (*
    ,* : text,move-cursor-to-row (\* row-index -- *\)
    ,* ; defineFunction
    ,*
    ,* : text,move-cursor-to-row-&-col (\* row-index, col-index -- *\)
    ,* ; defineFunction
    ,*)
   
   
   (* the position of the cursor
    ,* is also as an argument of the following functions
    ,* but the cursor do not move when these functions are executed
    ,*)
   
   
   
   (*
    ,* : delete-lines (\* number -- *\)
    ,* ; defineFunction
    ,*)
   
   
   
   (*
    ,* : erase-half-screen-to-end (\* -- *\)
    ,* ; defineFunction
    ,*
    ,* : erase-half-screen-to-start (\* -- *\)
    ,* ; defineFunction
    ,*
    ,* : erase-screen (\* -- *\)
    * ; defineFunction
    *)
   #+end_src
* x & k
  - x :: 被读入的text是被结构化地保存的
         显示的时候也可以根据结构高亮
  - x :: 每个命令都是一个 string-processing function
         有一个命令的缓冲区 也就是说并不是每个命令都会马上被执行
         这样在显示方面就要多费些功夫
         显示与命令的执行分离
         命令的执行也通过缓冲区与这些命令作为 string-processing function 的功能分离
         这样整个文本编辑器就是cicada的string-processing的应用了
         只是在cicada的string-processing上面添加了一个函数缓冲还有显示而已
         cicada的string-processing中的函数有两种类型
         一种是副作用类型的
         一种是利用原有的字符串构造新的字符串的(函数式编程范式)
         我将首先只实现函数式的那一种
         也就是说对于一个字符串 插入 删除 替换 等操作都会生成一个全新的字符串
         这也许非常耗费内存 但是其能行性值得被实验一下
         注意
         我必须利用缓冲下来的很多命令来形成一个字符处理函数
         因为每个字符处理函数都是要申请很多内存 来保存一行字符的
         这也要求我设计很多新的字符串处理的语法
         还要实现对这些语法的处理
         这是最难的部分
         注意
         另一个重要的 操作是 匹配
         它的函数类型与上面的不同
         注意
         这里可能需要加强cicada对字符串的实现方式
         尤其是需要考虑gc
  - k :: 太好了!
         你已经有一个大致的思路了
         我们可以先假装gc没有问题然后去实现这些想法试试
  - x :: 没错
         我之前说过
         字符串处理 模块系统 文档系统 文本编辑器 都应该被同时设计
         但是现在我明白了
         应该被同时设计的是
         字符串处理 和 文本编辑器
         而 模块系统 文档系统 其实应该与集成开发环境的用户接口一起设计
         模块系统涉及到对命名空间的控制
         当用hash-table来实现find的时候这并不难做到
         模块系统还涉及到 如何定义什么是一个模块
         非常简单 就是一个词的集合而已 其中可以有 任何类型的词
* x & k 2
  - x :: 写好文本编辑器之后我就可以把文档写在我设计的类org-mode中了
	 并且有语法高亮
	 并且我可以自己设计文档的格式
	 设计自己的markdown
* >< tryREDL
  just use the ``readChar''
  #+begin_src cicada
  :" 1234567890"
  : InitString,for-update-display ; defineConstString
  
  InitString,for-update-display
  : Var-string,for-update-display ; define
  
  
  : update-display
    (*  --  *)
    terminal,clearScreen
    Var-string,for-update-display
    fetch2 printString cr
    Exit
  ; defineFunction
  
  
  :" kkk
  : tryREDL (*  --  *)
    setTerminalToReadKey
    help,tryREDL
    Exit
  ; defineFunction
  "
  : String-for,kkk ; defineConstString
  
  :" kkk" string-hash->index
  : SymbolIndex,kkk ; defineConst
  : kkk (*  -- *)
    String-for,kkk
    Var-string,for-update-display
    save2
    Exit
  ; defineFunction
  
  :" aaa
  
  : help,tryREDL (*  --  *)
    (* D *)
    update-display
    (* R *)
    readChar  (* writeSpace writeDecNumber cr *)
    (* E *)
    char->function-name-symbol
    executeSymbol
    (* L *)
    help,tryREDL
    Exit
  ; defineRecursiveFunction
  "
  : String-for,aaa
  ; defineConstString
  
  :" aaa" string-hash->index
  : SymbolIndex,aaa ; defineConst
  : aaa (*  -- *)
    String-for,aaa
    Var-string,for-update-display
    save2
    Exit
  ; defineFunction
  
  
  
  (* in the future this funciton must see a lot of global variables *)
  : char->function-name-symbol
    (* char -- [index, <symbol>] *)
    dup 'k' == if
      drop SymbolIndex,kkk <symbol> Exit
    then
    dup 'a' == if
      drop SymbolIndex,aaa <symbol> Exit
    then
    Exit
  ; defineFunction
  
  
  :" executeSymbol said:
     ``My function-type is (* [index, <symbol>] -- unknown *)
       But I meet the following type
       I will not touch it and call debuger.''
     --> "
  : String,executeSymbol,type-error ; defineConstString
  : executeSymbol (* [index, <symbol>] -- unknown *)
    dup <symbol> =/= if
      String,executeSymbol,type-error printString
      dup printTypeTag cr
      debuger
      Exit
    then
    drop (* drop <symbol> *)
    index-hashback->string
    executeWord
    Exit
  ; defineFunction
  
  
  
  : help,tryREDL (*  --  *)
    (* D *)
    update-display
    (* R *)
    readChar
    (* E *)
    char->function-name-symbol
    executeSymbol
    (* L *)
    help,tryREDL
    Exit
  ; defineRecursiveFunction
  
  : tryREDL (*  --  *)
    setTerminalToReadKey
    help,tryREDL
    Exit
  ; defineFunction
  
  : t tryREDL Exit ; defineFunction
  #+end_src
* ==================================================
* welcome
  #+begin_src cicada :tangle ./core/english.ccd
  :"    welcome to cicada ^_^"
  : String,welcome ; defineConstString
  : welcome (* -- *)
    String,welcome printString cr
    Exit
  ; defineFunction
  
  cr
  
  welcome
  
  cr
  
  (* report the UserDataSegment size *)
  ."  the size of UserDataSegment is: " cr
  writeSpace
  EndOfUserDataSegment  UserDataSegment  -  writeDecNumber
  ."  bytes" cr
  
  writeSpace
  EndOfUserDataSegment  Here fetch  -  writeDecNumber
  ."  bytes free" cr
  
  writeSpace
  Here fetch  UserDataSegment  -  writeDecNumber
  ."  bytes used" cr
  
  cr
  
  ."  you are in symbolREPL
   in this REPL some types of symbol will be processed specially" cr
  
  cr
  #+end_src
* ==================================================
