#+TITLE: cicada compiler
#+AUTHOR: XIE Yuheng
#+EMAIL: xyheme@gmail.com


* ==================================================
* about assembler
  1. 动机
     1) 统一汇编代码和 cicada 代码中的命名规则
     2) 方便向没有很好的汇编器的小型机器移植
     3) 作为一个系统程序员 我需要尽量避免 "抽象泄漏"
        这在于 我发现 当需要处理
        ELF文件格式 以及对共享库的动态调用的时候
        有很多底层的东西还是我没有理解的
        而 fasm 在形成 ELF 的时候 共享库的动态调用 有问题
        这个问题 让我认识到了 在 cicada 中实现汇编器的紧迫性
  2. 方法
     以 fasm 为汇编器 编译的目标代码
     但是仅仅使用 "db" 还有 很 CPU 指令有关的部分
     也就是说通过暂时把最枯燥与无聊的工作外包给 fasm
     我能够在 cicada 快速地实现一个汇编器
     并且在不好处理 或 没时间处理的地方 能够给我一个退路
  3. 对语义的处理
     就我的认识而言 解释语义与编译语义 之间有很大的不一致性
     也许这只 cicada (类 Forth 语言) 的特点而已
     对于 cicada (类 Forth 语言) 其特点在于
     1) 解释器 中的 cicada 代码 和 汇编器中的 汇编代码
        都在以相似的方式把函数编译到字典中
     2) 在解释器中 对函数的编译依赖于函数的顺序
        被调用的辅助函数 必须得出现在调用它的函数之前
        不方便进行相互递归
        很方便重新定义一个函数
     3) 在汇编代码中 对函数的编译不依赖于函数的顺序
        很方便进行相互递归
        不方便重新定义函数
  4. 步骤
     1) 首先
        在已有的 linux 版本的 cicada 解释器中实现 对文件的处理
     2) 接着
        利用 文件处理函数 在解释器中 实现编译器
        这个编译器必须要能够 方便地 重新定义函数
        这样就能够
        直接重新利用曾经被解释器的代码
        再把原本的汇编代码按新的编译器的语法重写一遍
        然后我就获得了一个测试我的新编译器的机会
        即去把这些代码编译成一个能用的解释器
     3) 然后
        利用编译器对函数的编译不依赖于函数的顺序的特点
        重写那些 没有在编译器中处理好的函数
        获得一个目前只能被新的编译器处理
        而不能被旧的解释器处理的版本
     4) 之后
        重新实现解释器中的基本函数
        使得解释器对函数的定义也不依赖于函数的顺序
        此时两个版本就应该能够同时被两个机器处理了
     5) 最后
        cicada 将能够基本独立
        我所获得的将不是分开的 一个解释器 和 一个编译器
        而是一个具有编译功能的解释器
        对于同样的代码
        在测试的时候我可以使用解释器
        在测试结束之后
        我可以把被解释的代码 融合到稳定的被编译的代码中
* ==================================================
* note
  - x :: k 我们应该怎么实现 编译器 ?
         我知道我们的计划的大方向了
         但是
         用户接口怎么设计 ?
         要知道现在在解释器里我们已经有很丰富的数据结构了
         在实现解释器的时候我们要不要用到它们 ?
  - k :: 可以用 dali 和 wodili
         但是我担心这两个数据结构在 cicada 中 还不够成熟
         也学没没有够多的函数来处理它们
         但是 lambda-calculus 已经用它们来实现了不是吗 ?
  - x :: 没错 那我们就充分的利用 这两个数据结构
         它们很适合用来形成 multi-pass
         并且在使用的过程中 我们能继续完善这两个数据结构
         那么用户接口呢 ?
  - k :: 我们将在解释器中调用 compiler 这个函数
         它 必须能调用解释器中的函数 同时又必须 使用另一个命名 空间
         以不 影响 解释器 的命名空间
  - x :: 我规定 必须在 cicada 的解释器里调用他
         这样 我对用户接口的设计 就能够不依赖于其他操作系统的环境了
         让我来试着 想像一下:
    1) file -> string
    2) string -> wodili
       这里的 wodili
       必须是针对 被编译的语言的语法 而结构化的 数据类型
    3) multi-pass to process wodi of wodili
    4) wodili -> string
    5) string -> file
  - x :: 这是典型的函数式编程范式
         是一些分工良好的 函数的复合 在完成着编译工作
         但是 要注意 输入文件 和 输出文件的名字最好在函数开头指定
         只要用变量 就能实现 这一点
  - k :: 可以发现
         这里名没有所谓的特殊的用户接口的设计
         你想到了 需要新的用户 接口
         是因为 你认为 你需要进入一个新的 REPL
         但是其实不用
         因为被编译的文本是在另一个文件中的
         而不是与被解释的文本交叉存在于一个文件中的
  - x :: 没错
         但是这种 "代码块的交叉存在"是否是需要的性质呢 ?
         我想 这也是需要的
         但是这些因该很简单
         只是用一对 bra-ket 把一段字符串 读到 一个 buffer 中而已
  - k :: 我们还可以发现 如果进行良好的因子化
         那么 我们就也可以 利用这里所实现的基础设施
         在 cicada 中 实现对 别的语言 的处理
  - x :: 现在就是要设计被编译的文本应该是什么样子的了
         我希望 被编译的文本 能够具有一些解释性脚本的性质
  - k :: 这是什么意思 "解释性脚本的性质" ???
  - x :: 
* compiler
  #+begin_src cicada :tangle compiler.cicada

  #+end_src
